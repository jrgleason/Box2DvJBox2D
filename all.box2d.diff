Only in ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d: .cproject
Only in ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d: .project
diff -r -x './svn/*' native/Box2D/.svn/all-wcprops ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/.svn/all-wcprops
3,4c3,4
< V 35
< /svn/!svn/ver/254/trunk/Box2D/Box2D
---
> V 39
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d
6c6
< Box2DConfig.cmake
---
> JNIBox2DShape.cpp
9,10c9,10
< V 52
< /svn/!svn/ver/59/trunk/Box2D/Box2D/Box2DConfig.cmake
---
> V 57
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/JNIBox2DShape.cpp
12c12
< Box2D.h
---
> JNIRefs.cpp
15,16c15,16
< V 43
< /svn/!svn/ver/247/trunk/Box2D/Box2D/Box2D.h
---
> V 51
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/JNIRefs.cpp
18c18
< CMakeLists.txt
---
> .project
21,22c21,64
< V 50
< /svn/!svn/ver/239/trunk/Box2D/Box2D/CMakeLists.txt
---
> V 48
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/.project
> END
> box2d.h
> K 25
> svn:wc:ra_dav:version-url
> V 47
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/box2d.h
> END
> JNIRefs.h
> K 25
> svn:wc:ra_dav:version-url
> V 49
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/JNIRefs.h
> END
> .cproject
> K 25
> svn:wc:ra_dav:version-url
> V 49
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/.cproject
> END
> JNIBox2DWorld.cpp
> K 25
> svn:wc:ra_dav:version-url
> V 57
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/JNIBox2DWorld.cpp
> END
> JNIBox2DWorld.h
> K 25
> svn:wc:ra_dav:version-url
> V 55
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/JNIBox2DWorld.h
> END
> Makefile
> K 25
> svn:wc:ra_dav:version-url
> V 48
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Makefile
> END
> JNIBox2DBody.cpp
> K 25
> svn:wc:ra_dav:version-url
> V 56
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/JNIBox2DBody.cpp
diff -r -x './svn/*' native/Box2D/.svn/entries ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/.svn/entries
4,6c4,6
< 254
< http://box2d.googlecode.com/svn/trunk/Box2D/Box2D
< http://box2d.googlecode.com/svn
---
> 7
> http://android-opengl-box2d-basics.googlecode.com/svn/trunk/rt-jnibox2d/box2d
> http://android-opengl-box2d-basics.googlecode.com/svn
10,12c10,12
< 2013-02-19T07:02:35.722054Z
< 254
< erincatto@gmail.com
---
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
27c27
< cafe418c-1137-0410-84cc-357ec87a5d9b
---
> 5131c71c-dced-4c25-419c-0ca2576ce0a2
29c29
< Box2DConfig.cmake
---
> JNIBox2DShape.cpp
35,39c35,39
< 2013-06-18T12:51:08.000000Z
< da1a45b32e3b86e95364163a8c423436
< 2010-02-28T18:53:10.341684Z
< 59
< erincatto
---
> 2013-07-02T14:40:41.000000Z
> 38fd265970c075314d9c6835cf607811
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
61c61
< 191
---
> 888
63c63
< Box2D.h
---
> JNIRefs.cpp
69,73c69,73
< 2013-06-18T12:51:08.000000Z
< 8ea5c657d9fb070acc8907a341aed137
< 2012-03-19T06:31:22.740365Z
< 247
< erincatto@gmail.com
---
> 2013-07-02T14:40:41.000000Z
> db6f1b1ffba594b8f0fcfcdcacdca6c3
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
95c95
< 2512
---
> 1405
97,98c97,197
< Rope
< dir
---
> .project
> file
> 
> 
> 
> 
> 2013-07-02T14:40:41.000000Z
> f01bc6fc9038f3250662de35abda0490
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 2296
> 
> box2d.h
> file
> 
> 
> 
> 
> 2013-07-02T14:40:41.000000Z
> 549f34995ee02dc558390dcadbf740e3
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 1779
> 
> JNIRefs.h
> file
> 
> 
> 
> 
> 2013-07-02T14:40:41.000000Z
> 3c17a07588b79ca14dd41514b1bbaf91
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 355
102a202,235
> .cproject
> file
> 
> 
> 
> 
> 2013-07-02T14:40:41.000000Z
> 04f4cd9b610de30c7dd0475573bbbca4
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 26119
> 
105a239,275
> JNIBox2DWorld.cpp
> file
> 
> 
> 
> 
> 2013-07-02T14:40:41.000000Z
> 56ed1f913ebc60fed97097cb9b7e5bed
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 9278
> 
> Headers
> dir
> 
109c279,347
< CMakeLists.txt
---
> JNIBox2DWorld.h
> file
> 
> 
> 
> 
> 2013-07-02T14:40:41.000000Z
> 5c0bafbe7f0db06f487024065ed7004c
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 598
> 
> Makefile
> file
> 
> 
> 
> 
> 2013-07-02T14:40:41.000000Z
> e2de1b7349a3ef80b7a1dab5a4833301
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 4982
> 
> JNIBox2DBody.cpp
115,119c353,357
< 2013-06-18T12:51:08.000000Z
< aa23c4debe6991df86d4eb995d400085
< 2011-11-14T06:03:00.804752Z
< 239
< erincatto@gmail.com
---
> 2013-07-02T14:40:41.000000Z
> 20877637244e398b45c5fdec36ab5339
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
141c379
< 5987
---
> 9013
Only in ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/.svn/text-base: .cproject.svn-base
Only in ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/.svn/text-base: .project.svn-base
Only in native/Box2D/.svn/text-base: Box2D.h.svn-base
Only in native/Box2D/.svn/text-base: Box2DConfig.cmake.svn-base
Only in native/Box2D/.svn/text-base: CMakeLists.txt.svn-base
Only in ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/.svn/text-base: JNIBox2DBody.cpp.svn-base
Only in ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/.svn/text-base: JNIBox2DShape.cpp.svn-base
Only in ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/.svn/text-base: JNIBox2DWorld.cpp.svn-base
Only in ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/.svn/text-base: JNIBox2DWorld.h.svn-base
Only in ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/.svn/text-base: JNIRefs.cpp.svn-base
Only in ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/.svn/text-base: JNIRefs.h.svn-base
Only in ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/.svn/text-base: Makefile.svn-base
Only in ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/.svn/text-base: box2d.h.svn-base
Only in native/Box2D: Android.mk
Only in native/Box2D: Application.mk
Only in native/Box2D: Box2D.h
Only in native/Box2D: Box2DConfig.cmake
Only in native/Box2D: BuildDroid.sh
Only in native/Box2D: CMakeLists.txt
diff -r -x './svn/*' native/Box2D/Collision/.svn/all-wcprops ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Collision/.svn/all-wcprops
3,4c3,4
< V 45
< /svn/!svn/ver/253/trunk/Box2D/Box2D/Collision
---
> V 49
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Collision
9,10c9,10
< V 60
< /svn/!svn/ver/251/trunk/Box2D/Box2D/Collision/b2Distance.cpp
---
> V 64
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Collision/b2Distance.cpp
15,16c15,16
< V 61
< /svn/!svn/ver/186/trunk/Box2D/Box2D/Collision/b2Collision.cpp
---
> V 65
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Collision/b2Collision.cpp
18c18
< b2BroadPhase.h
---
> b2PairManager.h
21,22c21,22
< V 60
< /svn/!svn/ver/247/trunk/Box2D/Box2D/Collision/b2BroadPhase.h
---
> V 65
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Collision/b2PairManager.h
24c24
< b2CollideCircle.cpp
---
> b2BroadPhase.h
27,28c27,28
< V 65
< /svn/!svn/ver/233/trunk/Box2D/Box2D/Collision/b2CollideCircle.cpp
---
> V 64
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Collision/b2BroadPhase.h
30c30
< b2Distance.h
---
> b2CollideCircle.cpp
33,34c33,34
< V 58
< /svn/!svn/ver/158/trunk/Box2D/Box2D/Collision/b2Distance.h
---
> V 69
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Collision/b2CollideCircle.cpp
36c36
< b2CollideEdge.cpp
---
> b2CollidePoly.cpp
39,40c39,40
< V 63
< /svn/!svn/ver/233/trunk/Box2D/Box2D/Collision/b2CollideEdge.cpp
---
> V 67
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Collision/b2CollidePoly.cpp
45,46c45,46
< V 59
< /svn/!svn/ver/186/trunk/Box2D/Box2D/Collision/b2Collision.h
---
> V 63
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Collision/b2Collision.h
51,64c51,52
< V 64
< /svn/!svn/ver/253/trunk/Box2D/Box2D/Collision/b2TimeOfImpact.cpp
< END
< b2CollidePolygon.cpp
< K 25
< svn:wc:ra_dav:version-url
< V 66
< /svn/!svn/ver/233/trunk/Box2D/Box2D/Collision/b2CollidePolygon.cpp
< END
< b2DynamicTree.cpp
< K 25
< svn:wc:ra_dav:version-url
< V 63
< /svn/!svn/ver/247/trunk/Box2D/Box2D/Collision/b2DynamicTree.cpp
---
> V 68
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Collision/b2TimeOfImpact.cpp
66c54
< b2TimeOfImpact.h
---
> b2PairManager.cpp
69,70c57,58
< V 62
< /svn/!svn/ver/158/trunk/Box2D/Box2D/Collision/b2TimeOfImpact.h
---
> V 67
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Collision/b2PairManager.cpp
75,82c63,64
< V 62
< /svn/!svn/ver/238/trunk/Box2D/Box2D/Collision/b2BroadPhase.cpp
< END
< b2DynamicTree.h
< K 25
< svn:wc:ra_dav:version-url
< V 61
< /svn/!svn/ver/247/trunk/Box2D/Box2D/Collision/b2DynamicTree.h
---
> V 66
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Collision/b2BroadPhase.cpp
diff -r -x './svn/*' native/Box2D/Collision/.svn/entries ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Collision/.svn/entries
4,6c4,6
< 254
< http://box2d.googlecode.com/svn/trunk/Box2D/Box2D/Collision
< http://box2d.googlecode.com/svn
---
> 7
> http://android-opengl-box2d-basics.googlecode.com/svn/trunk/rt-jnibox2d/box2d/Collision
> http://android-opengl-box2d-basics.googlecode.com/svn
10,12c10,12
< 2013-01-31T05:59:27.987463Z
< 253
< erincatto@gmail.com
---
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
27c27
< cafe418c-1137-0410-84cc-357ec87a5d9b
---
> 5131c71c-dced-4c25-419c-0ca2576ce0a2
35,39c35,39
< 2013-06-18T12:51:08.000000Z
< 9210af528259184d972d8400a9e3b147
< 2012-07-03T06:02:22.504491Z
< 251
< erincatto@gmail.com
---
> 2013-07-02T14:40:41.000000Z
> 74fc35e36eda78ae7cac94a717656e52
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
61c61
< 13737
---
> 11175
69,73c69,73
< 2013-06-18T12:51:08.000000Z
< d08ce0391b1d952c50e8d3745b3017ca
< 2011-06-18T08:05:55.703617Z
< 186
< erincatto@gmail.com
---
> 2013-07-02T14:40:41.000000Z
> 08ea36715fdacd01e2f24a6914a0ef69
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
95c95
< 6522
---
> 2321
97c97
< b2BroadPhase.h
---
> b2PairManager.h
103,107c103,107
< 2013-06-18T12:51:08.000000Z
< 9a369ac3966de15bbfa2376a5a6eb323
< 2012-03-19T06:31:22.740365Z
< 247
< erincatto@gmail.com
---
> 2013-07-02T14:40:41.000000Z
> 0b2edb5555a029f302404b3bb28bf11a
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
129c129
< 7213
---
> 3602
131c131
< b2CollideCircle.cpp
---
> b2BroadPhase.h
137,141c137,141
< 2013-06-18T12:51:08.000000Z
< 01c7c0c42a129bef96e55c8c3446299c
< 2011-09-19T05:49:06.756419Z
< 233
< erincatto@gmail.com
---
> 2013-07-02T14:40:41.000000Z
> a7770a8bda358df9057b6db6f97604e1
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
163,166c163
< 4508
< 
< Shapes
< dir
---
> 5163
168c165
< b2Distance.h
---
> b2CollideCircle.cpp
174,178c171,175
< 2013-06-18T12:51:08.000000Z
< 1ac48ff66b7cc61c43f523537709063d
< 2011-03-24T17:36:44.542193Z
< 158
< erincatto
---
> 2013-07-02T14:40:41.000000Z
> cac8c6144e57f93d43f28163cea685e2
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
200c197,200
< 3918
---
> 5145
> 
> Shapes
> dir
202c202
< b2CollideEdge.cpp
---
> b2CollidePoly.cpp
208,212c208,212
< 2013-06-18T12:51:08.000000Z
< d54a69804fd61add4847d03dd5ed9fc6
< 2011-09-19T05:49:06.756419Z
< 233
< erincatto@gmail.com
---
> 2013-07-02T14:40:41.000000Z
> bb758beee64c6eeee95fbe8e65377dad
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
234c234
< 16223
---
> 9624
242,246c242,246
< 2013-06-18T12:51:08.000000Z
< f6b43e94dcabc8dc033f74c0174369e4
< 2011-06-18T08:05:55.703617Z
< 186
< erincatto@gmail.com
---
> 2013-07-02T14:40:41.000000Z
> 4a3540dea2d69fec460d3031a31b766c
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
268c268
< 9248
---
> 5519
276,314c276,280
< 2013-06-18T12:51:08.000000Z
< f7f4817c8a355c2274604368f62f6397
< 2013-01-31T05:59:27.987463Z
< 253
< erincatto@gmail.com
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 12193
< 
< b2CollidePolygon.cpp
< file
< 
< 
< 
< 
< 2013-06-18T12:51:08.000000Z
< f67fb81d3950d86043d80929a3bc1ba0
< 2011-09-19T05:49:06.756419Z
< 233
< erincatto@gmail.com
---
> 2013-07-02T14:40:41.000000Z
> fc419b300395ab25bcf8ea071fcc0cdf
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
336c302
< 8978
---
> 3349
338c304
< b2DynamicTree.cpp
---
> b2PairManager.cpp
344,348c310,314
< 2013-06-18T12:51:08.000000Z
< fc0cbad5ceaedf8d89c21e358ad76b0b
< 2012-03-19T06:31:22.740365Z
< 247
< erincatto@gmail.com
---
> 2013-07-02T14:40:41.000000Z
> 5346d9ae0f280e0114c359d0cecd4cee
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
370,404c336
< 17690
< 
< b2TimeOfImpact.h
< file
< 
< 
< 
< 
< 2013-06-18T12:51:08.000000Z
< 38a672cdb172f198c4c31118c8c402e1
< 2011-03-24T17:36:44.542193Z
< 158
< erincatto
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 1921
---
> 10602
412,450c344,348
< 2013-06-18T12:51:08.000000Z
< 38e1e64dc98f654dd8c4f383d5777071
< 2011-11-14T05:45:39.018408Z
< 238
< erincatto@gmail.com
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 3246
< 
< b2DynamicTree.h
< file
< 
< 
< 
< 
< 2013-06-18T12:51:08.000000Z
< 326d9fe6e63dd2dfd5b9448910f5db25
< 2012-03-19T06:31:22.740365Z
< 247
< erincatto@gmail.com
---
> 2013-07-02T14:40:41.000000Z
> 2abc83019ab5b0e1dc2ce928cda6cd0c
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
472c370
< 7967
---
> 24723
diff -r -x './svn/*' native/Box2D/Collision/.svn/text-base/b2BroadPhase.cpp.svn-base ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Collision/.svn/text-base/b2BroadPhase.cpp.svn-base
2c2
< * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
19,21c19
< #include <Box2D/Collision/b2BroadPhase.h>
< #include <cstring>
< using namespace std;
---
> #include "b2BroadPhase.h"
23c21,67
< b2BroadPhase::b2BroadPhase()
---
> #include <string.h>
> 
> // Notes:
> // - we use bound arrays instead of linked lists for cache coherence.
> // - we use quantized integral values for fast compares.
> // - we use short indices rather than pointers to save memory.
> // - we use a stabbing count for fast overlap queries (less than order N).
> // - we also use a time stamp on each proxy to speed up the registration of
> //   overlap query results.
> // - where possible, we compare bound indices instead of values to reduce
> //   cache misses (TODO_ERIN).
> // - no broadphase is perfect and neither is this one: it is not great for huge
> //   worlds (use a multi-SAP instead), it is not great for large objects.
> 
> bool b2BroadPhase::s_validate = false;
> 
> struct b2BoundValues
> {
> 	uint16 lowerValues[2];
> 	uint16 upperValues[2];
> };
> 
> static int32 BinarySearch(b2Bound* bounds, int32 count, uint16 value)
> {
> 	int32 low = 0;
> 	int32 high = count - 1;
> 	while (low <= high)
> 	{
> 		int32 mid = (low + high) >> 1;
> 		if (bounds[mid].value > value)
> 		{
> 			high = mid - 1;
> 		}
> 		else if (bounds[mid].value < value)
> 		{
> 			low = mid + 1;
> 		}
> 		else
> 		{
> 			return (uint16)mid;
> 		}
> 	}
> 	
> 	return low;
> }
> 
> b2BroadPhase::b2BroadPhase(const b2AABB& worldAABB, b2PairCallback* callback)
24a69,72
> 	m_pairManager.Initialize(this, callback);
> 
> 	b2Assert(worldAABB.IsValid());
> 	m_worldAABB = worldAABB;
27,33c75,93
< 	m_pairCapacity = 16;
< 	m_pairCount = 0;
< 	m_pairBuffer = (b2Pair*)b2Alloc(m_pairCapacity * sizeof(b2Pair));
< 
< 	m_moveCapacity = 16;
< 	m_moveCount = 0;
< 	m_moveBuffer = (int32*)b2Alloc(m_moveCapacity * sizeof(int32));
---
> 	b2Vec2 d = worldAABB.upperBound - worldAABB.lowerBound;
> 	m_quantizationFactor.x = float32(B2BROADPHASE_MAX) / d.x;
> 	m_quantizationFactor.y = float32(B2BROADPHASE_MAX) / d.y;
> 
> 	for (uint16 i = 0; i < b2_maxProxies - 1; ++i)
> 	{
> 		m_proxyPool[i].SetNext(i + 1);
> 		m_proxyPool[i].timeStamp = 0;
> 		m_proxyPool[i].overlapCount = b2_invalid;
> 		m_proxyPool[i].userData = NULL;
> 	}
> 	m_proxyPool[b2_maxProxies-1].SetNext(b2_nullProxy);
> 	m_proxyPool[b2_maxProxies-1].timeStamp = 0;
> 	m_proxyPool[b2_maxProxies-1].overlapCount = b2_invalid;
> 	m_proxyPool[b2_maxProxies-1].userData = NULL;
> 	m_freeProxy = 0;
> 
> 	m_timeStamp = 1;
> 	m_queryResultCount = 0;
38,39d97
< 	b2Free(m_moveBuffer);
< 	b2Free(m_pairBuffer);
42c100,159
< int32 b2BroadPhase::CreateProxy(const b2AABB& aabb, void* userData)
---
> // This one is only used for validation.
> bool b2BroadPhase::TestOverlap(b2Proxy* p1, b2Proxy* p2)
> {
> 	for (int32 axis = 0; axis < 2; ++axis)
> 	{
> 		b2Bound* bounds = m_bounds[axis];
> 
> 		b2Assert(p1->lowerBounds[axis] < 2 * m_proxyCount);
> 		b2Assert(p1->upperBounds[axis] < 2 * m_proxyCount);
> 		b2Assert(p2->lowerBounds[axis] < 2 * m_proxyCount);
> 		b2Assert(p2->upperBounds[axis] < 2 * m_proxyCount);
> 
> 		if (bounds[p1->lowerBounds[axis]].value > bounds[p2->upperBounds[axis]].value)
> 			return false;
> 
> 		if (bounds[p1->upperBounds[axis]].value < bounds[p2->lowerBounds[axis]].value)
> 			return false;
> 	}
> 
> 	return true;
> }
> 
> bool b2BroadPhase::TestOverlap(const b2BoundValues& b, b2Proxy* p)
> {
> 	for (int32 axis = 0; axis < 2; ++axis)
> 	{
> 		b2Bound* bounds = m_bounds[axis];
> 
> 		b2Assert(p->lowerBounds[axis] < 2 * m_proxyCount);
> 		b2Assert(p->upperBounds[axis] < 2 * m_proxyCount);
> 
> 		if (b.lowerValues[axis] > bounds[p->upperBounds[axis]].value)
> 			return false;
> 
> 		if (b.upperValues[axis] < bounds[p->lowerBounds[axis]].value)
> 			return false;
> 	}
> 
> 	return true;
> }
> 
> void b2BroadPhase::ComputeBounds(uint16* lowerValues, uint16* upperValues, const b2AABB& aabb)
> {
> 	b2Assert(aabb.upperBound.x >= aabb.lowerBound.x);
> 	b2Assert(aabb.upperBound.y >= aabb.lowerBound.y);
> 
> 	b2Vec2 minVertex = b2Clamp(aabb.lowerBound, m_worldAABB.lowerBound, m_worldAABB.upperBound);
> 	b2Vec2 maxVertex = b2Clamp(aabb.upperBound, m_worldAABB.lowerBound, m_worldAABB.upperBound);
> 
> 	// Bump lower bounds downs and upper bounds up. This ensures correct sorting of
> 	// lower/upper bounds that would have equal values.
> 	// TODO_ERIN implement fast float to uint16 conversion.
> 	lowerValues[0] = (uint16)(m_quantizationFactor.x * (minVertex.x - m_worldAABB.lowerBound.x)) & (B2BROADPHASE_MAX - 1);
> 	upperValues[0] = (uint16)(m_quantizationFactor.x * (maxVertex.x - m_worldAABB.lowerBound.x)) | 1;
> 
> 	lowerValues[1] = (uint16)(m_quantizationFactor.y * (minVertex.y - m_worldAABB.lowerBound.y)) & (B2BROADPHASE_MAX - 1);
> 	upperValues[1] = (uint16)(m_quantizationFactor.y * (maxVertex.y - m_worldAABB.lowerBound.y)) | 1;
> }
> 
> void b2BroadPhase::IncrementTimeStamp()
44c161,296
< 	int32 proxyId = m_tree.CreateProxy(aabb, userData);
---
> 	if (m_timeStamp == B2BROADPHASE_MAX)
> 	{
> 		for (uint16 i = 0; i < b2_maxProxies; ++i)
> 		{
> 			m_proxyPool[i].timeStamp = 0;
> 		}
> 		m_timeStamp = 1;
> 	}
> 	else
> 	{
> 		++m_timeStamp;
> 	}
> }
> 
> void b2BroadPhase::IncrementOverlapCount(int32 proxyId)
> {
> 	b2Proxy* proxy = m_proxyPool + proxyId;
> 	if (proxy->timeStamp < m_timeStamp)
> 	{
> 		proxy->timeStamp = m_timeStamp;
> 		proxy->overlapCount = 1;
> 	}
> 	else
> 	{
> 		proxy->overlapCount = 2;
> 		b2Assert(m_queryResultCount < b2_maxProxies);
> 		m_queryResults[m_queryResultCount] = (uint16)proxyId;
> 		++m_queryResultCount;
> 	}
> }
> 
> void b2BroadPhase::Query(int32* lowerQueryOut, int32* upperQueryOut,
> 					   uint16 lowerValue, uint16 upperValue,
> 					   b2Bound* bounds, int32 boundCount, int32 axis)
> {
> 	int32 lowerQuery = BinarySearch(bounds, boundCount, lowerValue);
> 	int32 upperQuery = BinarySearch(bounds, boundCount, upperValue);
> 
> 	// Easy case: lowerQuery <= lowerIndex(i) < upperQuery
> 	// Solution: search query range for min bounds.
> 	for (int32 i = lowerQuery; i < upperQuery; ++i)
> 	{
> 		if (bounds[i].IsLower())
> 		{
> 			IncrementOverlapCount(bounds[i].proxyId);
> 		}
> 	}
> 
> 	// Hard case: lowerIndex(i) < lowerQuery < upperIndex(i)
> 	// Solution: use the stabbing count to search down the bound array.
> 	if (lowerQuery > 0)
> 	{
> 		int32 i = lowerQuery - 1;
> 		int32 s = bounds[i].stabbingCount;
> 
> 		// Find the s overlaps.
> 		while (s)
> 		{
> 			b2Assert(i >= 0);
> 
> 			if (bounds[i].IsLower())
> 			{
> 				b2Proxy* proxy = m_proxyPool + bounds[i].proxyId;
> 				if (lowerQuery <= proxy->upperBounds[axis])
> 				{
> 					IncrementOverlapCount(bounds[i].proxyId);
> 					--s;
> 				}
> 			}
> 			--i;
> 		}
> 	}
> 
> 	*lowerQueryOut = lowerQuery;
> 	*upperQueryOut = upperQuery;
> }
> 
> uint16 b2BroadPhase::CreateProxy(const b2AABB& aabb, void* userData)
> {
> 	b2Assert(m_proxyCount < b2_maxProxies);
> 	b2Assert(m_freeProxy != b2_nullProxy);
> 
> 	uint16 proxyId = m_freeProxy;
> 	b2Proxy* proxy = m_proxyPool + proxyId;
> 	m_freeProxy = proxy->GetNext();
> 
> 	proxy->overlapCount = 0;
> 	proxy->userData = userData;
> 
> 	int32 boundCount = 2 * m_proxyCount;
> 
> 	uint16 lowerValues[2], upperValues[2];
> 	ComputeBounds(lowerValues, upperValues, aabb);
> 
> 	for (int32 axis = 0; axis < 2; ++axis)
> 	{
> 		b2Bound* bounds = m_bounds[axis];
> 		int32 lowerIndex, upperIndex;
> 		Query(&lowerIndex, &upperIndex, lowerValues[axis], upperValues[axis], bounds, boundCount, axis);
> 
> 		memmove(bounds + upperIndex + 2, bounds + upperIndex, (boundCount - upperIndex) * sizeof(b2Bound));
> 		memmove(bounds + lowerIndex + 1, bounds + lowerIndex, (upperIndex - lowerIndex) * sizeof(b2Bound));
> 
> 		// The upper index has increased because of the lower bound insertion.
> 		++upperIndex;
> 
> 		// Copy in the new bounds.
> 		bounds[lowerIndex].value = lowerValues[axis];
> 		bounds[lowerIndex].proxyId = proxyId;
> 		bounds[upperIndex].value = upperValues[axis];
> 		bounds[upperIndex].proxyId = proxyId;
> 
> 		bounds[lowerIndex].stabbingCount = lowerIndex == 0 ? 0 : bounds[lowerIndex-1].stabbingCount;
> 		bounds[upperIndex].stabbingCount = bounds[upperIndex-1].stabbingCount;
> 
> 		// Adjust the stabbing count between the new bounds.
> 		for (int32 index = lowerIndex; index < upperIndex; ++index)
> 		{
> 			++bounds[index].stabbingCount;
> 		}
> 
> 		// Adjust the all the affected bound indices.
> 		for (int32 index = lowerIndex; index < boundCount + 2; ++index)
> 		{
> 			b2Proxy* proxy = m_proxyPool + bounds[index].proxyId;
> 			if (bounds[index].IsLower())
> 			{
> 				proxy->lowerBounds[axis] = (uint16)index;
> 			}
> 			else
> 			{
> 				proxy->upperBounds[axis] = (uint16)index;
> 			}
> 		}
> 	}
> 
46c298,320
< 	BufferMove(proxyId);
---
> 
> 	b2Assert(m_queryResultCount < b2_maxProxies);
> 
> 	// Create pairs if the AABB is in range.
> 	for (int32 i = 0; i < m_queryResultCount; ++i)
> 	{
> 		b2Assert(m_queryResults[i] < b2_maxProxies);
> 		b2Assert(m_proxyPool[m_queryResults[i]].IsValid());
> 
> 		m_pairManager.AddBufferedPair(proxyId, m_queryResults[i]);
> 	}
> 
> 	m_pairManager.Commit();
> 
> 	if (s_validate)
> 	{
> 		Validate();
> 	}
> 
> 	// Prepare for next query.
> 	m_queryResultCount = 0;
> 	IncrementTimeStamp();
> 
52c326,391
< 	UnBufferMove(proxyId);
---
> 	b2Assert(0 < m_proxyCount && m_proxyCount <= b2_maxProxies);
> 	b2Proxy* proxy = m_proxyPool + proxyId;
> 	b2Assert(proxy->IsValid());
> 
> 	int32 boundCount = 2 * m_proxyCount;
> 
> 	for (int32 axis = 0; axis < 2; ++axis)
> 	{
> 		b2Bound* bounds = m_bounds[axis];
> 
> 		int32 lowerIndex = proxy->lowerBounds[axis];
> 		int32 upperIndex = proxy->upperBounds[axis];
> 		uint16 lowerValue = bounds[lowerIndex].value;
> 		uint16 upperValue = bounds[upperIndex].value;
> 
> 		memmove(bounds + lowerIndex, bounds + lowerIndex + 1, (upperIndex - lowerIndex - 1) * sizeof(b2Bound));
> 		memmove(bounds + upperIndex-1, bounds + upperIndex + 1, (boundCount - upperIndex - 1) * sizeof(b2Bound));
> 
> 		// Fix bound indices.
> 		for (int32 index = lowerIndex; index < boundCount - 2; ++index)
> 		{
> 			b2Proxy* proxy = m_proxyPool + bounds[index].proxyId;
> 			if (bounds[index].IsLower())
> 			{
> 				proxy->lowerBounds[axis] = (uint16)index;
> 			}
> 			else
> 			{
> 				proxy->upperBounds[axis] = (uint16)index;
> 			}
> 		}
> 
> 		// Fix stabbing count.
> 		for (int32 index = lowerIndex; index < upperIndex - 1; ++index)
> 		{
> 			--bounds[index].stabbingCount;
> 		}
> 
> 		// Query for pairs to be removed. lowerIndex and upperIndex are not needed.
> 		Query(&lowerIndex, &upperIndex, lowerValue, upperValue, bounds, boundCount - 2, axis);
> 	}
> 
> 	b2Assert(m_queryResultCount < b2_maxProxies);
> 
> 	for (int32 i = 0; i < m_queryResultCount; ++i)
> 	{
> 		b2Assert(m_proxyPool[m_queryResults[i]].IsValid());
> 		m_pairManager.RemoveBufferedPair(proxyId, m_queryResults[i]);
> 	}
> 
> 	m_pairManager.Commit();
> 
> 	// Prepare for next query.
> 	m_queryResultCount = 0;
> 	IncrementTimeStamp();
> 
> 	// Return the proxy to the pool.
> 	proxy->userData = NULL;
> 	proxy->overlapCount = b2_invalid;
> 	proxy->lowerBounds[0] = b2_invalid;
> 	proxy->lowerBounds[1] = b2_invalid;
> 	proxy->upperBounds[0] = b2_invalid;
> 	proxy->upperBounds[1] = b2_invalid;
> 
> 	proxy->SetNext(m_freeProxy);
> 	m_freeProxy = (uint16)proxyId;
54c393,397
< 	m_tree.DestroyProxy(proxyId);
---
> 
> 	if (s_validate)
> 	{
> 		Validate();
> 	}
57c400
< void b2BroadPhase::MoveProxy(int32 proxyId, const b2AABB& aabb, const b2Vec2& displacement)
---
> void b2BroadPhase::MoveProxy(int32 proxyId, const b2AABB& aabb)
59,60c402,598
< 	bool buffer = m_tree.MoveProxy(proxyId, aabb, displacement);
< 	if (buffer)
---
> 	if (proxyId == b2_nullProxy || b2_maxProxies <= proxyId)
> 	{
> 		b2Assert(false);
> 		return;
> 	}
> 
> 	if (aabb.IsValid() == false)
> 	{
> 		b2Assert(false);
> 		return;
> 	}
> 
> 	int32 boundCount = 2 * m_proxyCount;
> 
> 	b2Proxy* proxy = m_proxyPool + proxyId;
> 
> 	// Get new bound values
> 	b2BoundValues newValues;
> 	ComputeBounds(newValues.lowerValues, newValues.upperValues, aabb);
> 
> 	// Get old bound values
> 	b2BoundValues oldValues;
> 	for (int32 axis = 0; axis < 2; ++axis)
> 	{
> 		oldValues.lowerValues[axis] = m_bounds[axis][proxy->lowerBounds[axis]].value;
> 		oldValues.upperValues[axis] = m_bounds[axis][proxy->upperBounds[axis]].value;
> 	}
> 
> 	for (int32 axis = 0; axis < 2; ++axis)
> 	{
> 		b2Bound* bounds = m_bounds[axis];
> 
> 		int32 lowerIndex = proxy->lowerBounds[axis];
> 		int32 upperIndex = proxy->upperBounds[axis];
> 
> 		uint16 lowerValue = newValues.lowerValues[axis];
> 		uint16 upperValue = newValues.upperValues[axis];
> 
> 		int32 deltaLower = lowerValue - bounds[lowerIndex].value;
> 		int32 deltaUpper = upperValue - bounds[upperIndex].value;
> 
> 		bounds[lowerIndex].value = lowerValue;
> 		bounds[upperIndex].value = upperValue;
> 
> 		//
> 		// Expanding adds overlaps
> 		//
> 
> 		// Should we move the lower bound down?
> 		if (deltaLower < 0)
> 		{
> 			int32 index = lowerIndex;
> 			while (index > 0 && lowerValue < bounds[index-1].value)
> 			{
> 				b2Bound* bound = bounds + index;
> 				b2Bound* prevBound = bound - 1;
> 
> 				int32 prevProxyId = prevBound->proxyId;
> 				b2Proxy* prevProxy = m_proxyPool + prevBound->proxyId;
> 
> 				++prevBound->stabbingCount;
> 
> 				if (prevBound->IsUpper() == true)
> 				{
> 					if (TestOverlap(newValues, prevProxy))
> 					{
> 						m_pairManager.AddBufferedPair(proxyId, prevProxyId);
> 					}
> 
> 					++prevProxy->upperBounds[axis];
> 					++bound->stabbingCount;
> 				}
> 				else
> 				{
> 					++prevProxy->lowerBounds[axis];
> 					--bound->stabbingCount;
> 				}
> 
> 				--proxy->lowerBounds[axis];
> 				b2Swap(*bound, *prevBound);
> 				--index;
> 			}
> 		}
> 
> 		// Should we move the upper bound up?
> 		if (deltaUpper > 0)
> 		{
> 			int32 index = upperIndex;
> 			while (index < boundCount-1 && bounds[index+1].value <= upperValue)
> 			{
> 				b2Bound* bound = bounds + index;
> 				b2Bound* nextBound = bound + 1;
> 				int32 nextProxyId = nextBound->proxyId;
> 				b2Proxy* nextProxy = m_proxyPool + nextProxyId;
> 
> 				++nextBound->stabbingCount;
> 
> 				if (nextBound->IsLower() == true)
> 				{
> 					if (TestOverlap(newValues, nextProxy))
> 					{
> 						m_pairManager.AddBufferedPair(proxyId, nextProxyId);
> 					}
> 
> 					--nextProxy->lowerBounds[axis];
> 					++bound->stabbingCount;
> 				}
> 				else
> 				{
> 					--nextProxy->upperBounds[axis];
> 					--bound->stabbingCount;
> 				}
> 
> 				++proxy->upperBounds[axis];
> 				b2Swap(*bound, *nextBound);
> 				++index;
> 			}
> 		}
> 
> 		//
> 		// Shrinking removes overlaps
> 		//
> 
> 		// Should we move the lower bound up?
> 		if (deltaLower > 0)
> 		{
> 			int32 index = lowerIndex;
> 			while (index < boundCount-1 && bounds[index+1].value <= lowerValue)
> 			{
> 				b2Bound* bound = bounds + index;
> 				b2Bound* nextBound = bound + 1;
> 
> 				int32 nextProxyId = nextBound->proxyId;
> 				b2Proxy* nextProxy = m_proxyPool + nextProxyId;
> 
> 				--nextBound->stabbingCount;
> 
> 				if (nextBound->IsUpper())
> 				{
> 					if (TestOverlap(oldValues, nextProxy))
> 					{
> 						m_pairManager.RemoveBufferedPair(proxyId, nextProxyId);
> 					}
> 
> 					--nextProxy->upperBounds[axis];
> 					--bound->stabbingCount;
> 				}
> 				else
> 				{
> 					--nextProxy->lowerBounds[axis];
> 					++bound->stabbingCount;
> 				}
> 
> 				++proxy->lowerBounds[axis];
> 				b2Swap(*bound, *nextBound);
> 				++index;
> 			}
> 		}
> 
> 		// Should we move the upper bound down?
> 		if (deltaUpper < 0)
> 		{
> 			int32 index = upperIndex;
> 			while (index > 0 && upperValue < bounds[index-1].value)
> 			{
> 				b2Bound* bound = bounds + index;
> 				b2Bound* prevBound = bound - 1;
> 
> 				int32 prevProxyId = prevBound->proxyId;
> 				b2Proxy* prevProxy = m_proxyPool + prevProxyId;
> 
> 				--prevBound->stabbingCount;
> 
> 				if (prevBound->IsLower() == true)
> 				{
> 					if (TestOverlap(oldValues, prevProxy))
> 					{
> 						m_pairManager.RemoveBufferedPair(proxyId, prevProxyId);
> 					}
> 
> 					++prevProxy->lowerBounds[axis];
> 					--bound->stabbingCount;
> 				}
> 				else
> 				{
> 					++prevProxy->upperBounds[axis];
> 					++bound->stabbingCount;
> 				}
> 
> 				--proxy->upperBounds[axis];
> 				b2Swap(*bound, *prevBound);
> 				--index;
> 			}
> 		}
> 	}
> 
> 	if (s_validate)
62c600
< 		BufferMove(proxyId);
---
> 		Validate();
66c604
< void b2BroadPhase::TouchProxy(int32 proxyId)
---
> void b2BroadPhase::Commit()
68c606
< 	BufferMove(proxyId);
---
> 	m_pairManager.Commit();
71c609
< void b2BroadPhase::BufferMove(int32 proxyId)
---
> int32 b2BroadPhase::Query(const b2AABB& aabb, void** userData, int32 maxCount)
73c611,623
< 	if (m_moveCount == m_moveCapacity)
---
> 	uint16 lowerValues[2];
> 	uint16 upperValues[2];
> 	ComputeBounds(lowerValues, upperValues, aabb);
> 
> 	int32 lowerIndex, upperIndex;
> 
> 	Query(&lowerIndex, &upperIndex, lowerValues[0], upperValues[0], m_bounds[0], 2*m_proxyCount, 0);
> 	Query(&lowerIndex, &upperIndex, lowerValues[1], upperValues[1], m_bounds[1], 2*m_proxyCount, 1);
> 
> 	b2Assert(m_queryResultCount < b2_maxProxies);
> 
> 	int32 count = 0;
> 	for (int32 i = 0; i < m_queryResultCount && count < maxCount; ++i, ++count)
75,79c625,628
< 		int32* oldBuffer = m_moveBuffer;
< 		m_moveCapacity *= 2;
< 		m_moveBuffer = (int32*)b2Alloc(m_moveCapacity * sizeof(int32));
< 		memcpy(m_moveBuffer, oldBuffer, m_moveCount * sizeof(int32));
< 		b2Free(oldBuffer);
---
> 		b2Assert(m_queryResults[i] < b2_maxProxies);
> 		b2Proxy* proxy = m_proxyPool + m_queryResults[i];
> 		b2Assert(proxy->IsValid());
> 		userData[i] = proxy->userData;
82,83c631,635
< 	m_moveBuffer[m_moveCount] = proxyId;
< 	++m_moveCount;
---
> 	// Prepare for next query.
> 	m_queryResultCount = 0;
> 	IncrementTimeStamp();
> 
> 	return count;
86c638
< void b2BroadPhase::UnBufferMove(int32 proxyId)
---
> void b2BroadPhase::Validate()
88c640
< 	for (int32 i = 0; i < m_moveCount; ++i)
---
> 	for (int32 axis = 0; axis < 2; ++axis)
90c642,647
< 		if (m_moveBuffer[i] == proxyId)
---
> 		b2Bound* bounds = m_bounds[axis];
> 
> 		int32 boundCount = 2 * m_proxyCount;
> 		uint16 stabbingCount = 0;
> 
> 		for (int32 i = 0; i < boundCount; ++i)
92c649,665
< 			m_moveBuffer[i] = e_nullProxy;
---
> 			b2Bound* bound = bounds + i;
> 			b2Assert(i == 0 || bounds[i-1].value <= bound->value);
> 			b2Assert(bound->proxyId != b2_nullProxy);
> 			b2Assert(m_proxyPool[bound->proxyId].IsValid());
> 
> 			if (bound->IsLower() == true)
> 			{
> 				b2Assert(m_proxyPool[bound->proxyId].lowerBounds[axis] == i);
> 				++stabbingCount;
> 			}
> 			else
> 			{
> 				b2Assert(m_proxyPool[bound->proxyId].upperBounds[axis] == i);
> 				--stabbingCount;
> 			}
> 
> 			b2Assert(bound->stabbingCount == stabbingCount);
97,98c670,671
< // This is called from b2DynamicTree::Query when we are gathering pairs.
< bool b2BroadPhase::QueryCallback(int32 proxyId)
---
> 
> int32 b2BroadPhase::QuerySegment(const b2Segment& segment, void** userData, int32 maxCount, SortKeyFunc sortKey)
100,101c673,713
< 	// A proxy cannot form a pair with itself.
< 	if (proxyId == m_queryProxyId)
---
> 	float32 maxLambda = 1;
> 
> 	float32 dx = (segment.p2.x-segment.p1.x)*m_quantizationFactor.x;
> 	float32 dy = (segment.p2.y-segment.p1.y)*m_quantizationFactor.y;
> 
> 	int32 sx = dx<-B2_FLT_EPSILON ? -1 : (dx>B2_FLT_EPSILON ? 1 : 0);
> 	int32 sy = dy<-B2_FLT_EPSILON ? -1 : (dy>B2_FLT_EPSILON ? 1 : 0);
> 
> 	b2Assert(sx!=0||sy!=0);
> 
> 	float32 p1x = (segment.p1.x-m_worldAABB.lowerBound.x)*m_quantizationFactor.x;
> 	float32 p1y = (segment.p1.y-m_worldAABB.lowerBound.y)*m_quantizationFactor.y;
> 
> 	uint16 startValues[2];
> 	uint16 startValues2[2];
> 
> 	int32 xIndex;
> 	int32 yIndex;
> 
> 	uint16 proxyId;
> 	b2Proxy* proxy;
> 	
> 	// TODO_ERIN implement fast float to uint16 conversion.
> 	startValues[0] = (uint16)(p1x) & (B2BROADPHASE_MAX - 1);
> 	startValues2[0] = (uint16)(p1x) | 1;
> 
> 	startValues[1] = (uint16)(p1y) & (B2BROADPHASE_MAX - 1);
> 	startValues2[1] = (uint16)(p1y) | 1;
> 
> 	//First deal with all the proxies that contain segment.p1
> 	int32 lowerIndex;
> 	int32 upperIndex;
> 	Query(&lowerIndex,&upperIndex,startValues[0],startValues2[0],m_bounds[0],2*m_proxyCount,0);
> 	if(sx>=0)	xIndex = upperIndex-1;
> 	else		xIndex = lowerIndex;
> 	Query(&lowerIndex,&upperIndex,startValues[1],startValues2[1],m_bounds[1],2*m_proxyCount,1);
> 	if(sy>=0)	yIndex = upperIndex-1;
> 	else		yIndex = lowerIndex;
> 
> 	//If we are using sortKey, then sort what we have so far, filtering negative keys
> 	if(sortKey)
103c715,744
< 		return true;
---
> 		//Fill keys
> 		for(int32 i=0;i<m_queryResultCount;i++)
> 		{
> 			m_querySortKeys[i] = sortKey(m_proxyPool[m_queryResults[i]].userData);
> 		}
> 		//Bubble sort keys
> 		//Sorting negative values to the top, so we can easily remove them
> 		int32 i = 0;
> 		while(i<m_queryResultCount-1)
> 		{
> 			float32 a = m_querySortKeys[i];
> 			float32 b = m_querySortKeys[i+1];
> 			if((a<0)?(b>=0):(a>b&&b>=0))
> 			{
> 				m_querySortKeys[i+1] = a;
> 				m_querySortKeys[i]   = b;
> 				uint16 tempValue = m_queryResults[i+1];
> 				m_queryResults[i+1] = m_queryResults[i];
> 				m_queryResults[i] = tempValue;
> 				i--;
> 				if(i==-1) i=1;
> 			}
> 			else
> 			{
> 				i++;
> 			}
> 		}
> 		//Skim off negative values
> 		while(m_queryResultCount>0 && m_querySortKeys[m_queryResultCount-1]<0)
> 			m_queryResultCount--;
106,107c747,748
< 	// Grow the pair buffer as needed.
< 	if (m_pairCount == m_pairCapacity)
---
> 	//Now work through the rest of the segment
> 	for (;;)
109,113c750,894
< 		b2Pair* oldBuffer = m_pairBuffer;
< 		m_pairCapacity *= 2;
< 		m_pairBuffer = (b2Pair*)b2Alloc(m_pairCapacity * sizeof(b2Pair));
< 		memcpy(m_pairBuffer, oldBuffer, m_pairCount * sizeof(b2Pair));
< 		b2Free(oldBuffer);
---
> 		float32 xProgress = 0;
> 		float32 yProgress = 0;
> 		//Move on to the next bound
> 		xIndex += sx>=0?1:-1;
> 		if(xIndex<0||xIndex>=m_proxyCount*2)
> 			break;
> 		if(sx!=0)
> 			xProgress = ((float32)m_bounds[0][xIndex].value-p1x)/dx;
> 		//Move on to the next bound
> 		yIndex += sy>=0?1:-1;
> 		if(yIndex<0||yIndex>=m_proxyCount*2)
> 			break;
> 		if(sy!=0)
> 			yProgress = ((float32)m_bounds[1][yIndex].value-p1y)/dy;
> 		for(;;)
> 		{
> 			if(sy==0||(sx!=0&&xProgress<yProgress))
> 			{
> 				if(xProgress>maxLambda)
> 					break;
> 
> 				//Check that we are entering a proxy, not leaving
> 				if(sx>0?m_bounds[0][xIndex].IsLower():m_bounds[0][xIndex].IsUpper()){
> 					//Check the other axis of the proxy
> 					proxyId = m_bounds[0][xIndex].proxyId;
> 					proxy = m_proxyPool+proxyId;
> 					if(sy>=0)
> 					{
> 						if(proxy->lowerBounds[1]<=yIndex-1&&proxy->upperBounds[1]>=yIndex)
> 						{
> 							//Add the proxy
> 							if(sortKey)
> 							{
> 								AddProxyResult(proxyId,proxy,maxCount,sortKey);
> 							}
> 							else
> 							{
> 								m_queryResults[m_queryResultCount] = proxyId;
> 								++m_queryResultCount;
> 							}
> 						}
> 					}
> 					else
> 					{
> 						if(proxy->lowerBounds[1]<=yIndex&&proxy->upperBounds[1]>=yIndex+1)
> 						{
> 							//Add the proxy
> 							if(sortKey)
> 							{
> 								AddProxyResult(proxyId,proxy,maxCount,sortKey);
> 							}
> 							else
> 							{
> 								m_queryResults[m_queryResultCount] = proxyId;
> 								++m_queryResultCount;
> 							}
> 						}
> 					}
> 				}
> 
> 				//Early out
> 				if(sortKey && m_queryResultCount==maxCount && m_queryResultCount>0 && xProgress>m_querySortKeys[m_queryResultCount-1])
> 					break;
> 
> 				//Move on to the next bound
> 				if(sx>0)
> 				{
> 					xIndex++;
> 					if(xIndex==m_proxyCount*2)
> 						break;
> 				}
> 				else
> 				{
> 					xIndex--;
> 					if(xIndex<0)
> 						break;
> 				}
> 				xProgress = ((float32)m_bounds[0][xIndex].value - p1x) / dx;
> 			}
> 			else
> 			{
> 				if(yProgress>maxLambda)
> 					break;
> 
> 				//Check that we are entering a proxy, not leaving
> 				if(sy>0?m_bounds[1][yIndex].IsLower():m_bounds[1][yIndex].IsUpper()){
> 					//Check the other axis of the proxy
> 					proxyId = m_bounds[1][yIndex].proxyId;
> 					proxy = m_proxyPool+proxyId;
> 					if(sx>=0)
> 					{
> 						if(proxy->lowerBounds[0]<=xIndex-1&&proxy->upperBounds[0]>=xIndex)
> 						{
> 							//Add the proxy
> 							if(sortKey)
> 							{
> 								AddProxyResult(proxyId,proxy,maxCount,sortKey);
> 							}
> 							else
> 							{
> 								m_queryResults[m_queryResultCount] = proxyId;
> 								++m_queryResultCount;
> 							}
> 						}
> 					}
> 					else
> 					{
> 						if(proxy->lowerBounds[0]<=xIndex&&proxy->upperBounds[0]>=xIndex+1)
> 						{
> 							//Add the proxy
> 							if(sortKey)
> 							{
> 								AddProxyResult(proxyId,proxy,maxCount,sortKey);
> 							}
> 							else
> 							{
> 								m_queryResults[m_queryResultCount] = proxyId;
> 								++m_queryResultCount;
> 							}
> 						}
> 					}
> 				}
> 
> 				//Early out
> 				if(sortKey && m_queryResultCount==maxCount && m_queryResultCount>0 && yProgress>m_querySortKeys[m_queryResultCount-1])
> 					break;
> 
> 				//Move on to the next bound
> 				if(sy>0)
> 				{
> 					yIndex++;
> 					if(yIndex==m_proxyCount*2)
> 						break;
> 				}
> 				else
> 				{
> 					yIndex--;
> 					if(yIndex<0)
> 						break;
> 				}
> 				yProgress = ((float32)m_bounds[1][yIndex].value - p1y) / dy;
> 			}
> 		}
> 
> 		break;
116,118c897,910
< 	m_pairBuffer[m_pairCount].proxyIdA = b2Min(proxyId, m_queryProxyId);
< 	m_pairBuffer[m_pairCount].proxyIdB = b2Max(proxyId, m_queryProxyId);
< 	++m_pairCount;
---
> 	int32 count = 0;
> 	for(int32 i=0;i < m_queryResultCount && count<maxCount; ++i, ++count)
> 	{
> 		b2Assert(m_queryResults[i] < b2_maxProxies);
> 		b2Proxy* proxy = m_proxyPool + m_queryResults[i];
> 		b2Assert(proxy->IsValid());
> 		userData[i] = proxy->userData;
> 	}
> 
> 	// Prepare for next query.
> 	m_queryResultCount = 0;
> 	IncrementTimeStamp();
> 	
> 	return count;
120d911
< 	return true;
121a913,938
> void b2BroadPhase::AddProxyResult(uint16 proxyId, b2Proxy* proxy, int32 maxCount, SortKeyFunc sortKey)
> {
> 	float32 key = sortKey(proxy->userData);
> 	//Filter proxies on positive keys
> 	if(key<0)
> 		return;
> 	//Merge the new key into the sorted list.
> 	//float32* p = std::lower_bound(m_querySortKeys,m_querySortKeys+m_queryResultCount,key);
> 	float32* p = m_querySortKeys;
> 	while(*p<key&&p<m_querySortKeys+m_queryResultCount)
> 		p++;
> 	int32 i = (int32)(p-m_querySortKeys);
> 	if(maxCount==m_queryResultCount&&i==m_queryResultCount)
> 		return;
> 	if(maxCount==m_queryResultCount)
> 		m_queryResultCount--;
> 	//std::copy_backward
> 	for(int32 j=m_queryResultCount+1;j>i;--j){
> 		m_querySortKeys[j] = m_querySortKeys[j-1];
> 		m_queryResults[j]  = m_queryResults[j-1];
> 	}
> 	m_querySortKeys[i] = key;
> 	m_queryResults[i] = proxyId;
> 	m_queryResultCount++;
> }
> 
diff -r -x './svn/*' native/Box2D/Collision/.svn/text-base/b2BroadPhase.h.svn-base ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Collision/.svn/text-base/b2BroadPhase.h.svn-base
2c2
< * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
22,25c22,39
< #include <Box2D/Common/b2Settings.h>
< #include <Box2D/Collision/b2Collision.h>
< #include <Box2D/Collision/b2DynamicTree.h>
< #include <algorithm>
---
> /*
> This broad phase uses the Sweep and Prune algorithm as described in:
> Collision Detection in Interactive 3D Environments by Gino van den Bergen
> Also, some ideas, such as using integral values for fast compares comes from
> Bullet (http:/www.bulletphysics.com).
> */
> 
> #include "../Common/b2Settings.h"
> #include "b2Collision.h"
> #include "b2PairManager.h"
> #include <limits.h>
> 
> #ifdef TARGET_FLOAT32_IS_FIXED
> #define	B2BROADPHASE_MAX	(USHRT_MAX/2)
> #else
> #define	B2BROADPHASE_MAX	USHRT_MAX
> 
> #endif
27c41,55
< struct b2Pair
---
> const uint16 b2_invalid = B2BROADPHASE_MAX;
> const uint16 b2_nullEdge = B2BROADPHASE_MAX;
> struct b2BoundValues;
> 
> struct b2Bound
> {
> 	bool IsLower() const { return (value & 1) == 0; }
> 	bool IsUpper() const { return (value & 1) == 1; }
> 
> 	uint16 value;
> 	uint16 proxyId;
> 	uint16 stabbingCount;
> };
> 
> struct b2Proxy
29,30c57,64
< 	int32 proxyIdA;
< 	int32 proxyIdB;
---
> 	uint16 GetNext() const { return lowerBounds[0]; }
> 	void SetNext(uint16 next) { lowerBounds[0] = next; }
> 	bool IsValid() const { return overlapCount != b2_invalid; }
> 
> 	uint16 lowerBounds[2], upperBounds[2];
> 	uint16 overlapCount;
> 	uint16 timeStamp;
> 	void* userData;
33,35c67,68
< /// The broad-phase is used for computing pairs and performing volume queries and ray casts.
< /// This broad-phase does not persist pairs. Instead, this reports potentially new pairs.
< /// It is up to the client to consume the new pairs and to track subsequent overlap.
---
> typedef float32 (*SortKeyFunc)(void* shape);
> 
39,45c72
< 
< 	enum
< 	{
< 		e_nullProxy = -1
< 	};
< 
< 	b2BroadPhase();
---
> 	b2BroadPhase(const b2AABB& worldAABB, b2PairCallback* callback);
48,50c75,78
< 	/// Create a proxy with an initial AABB. Pairs are not reported until
< 	/// UpdatePairs is called.
< 	int32 CreateProxy(const b2AABB& aabb, void* userData);
---
> 	// Use this to see if your proxy is in range. If it is not in range,
> 	// it should be destroyed. Otherwise you may get O(m^2) pairs, where m
> 	// is the number of proxies that are out of range.
> 	bool InRange(const b2AABB& aabb) const;
52c80,81
< 	/// Destroy a proxy. It is up to the client to remove any pairs.
---
> 	// Create and destroy proxies. These call Flush first.
> 	uint16 CreateProxy(const b2AABB& aabb, void* userData);
55,112c84,102
< 	/// Call MoveProxy as many times as you like, then when you are done
< 	/// call UpdatePairs to finalized the proxy pairs (for your time step).
< 	void MoveProxy(int32 proxyId, const b2AABB& aabb, const b2Vec2& displacement);
< 
< 	/// Call to trigger a re-processing of it's pairs on the next call to UpdatePairs.
< 	void TouchProxy(int32 proxyId);
< 
< 	/// Get the fat AABB for a proxy.
< 	const b2AABB& GetFatAABB(int32 proxyId) const;
< 
< 	/// Get user data from a proxy. Returns NULL if the id is invalid.
< 	void* GetUserData(int32 proxyId) const;
< 
< 	/// Test overlap of fat AABBs.
< 	bool TestOverlap(int32 proxyIdA, int32 proxyIdB) const;
< 
< 	/// Get the number of proxies.
< 	int32 GetProxyCount() const;
< 
< 	/// Update the pairs. This results in pair callbacks. This can only add pairs.
< 	template <typename T>
< 	void UpdatePairs(T* callback);
< 
< 	/// Query an AABB for overlapping proxies. The callback class
< 	/// is called for each proxy that overlaps the supplied AABB.
< 	template <typename T>
< 	void Query(T* callback, const b2AABB& aabb) const;
< 
< 	/// Ray-cast against the proxies in the tree. This relies on the callback
< 	/// to perform a exact ray-cast in the case were the proxy contains a shape.
< 	/// The callback also performs the any collision filtering. This has performance
< 	/// roughly equal to k * log(n), where k is the number of collisions and n is the
< 	/// number of proxies in the tree.
< 	/// @param input the ray-cast input data. The ray extends from p1 to p1 + maxFraction * (p2 - p1).
< 	/// @param callback a callback class that is called for each proxy that is hit by the ray.
< 	template <typename T>
< 	void RayCast(T* callback, const b2RayCastInput& input) const;
< 
< 	/// Get the height of the embedded tree.
< 	int32 GetTreeHeight() const;
< 
< 	/// Get the balance of the embedded tree.
< 	int32 GetTreeBalance() const;
< 
< 	/// Get the quality metric of the embedded tree.
< 	float32 GetTreeQuality() const;
< 
< 	/// Shift the world origin. Useful for large worlds.
< 	/// The shift formula is: position -= newOrigin
< 	/// @param newOrigin the new origin with respect to the old origin
< 	void ShiftOrigin(const b2Vec2& newOrigin);
< 
< private:
< 
< 	friend class b2DynamicTree;
< 
< 	void BufferMove(int32 proxyId);
< 	void UnBufferMove(int32 proxyId);
---
> 	// Call MoveProxy as many times as you like, then when you are done
> 	// call Commit to finalized the proxy pairs (for your time step).
> 	void MoveProxy(int32 proxyId, const b2AABB& aabb);
> 	void Commit();
> 
> 	// Get a single proxy. Returns NULL if the id is invalid.
> 	b2Proxy* GetProxy(int32 proxyId);
> 
> 	// Query an AABB for overlapping proxies, returns the user data and
> 	// the count, up to the supplied maximum count.
> 	int32 Query(const b2AABB& aabb, void** userData, int32 maxCount);
> 
> 	// Query a segment for overlapping proxies, returns the user data and
> 	// the count, up to the supplied maximum count.
> 	// If sortKey is provided, then it is a function mapping from proxy userDatas to distances along the segment (between 0 & 1)
> 	// Then the returned proxies are sorted on that, before being truncated to maxCount
> 	// The sortKey of a proxy is assumed to be larger than the closest point inside the proxy along the segment, this allows for early exits
> 	// Proxies with a negative sortKey are discarded
> 	int32 QuerySegment(const b2Segment& segment, void** userData, int32 maxCount, SortKeyFunc sortKey);
114c104,105
< 	bool QueryCallback(int32 proxyId);
---
> 	void Validate();
> 	void ValidatePairs();
116,118c107,108
< 	b2DynamicTree m_tree;
< 
< 	int32 m_proxyCount;
---
> private:
> 	void ComputeBounds(uint16* lowerValues, uint16* upperValues, const b2AABB& aabb);
120,126c110,111
< 	int32* m_moveBuffer;
< 	int32 m_moveCapacity;
< 	int32 m_moveCount;
< 
< 	b2Pair* m_pairBuffer;
< 	int32 m_pairCapacity;
< 	int32 m_pairCount;
---
> 	bool TestOverlap(b2Proxy* p1, b2Proxy* p2);
> 	bool TestOverlap(const b2BoundValues& b, b2Proxy* p);
128,137c113,117
< 	int32 m_queryProxyId;
< };
< 
< /// This is used to sort pairs.
< inline bool b2PairLessThan(const b2Pair& pair1, const b2Pair& pair2)
< {
< 	if (pair1.proxyIdA < pair2.proxyIdA)
< 	{
< 		return true;
< 	}
---
> 	void Query(int32* lowerIndex, int32* upperIndex, uint16 lowerValue, uint16 upperValue,
> 				b2Bound* bounds, int32 boundCount, int32 axis);
> 	void IncrementOverlapCount(int32 proxyId);
> 	void IncrementTimeStamp();
> 	void AddProxyResult(uint16 proxyId, b2Proxy* proxy, int32 maxCount, SortKeyFunc sortKey);
139,142c119,120
< 	if (pair1.proxyIdA == pair2.proxyIdA)
< 	{
< 		return pair1.proxyIdB < pair2.proxyIdB;
< 	}
---
> public:
> 	friend class b2PairManager;
144,145c122
< 	return false;
< }
---
> 	b2PairManager m_pairManager;
147,150c124,125
< inline void* b2BroadPhase::GetUserData(int32 proxyId) const
< {
< 	return m_tree.GetUserData(proxyId);
< }
---
> 	b2Proxy m_proxyPool[b2_maxProxies];
> 	uint16 m_freeProxy;
152,157c127
< inline bool b2BroadPhase::TestOverlap(int32 proxyIdA, int32 proxyIdB) const
< {
< 	const b2AABB& aabbA = m_tree.GetFatAABB(proxyIdA);
< 	const b2AABB& aabbB = m_tree.GetFatAABB(proxyIdB);
< 	return b2TestOverlap(aabbA, aabbB);
< }
---
> 	b2Bound m_bounds[2][2*b2_maxProxies];
159,162c129,131
< inline const b2AABB& b2BroadPhase::GetFatAABB(int32 proxyId) const
< {
< 	return m_tree.GetFatAABB(proxyId);
< }
---
> 	uint16 m_queryResults[b2_maxProxies];
> 	float32 m_querySortKeys[b2_maxProxies];
> 	int32 m_queryResultCount;
164,167c133,136
< inline int32 b2BroadPhase::GetProxyCount() const
< {
< 	return m_proxyCount;
< }
---
> 	b2AABB m_worldAABB;
> 	b2Vec2 m_quantizationFactor;
> 	int32 m_proxyCount;
> 	uint16 m_timeStamp;
169,172c138,139
< inline int32 b2BroadPhase::GetTreeHeight() const
< {
< 	return m_tree.GetHeight();
< }
---
> 	static bool s_validate;
> };
174,177d140
< inline int32 b2BroadPhase::GetTreeBalance() const
< {
< 	return m_tree.GetMaxBalance();
< }
179c142
< inline float32 b2BroadPhase::GetTreeQuality() const
---
> inline bool b2BroadPhase::InRange(const b2AABB& aabb) const
181c144,145
< 	return m_tree.GetAreaRatio();
---
> 	b2Vec2 d = b2Max(aabb.lowerBound - m_worldAABB.upperBound, m_worldAABB.lowerBound - aabb.upperBound);
> 	return b2Max(d.x, d.y) < 0.0f;
184,185c148
< template <typename T>
< void b2BroadPhase::UpdatePairs(T* callback)
---
> inline b2Proxy* b2BroadPhase::GetProxy(int32 proxyId)
187,215c150
< 	// Reset pair buffer
< 	m_pairCount = 0;
< 
< 	// Perform tree queries for all moving proxies.
< 	for (int32 i = 0; i < m_moveCount; ++i)
< 	{
< 		m_queryProxyId = m_moveBuffer[i];
< 		if (m_queryProxyId == e_nullProxy)
< 		{
< 			continue;
< 		}
< 
< 		// We have to query the tree with the fat AABB so that
< 		// we don't fail to create a pair that may touch later.
< 		const b2AABB& fatAABB = m_tree.GetFatAABB(m_queryProxyId);
< 
< 		// Query tree, create pairs and add them pair buffer.
< 		m_tree.Query(this, fatAABB);
< 	}
< 
< 	// Reset move buffer
< 	m_moveCount = 0;
< 
< 	// Sort the pair buffer to expose duplicates.
< 	std::sort(m_pairBuffer, m_pairBuffer + m_pairCount, b2PairLessThan);
< 
< 	// Send the pairs back to the client.
< 	int32 i = 0;
< 	while (i < m_pairCount)
---
> 	if (proxyId == b2_nullProxy || m_proxyPool[proxyId].IsValid() == false)
217,233c152
< 		b2Pair* primaryPair = m_pairBuffer + i;
< 		void* userDataA = m_tree.GetUserData(primaryPair->proxyIdA);
< 		void* userDataB = m_tree.GetUserData(primaryPair->proxyIdB);
< 
< 		callback->AddPair(userDataA, userDataB);
< 		++i;
< 
< 		// Skip any duplicate pairs.
< 		while (i < m_pairCount)
< 		{
< 			b2Pair* pair = m_pairBuffer + i;
< 			if (pair->proxyIdA != primaryPair->proxyIdA || pair->proxyIdB != primaryPair->proxyIdB)
< 			{
< 				break;
< 			}
< 			++i;
< 		}
---
> 		return NULL;
236,254c155
< 	// Try to keep the tree balanced.
< 	//m_tree.Rebalance(4);
< }
< 
< template <typename T>
< inline void b2BroadPhase::Query(T* callback, const b2AABB& aabb) const
< {
< 	m_tree.Query(callback, aabb);
< }
< 
< template <typename T>
< inline void b2BroadPhase::RayCast(T* callback, const b2RayCastInput& input) const
< {
< 	m_tree.RayCast(callback, input);
< }
< 
< inline void b2BroadPhase::ShiftOrigin(const b2Vec2& newOrigin)
< {
< 	m_tree.ShiftOrigin(newOrigin);
---
> 	return m_proxyPool + proxyId;
diff -r -x './svn/*' native/Box2D/Collision/.svn/text-base/b2CollideCircle.cpp.svn-base ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Collision/.svn/text-base/b2CollideCircle.cpp.svn-base
2c2
< * Copyright (c) 2007-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2007 Erin Catto http://www.gphysics.com
19,21c19,21
< #include <Box2D/Collision/b2Collision.h>
< #include <Box2D/Collision/Shapes/b2CircleShape.h>
< #include <Box2D/Collision/Shapes/b2PolygonShape.h>
---
> #include "b2Collision.h"
> #include "Shapes/b2CircleShape.h"
> #include "Shapes/b2PolygonShape.h"
25,26c25,26
< 	const b2CircleShape* circleA, const b2Transform& xfA,
< 	const b2CircleShape* circleB, const b2Transform& xfB)
---
> 	const b2CircleShape* circle1, const b2XForm& xf1,
> 	const b2CircleShape* circle2, const b2XForm& xf2)
30,31c30,31
< 	b2Vec2 pA = b2Mul(xfA, circleA->m_p);
< 	b2Vec2 pB = b2Mul(xfB, circleB->m_p);
---
> 	b2Vec2 p1 = b2Mul(xf1, circle1->GetLocalPosition());
> 	b2Vec2 p2 = b2Mul(xf2, circle2->GetLocalPosition());
33c33
< 	b2Vec2 d = pB - pA;
---
> 	b2Vec2 d = p2 - p1;
35,37c35,38
< 	float32 rA = circleA->m_radius, rB = circleB->m_radius;
< 	float32 radius = rA + rB;
< 	if (distSqr > radius * radius)
---
> 	float32 r1 = circle1->GetRadius();
> 	float32 r2 = circle2->GetRadius();
> 	float32 radiusSum = r1 + r2;
> 	if (distSqr > radiusSum * radiusSum)
42,45c43,56
< 	manifold->type = b2Manifold::e_circles;
< 	manifold->localPoint = circleA->m_p;
< 	manifold->localNormal.SetZero();
< 	manifold->pointCount = 1;
---
> 	float32 separation;
> 	if (distSqr < B2_FLT_EPSILON)
> 	{
> 		separation = -radiusSum;
> 		manifold->normal.Set(0.0f, 1.0f);
> 	}
> 	else
> 	{
> 		float32 dist = b2Sqrt(distSqr);
> 		separation = dist - radiusSum;
> 		float32 a = 1.0f / dist;
> 		manifold->normal.x = a * d.x;
> 		manifold->normal.y = a * d.y;
> 	}
47c58
< 	manifold->points[0].localPoint = circleB->m_p;
---
> 	manifold->pointCount = 1;
48a60,68
> 	manifold->points[0].separation = separation;
> 
> 	p1 += r1 * manifold->normal;
> 	p2 -= r2 * manifold->normal;
> 
> 	b2Vec2 p = 0.5f * (p1 + p2);
> 
> 	manifold->points[0].localPoint1 = b2MulT(xf1, p);
> 	manifold->points[0].localPoint2 = b2MulT(xf2, p);
53,54c73,74
< 	const b2PolygonShape* polygonA, const b2Transform& xfA,
< 	const b2CircleShape* circleB, const b2Transform& xfB)
---
> 	const b2PolygonShape* polygon, const b2XForm& xf1,
> 	const b2CircleShape* circle, const b2XForm& xf2)
59,60c79,80
< 	b2Vec2 c = b2Mul(xfB, circleB->m_p);
< 	b2Vec2 cLocal = b2MulT(xfA, c);
---
> 	b2Vec2 c = b2Mul(xf2, circle->GetLocalPosition());
> 	b2Vec2 cLocal = b2MulT(xf1, c);
64,68c84,88
< 	float32 separation = -b2_maxFloat;
< 	float32 radius = polygonA->m_radius + circleB->m_radius;
< 	int32 vertexCount = polygonA->m_count;
< 	const b2Vec2* vertices = polygonA->m_vertices;
< 	const b2Vec2* normals = polygonA->m_normals;
---
> 	float32 separation = -B2_FLT_MAX;
> 	float32 radius = circle->GetRadius();
> 	int32 vertexCount = polygon->GetVertexCount();
> 	const b2Vec2* vertices = polygon->GetVertices();
> 	const b2Vec2* normals = polygon->GetNormals();
87,92d106
< 	// Vertices that subtend the incident face.
< 	int32 vertIndex1 = normalIndex;
< 	int32 vertIndex2 = vertIndex1 + 1 < vertexCount ? vertIndex1 + 1 : 0;
< 	b2Vec2 v1 = vertices[vertIndex1];
< 	b2Vec2 v2 = vertices[vertIndex2];
< 
94c108
< 	if (separation < b2_epsilon)
---
> 	if (separation < B2_FLT_EPSILON)
97,101c111,119
< 		manifold->type = b2Manifold::e_faceA;
< 		manifold->localNormal = normals[normalIndex];
< 		manifold->localPoint = 0.5f * (v1 + v2);
< 		manifold->points[0].localPoint = circleB->m_p;
< 		manifold->points[0].id.key = 0;
---
> 		manifold->normal = b2Mul(xf1.R, normals[normalIndex]);
> 		manifold->points[0].id.features.incidentEdge = (uint8)normalIndex;
> 		manifold->points[0].id.features.incidentVertex = b2_nullFeature;
> 		manifold->points[0].id.features.referenceEdge = 0;
> 		manifold->points[0].id.features.flip = 0;
> 		b2Vec2 position = c - radius * manifold->normal;
> 		manifold->points[0].localPoint1 = b2MulT(xf1, position);
> 		manifold->points[0].localPoint2 = b2MulT(xf2, position);
> 		manifold->points[0].separation = separation - radius;
105,113c123,126
< 	// Compute barycentric coordinates
< 	float32 u1 = b2Dot(cLocal - v1, v2 - v1);
< 	float32 u2 = b2Dot(cLocal - v2, v1 - v2);
< 	if (u1 <= 0.0f)
< 	{
< 		if (b2DistanceSquared(cLocal, v1) > radius * radius)
< 		{
< 			return;
< 		}
---
> 	// Project the circle center onto the edge segment.
> 	int32 vertIndex1 = normalIndex;
> 	int32 vertIndex2 = vertIndex1 + 1 < vertexCount ? vertIndex1 + 1 : 0;
> 	b2Vec2 e = vertices[vertIndex2] - vertices[vertIndex1];
115,121c128,138
< 		manifold->pointCount = 1;
< 		manifold->type = b2Manifold::e_faceA;
< 		manifold->localNormal = cLocal - v1;
< 		manifold->localNormal.Normalize();
< 		manifold->localPoint = v1;
< 		manifold->points[0].localPoint = circleB->m_p;
< 		manifold->points[0].id.key = 0;
---
> 	float32 length = e.Normalize();
> 	b2Assert(length > B2_FLT_EPSILON);
> 
> 	// Project the center onto the edge.
> 	float32 u = b2Dot(cLocal - vertices[vertIndex1], e);
> 	b2Vec2 p;
> 	if (u <= 0.0f)
> 	{
> 		p = vertices[vertIndex1];
> 		manifold->points[0].id.features.incidentEdge = b2_nullFeature;
> 		manifold->points[0].id.features.incidentVertex = (uint8)vertIndex1;
123c140
< 	else if (u2 <= 0.0f)
---
> 	else if (u >= length)
125,136c142,144
< 		if (b2DistanceSquared(cLocal, v2) > radius * radius)
< 		{
< 			return;
< 		}
< 
< 		manifold->pointCount = 1;
< 		manifold->type = b2Manifold::e_faceA;
< 		manifold->localNormal = cLocal - v2;
< 		manifold->localNormal.Normalize();
< 		manifold->localPoint = v2;
< 		manifold->points[0].localPoint = circleB->m_p;
< 		manifold->points[0].id.key = 0;
---
> 		p = vertices[vertIndex2];
> 		manifold->points[0].id.features.incidentEdge = b2_nullFeature;
> 		manifold->points[0].id.features.incidentVertex = (uint8)vertIndex2;
140,145c148,151
< 		b2Vec2 faceCenter = 0.5f * (v1 + v2);
< 		float32 separation = b2Dot(cLocal - faceCenter, normals[vertIndex1]);
< 		if (separation > radius)
< 		{
< 			return;
< 		}
---
> 		p = vertices[vertIndex1] + u * e;
> 		manifold->points[0].id.features.incidentEdge = (uint8)normalIndex;
> 		manifold->points[0].id.features.incidentVertex = b2_nullFeature;
> 	}
147,152c153,157
< 		manifold->pointCount = 1;
< 		manifold->type = b2Manifold::e_faceA;
< 		manifold->localNormal = normals[vertIndex1];
< 		manifold->localPoint = faceCenter;
< 		manifold->points[0].localPoint = circleB->m_p;
< 		manifold->points[0].id.key = 0;
---
> 	b2Vec2 d = cLocal - p;
> 	float32 dist = d.Normalize();
> 	if (dist > radius)
> 	{
> 		return;
153a159,167
> 
> 	manifold->pointCount = 1;
> 	manifold->normal = b2Mul(xf1.R, d);
> 	b2Vec2 position = c - radius * manifold->normal;
> 	manifold->points[0].localPoint1 = b2MulT(xf1, position);
> 	manifold->points[0].localPoint2 = b2MulT(xf2, position);
> 	manifold->points[0].separation = dist - radius;
> 	manifold->points[0].id.features.referenceEdge = 0;
> 	manifold->points[0].id.features.flip = 0;
Only in native/Box2D/Collision/.svn/text-base: b2CollideEdge.cpp.svn-base
Only in ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Collision/.svn/text-base: b2CollidePoly.cpp.svn-base
Only in native/Box2D/Collision/.svn/text-base: b2CollidePolygon.cpp.svn-base
diff -r -x './svn/*' native/Box2D/Collision/.svn/text-base/b2Collision.cpp.svn-base ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Collision/.svn/text-base/b2Collision.cpp.svn-base
2c2
< * Copyright (c) 2007-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2007 Erin Catto http://www.gphysics.com
19,20c19
< #include <Box2D/Collision/b2Collision.h>
< #include <Box2D/Collision/b2Distance.h>
---
> #include "b2Collision.h"
22,24c21,36
< void b2WorldManifold::Initialize(const b2Manifold* manifold,
< 						  const b2Transform& xfA, float32 radiusA,
< 						  const b2Transform& xfB, float32 radiusB)
---
> // Collision Detection in Interactive 3D Environments by Gino van den Bergen
> // From Section 3.4.1
> // x = mu1 * p1 + mu2 * p2
> // mu1 + mu2 = 1 && mu1 >= 0 && mu2 >= 0
> // mu1 = 1 - mu2;
> // x = (1 - mu2) * p1 + mu2 * p2
> //   = p1 + mu2 * (p2 - p1)
> // x = s + a * r (s := start, r := end - start)
> // s + a * r = p1 + mu2 * d (d := p2 - p1)
> // -a * r + mu2 * d = b (b := s - p1)
> // [-r d] * [a; mu2] = b
> // Cramer's rule:
> // denom = det[-r d]
> // a = det[b d] / denom
> // mu2 = det[-r b] / denom
> bool b2Segment::TestSegment(float32* lambda, b2Vec2* normal, const b2Segment& segment, float32 maxLambda) const
26,76c38,41
< 	if (manifold->pointCount == 0)
< 	{
< 		return;
< 	}
< 
< 	switch (manifold->type)
< 	{
< 	case b2Manifold::e_circles:
< 		{
< 			normal.Set(1.0f, 0.0f);
< 			b2Vec2 pointA = b2Mul(xfA, manifold->localPoint);
< 			b2Vec2 pointB = b2Mul(xfB, manifold->points[0].localPoint);
< 			if (b2DistanceSquared(pointA, pointB) > b2_epsilon * b2_epsilon)
< 			{
< 				normal = pointB - pointA;
< 				normal.Normalize();
< 			}
< 
< 			b2Vec2 cA = pointA + radiusA * normal;
< 			b2Vec2 cB = pointB - radiusB * normal;
< 			points[0] = 0.5f * (cA + cB);
< 		}
< 		break;
< 
< 	case b2Manifold::e_faceA:
< 		{
< 			normal = b2Mul(xfA.q, manifold->localNormal);
< 			b2Vec2 planePoint = b2Mul(xfA, manifold->localPoint);
< 			
< 			for (int32 i = 0; i < manifold->pointCount; ++i)
< 			{
< 				b2Vec2 clipPoint = b2Mul(xfB, manifold->points[i].localPoint);
< 				b2Vec2 cA = clipPoint + (radiusA - b2Dot(clipPoint - planePoint, normal)) * normal;
< 				b2Vec2 cB = clipPoint - radiusB * normal;
< 				points[i] = 0.5f * (cA + cB);
< 			}
< 		}
< 		break;
< 
< 	case b2Manifold::e_faceB:
< 		{
< 			normal = b2Mul(xfB.q, manifold->localNormal);
< 			b2Vec2 planePoint = b2Mul(xfB, manifold->localPoint);
< 
< 			for (int32 i = 0; i < manifold->pointCount; ++i)
< 			{
< 				b2Vec2 clipPoint = b2Mul(xfA, manifold->points[i].localPoint);
< 				b2Vec2 cB = clipPoint + (radiusB - b2Dot(clipPoint - planePoint, normal)) * normal;
< 				b2Vec2 cA = clipPoint - radiusA * normal;
< 				points[i] = 0.5f * (cA + cB);
< 			}
---
> 	b2Vec2 s = segment.p1;
> 	b2Vec2 r = segment.p2 - s;
> 	b2Vec2 d = p2 - p1;
> 	b2Vec2 n = b2Cross(d, 1.0f);
78,92c43,44
< 			// Ensure normal points from A to B.
< 			normal = -normal;
< 		}
< 		break;
< 	}
< }
< 
< void b2GetPointStates(b2PointState state1[b2_maxManifoldPoints], b2PointState state2[b2_maxManifoldPoints],
< 					  const b2Manifold* manifold1, const b2Manifold* manifold2)
< {
< 	for (int32 i = 0; i < b2_maxManifoldPoints; ++i)
< 	{
< 		state1[i] = b2_nullState;
< 		state2[i] = b2_nullState;
< 	}
---
> 	const float32 k_slop = 100.0f * B2_FLT_EPSILON;
> 	float32 denom = -b2Dot(r, n);
94,95c46,47
< 	// Detect persists and removes.
< 	for (int32 i = 0; i < manifold1->pointCount; ++i)
---
> 	// Cull back facing collision and ignore parallel segments.
> 	if (denom > k_slop)
97,127c49,51
< 		b2ContactID id = manifold1->points[i].id;
< 
< 		state1[i] = b2_removeState;
< 
< 		for (int32 j = 0; j < manifold2->pointCount; ++j)
< 		{
< 			if (manifold2->points[j].id.key == id.key)
< 			{
< 				state1[i] = b2_persistState;
< 				break;
< 			}
< 		}
< 	}
< 
< 	// Detect persists and adds.
< 	for (int32 i = 0; i < manifold2->pointCount; ++i)
< 	{
< 		b2ContactID id = manifold2->points[i].id;
< 
< 		state2[i] = b2_addState;
< 
< 		for (int32 j = 0; j < manifold1->pointCount; ++j)
< 		{
< 			if (manifold1->points[j].id.key == id.key)
< 			{
< 				state2[i] = b2_persistState;
< 				break;
< 			}
< 		}
< 	}
< }
---
> 		// Does the segment intersect the infinite line associated with this segment?
> 		b2Vec2 b = s - p1;
> 		float32 a = b2Dot(b, n);
129,143c53
< // From Real-time Collision Detection, p179.
< bool b2AABB::RayCast(b2RayCastOutput* output, const b2RayCastInput& input) const
< {
< 	float32 tmin = -b2_maxFloat;
< 	float32 tmax = b2_maxFloat;
< 
< 	b2Vec2 p = input.p1;
< 	b2Vec2 d = input.p2 - input.p1;
< 	b2Vec2 absD = b2Abs(d);
< 
< 	b2Vec2 normal;
< 
< 	for (int32 i = 0; i < 2; ++i)
< 	{
< 		if (absD(i) < b2_epsilon)
---
> 		if (0.0f <= a && a <= maxLambda * denom)
145,175c55
< 			// Parallel.
< 			if (p(i) < lowerBound(i) || upperBound(i) < p(i))
< 			{
< 				return false;
< 			}
< 		}
< 		else
< 		{
< 			float32 inv_d = 1.0f / d(i);
< 			float32 t1 = (lowerBound(i) - p(i)) * inv_d;
< 			float32 t2 = (upperBound(i) - p(i)) * inv_d;
< 
< 			// Sign of the normal vector.
< 			float32 s = -1.0f;
< 
< 			if (t1 > t2)
< 			{
< 				b2Swap(t1, t2);
< 				s = 1.0f;
< 			}
< 
< 			// Push the min up
< 			if (t1 > tmin)
< 			{
< 				normal.SetZero();
< 				normal(i) = s;
< 				tmin = t1;
< 			}
< 
< 			// Pull the max down
< 			tmax = b2Min(tmax, t2);
---
> 			float32 mu2 = -r.x * b.y + r.y * b.x;
177c57,58
< 			if (tmin > tmax)
---
> 			// Does the segment intersect this segment?
> 			if (-k_slop * denom <= mu2 && mu2 <= denom * (1.0f + k_slop))
179c60,64
< 				return false;
---
> 				a /= denom;
> 				n.Normalize();
> 				*lambda = a;
> 				*normal = n;
> 				return true;
184,194c69
< 	// Does the ray start inside the box?
< 	// Does the ray intersect beyond the max fraction?
< 	if (tmin < 0.0f || input.maxFraction < tmin)
< 	{
< 		return false;
< 	}
< 
< 	// Intersection.
< 	output->fraction = tmin;
< 	output->normal = normal;
< 	return true;
---
> 	return false;
197,210d71
< // Sutherland-Hodgman clipping.
< int32 b2ClipSegmentToLine(b2ClipVertex vOut[2], const b2ClipVertex vIn[2],
< 						const b2Vec2& normal, float32 offset, int32 vertexIndexA)
< {
< 	// Start with no output points
< 	int32 numOut = 0;
< 
< 	// Calculate the distance of end points to the line
< 	float32 distance0 = b2Dot(normal, vIn[0].v) - offset;
< 	float32 distance1 = b2Dot(normal, vIn[1].v) - offset;
< 
< 	// If the points are behind the plane
< 	if (distance0 <= 0.0f) vOut[numOut++] = vIn[0];
< 	if (distance1 <= 0.0f) vOut[numOut++] = vIn[1];
212,249d72
< 	// If the points are on different sides of the plane
< 	if (distance0 * distance1 < 0.0f)
< 	{
< 		// Find intersection point of edge and plane
< 		float32 interp = distance0 / (distance0 - distance1);
< 		vOut[numOut].v = vIn[0].v + interp * (vIn[1].v - vIn[0].v);
< 
< 		// VertexA is hitting edgeB.
< 		vOut[numOut].id.cf.indexA = vertexIndexA;
< 		vOut[numOut].id.cf.indexB = vIn[0].id.cf.indexB;
< 		vOut[numOut].id.cf.typeA = b2ContactFeature::e_vertex;
< 		vOut[numOut].id.cf.typeB = b2ContactFeature::e_face;
< 		++numOut;
< 	}
< 
< 	return numOut;
< }
< 
< bool b2TestOverlap(	const b2Shape* shapeA, int32 indexA,
< 					const b2Shape* shapeB, int32 indexB,
< 					const b2Transform& xfA, const b2Transform& xfB)
< {
< 	b2DistanceInput input;
< 	input.proxyA.Set(shapeA, indexA);
< 	input.proxyB.Set(shapeB, indexB);
< 	input.transformA = xfA;
< 	input.transformB = xfB;
< 	input.useRadii = true;
< 
< 	b2SimplexCache cache;
< 	cache.count = 0;
< 
< 	b2DistanceOutput output;
< 
< 	b2Distance(&output, &cache, &input);
< 
< 	return output.distance < 10.0f * b2_epsilon;
< }
diff -r -x './svn/*' native/Box2D/Collision/.svn/text-base/b2Collision.h.svn-base ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Collision/.svn/text-base/b2Collision.h.svn-base
2c2
< * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
22,23c22,23
< #include <Box2D/Common/b2Math.h>
< #include <climits>
---
> #include "../Common/b2Math.h"
> #include <limits.h>
31d30
< class b2EdgeShape;
32a32
> class b2EdgeShape;
36,51d35
< /// The features that intersect to form the contact point
< /// This must be 4 bytes or less.
< struct b2ContactFeature
< {
< 	enum Type
< 	{
< 		e_vertex = 0,
< 		e_face = 1
< 	};
< 
< 	uint8 indexA;		///< Feature index on shapeA
< 	uint8 indexB;		///< Feature index on shapeB
< 	uint8 typeA;		///< The feature type on shapeA
< 	uint8 typeB;		///< The feature type on shapeB
< };
< 
55c39,46
< 	b2ContactFeature cf;
---
> 	/// The features that intersect to form the contact point
> 	struct Features
> 	{
> 		uint8 referenceEdge;	///< The edge that defines the outward contact normal.
> 		uint8 incidentEdge;		///< The edge most anti-parallel to the reference edge.
> 		uint8 incidentVertex;	///< The vertex (0 or 1) on the incident edge that was clipped.
> 		uint8 flip;				///< A value of 1 indicates that the reference edge is on shape2.
> 	} features;
62,68c53,54
< /// The local point usage depends on the manifold type:
< /// -e_circles: the local center of circleB
< /// -e_faceA: the local center of cirlceB or the clip point of polygonB
< /// -e_faceB: the clip point of polygonA
< /// This structure is stored across time steps, so we keep it small.
< /// Note: the impulses are used for internal caching and may not
< /// provide reliable contact forces, especially for high speed collisions.
---
> /// The point is stored in local coordinates because CCD
> /// requires sub-stepping in which the separation is stale.
71c57,59
< 	b2Vec2 localPoint;		///< usage depends on manifold type
---
> 	b2Vec2 localPoint1;		///< local position of the contact point in body1
> 	b2Vec2 localPoint2;		///< local position of the contact point in body2
> 	float32 separation;		///< the separation of the shapes along the normal vector
78,92d65
< /// Box2D supports multiple types of contact:
< /// - clip point versus plane with radius
< /// - point versus point with radius (circles)
< /// The local point usage depends on the manifold type:
< /// -e_circles: the local center of circleA
< /// -e_faceA: the center of faceA
< /// -e_faceB: the center of faceB
< /// Similarly the local normal usage:
< /// -e_circles: not used
< /// -e_faceA: the normal on polygonA
< /// -e_faceB: the normal on polygonB
< /// We store contacts in this way so that position correction can
< /// account for movement, which is critical for continuous physics.
< /// All contact scenarios must be expressed in one of these types.
< /// This structure is stored across time steps, so we keep it small.
95,101d67
< 	enum Type
< 	{
< 		e_circles,
< 		e_faceA,
< 		e_faceB
< 	};
< 
103,142c69,70
< 	b2Vec2 localNormal;								///< not use for Type::e_points
< 	b2Vec2 localPoint;								///< usage depends on manifold type
< 	Type type;
< 	int32 pointCount;								///< the number of manifold points
< };
< 
< /// This is used to compute the current state of a contact manifold.
< struct b2WorldManifold
< {
< 	/// Evaluate the manifold with supplied transforms. This assumes
< 	/// modest motion from the original state. This does not change the
< 	/// point count, impulses, etc. The radii must come from the shapes
< 	/// that generated the manifold.
< 	void Initialize(const b2Manifold* manifold,
< 					const b2Transform& xfA, float32 radiusA,
< 					const b2Transform& xfB, float32 radiusB);
< 
< 	b2Vec2 normal;							///< world vector pointing from A to B
< 	b2Vec2 points[b2_maxManifoldPoints];	///< world contact point (point of intersection)
< };
< 
< /// This is used for determining the state of contact points.
< enum b2PointState
< {
< 	b2_nullState,		///< point does not exist
< 	b2_addState,		///< point was added in the update
< 	b2_persistState,	///< point persisted across the update
< 	b2_removeState		///< point was removed in the update
< };
< 
< /// Compute the point states given two manifolds. The states pertain to the transition from manifold1
< /// to manifold2. So state1 is either persist or remove while state2 is either add or persist.
< void b2GetPointStates(b2PointState state1[b2_maxManifoldPoints], b2PointState state2[b2_maxManifoldPoints],
< 					  const b2Manifold* manifold1, const b2Manifold* manifold2);
< 
< /// Used for computing contact manifolds.
< struct b2ClipVertex
< {
< 	b2Vec2 v;
< 	b2ContactID id;
---
> 	b2Vec2 normal;	///< the shared unit normal vector
> 	int32 pointCount;	///< the number of manifold points
145,146c73,74
< /// Ray-cast input data. The ray extends from p1 to p1 + maxFraction * (p2 - p1).
< struct b2RayCastInput
---
> /// A line segment.
> struct b2Segment
148,150c76,77
< 	b2Vec2 p1, p2;
< 	float32 maxFraction;
< };
---
> 	/// Ray cast against this segment with another segment.
> 	bool TestSegment(float32* lambda, b2Vec2* normal, const b2Segment& segment, float32 maxLambda) const;
152,157c79,80
< /// Ray-cast output data. The ray hits at p1 + fraction * (p2 - p1), where p1 and p2
< /// come from b2RayCastInput.
< struct b2RayCastOutput
< {
< 	b2Vec2 normal;
< 	float32 fraction;
---
> 	b2Vec2 p1;	///< the starting point
> 	b2Vec2 p2;	///< the ending point
166,212d88
< 	/// Get the center of the AABB.
< 	b2Vec2 GetCenter() const
< 	{
< 		return 0.5f * (lowerBound + upperBound);
< 	}
< 
< 	/// Get the extents of the AABB (half-widths).
< 	b2Vec2 GetExtents() const
< 	{
< 		return 0.5f * (upperBound - lowerBound);
< 	}
< 
< 	/// Get the perimeter length
< 	float32 GetPerimeter() const
< 	{
< 		float32 wx = upperBound.x - lowerBound.x;
< 		float32 wy = upperBound.y - lowerBound.y;
< 		return 2.0f * (wx + wy);
< 	}
< 
< 	/// Combine an AABB into this one.
< 	void Combine(const b2AABB& aabb)
< 	{
< 		lowerBound = b2Min(lowerBound, aabb.lowerBound);
< 		upperBound = b2Max(upperBound, aabb.upperBound);
< 	}
< 
< 	/// Combine two AABBs into this one.
< 	void Combine(const b2AABB& aabb1, const b2AABB& aabb2)
< 	{
< 		lowerBound = b2Min(aabb1.lowerBound, aabb2.lowerBound);
< 		upperBound = b2Max(aabb1.upperBound, aabb2.upperBound);
< 	}
< 
< 	/// Does this aabb contain the provided AABB.
< 	bool Contains(const b2AABB& aabb) const
< 	{
< 		bool result = true;
< 		result = result && lowerBound.x <= aabb.lowerBound.x;
< 		result = result && lowerBound.y <= aabb.lowerBound.y;
< 		result = result && aabb.upperBound.x <= upperBound.x;
< 		result = result && aabb.upperBound.y <= upperBound.y;
< 		return result;
< 	}
< 
< 	bool RayCast(b2RayCastOutput* output, const b2RayCastInput& input) const;
< 
216a93,100
> /// An oriented bounding box.
> struct b2OBB
> {
> 	b2Mat22 R;			///< the rotation matrix
> 	b2Vec2 center;		///< the local centroid
> 	b2Vec2 extents;		///< the half-widths
> };
> 
219,220c103,104
< 					  const b2CircleShape* circleA, const b2Transform& xfA,
< 					  const b2CircleShape* circleB, const b2Transform& xfB);
---
> 					  const b2CircleShape* circle1, const b2XForm& xf1,
> 					  const b2CircleShape* circle2, const b2XForm& xf2);
224,225c108,109
< 							   const b2PolygonShape* polygonA, const b2Transform& xfA,
< 							   const b2CircleShape* circleB, const b2Transform& xfB);
---
> 							   const b2PolygonShape* polygon, const b2XForm& xf1,
> 							   const b2CircleShape* circle, const b2XForm& xf2);
227c111
< /// Compute the collision manifold between two polygons.
---
> /// Compute the collision manifold between two circles.
229,230c113,127
< 					   const b2PolygonShape* polygonA, const b2Transform& xfA,
< 					   const b2PolygonShape* polygonB, const b2Transform& xfB);
---
> 					   const b2PolygonShape* polygon1, const b2XForm& xf1,
> 					   const b2PolygonShape* polygon2, const b2XForm& xf2);
> 
> /// Compute the distance between two shapes and the closest points.
> /// @return the distance between the shapes or zero if they are overlapped/touching.
> float32 b2Distance(b2Vec2* x1, b2Vec2* x2,
> 				   const b2Shape* shape1, const b2XForm& xf1,
> 				   const b2Shape* shape2, const b2XForm& xf2);
> 
> /// Compute the time when two shapes begin to touch or touch at a closer distance.
> /// @warning the sweeps must have the same time interval.
> /// @return the fraction between [0,1] in which the shapes first touch.
> /// fraction=0 means the shapes begin touching/overlapped, and fraction=1 means the shapes don't touch.
> float32 b2TimeOfImpact(const b2Shape* shape1, const b2Sweep& sweep1,
> 					   const b2Shape* shape2, const b2Sweep& sweep2);
232,249d128
< /// Compute the collision manifold between an edge and a circle.
< void b2CollideEdgeAndCircle(b2Manifold* manifold,
< 							   const b2EdgeShape* polygonA, const b2Transform& xfA,
< 							   const b2CircleShape* circleB, const b2Transform& xfB);
< 
< /// Compute the collision manifold between an edge and a circle.
< void b2CollideEdgeAndPolygon(b2Manifold* manifold,
< 							   const b2EdgeShape* edgeA, const b2Transform& xfA,
< 							   const b2PolygonShape* circleB, const b2Transform& xfB);
< 
< /// Clipping for contact manifolds.
< int32 b2ClipSegmentToLine(b2ClipVertex vOut[2], const b2ClipVertex vIn[2],
< 							const b2Vec2& normal, float32 offset, int32 vertexIndexA);
< 
< /// Determine if two generic shapes overlap.
< bool b2TestOverlap(	const b2Shape* shapeA, int32 indexA,
< 					const b2Shape* shapeB, int32 indexB,
< 					const b2Transform& xfA, const b2Transform& xfB);
diff -r -x './svn/*' native/Box2D/Collision/.svn/text-base/b2Distance.cpp.svn-base ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Collision/.svn/text-base/b2Distance.cpp.svn-base
2c2
< * Copyright (c) 2007-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2007 Erin Catto http://www.gphysics.com
19,23c19,54
< #include <Box2D/Collision/b2Distance.h>
< #include <Box2D/Collision/Shapes/b2CircleShape.h>
< #include <Box2D/Collision/Shapes/b2EdgeShape.h>
< #include <Box2D/Collision/Shapes/b2ChainShape.h>
< #include <Box2D/Collision/Shapes/b2PolygonShape.h>
---
> #include "b2Collision.h"
> #include "Shapes/b2CircleShape.h"
> #include "Shapes/b2PolygonShape.h"
> #include "Shapes/b2EdgeShape.h"
> 
> int32 g_GJK_Iterations = 0;
> 
> // GJK using Voronoi regions (Christer Ericson) and region selection
> // optimizations (Casey Muratori).
> 
> // The origin is either in the region of points[1] or in the edge region. The origin is
> // not in region of points[0] because that is the old point.
> static int32 ProcessTwo(b2Vec2* x1, b2Vec2* x2, b2Vec2* p1s, b2Vec2* p2s, b2Vec2* points)
> {
> 	// If in point[1] region
> 	b2Vec2 r = -points[1];
> 	b2Vec2 d = points[0] - points[1];
> 	float32 length = d.Normalize();
> 	float32 lambda = b2Dot(r, d);
> 	if (lambda <= 0.0f || length < B2_FLT_EPSILON)
> 	{
> 		// The simplex is reduced to a point.
> 		*x1 = p1s[1];
> 		*x2 = p2s[1];
> 		p1s[0] = p1s[1];
> 		p2s[0] = p2s[1];
> 		points[0] = points[1];
> 		return 1;
> 	}
> 
> 	// Else in edge region
> 	lambda /= length;
> 	*x1 = p1s[1] + lambda * (p1s[0] - p1s[1]);
> 	*x2 = p2s[1] + lambda * (p2s[0] - p2s[1]);
> 	return 2;
> }
25,26c56,147
< // GJK using Voronoi regions (Christer Ericson) and Barycentric coordinates.
< int32 b2_gjkCalls, b2_gjkIters, b2_gjkMaxIters;
---
> // Possible regions:
> // - points[2]
> // - edge points[0]-points[2]
> // - edge points[1]-points[2]
> // - inside the triangle
> static int32 ProcessThree(b2Vec2* x1, b2Vec2* x2, b2Vec2* p1s, b2Vec2* p2s, b2Vec2* points)
> {
> 	b2Vec2 a = points[0];
> 	b2Vec2 b = points[1];
> 	b2Vec2 c = points[2];
> 
> 	b2Vec2 ab = b - a;
> 	b2Vec2 ac = c - a;
> 	b2Vec2 bc = c - b;
> 
> 	float32 sn = -b2Dot(a, ab), sd = b2Dot(b, ab);
> 	float32 tn = -b2Dot(a, ac), td = b2Dot(c, ac);
> 	float32 un = -b2Dot(b, bc), ud = b2Dot(c, bc);
> 
> 	// In vertex c region?
> 	if (td <= 0.0f && ud <= 0.0f)
> 	{
> 		// Single point
> 		*x1 = p1s[2];
> 		*x2 = p2s[2];
> 		p1s[0] = p1s[2];
> 		p2s[0] = p2s[2];
> 		points[0] = points[2];
> 		return 1;
> 	}
> 
> 	// Should not be in vertex a or b region.
> 	B2_NOT_USED(sd);
> 	B2_NOT_USED(sn);
> 	b2Assert(sn > 0.0f || tn > 0.0f);
> 	b2Assert(sd > 0.0f || un > 0.0f);
> 
> 	float32 n = b2Cross(ab, ac);
> 
> #ifdef TARGET_FLOAT32_IS_FIXED
> 	n = (n < 0.0)? -1.0 : ((n > 0.0)? 1.0 : 0.0);
> #endif
> 
> 	// Should not be in edge ab region.
> 	float32 vc = n * b2Cross(a, b);
> 	b2Assert(vc > 0.0f || sn > 0.0f || sd > 0.0f);
> 
> 	// In edge bc region?
> 	float32 va = n * b2Cross(b, c);
> 	if (va <= 0.0f && un >= 0.0f && ud >= 0.0f && (un+ud) > 0.0f)
> 	{
> 		b2Assert(un + ud > 0.0f);
> 		float32 lambda = un / (un + ud);
> 		*x1 = p1s[1] + lambda * (p1s[2] - p1s[1]);
> 		*x2 = p2s[1] + lambda * (p2s[2] - p2s[1]);
> 		p1s[0] = p1s[2];
> 		p2s[0] = p2s[2];
> 		points[0] = points[2];
> 		return 2;
> 	}
> 
> 	// In edge ac region?
> 	float32 vb = n * b2Cross(c, a);
> 	if (vb <= 0.0f && tn >= 0.0f && td >= 0.0f && (tn+td) > 0.0f)
> 	{
> 		b2Assert(tn + td > 0.0f);
> 		float32 lambda = tn / (tn + td);
> 		*x1 = p1s[0] + lambda * (p1s[2] - p1s[0]);
> 		*x2 = p2s[0] + lambda * (p2s[2] - p2s[0]);
> 		p1s[1] = p1s[2];
> 		p2s[1] = p2s[2];
> 		points[1] = points[2];
> 		return 2;
> 	}
> 
> 	// Inside the triangle, compute barycentric coordinates
> 	float32 denom = va + vb + vc;
> 	b2Assert(denom > 0.0f);
> 	denom = 1.0f / denom;
> 
> #ifdef TARGET_FLOAT32_IS_FIXED
> 	*x1 = denom * (va * p1s[0] + vb * p1s[1] + vc * p1s[2]);
> 	*x2 = denom * (va * p2s[0] + vb * p2s[1] + vc * p2s[2]);
> #else
> 	float32 u = va * denom;
> 	float32 v = vb * denom;
> 	float32 w = 1.0f - u - v;
> 	*x1 = u * p1s[0] + v * p1s[1] + w * p1s[2];
> 	*x2 = u * p2s[0] + v * p2s[1] + w * p2s[2];
> #endif
> 	return 3;
> }
28c149
< void b2DistanceProxy::Set(const b2Shape* shape, int32 index)
---
> static bool InPoints(const b2Vec2& w, const b2Vec2* points, int32 pointCount)
30c151,152
< 	switch (shape->GetType())
---
> 	const float32 k_tolerance = 100.0f * B2_FLT_EPSILON;
> 	for (int32 i = 0; i < pointCount; ++i)
32c154,158
< 	case b2Shape::e_circle:
---
> 		b2Vec2 d = b2Abs(w - points[i]);
> 		b2Vec2 m = b2Max(b2Abs(w), b2Abs(points[i]));
> 		
> 		if (d.x < k_tolerance * (m.x + 1.0f) &&
> 			d.y < k_tolerance * (m.y + 1.0f))
34,37c160
< 			const b2CircleShape* circle = (b2CircleShape*)shape;
< 			m_vertices = &circle->m_p;
< 			m_count = 1;
< 			m_radius = circle->m_radius;
---
> 			return true;
39c162
< 		break;
---
> 	}
41,48c164,165
< 	case b2Shape::e_polygon:
< 		{
< 			const b2PolygonShape* polygon = (b2PolygonShape*)shape;
< 			m_vertices = polygon->m_vertices;
< 			m_count = polygon->m_count;
< 			m_radius = polygon->m_radius;
< 		}
< 		break;
---
> 	return false;
> }
50c167,190
< 	case b2Shape::e_chain:
---
> template <typename T1, typename T2>
> float32 DistanceGeneric(b2Vec2* x1, b2Vec2* x2,
> 				   const T1* shape1, const b2XForm& xf1,
> 				   const T2* shape2, const b2XForm& xf2)
> {
> 	b2Vec2 p1s[3], p2s[3];
> 	b2Vec2 points[3];
> 	int32 pointCount = 0;
> 
> 	*x1 = shape1->GetFirstVertex(xf1);
> 	*x2 = shape2->GetFirstVertex(xf2);
> 
> 	float32 vSqr = 0.0f;
> 	const int32 maxIterations = 20;
> 	for (int32 iter = 0; iter < maxIterations; ++iter)
> 	{
> 		b2Vec2 v = *x2 - *x1;
> 		b2Vec2 w1 = shape1->Support(xf1, v);
> 		b2Vec2 w2 = shape2->Support(xf2, -v);
> 
> 		vSqr = b2Dot(v, v);
> 		b2Vec2 w = w2 - w1;
> 		float32 vw = b2Dot(v, w);
> 		if (vSqr - vw <= 0.01f * vSqr || InPoints(w, points, pointCount)) // or w in points
52,56c192
< 			const b2ChainShape* chain = (b2ChainShape*)shape;
< 			b2Assert(0 <= index && index < chain->m_count);
< 
< 			m_buffer[0] = chain->m_vertices[index];
< 			if (index + 1 < chain->m_count)
---
> 			if (pointCount == 0)
58c194,195
< 				m_buffer[1] = chain->m_vertices[index + 1];
---
> 				*x1 = w1;
> 				*x2 = w2;
60,67c197,198
< 			else
< 			{
< 				m_buffer[1] = chain->m_vertices[0];
< 			}
< 
< 			m_vertices = m_buffer;
< 			m_count = 2;
< 			m_radius = chain->m_radius;
---
> 			g_GJK_Iterations = iter;
> 			return b2Sqrt(vSqr);
69d199
< 		break;
71c201
< 	case b2Shape::e_edge:
---
> 		switch (pointCount)
73,84c203,210
< 			const b2EdgeShape* edge = (b2EdgeShape*)shape;
< 			m_vertices = &edge->m_vertex1;
< 			m_count = 2;
< 			m_radius = edge->m_radius;
< 		}
< 		break;
< 
< 	default:
< 		b2Assert(false);
< 	}
< }
< 
---
> 		case 0:
> 			p1s[0] = w1;
> 			p2s[0] = w2;
> 			points[0] = w;
> 			*x1 = p1s[0];
> 			*x2 = p2s[0];
> 			++pointCount;
> 			break;
86,94c212,217
< struct b2SimplexVertex
< {
< 	b2Vec2 wA;		// support point in proxyA
< 	b2Vec2 wB;		// support point in proxyB
< 	b2Vec2 w;		// wB - wA
< 	float32 a;		// barycentric coordinate for closest point
< 	int32 indexA;	// wA index
< 	int32 indexB;	// wB index
< };
---
> 		case 1:
> 			p1s[1] = w1;
> 			p2s[1] = w2;
> 			points[1] = w;
> 			pointCount = ProcessTwo(x1, x2, p1s, p2s, points);
> 			break;
96,117c219,224
< struct b2Simplex
< {
< 	void ReadCache(	const b2SimplexCache* cache,
< 					const b2DistanceProxy* proxyA, const b2Transform& transformA,
< 					const b2DistanceProxy* proxyB, const b2Transform& transformB)
< 	{
< 		b2Assert(cache->count <= 3);
< 		
< 		// Copy data from cache.
< 		m_count = cache->count;
< 		b2SimplexVertex* vertices = &m_v1;
< 		for (int32 i = 0; i < m_count; ++i)
< 		{
< 			b2SimplexVertex* v = vertices + i;
< 			v->indexA = cache->indexA[i];
< 			v->indexB = cache->indexB[i];
< 			b2Vec2 wALocal = proxyA->GetVertex(v->indexA);
< 			b2Vec2 wBLocal = proxyB->GetVertex(v->indexB);
< 			v->wA = b2Mul(transformA, wALocal);
< 			v->wB = b2Mul(transformB, wBLocal);
< 			v->w = v->wB - v->wA;
< 			v->a = 0.0f;
---
> 		case 2:
> 			p1s[2] = w1;
> 			p2s[2] = w2;
> 			points[2] = w;
> 			pointCount = ProcessThree(x1, x2, p1s, p2s, points);
> 			break;
120,122c227,228
< 		// Compute the new simplex metric, if it is substantially different than
< 		// old metric then flush the simplex.
< 		if (m_count > 1)
---
> 		// If we have three points, then the origin is in the corresponding triangle.
> 		if (pointCount == 3)
124,130c230,231
< 			float32 metric1 = cache->metric;
< 			float32 metric2 = GetMetric();
< 			if (metric2 < 0.5f * metric1 || 2.0f * metric1 < metric2 || metric2 < b2_epsilon)
< 			{
< 				// Reset the simplex.
< 				m_count = 0;
< 			}
---
> 			g_GJK_Iterations = iter;
> 			return 0.0f;
133,134c234,235
< 		// If the cache is empty or invalid ...
< 		if (m_count == 0)
---
> 		float32 maxSqr = -B2_FLT_MAX;
> 		for (int32 i = 0; i < pointCount; ++i)
136,145c237
< 			b2SimplexVertex* v = vertices + 0;
< 			v->indexA = 0;
< 			v->indexB = 0;
< 			b2Vec2 wALocal = proxyA->GetVertex(0);
< 			b2Vec2 wBLocal = proxyB->GetVertex(0);
< 			v->wA = b2Mul(transformA, wALocal);
< 			v->wB = b2Mul(transformB, wBLocal);
< 			v->w = v->wB - v->wA;
< 			v->a = 1.0f;
< 			m_count = 1;
---
> 			maxSqr = b2Max(maxSqr, b2Dot(points[i], points[i]));
147d238
< 	}
149,154c240,244
< 	void WriteCache(b2SimplexCache* cache) const
< 	{
< 		cache->metric = GetMetric();
< 		cache->count = uint16(m_count);
< 		const b2SimplexVertex* vertices = &m_v1;
< 		for (int32 i = 0; i < m_count; ++i)
---
> #ifdef TARGET_FLOAT32_IS_FIXED
> 		if (pointCount == 3 || vSqr <= 5.0*B2_FLT_EPSILON * maxSqr)
> #else
> 		if (vSqr <= 100.0f * B2_FLT_EPSILON * maxSqr)
> #endif
156,157c246,249
< 			cache->indexA[i] = uint8(vertices[i].indexA);
< 			cache->indexB[i] = uint8(vertices[i].indexB);
---
> 			g_GJK_Iterations = iter;
> 			v = *x2 - *x1;
> 			vSqr = b2Dot(v, v);
> 			return b2Sqrt(vSqr);
161,166c253,255
< 	b2Vec2 GetSearchDirection() const
< 	{
< 		switch (m_count)
< 		{
< 		case 1:
< 			return -m_v1.w;
---
> 	g_GJK_Iterations = maxIterations;
> 	return b2Sqrt(vSqr);
> }
168,182c257,289
< 		case 2:
< 			{
< 				b2Vec2 e12 = m_v2.w - m_v1.w;
< 				float32 sgn = b2Cross(e12, -m_v1.w);
< 				if (sgn > 0.0f)
< 				{
< 					// Origin is left of e12.
< 					return b2Cross(1.0f, e12);
< 				}
< 				else
< 				{
< 					// Origin is right of e12.
< 					return b2Cross(e12, 1.0f);
< 				}
< 			}
---
> static float32 DistanceCC(
> 	b2Vec2* x1, b2Vec2* x2,
> 	const b2CircleShape* circle1, const b2XForm& xf1,
> 	const b2CircleShape* circle2, const b2XForm& xf2)
> {
> 	b2Vec2 p1 = b2Mul(xf1, circle1->GetLocalPosition());
> 	b2Vec2 p2 = b2Mul(xf2, circle2->GetLocalPosition());
> 
> 	b2Vec2 d = p2 - p1;
> 	float32 dSqr = b2Dot(d, d);
> 	float32 r1 = circle1->GetRadius() - b2_toiSlop;
> 	float32 r2 = circle2->GetRadius() - b2_toiSlop;
> 	float32 r = r1 + r2;
> 	if (dSqr > r * r)
> 	{
> 		float32 dLen = d.Normalize();
> 		float32 distance = dLen - r;
> 		*x1 = p1 + r1 * d;
> 		*x2 = p2 - r2 * d;
> 		return distance;
> 	}
> 	else if (dSqr > B2_FLT_EPSILON * B2_FLT_EPSILON)
> 	{
> 		d.Normalize();
> 		*x1 = p1 + r1 * d;
> 		*x2 = *x1;
> 		return 0.0f;
> 	}
> 
> 	*x1 = p1;
> 	*x2 = *x1;
> 	return 0.0f;
> }
184,186c291,326
< 		default:
< 			b2Assert(false);
< 			return b2Vec2_zero;
---
> static float32 DistanceEdgeCircle(
> 	b2Vec2* x1, b2Vec2* x2,
> 	const b2EdgeShape* edge, const b2XForm& xf1,
> 	const b2CircleShape* circle, const b2XForm& xf2)
> {
> 	b2Vec2 vWorld;
> 	b2Vec2 d;
> 	float32 dSqr;
> 	float32 dLen;
> 	float32 r = circle->GetRadius() - b2_toiSlop;
> 	b2Vec2 cWorld = b2Mul(xf2, circle->GetLocalPosition());
> 	b2Vec2 cLocal = b2MulT(xf1, cWorld);
> 	float32 dirDist = b2Dot(cLocal - edge->GetCoreVertex1(), edge->GetDirectionVector());
> 	if (dirDist <= 0.0f) {
> 		vWorld = b2Mul(xf1, edge->GetCoreVertex1());
> 	} else if (dirDist >= edge->GetLength()) {
> 		vWorld = b2Mul(xf1, edge->GetCoreVertex2());
> 	} else {
> 		*x1 = b2Mul(xf1, edge->GetCoreVertex1() + dirDist * edge->GetDirectionVector());
> 		dLen = b2Dot(cLocal - edge->GetCoreVertex1(), edge->GetNormalVector());
> 		if (dLen < 0.0f) {
> 			if (dLen < -r) {
> 				*x2 = b2Mul(xf1, cLocal + r * edge->GetNormalVector());
> 				return -dLen - r;
> 			} else {
> 				*x2 = *x1;
> 				return 0.0f;
> 			}
> 		} else {
> 			if (dLen > r) {
> 				*x2 = b2Mul(xf1, cLocal  - r * edge->GetNormalVector());
> 				return dLen - r;
> 			} else {
> 				*x2 = *x1;
> 				return 0.0f;
> 			}
188a329,341
> 	
> 	*x1 = vWorld;
> 	d = cWorld - vWorld;
> 	dSqr = b2Dot(d, d);
> 	if (dSqr > r * r) {
> 		dLen = d.Normalize();
> 		*x2 = cWorld - r * d;
> 		return dLen - r;
> 	} else {
> 		*x2 = vWorld;
> 		return 0.0f;
> 	}
> }
190c343,346
< 	b2Vec2 GetClosestPoint() const
---
> // This is used for polygon-vs-circle distance.
> struct Point
> {
> 	b2Vec2 Support(const b2XForm&, const b2Vec2&) const
192,210c348
< 		switch (m_count)
< 		{
< 		case 0:
< 			b2Assert(false);
< 			return b2Vec2_zero;
< 
< 		case 1:
< 			return m_v1.w;
< 
< 		case 2:
< 			return m_v1.a * m_v1.w + m_v2.a * m_v2.w;
< 
< 		case 3:
< 			return b2Vec2_zero;
< 
< 		default:
< 			b2Assert(false);
< 			return b2Vec2_zero;
< 		}
---
> 		return p;
213c351
< 	void GetWitnessPoints(b2Vec2* pA, b2Vec2* pB) const
---
> 	b2Vec2 GetFirstVertex(const b2XForm&) const
215,219c353,357
< 		switch (m_count)
< 		{
< 		case 0:
< 			b2Assert(false);
< 			break;
---
> 		return p;
> 	}
> 	
> 	b2Vec2 p;
> };
221,224c359,367
< 		case 1:
< 			*pA = m_v1.wA;
< 			*pB = m_v1.wB;
< 			break;
---
> // GJK is more robust with polygon-vs-point than polygon-vs-circle.
> // So we convert polygon-vs-circle to polygon-vs-point.
> static float32 DistancePC(
> 	b2Vec2* x1, b2Vec2* x2,
> 	const b2PolygonShape* polygon, const b2XForm& xf1,
> 	const b2CircleShape* circle, const b2XForm& xf2)
> {
> 	Point point;
> 	point.p = b2Mul(xf2, circle->GetLocalPosition());
226,229c369
< 		case 2:
< 			*pA = m_v1.a * m_v1.wA + m_v2.a * m_v2.wA;
< 			*pB = m_v1.a * m_v1.wB + m_v2.a * m_v2.wB;
< 			break;
---
> 	float32 distance = DistanceGeneric(x1, x2, polygon, xf1, &point, b2XForm_identity);
231,234c371
< 		case 3:
< 			*pA = m_v1.a * m_v1.wA + m_v2.a * m_v2.wA + m_v3.a * m_v3.wA;
< 			*pB = *pA;
< 			break;
---
> 	float32 r = circle->GetRadius() - b2_toiSlop;
236,239c373,378
< 		default:
< 			b2Assert(false);
< 			break;
< 		}
---
> 	if (distance > r)
> 	{
> 		distance -= r;
> 		b2Vec2 d = *x2 - *x1;
> 		d.Normalize();
> 		*x2 -= r * d;
241,242c380
< 
< 	float32 GetMetric() const
---
> 	else
244,262c382,383
< 		switch (m_count)
< 		{
< 		case 0:
< 			b2Assert(false);
< 			return 0.0f;
< 
< 		case 1:
< 			return 0.0f;
< 
< 		case 2:
< 			return b2Distance(m_v1.w, m_v2.w);
< 
< 		case 3:
< 			return b2Cross(m_v2.w - m_v1.w, m_v3.w - m_v1.w);
< 
< 		default:
< 			b2Assert(false);
< 			return 0.0f;
< 		}
---
> 		distance = 0.0f;
> 		*x2 = *x1;
265,327c386
< 	void Solve2();
< 	void Solve3();
< 
< 	b2SimplexVertex m_v1, m_v2, m_v3;
< 	int32 m_count;
< };
< 
< 
< // Solve a line segment using barycentric coordinates.
< //
< // p = a1 * w1 + a2 * w2
< // a1 + a2 = 1
< //
< // The vector from the origin to the closest point on the line is
< // perpendicular to the line.
< // e12 = w2 - w1
< // dot(p, e) = 0
< // a1 * dot(w1, e) + a2 * dot(w2, e) = 0
< //
< // 2-by-2 linear system
< // [1      1     ][a1] = [1]
< // [w1.e12 w2.e12][a2] = [0]
< //
< // Define
< // d12_1 =  dot(w2, e12)
< // d12_2 = -dot(w1, e12)
< // d12 = d12_1 + d12_2
< //
< // Solution
< // a1 = d12_1 / d12
< // a2 = d12_2 / d12
< void b2Simplex::Solve2()
< {
< 	b2Vec2 w1 = m_v1.w;
< 	b2Vec2 w2 = m_v2.w;
< 	b2Vec2 e12 = w2 - w1;
< 
< 	// w1 region
< 	float32 d12_2 = -b2Dot(w1, e12);
< 	if (d12_2 <= 0.0f)
< 	{
< 		// a2 <= 0, so we clamp it to 0
< 		m_v1.a = 1.0f;
< 		m_count = 1;
< 		return;
< 	}
< 
< 	// w2 region
< 	float32 d12_1 = b2Dot(w2, e12);
< 	if (d12_1 <= 0.0f)
< 	{
< 		// a1 <= 0, so we clamp it to 0
< 		m_v2.a = 1.0f;
< 		m_count = 1;
< 		m_v1 = m_v2;
< 		return;
< 	}
< 
< 	// Must be in e12 region.
< 	float32 inv_d12 = 1.0f / (d12_1 + d12_2);
< 	m_v1.a = d12_1 * inv_d12;
< 	m_v2.a = d12_2 * inv_d12;
< 	m_count = 2;
---
> 	return distance;
330,335c389,391
< // Possible regions:
< // - points[2]
< // - edge points[0]-points[2]
< // - edge points[1]-points[2]
< // - inside the triangle
< void b2Simplex::Solve3()
---
> float32 b2Distance(b2Vec2* x1, b2Vec2* x2,
> 				   const b2Shape* shape1, const b2XForm& xf1,
> 				   const b2Shape* shape2, const b2XForm& xf2)
337,376c393,394
< 	b2Vec2 w1 = m_v1.w;
< 	b2Vec2 w2 = m_v2.w;
< 	b2Vec2 w3 = m_v3.w;
< 
< 	// Edge12
< 	// [1      1     ][a1] = [1]
< 	// [w1.e12 w2.e12][a2] = [0]
< 	// a3 = 0
< 	b2Vec2 e12 = w2 - w1;
< 	float32 w1e12 = b2Dot(w1, e12);
< 	float32 w2e12 = b2Dot(w2, e12);
< 	float32 d12_1 = w2e12;
< 	float32 d12_2 = -w1e12;
< 
< 	// Edge13
< 	// [1      1     ][a1] = [1]
< 	// [w1.e13 w3.e13][a3] = [0]
< 	// a2 = 0
< 	b2Vec2 e13 = w3 - w1;
< 	float32 w1e13 = b2Dot(w1, e13);
< 	float32 w3e13 = b2Dot(w3, e13);
< 	float32 d13_1 = w3e13;
< 	float32 d13_2 = -w1e13;
< 
< 	// Edge23
< 	// [1      1     ][a2] = [1]
< 	// [w2.e23 w3.e23][a3] = [0]
< 	// a1 = 0
< 	b2Vec2 e23 = w3 - w2;
< 	float32 w2e23 = b2Dot(w2, e23);
< 	float32 w3e23 = b2Dot(w3, e23);
< 	float32 d23_1 = w3e23;
< 	float32 d23_2 = -w2e23;
< 	
< 	// Triangle123
< 	float32 n123 = b2Cross(e12, e13);
< 
< 	float32 d123_1 = n123 * b2Cross(w2, w3);
< 	float32 d123_2 = n123 * b2Cross(w3, w1);
< 	float32 d123_3 = n123 * b2Cross(w1, w2);
---
> 	b2ShapeType type1 = shape1->GetType();
> 	b2ShapeType type2 = shape2->GetType();
378,379c396
< 	// w1 region
< 	if (d12_2 <= 0.0f && d13_2 <= 0.0f)
---
> 	if (type1 == e_circleShape && type2 == e_circleShape)
381,383c398
< 		m_v1.a = 1.0f;
< 		m_count = 1;
< 		return;
---
> 		return DistanceCC(x1, x2, (b2CircleShape*)shape1, xf1, (b2CircleShape*)shape2, xf2);
385,387c400,401
< 
< 	// e12
< 	if (d12_1 > 0.0f && d12_2 > 0.0f && d123_3 <= 0.0f)
---
> 	
> 	if (type1 == e_polygonShape && type2 == e_circleShape)
389,393c403
< 		float32 inv_d12 = 1.0f / (d12_1 + d12_2);
< 		m_v1.a = d12_1 * inv_d12;
< 		m_v2.a = d12_2 * inv_d12;
< 		m_count = 2;
< 		return;
---
> 		return DistancePC(x1, x2, (b2PolygonShape*)shape1, xf1, (b2CircleShape*)shape2, xf2);
396,397c406
< 	// e13
< 	if (d13_1 > 0.0f && d13_2 > 0.0f && d123_2 <= 0.0f)
---
> 	if (type1 == e_circleShape && type2 == e_polygonShape)
399,404c408
< 		float32 inv_d13 = 1.0f / (d13_1 + d13_2);
< 		m_v1.a = d13_1 * inv_d13;
< 		m_v3.a = d13_2 * inv_d13;
< 		m_count = 2;
< 		m_v2 = m_v3;
< 		return;
---
> 		return DistancePC(x2, x1, (b2PolygonShape*)shape2, xf2, (b2CircleShape*)shape1, xf1);
407,408c411
< 	// w2 region
< 	if (d12_1 <= 0.0f && d23_2 <= 0.0f)
---
> 	if (type1 == e_polygonShape && type2 == e_polygonShape)
410,413c413
< 		m_v2.a = 1.0f;
< 		m_count = 1;
< 		m_v1 = m_v2;
< 		return;
---
> 		return DistanceGeneric(x1, x2, (b2PolygonShape*)shape1, xf1, (b2PolygonShape*)shape2, xf2);
416,417c416
< 	// w3 region
< 	if (d13_1 <= 0.0f && d23_1 <= 0.0f)
---
> 	if (type1 == e_edgeShape && type2 == e_circleShape)
419,422c418
< 		m_v3.a = 1.0f;
< 		m_count = 1;
< 		m_v1 = m_v3;
< 		return;
---
> 		return DistanceEdgeCircle(x1, x2, (b2EdgeShape*)shape1, xf1, (b2CircleShape*)shape2, xf2);
424,426c420,421
< 
< 	// e23
< 	if (d23_1 > 0.0f && d23_2 > 0.0f && d123_1 <= 0.0f)
---
> 	
> 	if (type1 == e_circleShape && type2 == e_edgeShape)
428,433c423
< 		float32 inv_d23 = 1.0f / (d23_1 + d23_2);
< 		m_v2.a = d23_1 * inv_d23;
< 		m_v3.a = d23_2 * inv_d23;
< 		m_count = 2;
< 		m_v1 = m_v3;
< 		return;
---
> 		return DistanceEdgeCircle(x2, x1, (b2EdgeShape*)shape2, xf2, (b2CircleShape*)shape1, xf1);
436,474c426
< 	// Must be in triangle123
< 	float32 inv_d123 = 1.0f / (d123_1 + d123_2 + d123_3);
< 	m_v1.a = d123_1 * inv_d123;
< 	m_v2.a = d123_2 * inv_d123;
< 	m_v3.a = d123_3 * inv_d123;
< 	m_count = 3;
< }
< 
< void b2Distance(b2DistanceOutput* output,
< 				b2SimplexCache* cache,
< 				const b2DistanceInput* input)
< {
< 	++b2_gjkCalls;
< 
< 	const b2DistanceProxy* proxyA = &input->proxyA;
< 	const b2DistanceProxy* proxyB = &input->proxyB;
< 
< 	b2Transform transformA = input->transformA;
< 	b2Transform transformB = input->transformB;
< 
< 	// Initialize the simplex.
< 	b2Simplex simplex;
< 	simplex.ReadCache(cache, proxyA, transformA, proxyB, transformB);
< 
< 	// Get simplex vertices as an array.
< 	b2SimplexVertex* vertices = &simplex.m_v1;
< 	const int32 k_maxIters = 20;
< 
< 	// These store the vertices of the last simplex so that we
< 	// can check for duplicates and prevent cycling.
< 	int32 saveA[3], saveB[3];
< 	int32 saveCount = 0;
< 
< 	float32 distanceSqr1 = b2_maxFloat;
< 	float32 distanceSqr2 = distanceSqr1;
< 
< 	// Main iteration loop.
< 	int32 iter = 0;
< 	while (iter < k_maxIters)
---
> 	if (type1 == e_polygonShape && type2 == e_edgeShape)
476,564c428
< 		// Copy simplex so we can identify duplicates.
< 		saveCount = simplex.m_count;
< 		for (int32 i = 0; i < saveCount; ++i)
< 		{
< 			saveA[i] = vertices[i].indexA;
< 			saveB[i] = vertices[i].indexB;
< 		}
< 
< 		switch (simplex.m_count)
< 		{
< 		case 1:
< 			break;
< 
< 		case 2:
< 			simplex.Solve2();
< 			break;
< 
< 		case 3:
< 			simplex.Solve3();
< 			break;
< 
< 		default:
< 			b2Assert(false);
< 		}
< 
< 		// If we have 3 points, then the origin is in the corresponding triangle.
< 		if (simplex.m_count == 3)
< 		{
< 			break;
< 		}
< 
< 		// Compute closest point.
< 		b2Vec2 p = simplex.GetClosestPoint();
< 		distanceSqr2 = p.LengthSquared();
< 
< 		// Ensure progress
< 		if (distanceSqr2 >= distanceSqr1)
< 		{
< 			//break;
< 		}
< 		distanceSqr1 = distanceSqr2;
< 
< 		// Get search direction.
< 		b2Vec2 d = simplex.GetSearchDirection();
< 
< 		// Ensure the search direction is numerically fit.
< 		if (d.LengthSquared() < b2_epsilon * b2_epsilon)
< 		{
< 			// The origin is probably contained by a line segment
< 			// or triangle. Thus the shapes are overlapped.
< 
< 			// We can't return zero here even though there may be overlap.
< 			// In case the simplex is a point, segment, or triangle it is difficult
< 			// to determine if the origin is contained in the CSO or very close to it.
< 			break;
< 		}
< 
< 		// Compute a tentative new simplex vertex using support points.
< 		b2SimplexVertex* vertex = vertices + simplex.m_count;
< 		vertex->indexA = proxyA->GetSupport(b2MulT(transformA.q, -d));
< 		vertex->wA = b2Mul(transformA, proxyA->GetVertex(vertex->indexA));
< 		b2Vec2 wBLocal;
< 		vertex->indexB = proxyB->GetSupport(b2MulT(transformB.q, d));
< 		vertex->wB = b2Mul(transformB, proxyB->GetVertex(vertex->indexB));
< 		vertex->w = vertex->wB - vertex->wA;
< 
< 		// Iteration count is equated to the number of support point calls.
< 		++iter;
< 		++b2_gjkIters;
< 
< 		// Check for duplicate support points. This is the main termination criteria.
< 		bool duplicate = false;
< 		for (int32 i = 0; i < saveCount; ++i)
< 		{
< 			if (vertex->indexA == saveA[i] && vertex->indexB == saveB[i])
< 			{
< 				duplicate = true;
< 				break;
< 			}
< 		}
< 
< 		// If we found a duplicate support point we must exit to avoid cycling.
< 		if (duplicate)
< 		{
< 			break;
< 		}
< 
< 		// New vertex is ok and needed.
< 		++simplex.m_count;
---
> 		return DistanceGeneric(x2, x1, (b2EdgeShape*)shape2, xf2, (b2PolygonShape*)shape1, xf1);
567,578c431
< 	b2_gjkMaxIters = b2Max(b2_gjkMaxIters, iter);
< 
< 	// Prepare output.
< 	simplex.GetWitnessPoints(&output->pointA, &output->pointB);
< 	output->distance = b2Distance(output->pointA, output->pointB);
< 	output->iterations = iter;
< 
< 	// Cache the simplex.
< 	simplex.WriteCache(cache);
< 
< 	// Apply radii if requested.
< 	if (input->useRadii)
---
> 	if (type1 == e_edgeShape && type2 == e_polygonShape)
580,601c433
< 		float32 rA = proxyA->m_radius;
< 		float32 rB = proxyB->m_radius;
< 
< 		if (output->distance > rA + rB && output->distance > b2_epsilon)
< 		{
< 			// Shapes are still no overlapped.
< 			// Move the witness points to the outer surface.
< 			output->distance -= rA + rB;
< 			b2Vec2 normal = output->pointB - output->pointA;
< 			normal.Normalize();
< 			output->pointA += rA * normal;
< 			output->pointB -= rB * normal;
< 		}
< 		else
< 		{
< 			// Shapes are overlapped when radii are considered.
< 			// Move the witness points to the middle.
< 			b2Vec2 p = 0.5f * (output->pointA + output->pointB);
< 			output->pointA = p;
< 			output->pointB = p;
< 			output->distance = 0.0f;
< 		}
---
> 		return DistanceGeneric(x1, x2, (b2EdgeShape*)shape1, xf1, (b2PolygonShape*)shape2, xf2);
602a435,436
> 
> 	return 0.0f;
Only in native/Box2D/Collision/.svn/text-base: b2Distance.h.svn-base
Only in native/Box2D/Collision/.svn/text-base: b2DynamicTree.cpp.svn-base
Only in native/Box2D/Collision/.svn/text-base: b2DynamicTree.h.svn-base
Only in ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Collision/.svn/text-base: b2PairManager.cpp.svn-base
Only in ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Collision/.svn/text-base: b2PairManager.h.svn-base
diff -r -x './svn/*' native/Box2D/Collision/.svn/text-base/b2TimeOfImpact.cpp.svn-base ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Collision/.svn/text-base/b2TimeOfImpact.cpp.svn-base
2c2
< * Copyright (c) 2007-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2007 Erin Catto http://www.gphysics.com
19,31c19,20
< #include <Box2D/Collision/b2Collision.h>
< #include <Box2D/Collision/b2Distance.h>
< #include <Box2D/Collision/b2TimeOfImpact.h>
< #include <Box2D/Collision/Shapes/b2CircleShape.h>
< #include <Box2D/Collision/Shapes/b2PolygonShape.h>
< #include <Box2D/Common/b2Timer.h>
< 
< #include <cstdio>
< using namespace std;
< 
< float32 b2_toiTime, b2_toiMaxTime;
< int32 b2_toiCalls, b2_toiIters, b2_toiMaxIters;
< int32 b2_toiRootIters, b2_toiMaxRootIters;
---
> #include "b2Collision.h"
> #include "Shapes/b2Shape.h"
33,34c22,26
< //
< struct b2SeparationFunction
---
> // This algorithm uses conservative advancement to compute the time of
> // impact (TOI) of two shapes.
> // Refs: Bullet, Young Kim
> float32 b2TimeOfImpact(const b2Shape* shape1, const b2Sweep& sweep1,
> 					   const b2Shape* shape2, const b2Sweep& sweep2)
36,85c28,29
< 	enum Type
< 	{
< 		e_points,
< 		e_faceA,
< 		e_faceB
< 	};
< 
< 	// TODO_ERIN might not need to return the separation
< 
< 	float32 Initialize(const b2SimplexCache* cache,
< 		const b2DistanceProxy* proxyA, const b2Sweep& sweepA,
< 		const b2DistanceProxy* proxyB, const b2Sweep& sweepB,
< 		float32 t1)
< 	{
< 		m_proxyA = proxyA;
< 		m_proxyB = proxyB;
< 		int32 count = cache->count;
< 		b2Assert(0 < count && count < 3);
< 
< 		m_sweepA = sweepA;
< 		m_sweepB = sweepB;
< 
< 		b2Transform xfA, xfB;
< 		m_sweepA.GetTransform(&xfA, t1);
< 		m_sweepB.GetTransform(&xfB, t1);
< 
< 		if (count == 1)
< 		{
< 			m_type = e_points;
< 			b2Vec2 localPointA = m_proxyA->GetVertex(cache->indexA[0]);
< 			b2Vec2 localPointB = m_proxyB->GetVertex(cache->indexB[0]);
< 			b2Vec2 pointA = b2Mul(xfA, localPointA);
< 			b2Vec2 pointB = b2Mul(xfB, localPointB);
< 			m_axis = pointB - pointA;
< 			float32 s = m_axis.Normalize();
< 			return s;
< 		}
< 		else if (cache->indexA[0] == cache->indexA[1])
< 		{
< 			// Two points on B and one on A.
< 			m_type = e_faceB;
< 			b2Vec2 localPointB1 = proxyB->GetVertex(cache->indexB[0]);
< 			b2Vec2 localPointB2 = proxyB->GetVertex(cache->indexB[1]);
< 
< 			m_axis = b2Cross(localPointB2 - localPointB1, 1.0f);
< 			m_axis.Normalize();
< 			b2Vec2 normal = b2Mul(xfB.q, m_axis);
< 
< 			m_localPoint = 0.5f * (localPointB1 + localPointB2);
< 			b2Vec2 pointB = b2Mul(xfB, m_localPoint);
---
> 	float32 r1 = shape1->GetSweepRadius();
> 	float32 r2 = shape2->GetSweepRadius();
87,88c31,32
< 			b2Vec2 localPointA = proxyA->GetVertex(cache->indexA[0]);
< 			b2Vec2 pointA = b2Mul(xfA, localPointA);
---
> 	b2Assert(sweep1.t0 == sweep2.t0);
> 	b2Assert(1.0f - sweep1.t0 > B2_FLT_EPSILON);
90,107c34,38
< 			float32 s = b2Dot(pointA - pointB, normal);
< 			if (s < 0.0f)
< 			{
< 				m_axis = -m_axis;
< 				s = -s;
< 			}
< 			return s;
< 		}
< 		else
< 		{
< 			// Two points on A and one or two points on B.
< 			m_type = e_faceA;
< 			b2Vec2 localPointA1 = m_proxyA->GetVertex(cache->indexA[0]);
< 			b2Vec2 localPointA2 = m_proxyA->GetVertex(cache->indexA[1]);
< 			
< 			m_axis = b2Cross(localPointA2 - localPointA1, 1.0f);
< 			m_axis.Normalize();
< 			b2Vec2 normal = b2Mul(xfA.q, m_axis);
---
> 	float32 t0 = sweep1.t0;
> 	b2Vec2 v1 = sweep1.c - sweep1.c0;
> 	b2Vec2 v2 = sweep2.c - sweep2.c0;
> 	float32 omega1 = sweep1.a - sweep1.a0;
> 	float32 omega2 = sweep2.a - sweep2.a0;
109,123c40
< 			m_localPoint = 0.5f * (localPointA1 + localPointA2);
< 			b2Vec2 pointA = b2Mul(xfA, m_localPoint);
< 
< 			b2Vec2 localPointB = m_proxyB->GetVertex(cache->indexB[0]);
< 			b2Vec2 pointB = b2Mul(xfB, localPointB);
< 
< 			float32 s = b2Dot(pointB - pointA, normal);
< 			if (s < 0.0f)
< 			{
< 				m_axis = -m_axis;
< 				s = -s;
< 			}
< 			return s;
< 		}
< 	}
---
> 	float32 alpha = 0.0f;
125,126c42,48
< 	//
< 	float32 FindMinSeparation(int32* indexA, int32* indexB, float32 t) const
---
> 	b2Vec2 p1, p2;
> 	const int32 k_maxIterations = 20;	// TODO_ERIN b2Settings
> 	int32 iter = 0;
> 	b2Vec2 normal = b2Vec2_zero;
> 	float32 distance = 0.0f;
> 	float32 targetDistance = 0.0f;
> 	for(;;)
128,192c50,53
< 		b2Transform xfA, xfB;
< 		m_sweepA.GetTransform(&xfA, t);
< 		m_sweepB.GetTransform(&xfB, t);
< 
< 		switch (m_type)
< 		{
< 		case e_points:
< 			{
< 				b2Vec2 axisA = b2MulT(xfA.q,  m_axis);
< 				b2Vec2 axisB = b2MulT(xfB.q, -m_axis);
< 
< 				*indexA = m_proxyA->GetSupport(axisA);
< 				*indexB = m_proxyB->GetSupport(axisB);
< 
< 				b2Vec2 localPointA = m_proxyA->GetVertex(*indexA);
< 				b2Vec2 localPointB = m_proxyB->GetVertex(*indexB);
< 				
< 				b2Vec2 pointA = b2Mul(xfA, localPointA);
< 				b2Vec2 pointB = b2Mul(xfB, localPointB);
< 
< 				float32 separation = b2Dot(pointB - pointA, m_axis);
< 				return separation;
< 			}
< 
< 		case e_faceA:
< 			{
< 				b2Vec2 normal = b2Mul(xfA.q, m_axis);
< 				b2Vec2 pointA = b2Mul(xfA, m_localPoint);
< 
< 				b2Vec2 axisB = b2MulT(xfB.q, -normal);
< 				
< 				*indexA = -1;
< 				*indexB = m_proxyB->GetSupport(axisB);
< 
< 				b2Vec2 localPointB = m_proxyB->GetVertex(*indexB);
< 				b2Vec2 pointB = b2Mul(xfB, localPointB);
< 
< 				float32 separation = b2Dot(pointB - pointA, normal);
< 				return separation;
< 			}
< 
< 		case e_faceB:
< 			{
< 				b2Vec2 normal = b2Mul(xfB.q, m_axis);
< 				b2Vec2 pointB = b2Mul(xfB, m_localPoint);
< 
< 				b2Vec2 axisA = b2MulT(xfA.q, -normal);
< 
< 				*indexB = -1;
< 				*indexA = m_proxyA->GetSupport(axisA);
< 
< 				b2Vec2 localPointA = m_proxyA->GetVertex(*indexA);
< 				b2Vec2 pointA = b2Mul(xfA, localPointA);
< 
< 				float32 separation = b2Dot(pointA - pointB, normal);
< 				return separation;
< 			}
< 
< 		default:
< 			b2Assert(false);
< 			*indexA = -1;
< 			*indexB = -1;
< 			return 0.0f;
< 		}
< 	}
---
> 		float32 t = (1.0f - alpha) * t0 + alpha;
> 		b2XForm xf1, xf2;
> 		sweep1.GetXForm(&xf1, t);
> 		sweep2.GetXForm(&xf2, t);
194,199c55,56
< 	//
< 	float32 Evaluate(int32 indexA, int32 indexB, float32 t) const
< 	{
< 		b2Transform xfA, xfB;
< 		m_sweepA.GetTransform(&xfA, t);
< 		m_sweepB.GetTransform(&xfB, t);
---
> 		// Get the distance between shapes.
> 		distance = b2Distance(&p1, &p2, shape1, xf1, shape2, xf2);
201c58
< 		switch (m_type)
---
> 		if (iter == 0)
203,215c60,62
< 		case e_points:
< 			{
< 				b2Vec2 localPointA = m_proxyA->GetVertex(indexA);
< 				b2Vec2 localPointB = m_proxyB->GetVertex(indexB);
< 
< 				b2Vec2 pointA = b2Mul(xfA, localPointA);
< 				b2Vec2 pointB = b2Mul(xfB, localPointB);
< 				float32 separation = b2Dot(pointB - pointA, m_axis);
< 
< 				return separation;
< 			}
< 
< 		case e_faceA:
---
> 			// Compute a reasonable target distance to give some breathing room
> 			// for conservative advancement.
> 			if (distance > 2.0f * b2_toiSlop)
217,224c64
< 				b2Vec2 normal = b2Mul(xfA.q, m_axis);
< 				b2Vec2 pointA = b2Mul(xfA, m_localPoint);
< 
< 				b2Vec2 localPointB = m_proxyB->GetVertex(indexB);
< 				b2Vec2 pointB = b2Mul(xfB, localPointB);
< 
< 				float32 separation = b2Dot(pointB - pointA, normal);
< 				return separation;
---
> 				targetDistance = 1.5f * b2_toiSlop;
226,227c66
< 
< 		case e_faceB:
---
> 			else
229,236c68
< 				b2Vec2 normal = b2Mul(xfB.q, m_axis);
< 				b2Vec2 pointB = b2Mul(xfB, m_localPoint);
< 
< 				b2Vec2 localPointA = m_proxyA->GetVertex(indexA);
< 				b2Vec2 pointA = b2Mul(xfA, localPointA);
< 
< 				float32 separation = b2Dot(pointA - pointB, normal);
< 				return separation;
---
> 				targetDistance = b2Max(0.05f * b2_toiSlop, distance - 0.5f * b2_toiSlop);
238,315d69
< 
< 		default:
< 			b2Assert(false);
< 			return 0.0f;
< 		}
< 	}
< 
< 	const b2DistanceProxy* m_proxyA;
< 	const b2DistanceProxy* m_proxyB;
< 	b2Sweep m_sweepA, m_sweepB;
< 	Type m_type;
< 	b2Vec2 m_localPoint;
< 	b2Vec2 m_axis;
< };
< 
< // CCD via the local separating axis method. This seeks progression
< // by computing the largest time at which separation is maintained.
< void b2TimeOfImpact(b2TOIOutput* output, const b2TOIInput* input)
< {
< 	b2Timer timer;
< 
< 	++b2_toiCalls;
< 
< 	output->state = b2TOIOutput::e_unknown;
< 	output->t = input->tMax;
< 
< 	const b2DistanceProxy* proxyA = &input->proxyA;
< 	const b2DistanceProxy* proxyB = &input->proxyB;
< 
< 	b2Sweep sweepA = input->sweepA;
< 	b2Sweep sweepB = input->sweepB;
< 
< 	// Large rotations can make the root finder fail, so we normalize the
< 	// sweep angles.
< 	sweepA.Normalize();
< 	sweepB.Normalize();
< 
< 	float32 tMax = input->tMax;
< 
< 	float32 totalRadius = proxyA->m_radius + proxyB->m_radius;
< 	float32 target = b2Max(b2_linearSlop, totalRadius - 3.0f * b2_linearSlop);
< 	float32 tolerance = 0.25f * b2_linearSlop;
< 	b2Assert(target > tolerance);
< 
< 	float32 t1 = 0.0f;
< 	const int32 k_maxIterations = 20;	// TODO_ERIN b2Settings
< 	int32 iter = 0;
< 
< 	// Prepare input for distance query.
< 	b2SimplexCache cache;
< 	cache.count = 0;
< 	b2DistanceInput distanceInput;
< 	distanceInput.proxyA = input->proxyA;
< 	distanceInput.proxyB = input->proxyB;
< 	distanceInput.useRadii = false;
< 
< 	// The outer loop progressively attempts to compute new separating axes.
< 	// This loop terminates when an axis is repeated (no progress is made).
< 	for(;;)
< 	{
< 		b2Transform xfA, xfB;
< 		sweepA.GetTransform(&xfA, t1);
< 		sweepB.GetTransform(&xfB, t1);
< 
< 		// Get the distance between shapes. We can also use the results
< 		// to get a separating axis.
< 		distanceInput.transformA = xfA;
< 		distanceInput.transformB = xfB;
< 		b2DistanceOutput distanceOutput;
< 		b2Distance(&distanceOutput, &cache, &distanceInput);
< 
< 		// If the shapes are overlapped, we give up on continuous collision.
< 		if (distanceOutput.distance <= 0.0f)
< 		{
< 			// Failure!
< 			output->state = b2TOIOutput::e_overlapped;
< 			output->t = 0.0f;
< 			break;
318c72
< 		if (distanceOutput.distance < target + tolerance)
---
> 		if (distance - targetDistance < 0.05f * b2_toiSlop || iter == k_maxIterations)
320,322d73
< 			// Victory!
< 			output->state = b2TOIOutput::e_touching;
< 			output->t = t1;
326,353c77,78
< 		// Initialize the separating axis.
< 		b2SeparationFunction fcn;
< 		fcn.Initialize(&cache, proxyA, sweepA, proxyB, sweepB, t1);
< #if 0
< 		// Dump the curve seen by the root finder
< 		{
< 			const int32 N = 100;
< 			float32 dx = 1.0f / N;
< 			float32 xs[N+1];
< 			float32 fs[N+1];
< 
< 			float32 x = 0.0f;
< 
< 			for (int32 i = 0; i <= N; ++i)
< 			{
< 				sweepA.GetTransform(&xfA, x);
< 				sweepB.GetTransform(&xfB, x);
< 				float32 f = fcn.Evaluate(xfA, xfB) - target;
< 
< 				printf("%g %g\n", x, f);
< 
< 				xs[i] = x;
< 				fs[i] = f;
< 
< 				x += dx;
< 			}
< 		}
< #endif
---
> 		normal = p2 - p1;
> 		normal.Normalize();
355,360c80,82
< 		// Compute the TOI on the separating axis. We do this by successively
< 		// resolving the deepest point. This loop is bounded by the number of vertices.
< 		bool done = false;
< 		float32 t2 = tMax;
< 		int32 pushBackIter = 0;
< 		for (;;)
---
> 		// Compute upper bound on remaining movement.
> 		float32 approachVelocityBound = b2Dot(normal, v1 - v2) + b2Abs(omega1) * r1 + b2Abs(omega2) * r2;
> 		if (b2Abs(approachVelocityBound) < B2_FLT_EPSILON)
362,462c84,85
< 			// Find the deepest point at t2. Store the witness point indices.
< 			int32 indexA, indexB;
< 			float32 s2 = fcn.FindMinSeparation(&indexA, &indexB, t2);
< 
< 			// Is the final configuration separated?
< 			if (s2 > target + tolerance)
< 			{
< 				// Victory!
< 				output->state = b2TOIOutput::e_separated;
< 				output->t = tMax;
< 				done = true;
< 				break;
< 			}
< 
< 			// Has the separation reached tolerance?
< 			if (s2 > target - tolerance)
< 			{
< 				// Advance the sweeps
< 				t1 = t2;
< 				break;
< 			}
< 
< 			// Compute the initial separation of the witness points.
< 			float32 s1 = fcn.Evaluate(indexA, indexB, t1);
< 
< 			// Check for initial overlap. This might happen if the root finder
< 			// runs out of iterations.
< 			if (s1 < target - tolerance)
< 			{
< 				output->state = b2TOIOutput::e_failed;
< 				output->t = t1;
< 				done = true;
< 				break;
< 			}
< 
< 			// Check for touching
< 			if (s1 <= target + tolerance)
< 			{
< 				// Victory! t1 should hold the TOI (could be 0.0).
< 				output->state = b2TOIOutput::e_touching;
< 				output->t = t1;
< 				done = true;
< 				break;
< 			}
< 
< 			// Compute 1D root of: f(x) - target = 0
< 			int32 rootIterCount = 0;
< 			float32 a1 = t1, a2 = t2;
< 			for (;;)
< 			{
< 				// Use a mix of the secant rule and bisection.
< 				float32 t;
< 				if (rootIterCount & 1)
< 				{
< 					// Secant rule to improve convergence.
< 					t = a1 + (target - s1) * (a2 - a1) / (s2 - s1);
< 				}
< 				else
< 				{
< 					// Bisection to guarantee progress.
< 					t = 0.5f * (a1 + a2);
< 				}
< 
< 				++rootIterCount;
< 				++b2_toiRootIters;
< 
< 				float32 s = fcn.Evaluate(indexA, indexB, t);
< 
< 				if (b2Abs(s - target) < tolerance)
< 				{
< 					// t2 holds a tentative value for t1
< 					t2 = t;
< 					break;
< 				}
< 
< 				// Ensure we continue to bracket the root.
< 				if (s > target)
< 				{
< 					a1 = t;
< 					s1 = s;
< 				}
< 				else
< 				{
< 					a2 = t;
< 					s2 = s;
< 				}
< 				
< 				if (rootIterCount == 50)
< 				{
< 					break;
< 				}
< 			}
< 
< 			b2_toiMaxRootIters = b2Max(b2_toiMaxRootIters, rootIterCount);
< 
< 			++pushBackIter;
< 
< 			if (pushBackIter == b2_maxPolygonVertices)
< 			{
< 				break;
< 			}
---
> 			alpha = 1.0f;
> 			break;
465,466c88,91
< 		++iter;
< 		++b2_toiIters;
---
> 		// Get the conservative time increment. Don't advance all the way.
> 		float32 dAlpha = (distance - targetDistance) / approachVelocityBound;
> 		//float32 dt = (distance - 0.5f * b2_linearSlop) / approachVelocityBound;
> 		float32 newAlpha = alpha + dAlpha;
468c93,94
< 		if (done)
---
> 		// The shapes may be moving apart or a safe distance apart.
> 		if (newAlpha < 0.0f || 1.0f < newAlpha)
469a96
> 			alpha = 1.0f;
473c100,101
< 		if (iter == k_maxIterations)
---
> 		// Ensure significant advancement.
> 		if (newAlpha < (1.0f + 100.0f * B2_FLT_EPSILON) * alpha)
475,477d102
< 			// Root finder got stuck. Semi-victory.
< 			output->state = b2TOIOutput::e_failed;
< 			output->t = t1;
480d104
< 	}
482c106,109
< 	b2_toiMaxIters = b2Max(b2_toiMaxIters, iter);
---
> 		alpha = newAlpha;
> 
> 		++iter;
> 	}
484,486c111
< 	float32 time = timer.GetMilliseconds();
< 	b2_toiMaxTime = b2Max(b2_toiMaxTime, time);
< 	b2_toiTime += time;
---
> 	return alpha;
Only in native/Box2D/Collision/.svn/text-base: b2TimeOfImpact.h.svn-base
diff -r -x './svn/*' native/Box2D/Collision/Shapes/.svn/all-wcprops ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Collision/Shapes/.svn/all-wcprops
3,4c3,4
< V 52
< /svn/!svn/ver/250/trunk/Box2D/Box2D/Collision/Shapes
---
> V 56
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Collision/Shapes
9,10c9,10
< V 66
< /svn/!svn/ver/210/trunk/Box2D/Box2D/Collision/Shapes/b2EdgeShape.h
---
> V 70
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Collision/Shapes/b2EdgeShape.h
15,16c15,16
< V 69
< /svn/!svn/ver/244/trunk/Box2D/Box2D/Collision/Shapes/b2PolygonShape.h
---
> V 73
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Collision/Shapes/b2PolygonShape.h
18c18
< b2CircleShape.cpp
---
> b2Shape.cpp
21,22c21,22
< V 70
< /svn/!svn/ver/186/trunk/Box2D/Box2D/Collision/Shapes/b2CircleShape.cpp
---
> V 68
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Collision/Shapes/b2Shape.cpp
24c24
< b2ChainShape.cpp
---
> b2CircleShape.cpp
27,28c27,28
< V 69
< /svn/!svn/ver/250/trunk/Box2D/Box2D/Collision/Shapes/b2ChainShape.cpp
---
> V 74
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Collision/Shapes/b2CircleShape.cpp
33,34c33,34
< V 68
< /svn/!svn/ver/200/trunk/Box2D/Box2D/Collision/Shapes/b2EdgeShape.cpp
---
> V 72
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Collision/Shapes/b2EdgeShape.cpp
39,40c39,40
< V 62
< /svn/!svn/ver/199/trunk/Box2D/Box2D/Collision/Shapes/b2Shape.h
---
> V 66
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Collision/Shapes/b2Shape.h
45,46c45,46
< V 68
< /svn/!svn/ver/158/trunk/Box2D/Box2D/Collision/Shapes/b2CircleShape.h
---
> V 72
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Collision/Shapes/b2CircleShape.h
51,58c51,52
< V 71
< /svn/!svn/ver/233/trunk/Box2D/Box2D/Collision/Shapes/b2PolygonShape.cpp
< END
< b2ChainShape.h
< K 25
< svn:wc:ra_dav:version-url
< V 67
< /svn/!svn/ver/210/trunk/Box2D/Box2D/Collision/Shapes/b2ChainShape.h
---
> V 75
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Collision/Shapes/b2PolygonShape.cpp
diff -r -x './svn/*' native/Box2D/Collision/Shapes/.svn/entries ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Collision/Shapes/.svn/entries
4,6c4,6
< 254
< http://box2d.googlecode.com/svn/trunk/Box2D/Box2D/Collision/Shapes
< http://box2d.googlecode.com/svn
---
> 7
> http://android-opengl-box2d-basics.googlecode.com/svn/trunk/rt-jnibox2d/box2d/Collision/Shapes
> http://android-opengl-box2d-basics.googlecode.com/svn
10,12c10,12
< 2012-06-24T02:55:58.404098Z
< 250
< erincatto@gmail.com
---
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
27c27
< cafe418c-1137-0410-84cc-357ec87a5d9b
---
> 5131c71c-dced-4c25-419c-0ca2576ce0a2
35,39c35,39
< 2013-06-18T12:51:08.000000Z
< ad6113446baf4db64ff2db15bed5371e
< 2011-09-01T07:50:55.584099Z
< 210
< erincatto@gmail.com
---
> 2013-07-02T14:40:41.000000Z
> 61f5073f95a6ae88a7ca5cbe30a2a924
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
61c61
< 2423
---
> 5470
69,73c69,73
< 2013-06-18T12:51:08.000000Z
< ca4bceae2d13ba8db67908d0f58755de
< 2012-02-26T07:59:27.872324Z
< 244
< erincatto@gmail.com
---
> 2013-07-02T14:40:41.000000Z
> 2109b1e91ab5fba39247fa5d69a69200
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
95c95
< 3584
---
> 4800
97c97
< b2CircleShape.cpp
---
> b2Shape.cpp
103,107c103,107
< 2013-06-18T12:51:08.000000Z
< 8d884d4921701ab0cb90ee008f84dbd3
< 2011-06-18T08:05:55.703617Z
< 186
< erincatto@gmail.com
---
> 2013-07-02T14:40:41.000000Z
> 5936bc1092595b6f54cbac35a1d17cca
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
129c129
< 3179
---
> 4036
131c131
< b2ChainShape.cpp
---
> b2CircleShape.cpp
137,141c137,141
< 2013-06-18T12:51:08.000000Z
< 59afce3fc88e924fa49e5a5c5fec4021
< 2012-06-24T02:55:58.404098Z
< 250
< erincatto@gmail.com
---
> 2013-07-02T14:40:41.000000Z
> 3f2b06cb995decf1d6e7dc741df88cb8
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
163c163
< 5044
---
> 4740
171,175c171,175
< 2013-06-18T12:51:08.000000Z
< 273ecdbabb1e2920b1198d71ad9e91c1
< 2011-08-22T23:37:58.328489Z
< 200
< erincatto@gmail.com
---
> 2013-07-02T14:40:41.000000Z
> 6572f9031d1341181089b2e3f5f6c53c
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
197c197
< 3457
---
> 5294
205,209c205,209
< 2013-06-18T12:51:08.000000Z
< ddef36b22673a3e4e866fe434b7b3c21
< 2011-08-22T08:16:55.999144Z
< 199
< erincatto@gmail.com
---
> 2013-07-02T14:40:41.000000Z
> 7a9fa8b1507fc74c51b8b2d035457881
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
231c231
< 3598
---
> 9524
239,243c239,243
< 2013-06-18T12:51:08.000000Z
< bed26948d21c7a97ca48ad7f65e451a8
< 2011-03-24T17:36:44.542193Z
< 158
< erincatto
---
> 2013-07-02T14:40:41.000000Z
> afa0b2d4cc7441757e6f3bff536b5363
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
265c265
< 2626
---
> 2705
273,311c273,277
< 2013-06-18T12:51:08.000000Z
< 2675fcfc61b3e70c7717e3bb454347cf
< 2011-09-19T05:49:06.756419Z
< 233
< erincatto@gmail.com
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 10614
< 
< b2ChainShape.h
< file
< 
< 
< 
< 
< 2013-06-18T12:51:08.000000Z
< b74ecdabf7e7db8b3a7556b409e56ac4
< 2011-09-01T07:50:55.584099Z
< 210
< erincatto@gmail.com
---
> 2013-07-02T14:40:41.000000Z
> 52cc84d4f63d11c0a67d846a170a3580
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
333c299
< 3524
---
> 14925
Only in native/Box2D/Collision/Shapes/.svn/text-base: b2ChainShape.cpp.svn-base
Only in native/Box2D/Collision/Shapes/.svn/text-base: b2ChainShape.h.svn-base
diff -r -x './svn/*' native/Box2D/Collision/Shapes/.svn/text-base/b2CircleShape.cpp.svn-base ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Collision/Shapes/.svn/text-base/b2CircleShape.cpp.svn-base
2c2
< * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
19,21c19
< #include <Box2D/Collision/Shapes/b2CircleShape.h>
< #include <new>
< using namespace std;
---
> #include "b2CircleShape.h"
23c21,22
< b2Shape* b2CircleShape::Clone(b2BlockAllocator* allocator) const
---
> b2CircleShape::b2CircleShape(const b2ShapeDef* def)
> : b2Shape(def)
25,28c24,29
< 	void* mem = allocator->Allocate(sizeof(b2CircleShape));
< 	b2CircleShape* clone = new (mem) b2CircleShape;
< 	*clone = *this;
< 	return clone;
---
> 	b2Assert(def->type == e_circleShape);
> 	const b2CircleDef* circleDef = (const b2CircleDef*)def;
> 
> 	m_type = e_circleShape;
> 	m_localPosition = circleDef->localPosition;
> 	m_radius = circleDef->radius;
31c32
< int32 b2CircleShape::GetChildCount() const
---
> void b2CircleShape::UpdateSweepRadius(const b2Vec2& center)
33c34,37
< 	return 1;
---
> 	// Update the sweep radius (maximum radius) as measured from
> 	// a local center point.
> 	b2Vec2 d = m_localPosition - center;
> 	m_sweepRadius = d.Length() + m_radius - b2_toiSlop;
36c40
< bool b2CircleShape::TestPoint(const b2Transform& transform, const b2Vec2& p) const
---
> bool b2CircleShape::TestPoint(const b2XForm& transform, const b2Vec2& p) const
38c42
< 	b2Vec2 center = transform.p + b2Mul(transform.q, m_p);
---
> 	b2Vec2 center = transform.position + b2Mul(transform.R, m_localPosition);
47,48c51,55
< bool b2CircleShape::RayCast(b2RayCastOutput* output, const b2RayCastInput& input,
< 							const b2Transform& transform, int32 childIndex) const
---
> b2SegmentCollide b2CircleShape::TestSegment(const b2XForm& transform,
> 								float32* lambda,
> 								b2Vec2* normal,
> 								const b2Segment& segment,
> 								float32 maxLambda) const
50,53c57,58
< 	B2_NOT_USED(childIndex);
< 
< 	b2Vec2 position = transform.p + b2Mul(transform.q, m_p);
< 	b2Vec2 s = input.p1 - position;
---
> 	b2Vec2 position = transform.position + b2Mul(transform.R, m_localPosition);
> 	b2Vec2 s = segment.p1 - position;
55a61,67
> 	// Does the segment start inside the circle?
> 	if (b < 0.0f)
> 	{
> 		*lambda = 0;
> 		return e_startsInsideCollide;
> 	}
> 
57c69
< 	b2Vec2 r = input.p2 - input.p1;
---
> 	b2Vec2 r = segment.p2 - segment.p1;
63c75
< 	if (sigma < 0.0f || rr < b2_epsilon)
---
> 	if (sigma < 0.0f || rr < B2_FLT_EPSILON)
65c77
< 		return false;
---
> 		return e_missCollide;
72c84
< 	if (0.0f <= a && a <= input.maxFraction * rr)
---
> 	if (0.0f <= a && a <= maxLambda * rr)
75,78c87,90
< 		output->fraction = a;
< 		output->normal = s + a * r;
< 		output->normal.Normalize();
< 		return true;
---
> 		*lambda = a;
> 		*normal = s + a * r;
> 		normal->Normalize();
> 		return e_hitCollide;
81c93
< 	return false;
---
> 	return e_missCollide;
84c96
< void b2CircleShape::ComputeAABB(b2AABB* aabb, const b2Transform& transform, int32 childIndex) const
---
> void b2CircleShape::ComputeAABB(b2AABB* aabb, const b2XForm& transform) const
86,88c98
< 	B2_NOT_USED(childIndex);
< 
< 	b2Vec2 p = transform.p + b2Mul(transform.q, m_p);
---
> 	b2Vec2 p = transform.position + b2Mul(transform.R, m_localPosition);
93c103,114
< void b2CircleShape::ComputeMass(b2MassData* massData, float32 density) const
---
> void b2CircleShape::ComputeSweptAABB(b2AABB* aabb, const b2XForm& transform1, const b2XForm& transform2) const
> {
> 	b2Vec2 p1 = transform1.position + b2Mul(transform1.R, m_localPosition);
> 	b2Vec2 p2 = transform2.position + b2Mul(transform2.R, m_localPosition);
> 	b2Vec2 lower = b2Min(p1, p2);
> 	b2Vec2 upper = b2Max(p1, p2);
> 
> 	aabb->lowerBound.Set(lower.x - m_radius, lower.y - m_radius);
> 	aabb->upperBound.Set(upper.x + m_radius, upper.y + m_radius);
> }
> 
> void b2CircleShape::ComputeMass(b2MassData* massData) const
95,96c116,117
< 	massData->mass = density * b2_pi * m_radius * m_radius;
< 	massData->center = m_p;
---
> 	massData->mass = m_density * b2_pi * m_radius * m_radius;
> 	massData->center = m_localPosition;
99c120,150
< 	massData->I = massData->mass * (0.5f * m_radius * m_radius + b2Dot(m_p, m_p));
---
> 	massData->I = massData->mass * (0.5f * m_radius * m_radius + b2Dot(m_localPosition, m_localPosition));
> }
> 
> float32 b2CircleShape::ComputeSubmergedArea(	const b2Vec2& normal,
> 												float32 offset,
> 												const b2XForm& xf, 
> 												b2Vec2* c) const
> {
> 	b2Vec2 p = b2Mul(xf,m_localPosition);
> 	float32 l = -(b2Dot(normal,p) - offset);
> 	if(l<-m_radius+B2_FLT_EPSILON){
> 		//Completely dry
> 		return 0;
> 	}
> 	if(l>m_radius){
> 		//Completely wet
> 		*c = p;
> 		return b2_pi*m_radius*m_radius;
> 	}
> 	
> 	//Magic
> 	float32 r2 = m_radius*m_radius;
> 	float32 l2 = l*l;
>     //TODO: write b2Sqrt to handle fixed point case.
> 	float32 area = r2 * (asin(l/m_radius) + b2_pi/2.0f)+ l * b2Sqrt(r2 - l2);
> 	float32 com = -2.0f/3.0f*pow(r2-l2,1.5f)/area;
> 	
> 	c->x = p.x + normal.x * com;
> 	c->y = p.y + normal.y * com;
> 	
> 	return area;
diff -r -x './svn/*' native/Box2D/Collision/Shapes/.svn/text-base/b2CircleShape.h.svn-base ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Collision/Shapes/.svn/text-base/b2CircleShape.h.svn-base
2c2
< * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
22c22,36
< #include <Box2D/Collision/Shapes/b2Shape.h>
---
> #include "b2Shape.h"
> 
> /// This structure is used to build circle shapes.
> struct b2CircleDef : public b2ShapeDef
> {
> 	b2CircleDef()
> 	{
> 		type = e_circleShape;
> 		localPosition.SetZero();
> 		radius = 1.0f;
> 	}
> 
> 	b2Vec2 localPosition;
> 	float32 radius;
> };
28c42,43
< 	b2CircleShape();
---
> 	/// @see b2Shape::TestPoint
> 	bool TestPoint(const b2XForm& transform, const b2Vec2& p) const;
30,41c45,50
< 	/// Implement b2Shape.
< 	b2Shape* Clone(b2BlockAllocator* allocator) const;
< 
< 	/// @see b2Shape::GetChildCount
< 	int32 GetChildCount() const;
< 
< 	/// Implement b2Shape.
< 	bool TestPoint(const b2Transform& transform, const b2Vec2& p) const;
< 
< 	/// Implement b2Shape.
< 	bool RayCast(b2RayCastOutput* output, const b2RayCastInput& input,
< 				const b2Transform& transform, int32 childIndex) const;
---
> 	/// @see b2Shape::TestSegment
> 	b2SegmentCollide TestSegment(	const b2XForm& transform,
> 						float32* lambda,
> 						b2Vec2* normal,
> 						const b2Segment& segment,
> 						float32 maxLambda) const;
44c53,58
< 	void ComputeAABB(b2AABB* aabb, const b2Transform& transform, int32 childIndex) const;
---
> 	void ComputeAABB(b2AABB* aabb, const b2XForm& transform) const;
> 
> 	/// @see b2Shape::ComputeSweptAABB
> 	void ComputeSweptAABB(	b2AABB* aabb,
> 							const b2XForm& transform1,
> 							const b2XForm& transform2) const;
47c61
< 	void ComputeMass(b2MassData* massData, float32 density) const;
---
> 	void ComputeMass(b2MassData* massData) const;
49,50c63,67
< 	/// Get the supporting vertex index in the given direction.
< 	int32 GetSupport(const b2Vec2& d) const;
---
> 	/// @see b2Shape::ComputeSubmergedArea
> 	float32 ComputeSubmergedArea(	const b2Vec2& normal,
> 									float32 offset,
> 									const b2XForm& xf, 
> 									b2Vec2* c) const;
52,53c69,70
< 	/// Get the supporting vertex in the given direction.
< 	const b2Vec2& GetSupportVertex(const b2Vec2& d) const;
---
> 	/// Get the local position of this circle in its parent body.
> 	const b2Vec2& GetLocalPosition() const;
55,56c72,73
< 	/// Get the vertex count.
< 	int32 GetVertexCount() const { return 1; }
---
> 	/// Get the radius of this circle.
> 	float32 GetRadius() const;
58,59c75
< 	/// Get a vertex by index. Used by b2Distance.
< 	const b2Vec2& GetVertex(int32 index) const;
---
> private:
61,63c77
< 	/// Position
< 	b2Vec2 m_p;
< };
---
> 	friend class b2Shape;
65,70c79
< inline b2CircleShape::b2CircleShape()
< {
< 	m_type = e_circle;
< 	m_radius = 0.0f;
< 	m_p.SetZero();
< }
---
> 	b2CircleShape(const b2ShapeDef* def);
72,76c81,86
< inline int32 b2CircleShape::GetSupport(const b2Vec2 &d) const
< {
< 	B2_NOT_USED(d);
< 	return 0;
< }
---
> 	void UpdateSweepRadius(const b2Vec2& center);
> 
> 	// Local position in parent body
> 	b2Vec2 m_localPosition;
> 	float32 m_radius;
> };
78c88
< inline const b2Vec2& b2CircleShape::GetSupportVertex(const b2Vec2 &d) const
---
> inline const b2Vec2& b2CircleShape::GetLocalPosition() const
80,81c90
< 	B2_NOT_USED(d);
< 	return m_p;
---
> 	return m_localPosition;
84c93
< inline const b2Vec2& b2CircleShape::GetVertex(int32 index) const
---
> inline float32 b2CircleShape::GetRadius() const
86,88c95
< 	B2_NOT_USED(index);
< 	b2Assert(index == 0);
< 	return m_p;
---
> 	return m_radius;
diff -r -x './svn/*' native/Box2D/Collision/Shapes/.svn/text-base/b2EdgeShape.cpp.svn-base ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Collision/Shapes/.svn/text-base/b2EdgeShape.cpp.svn-base
1,108c1,178
< /*
< * Copyright (c) 2006-2010 Erin Catto http://www.box2d.org
< *
< * This software is provided 'as-is', without any express or implied
< * warranty.  In no event will the authors be held liable for any damages
< * arising from the use of this software.
< * Permission is granted to anyone to use this software for any purpose,
< * including commercial applications, and to alter it and redistribute it
< * freely, subject to the following restrictions:
< * 1. The origin of this software must not be misrepresented; you must not
< * claim that you wrote the original software. If you use this software
< * in a product, an acknowledgment in the product documentation would be
< * appreciated but is not required.
< * 2. Altered source versions must be plainly marked as such, and must not be
< * misrepresented as being the original software.
< * 3. This notice may not be removed or altered from any source distribution.
< */
< 
< #include <Box2D/Collision/Shapes/b2EdgeShape.h>
< #include <new>
< using namespace std;
< 
< void b2EdgeShape::Set(const b2Vec2& v1, const b2Vec2& v2)
< {
< 	m_vertex1 = v1;
< 	m_vertex2 = v2;
< 	m_hasVertex0 = false;
< 	m_hasVertex3 = false;
< }
< 
< b2Shape* b2EdgeShape::Clone(b2BlockAllocator* allocator) const
< {
< 	void* mem = allocator->Allocate(sizeof(b2EdgeShape));
< 	b2EdgeShape* clone = new (mem) b2EdgeShape;
< 	*clone = *this;
< 	return clone;
< }
< 
< int32 b2EdgeShape::GetChildCount() const
< {
< 	return 1;
< }
< 
< bool b2EdgeShape::TestPoint(const b2Transform& xf, const b2Vec2& p) const
< {
< 	B2_NOT_USED(xf);
< 	B2_NOT_USED(p);
< 	return false;
< }
< 
< // p = p1 + t * d
< // v = v1 + s * e
< // p1 + t * d = v1 + s * e
< // s * e - t * d = p1 - v1
< bool b2EdgeShape::RayCast(b2RayCastOutput* output, const b2RayCastInput& input,
< 							const b2Transform& xf, int32 childIndex) const
< {
< 	B2_NOT_USED(childIndex);
< 
< 	// Put the ray into the edge's frame of reference.
< 	b2Vec2 p1 = b2MulT(xf.q, input.p1 - xf.p);
< 	b2Vec2 p2 = b2MulT(xf.q, input.p2 - xf.p);
< 	b2Vec2 d = p2 - p1;
< 
< 	b2Vec2 v1 = m_vertex1;
< 	b2Vec2 v2 = m_vertex2;
< 	b2Vec2 e = v2 - v1;
< 	b2Vec2 normal(e.y, -e.x);
< 	normal.Normalize();
< 
< 	// q = p1 + t * d
< 	// dot(normal, q - v1) = 0
< 	// dot(normal, p1 - v1) + t * dot(normal, d) = 0
< 	float32 numerator = b2Dot(normal, v1 - p1);
< 	float32 denominator = b2Dot(normal, d);
< 
< 	if (denominator == 0.0f)
< 	{
< 		return false;
< 	}
< 
< 	float32 t = numerator / denominator;
< 	if (t < 0.0f || input.maxFraction < t)
< 	{
< 		return false;
< 	}
< 
< 	b2Vec2 q = p1 + t * d;
< 
< 	// q = v1 + s * r
< 	// s = dot(q - v1, r) / dot(r, r)
< 	b2Vec2 r = v2 - v1;
< 	float32 rr = b2Dot(r, r);
< 	if (rr == 0.0f)
< 	{
< 		return false;
< 	}
< 
< 	float32 s = b2Dot(q - v1, r) / rr;
< 	if (s < 0.0f || 1.0f < s)
< 	{
< 		return false;
< 	}
< 
< 	output->fraction = t;
< 	if (numerator > 0.0f)
< 	{
< 		output->normal = -normal;
---
> /*
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
> *
> * This software is provided 'as-is', without any express or implied
> * warranty.  In no event will the authors be held liable for any damages
> * arising from the use of this software.
> * Permission is granted to anyone to use this software for any purpose,
> * including commercial applications, and to alter it and redistribute it
> * freely, subject to the following restrictions:
> * 1. The origin of this software must not be misrepresented; you must not
> * claim that you wrote the original software. If you use this software
> * in a product, an acknowledgment in the product documentation would be
> * appreciated but is not required.
> * 2. Altered source versions must be plainly marked as such, and must not be
> * misrepresented as being the original software.
> * 3. This notice may not be removed or altered from any source distribution.
> */
> 
> #include "b2EdgeShape.h"
> 
> b2EdgeShape::b2EdgeShape(const b2Vec2& v1, const b2Vec2& v2, const b2ShapeDef* def)
> : b2Shape(def)
> {
> 	b2Assert(def->type == e_edgeShape);
> 
> 	m_type = e_edgeShape;
> 	
> 	m_prevEdge = NULL;
> 	m_nextEdge = NULL;
> 	
> 	m_v1 = v1;
> 	m_v2 = v2;
> 	
> 	m_direction = m_v2 - m_v1;
> 	m_length = m_direction.Normalize();
> 	m_normal.Set(m_direction.y, -m_direction.x);
> 	
> 	m_coreV1 = -b2_toiSlop * (m_normal - m_direction) + m_v1;
> 	m_coreV2 = -b2_toiSlop * (m_normal + m_direction) + m_v2;
> 	
> 	m_cornerDir1 = m_normal;
> 	m_cornerDir2 = -1.0f * m_normal;
> }
> 
> void b2EdgeShape::UpdateSweepRadius(const b2Vec2& center)
> {
> 	// Update the sweep radius (maximum radius) as measured from
> 	// a local center point.
> 	b2Vec2 d = m_coreV1 - center;
> 	float32 d1 = b2Dot(d,d);
> 	d = m_coreV2 - center;
> 	float32 d2 = b2Dot(d,d);
> 	m_sweepRadius = b2Sqrt(d1 > d2 ? d1 : d2);
> }
> 
> bool b2EdgeShape::TestPoint(const b2XForm& transform, const b2Vec2& p) const
> {
> 	B2_NOT_USED(transform);
> 	B2_NOT_USED(p);
> 	return false;
> }
> 
> b2SegmentCollide b2EdgeShape::TestSegment(const b2XForm& transform,
> 								float32* lambda,
> 								b2Vec2* normal,
> 								const b2Segment& segment,
> 								float32 maxLambda) const
> {
> 	b2Vec2 r = segment.p2 - segment.p1;
> 	b2Vec2 v1 = b2Mul(transform, m_v1);
> 	b2Vec2 d = b2Mul(transform, m_v2) - v1;
> 	b2Vec2 n = b2Cross(d, 1.0f);
> 
> 	const float32 k_slop = 100.0f * B2_FLT_EPSILON;
> 	float32 denom = -b2Dot(r, n);
> 
> 	// Cull back facing collision and ignore parallel segments.
> 	if (denom > k_slop)
> 	{
> 		// Does the segment intersect the infinite line associated with this segment?
> 		b2Vec2 b = segment.p1 - v1;
> 		float32 a = b2Dot(b, n);
> 
> 		if (0.0f <= a && a <= maxLambda * denom)
> 		{
> 			float32 mu2 = -r.x * b.y + r.y * b.x;
> 
> 			// Does the segment intersect this segment?
> 			if (-k_slop * denom <= mu2 && mu2 <= denom * (1.0f + k_slop))
> 			{
> 				a /= denom;
> 				n.Normalize();
> 				*lambda = a;
> 				*normal = n;
> 				return e_hitCollide;
> 			}
> 		}
> 	}
> 
> 	return e_missCollide;
> }
> 
> void b2EdgeShape::ComputeAABB(b2AABB* aabb, const b2XForm& transform) const
> {
> 	b2Vec2 v1 = b2Mul(transform, m_v1);
> 	b2Vec2 v2 = b2Mul(transform, m_v2);
> 	aabb->lowerBound = b2Min(v1, v2);
> 	aabb->upperBound = b2Max(v1, v2);
> }
> 
> void b2EdgeShape::ComputeSweptAABB(b2AABB* aabb, const b2XForm& transform1, const b2XForm& transform2) const
> {
> 	b2Vec2 v1 = b2Mul(transform1, m_v1);
> 	b2Vec2 v2 = b2Mul(transform1, m_v2);
> 	b2Vec2 v3 = b2Mul(transform2, m_v1);
> 	b2Vec2 v4 = b2Mul(transform2, m_v2);
> 	aabb->lowerBound = b2Min(b2Min(b2Min(v1, v2), v3), v4);
> 	aabb->upperBound = b2Max(b2Max(b2Max(v1, v2), v3), v4);
> }
> 
> void b2EdgeShape::ComputeMass(b2MassData* massData) const
> {
> 	massData->mass = 0;
> 	massData->center = m_v1;
> 
> 	// inertia about the local origin
> 	massData->I = 0;
> }
> 
> b2Vec2 b2EdgeShape::Support(const b2XForm& xf, const b2Vec2& d) const
> {
> 	b2Vec2 v1 = b2Mul(xf, m_coreV1);
> 	b2Vec2 v2 = b2Mul(xf, m_coreV2);
> 	return b2Dot(v1, d) > b2Dot(v2, d) ? v1 : v2;
> }
> 
> void b2EdgeShape::SetPrevEdge(b2EdgeShape* edge, const b2Vec2& core, const b2Vec2& cornerDir, bool convex)
> {
> 	m_prevEdge = edge;
> 	m_coreV1 = core;
> 	m_cornerDir1 = cornerDir;
> 	m_cornerConvex1 = convex;
> }
> 
> void b2EdgeShape::SetNextEdge(b2EdgeShape* edge, const b2Vec2& core, const b2Vec2& cornerDir, bool convex)
> {
> 	m_nextEdge = edge;
> 	m_coreV2 = core;
> 	m_cornerDir2 = cornerDir;
> 	m_cornerConvex2 = convex;
> }
> 
> float32 b2EdgeShape::ComputeSubmergedArea(	const b2Vec2& normal,
> 												float32 offset,
> 												const b2XForm& xf, 
> 												b2Vec2* c) const
> {
> 	//Note that v0 is independant of any details of the specific edge
> 	//We are relying on v0 being consistent between multiple edges of the same body
> 	b2Vec2 v0 = offset * normal;
> 	//b2Vec2 v0 = xf.position + (offset - b2Dot(normal, xf.position)) * normal;
> 
> 	b2Vec2 v1 = b2Mul(xf, m_v1);
> 	b2Vec2 v2 = b2Mul(xf, m_v2);
> 
> 	float32 d1 = b2Dot(normal, v1) - offset;
> 	float32 d2 = b2Dot(normal, v2) - offset;
> 
> 	if(d1>0)
> 	{
> 		if(d2>0)
> 		{
> 			return 0;
> 		}
> 		else
> 		{
> 			v1 = -d2 / (d1 - d2) * v1 + d1 / (d1 - d2) * v2;
> 		}
112,139c182,203
< 		output->normal = normal;
< 	}
< 	return true;
< }
< 
< void b2EdgeShape::ComputeAABB(b2AABB* aabb, const b2Transform& xf, int32 childIndex) const
< {
< 	B2_NOT_USED(childIndex);
< 
< 	b2Vec2 v1 = b2Mul(xf, m_vertex1);
< 	b2Vec2 v2 = b2Mul(xf, m_vertex2);
< 
< 	b2Vec2 lower = b2Min(v1, v2);
< 	b2Vec2 upper = b2Max(v1, v2);
< 
< 	b2Vec2 r(m_radius, m_radius);
< 	aabb->lowerBound = lower - r;
< 	aabb->upperBound = upper + r;
< }
< 
< void b2EdgeShape::ComputeMass(b2MassData* massData, float32 density) const
< {
< 	B2_NOT_USED(density);
< 
< 	massData->mass = 0.0f;
< 	massData->center = 0.5f * (m_vertex1 + m_vertex2);
< 	massData->I = 0.0f;
< }
---
> 		if(d2>0)
> 		{
> 			v2 = -d2 / (d1 - d2) * v1 + d1 / (d1 - d2) * v2;
> 		}
> 		else
> 		{
> 			//Nothing
> 		}
> 	}
> 
> 	// v0,v1,v2 represents a fully submerged triangle
> 	float32 k_inv3 = 1.0f / 3.0f;
> 
> 	// Area weighted centroid
> 	*c = k_inv3 * (v0 + v1 + v2);
> 
> 	b2Vec2 e1 = v1 - v0;
> 	b2Vec2 e2 = v2 - v0;
> 
> 	return 0.5f * b2Cross(e1, e2);
> }
> 
diff -r -x './svn/*' native/Box2D/Collision/Shapes/.svn/text-base/b2EdgeShape.h.svn-base ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Collision/Shapes/.svn/text-base/b2EdgeShape.h.svn-base
1,74c1,222
< /*
< * Copyright (c) 2006-2010 Erin Catto http://www.box2d.org
< *
< * This software is provided 'as-is', without any express or implied
< * warranty.  In no event will the authors be held liable for any damages
< * arising from the use of this software.
< * Permission is granted to anyone to use this software for any purpose,
< * including commercial applications, and to alter it and redistribute it
< * freely, subject to the following restrictions:
< * 1. The origin of this software must not be misrepresented; you must not
< * claim that you wrote the original software. If you use this software
< * in a product, an acknowledgment in the product documentation would be
< * appreciated but is not required.
< * 2. Altered source versions must be plainly marked as such, and must not be
< * misrepresented as being the original software.
< * 3. This notice may not be removed or altered from any source distribution.
< */
< 
< #ifndef B2_EDGE_SHAPE_H
< #define B2_EDGE_SHAPE_H
< 
< #include <Box2D/Collision/Shapes/b2Shape.h>
< 
< /// A line segment (edge) shape. These can be connected in chains or loops
< /// to other edge shapes. The connectivity information is used to ensure
< /// correct contact normals.
< class b2EdgeShape : public b2Shape
< {
< public:
< 	b2EdgeShape();
< 
< 	/// Set this as an isolated edge.
< 	void Set(const b2Vec2& v1, const b2Vec2& v2);
< 
< 	/// Implement b2Shape.
< 	b2Shape* Clone(b2BlockAllocator* allocator) const;
< 
< 	/// @see b2Shape::GetChildCount
< 	int32 GetChildCount() const;
< 
< 	/// @see b2Shape::TestPoint
< 	bool TestPoint(const b2Transform& transform, const b2Vec2& p) const;
< 
< 	/// Implement b2Shape.
< 	bool RayCast(b2RayCastOutput* output, const b2RayCastInput& input,
< 				const b2Transform& transform, int32 childIndex) const;
< 
< 	/// @see b2Shape::ComputeAABB
< 	void ComputeAABB(b2AABB* aabb, const b2Transform& transform, int32 childIndex) const;
< 
< 	/// @see b2Shape::ComputeMass
< 	void ComputeMass(b2MassData* massData, float32 density) const;
< 	
< 	/// These are the edge vertices
< 	b2Vec2 m_vertex1, m_vertex2;
< 
< 	/// Optional adjacent vertices. These are used for smooth collision.
< 	b2Vec2 m_vertex0, m_vertex3;
< 	bool m_hasVertex0, m_hasVertex3;
< };
< 
< inline b2EdgeShape::b2EdgeShape()
< {
< 	m_type = e_edge;
< 	m_radius = b2_polygonRadius;
< 	m_vertex0.x = 0.0f;
< 	m_vertex0.y = 0.0f;
< 	m_vertex3.x = 0.0f;
< 	m_vertex3.y = 0.0f;
< 	m_hasVertex0 = false;
< 	m_hasVertex3 = false;
< }
< 
< #endif
---
> /*
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
> *
> * This software is provided 'as-is', without any express or implied
> * warranty.  In no event will the authors be held liable for any damages
> * arising from the use of this software.
> * Permission is granted to anyone to use this software for any purpose,
> * including commercial applications, and to alter it and redistribute it
> * freely, subject to the following restrictions:
> * 1. The origin of this software must not be misrepresented; you must not
> * claim that you wrote the original software. If you use this software
> * in a product, an acknowledgment in the product documentation would be
> * appreciated but is not required.
> * 2. Altered source versions must be plainly marked as such, and must not be
> * misrepresented as being the original software.
> * 3. This notice may not be removed or altered from any source distribution.
> */
> 
> #ifndef B2_EDGE_SHAPE_H
> #define B2_EDGE_SHAPE_H
> 
> #include "b2Shape.h"
> 
> /// This structure is used to build circle shapes.
> struct b2EdgeChainDef : public b2ShapeDef
> {
> 	b2EdgeChainDef()
> 	{
> 		type = e_edgeShape;
> 		vertexCount = 0;
> 		isALoop = true;
> 		vertices = NULL;
> 	}
> 	/// The vertices in local coordinates. You must manage the memory
> 	/// of this array on your own, outside of Box2D. 
> 	b2Vec2* vertices;
> 	
> 	/// The number of vertices in the chain. 
> 	int32 vertexCount;
> 	
> 	/// Whether to create an extra edge between the first and last vertices:
> 	bool isALoop;
> };
> 
> /// A circle shape.
> class b2EdgeShape : public b2Shape
> {
> public:
> 	/// @see b2Shape::TestPoint
> 	bool TestPoint(const b2XForm& transform, const b2Vec2& p) const;
> 
> 	/// @see b2Shape::TestSegment
> 	b2SegmentCollide TestSegment(	const b2XForm& transform,
> 						float32* lambda,
> 						b2Vec2* normal,
> 						const b2Segment& segment,
> 						float32 maxLambda) const;
> 
> 	/// @see b2Shape::ComputeAABB
> 	void ComputeAABB(b2AABB* aabb, const b2XForm& transform) const;
> 
> 	/// @see b2Shape::ComputeSweptAABB
> 	void ComputeSweptAABB(	b2AABB* aabb,
> 							const b2XForm& transform1,
> 							const b2XForm& transform2) const;
> 
> 	/// @see b2Shape::ComputeMass
> 	void ComputeMass(b2MassData* massData) const;
> 
> 	/// @warning This only gives a consistent and sensible answer when when summed over a body only contains loops of edges
> 	/// @see b2Shape::ComputeSubmergedArea
> 	float32 ComputeSubmergedArea(	const b2Vec2& normal,
> 									float32 offset,
> 									const b2XForm& xf, 
> 									b2Vec2* c) const;
> 	
> 	/// Linear distance from vertex1 to vertex2:
> 	float32 GetLength() const;
> 
> 	/// Local position of vertex in parent body
> 	const b2Vec2& GetVertex1() const;
> 
> 	/// Local position of vertex in parent body
> 	const b2Vec2& GetVertex2() const;
> 
> 	/// "Core" vertex with TOI slop for b2Distance functions:
> 	const b2Vec2& GetCoreVertex1() const;
> 
> 	/// "Core" vertex with TOI slop for b2Distance functions:
> 	const b2Vec2& GetCoreVertex2() const;
> 	
> 	/// Perpendicular unit vector point, pointing from the solid side to the empty side: 
> 	const b2Vec2& GetNormalVector() const;
> 	
> 	/// Parallel unit vector, pointing from vertex1 to vertex2:
> 	const b2Vec2& GetDirectionVector() const;
> 	
> 	const b2Vec2& GetCorner1Vector() const;
> 	
> 	const b2Vec2& GetCorner2Vector() const;
> 	
> 	bool Corner1IsConvex() const;
> 	
> 	bool Corner2IsConvex() const;
> 
> 	b2Vec2 GetFirstVertex(const b2XForm& xf) const;
> 
> 	b2Vec2 Support(const b2XForm& xf, const b2Vec2& d) const;
> 	
> 	/// Get the next edge in the chain.
> 	b2EdgeShape* GetNextEdge() const;
> 	
> 	/// Get the previous edge in the chain.
> 	b2EdgeShape* GetPrevEdge() const;
> 
> 	void SetPrevEdge(b2EdgeShape* edge, const b2Vec2& core, const b2Vec2& cornerDir, bool convex);
> 	void SetNextEdge(b2EdgeShape* edge, const b2Vec2& core, const b2Vec2& cornerDir, bool convex);
> 	
> private:
> 
> 	friend class b2Shape;
> 	friend class b2Body;
> 
> 	b2EdgeShape(const b2Vec2& v1, const b2Vec2& v2, const b2ShapeDef* def);
> 
> 	void UpdateSweepRadius(const b2Vec2& center);
> 
> 	b2Vec2 m_v1;
> 	b2Vec2 m_v2;
> 	
> 	b2Vec2 m_coreV1;
> 	b2Vec2 m_coreV2;
> 	
> 	float32 m_length;
> 	
> 	b2Vec2 m_normal;
> 	
> 	b2Vec2 m_direction;
> 	
> 	// Unit vector halfway between m_direction and m_prevEdge.m_direction:
> 	b2Vec2 m_cornerDir1;
> 	
> 	// Unit vector halfway between m_direction and m_nextEdge.m_direction:
> 	b2Vec2 m_cornerDir2;
> 	
> 	bool m_cornerConvex1;
> 	bool m_cornerConvex2;
> 	
> 	b2EdgeShape* m_nextEdge;
> 	b2EdgeShape* m_prevEdge;
> };
> 
> inline float32 b2EdgeShape::GetLength() const
> {
> 	return m_length;
> }
> 
> inline const b2Vec2& b2EdgeShape::GetVertex1() const
> {
> 	return m_v1;
> }
> 
> inline const b2Vec2& b2EdgeShape::GetVertex2() const
> {
> 	return m_v2;
> }
> 
> inline const b2Vec2& b2EdgeShape::GetCoreVertex1() const
> {
> 	return m_coreV1;
> }
> 
> inline const b2Vec2& b2EdgeShape::GetCoreVertex2() const
> {
> 	return m_coreV2;
> }
> 
> inline const b2Vec2& b2EdgeShape::GetNormalVector() const
> {
> 	return m_normal;
> }
> 
> inline const b2Vec2& b2EdgeShape::GetDirectionVector() const
> {
> 	return m_direction;
> }
> 
> inline const b2Vec2& b2EdgeShape::GetCorner1Vector() const
> {
> 	return m_cornerDir1;
> }
> 
> inline const b2Vec2& b2EdgeShape::GetCorner2Vector() const
> {
> 	return m_cornerDir2;
> }
> 
> inline b2EdgeShape* b2EdgeShape::GetNextEdge() const
> {
> 	return m_nextEdge;
> }
> 
> inline b2EdgeShape* b2EdgeShape::GetPrevEdge() const
> {
> 	return m_prevEdge;
> }
> 
> inline b2Vec2 b2EdgeShape::GetFirstVertex(const b2XForm& xf) const
> {
> 	return b2Mul(xf, m_coreV1);
> }
> 
> inline bool b2EdgeShape::Corner1IsConvex() const
> {
> 	return m_cornerConvex1;
> }
> 
> inline bool b2EdgeShape::Corner2IsConvex() const
> {
> 	return m_cornerConvex2;
> }
> #endif
diff -r -x './svn/*' native/Box2D/Collision/Shapes/.svn/text-base/b2PolygonShape.cpp.svn-base ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Collision/Shapes/.svn/text-base/b2PolygonShape.cpp.svn-base
0a1
> 
2c3
< * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
19,28c20
< #include <Box2D/Collision/Shapes/b2PolygonShape.h>
< #include <new>
< 
< b2Shape* b2PolygonShape::Clone(b2BlockAllocator* allocator) const
< {
< 	void* mem = allocator->Allocate(sizeof(b2PolygonShape));
< 	b2PolygonShape* clone = new (mem) b2PolygonShape;
< 	*clone = *this;
< 	return clone;
< }
---
> #include "b2PolygonShape.h"
30c22
< void b2PolygonShape::SetAsBox(float32 hx, float32 hy)
---
> void b2PolygonDef::SetAsBox(float32 hx, float32 hy)
32,41c24,28
< 	m_count = 4;
< 	m_vertices[0].Set(-hx, -hy);
< 	m_vertices[1].Set( hx, -hy);
< 	m_vertices[2].Set( hx,  hy);
< 	m_vertices[3].Set(-hx,  hy);
< 	m_normals[0].Set(0.0f, -1.0f);
< 	m_normals[1].Set(1.0f, 0.0f);
< 	m_normals[2].Set(0.0f, 1.0f);
< 	m_normals[3].Set(-1.0f, 0.0f);
< 	m_centroid.SetZero();
---
> 	vertexCount = 4;
> 	vertices[0].Set(-hx, -hy);
> 	vertices[1].Set( hx, -hy);
> 	vertices[2].Set( hx,  hy);
> 	vertices[3].Set(-hx,  hy);
44c31
< void b2PolygonShape::SetAsBox(float32 hx, float32 hy, const b2Vec2& center, float32 angle)
---
> void b2PolygonDef::SetAsBox(float32 hx, float32 hy, const b2Vec2& center, float32 angle)
46,55c33,36
< 	m_count = 4;
< 	m_vertices[0].Set(-hx, -hy);
< 	m_vertices[1].Set( hx, -hy);
< 	m_vertices[2].Set( hx,  hy);
< 	m_vertices[3].Set(-hx,  hy);
< 	m_normals[0].Set(0.0f, -1.0f);
< 	m_normals[1].Set(1.0f, 0.0f);
< 	m_normals[2].Set(0.0f, 1.0f);
< 	m_normals[3].Set(-1.0f, 0.0f);
< 	m_centroid = center;
---
> 	SetAsBox(hx, hy);
> 	b2XForm xf;
> 	xf.position = center;
> 	xf.R.Set(angle);
57,62c38
< 	b2Transform xf;
< 	xf.p = center;
< 	xf.q.Set(angle);
< 
< 	// Transform vertices and normals.
< 	for (int32 i = 0; i < m_count; ++i)
---
> 	for (int32 i = 0; i < vertexCount; ++i)
64,65c40
< 		m_vertices[i] = b2Mul(xf, m_vertices[i]);
< 		m_normals[i] = b2Mul(xf.q, m_normals[i]);
---
> 		vertices[i] = b2Mul(xf, vertices[i]);
69,73d43
< int32 b2PolygonShape::GetChildCount() const
< {
< 	return 1;
< }
< 
115c85
< 	b2Assert(area > b2_epsilon);
---
> 	b2Assert(area > B2_FLT_EPSILON);
120c90,91
< void b2PolygonShape::Set(const b2Vec2* vertices, int32 count)
---
> // http://www.geometrictools.com/Documentation/MinimumAreaRectangle.pdf
> static void ComputeOBB(b2OBB* obb, const b2Vec2* vs, int32 count)
122,123c93,95
< 	b2Assert(3 <= count && count <= b2_maxPolygonVertices);
< 	if (count < 3)
---
> 	b2Assert(count <= b2_maxPolygonVertices);
> 	b2Vec2 p[b2_maxPolygonVertices + 1];
> 	for (int32 i = 0; i < count; ++i)
125,126c97
< 		SetAsBox(1.0f, 1.0f);
< 		return;
---
> 		p[i] = vs[i];
128,129c99
< 	
< 	int32 n = b2Min(count, b2_maxPolygonVertices);
---
> 	p[count] = p[0];
131,133c101,103
< 	// Copy vertices into local buffer
< 	b2Vec2 ps[b2_maxPolygonVertices];
< 	for (int32 i = 0; i < n; ++i)
---
> 	float32 minArea = B2_FLT_MAX;
> 	
> 	for (int32 i = 1; i <= count; ++i)
135,136c105,111
< 		ps[i] = vertices[i];
< 	}
---
> 		b2Vec2 root = p[i-1];
> 		b2Vec2 ux = p[i] - root;
> 		float32 length = ux.Normalize();
> 		b2Assert(length > B2_FLT_EPSILON);
> 		b2Vec2 uy(-ux.y, ux.x);
> 		b2Vec2 lower(B2_FLT_MAX, B2_FLT_MAX);
> 		b2Vec2 upper(-B2_FLT_MAX, -B2_FLT_MAX);
138,139c113,121
< 	// Create the convex hull using the Gift wrapping algorithm
< 	// http://en.wikipedia.org/wiki/Gift_wrapping_algorithm
---
> 		for (int32 j = 0; j < count; ++j)
> 		{
> 			b2Vec2 d = p[j] - root;
> 			b2Vec2 r;
> 			r.x = b2Dot(ux, d);
> 			r.y = b2Dot(uy, d);
> 			lower = b2Min(lower, r);
> 			upper = b2Max(upper, r);
> 		}
141,147c123,124
< 	// Find the right most point on the hull
< 	int32 i0 = 0;
< 	float32 x0 = ps[0].x;
< 	for (int32 i = 1; i < count; ++i)
< 	{
< 		float32 x = ps[i].x;
< 		if (x > x0 || (x == x0 && ps[i].y < ps[i0].y))
---
> 		float32 area = (upper.x - lower.x) * (upper.y - lower.y);
> 		if (area < 0.95f * minArea)
149,150c126,131
< 			i0 = i;
< 			x0 = x;
---
> 			minArea = area;
> 			obb->R.col1 = ux;
> 			obb->R.col2 = uy;
> 			b2Vec2 center = 0.5f * (lower + upper);
> 			obb->center = root + b2Mul(obb->R, center);
> 			obb->extents = 0.5f * (upper - lower);
154,156c135,147
< 	int32 hull[b2_maxPolygonVertices];
< 	int32 m = 0;
< 	int32 ih = i0;
---
> 	b2Assert(minArea < B2_FLT_MAX);
> }
> 
> b2PolygonShape::b2PolygonShape(const b2ShapeDef* def)
> 	 : b2Shape(def)
> {
> 	b2Assert(def->type == e_polygonShape);
> 	m_type = e_polygonShape;
> 	const b2PolygonDef* poly = (const b2PolygonDef*)def;
> 
> 	// Get the vertices transformed into the body frame.
> 	m_vertexCount = poly->vertexCount;
> 	b2Assert(3 <= m_vertexCount && m_vertexCount <= b2_maxPolygonVertices);
158c149,150
< 	for (;;)
---
> 	// Copy vertices.
> 	for (int32 i = 0; i < m_vertexCount; ++i)
160c152,153
< 		hull[m] = ih;
---
> 		m_vertices[i] = poly->vertices[i];
> 	}
162,163c155,170
< 		int32 ie = 0;
< 		for (int32 j = 1; j < n; ++j)
---
> 	// Compute normals. Ensure the edges have non-zero length.
> 	for (int32 i = 0; i < m_vertexCount; ++i)
> 	{
> 		int32 i1 = i;
> 		int32 i2 = i + 1 < m_vertexCount ? i + 1 : 0;
> 		b2Vec2 edge = m_vertices[i2] - m_vertices[i1];
> 		b2Assert(edge.LengthSquared() > B2_FLT_EPSILON * B2_FLT_EPSILON);
> 		m_normals[i] = b2Cross(edge, 1.0f);
> 		m_normals[i].Normalize();
> 	}
> 
> #ifdef _DEBUG
> 	// Ensure the polygon is convex.
> 	for (int32 i = 0; i < m_vertexCount; ++i)
> 	{
> 		for (int32 j = 0; j < m_vertexCount; ++j)
165c172,173
< 			if (ie == ih)
---
> 			// Don't check vertices on the current edge.
> 			if (j == i || j == (i + 1) % m_vertexCount)
167d174
< 				ie = j;
170,183c177,181
< 
< 			b2Vec2 r = ps[ie] - ps[hull[m]];
< 			b2Vec2 v = ps[j] - ps[hull[m]];
< 			float32 c = b2Cross(r, v);
< 			if (c < 0.0f)
< 			{
< 				ie = j;
< 			}
< 
< 			// Collinearity check
< 			if (c == 0.0f && v.LengthSquared() > r.LengthSquared())
< 			{
< 				ie = j;
< 			}
---
> 			
> 			// Your polygon is non-convex (it has an indentation).
> 			// Or your polygon is too skinny.
> 			float32 s = b2Dot(m_normals[i], m_vertices[j] - m_vertices[i]);
> 			b2Assert(s < -b2_linearSlop);
184a183
> 	}
186,187c185,188
< 		++m;
< 		ih = ie;
---
> 	// Ensure the polygon is counter-clockwise.
> 	for (int32 i = 1; i < m_vertexCount; ++i)
> 	{
> 		float32 cross = b2Cross(m_normals[i-1], m_normals[i]);
189,192c190,195
< 		if (ie == i0)
< 		{
< 			break;
< 		}
---
> 		// Keep asinf happy.
> 		cross = b2Clamp(cross, -1.0f, 1.0f);
> 
> 		// You have consecutive edges that are almost parallel on your polygon.
> 		float32 angle = asinf(cross);
> 		b2Assert(angle > b2_angularSlop);
194,195c197
< 	
< 	m_count = m;
---
> #endif
197,198c199,207
< 	// Copy vertices.
< 	for (int32 i = 0; i < m; ++i)
---
> 	// Compute the polygon centroid.
> 	m_centroid = ComputeCentroid(poly->vertices, poly->vertexCount);
> 
> 	// Compute the oriented bounding box.
> 	ComputeOBB(&m_obb, m_vertices, m_vertexCount);
> 
> 	// Create core polygon shape by shifting edges inward.
> 	// Also compute the min/max radius for CCD.
> 	for (int32 i = 0; i < m_vertexCount; ++i)
200c209,229
< 		m_vertices[i] = ps[hull[i]];
---
> 		int32 i1 = i - 1 >= 0 ? i - 1 : m_vertexCount - 1;
> 		int32 i2 = i;
> 
> 		b2Vec2 n1 = m_normals[i1];
> 		b2Vec2 n2 = m_normals[i2];
> 		b2Vec2 v = m_vertices[i] - m_centroid;;
> 
> 		b2Vec2 d;
> 		d.x = b2Dot(n1, v) - b2_toiSlop;
> 		d.y = b2Dot(n2, v) - b2_toiSlop;
> 
> 		// Shifting the edge inward by b2_toiSlop should
> 		// not cause the plane to pass the centroid.
> 
> 		// Your shape has a radius/extent less than b2_toiSlop.
> 		b2Assert(d.x >= 0.0f);
> 		b2Assert(d.y >= 0.0f);
> 		b2Mat22 A;
> 		A.col1.x = n1.x; A.col2.x = n1.y;
> 		A.col1.y = n2.x; A.col2.y = n2.y;
> 		m_coreVertices[i] = A.Solve(d) + m_centroid;
201a231
> }
203,204c233,238
< 	// Compute normals. Ensure the edges have non-zero length.
< 	for (int32 i = 0; i < m; ++i)
---
> void b2PolygonShape::UpdateSweepRadius(const b2Vec2& center)
> {
> 	// Update the sweep radius (maximum radius) as measured from
> 	// a local center point.
> 	m_sweepRadius = 0.0f;
> 	for (int32 i = 0; i < m_vertexCount; ++i)
206,211c240,241
< 		int32 i1 = i;
< 		int32 i2 = i + 1 < m ? i + 1 : 0;
< 		b2Vec2 edge = m_vertices[i2] - m_vertices[i1];
< 		b2Assert(edge.LengthSquared() > b2_epsilon * b2_epsilon);
< 		m_normals[i] = b2Cross(edge, 1.0f);
< 		m_normals[i].Normalize();
---
> 		b2Vec2 d = m_coreVertices[i] - center;
> 		m_sweepRadius = b2Max(m_sweepRadius, d.Length());
213,215d242
< 
< 	// Compute the polygon centroid.
< 	m_centroid = ComputeCentroid(m_vertices, m);
218c245
< bool b2PolygonShape::TestPoint(const b2Transform& xf, const b2Vec2& p) const
---
> bool b2PolygonShape::TestPoint(const b2XForm& xf, const b2Vec2& p) const
220c247
< 	b2Vec2 pLocal = b2MulT(xf.q, p - xf.p);
---
> 	b2Vec2 pLocal = b2MulT(xf.R, p - xf.position);
222c249
< 	for (int32 i = 0; i < m_count; ++i)
---
> 	for (int32 i = 0; i < m_vertexCount; ++i)
234,235c261,266
< bool b2PolygonShape::RayCast(b2RayCastOutput* output, const b2RayCastInput& input,
< 								const b2Transform& xf, int32 childIndex) const
---
> b2SegmentCollide b2PolygonShape::TestSegment(
> 	const b2XForm& xf,
> 	float32* lambda,
> 	b2Vec2* normal,
> 	const b2Segment& segment,
> 	float32 maxLambda) const
237c268
< 	B2_NOT_USED(childIndex);
---
> 	float32 lower = 0.0f, upper = maxLambda;
239,241c270,271
< 	// Put the ray into the polygon's frame of reference.
< 	b2Vec2 p1 = b2MulT(xf.q, input.p1 - xf.p);
< 	b2Vec2 p2 = b2MulT(xf.q, input.p2 - xf.p);
---
> 	b2Vec2 p1 = b2MulT(xf.R, segment.p1 - xf.position);
> 	b2Vec2 p2 = b2MulT(xf.R, segment.p2 - xf.position);
243,245d272
< 
< 	float32 lower = 0.0f, upper = input.maxFraction;
< 
248c275
< 	for (int32 i = 0; i < m_count; ++i)
---
> 	for (int32 i = 0; i < m_vertexCount; ++i)
260c287
< 				return false;
---
> 				return e_missCollide;
284,287d310
< 		// The use of epsilon here causes the assert on lower to trip
< 		// in some cases. Apparently the use of epsilon was to make edge
< 		// shapes work, but now those are handled separately.
< 		//if (upper < lower - b2_epsilon)
290c313
< 			return false;
---
> 			return e_missCollide;
294c317
< 	b2Assert(0.0f <= lower && lower <= input.maxFraction);
---
> 	b2Assert(0.0f <= lower && lower <= maxLambda);
298,300c321,323
< 		output->fraction = lower;
< 		output->normal = b2Mul(xf.q, m_normals[index]);
< 		return true;
---
> 		*lambda = lower;
> 		*normal = b2Mul(xf.R, m_normals[index]);
> 		return e_hitCollide;
303c326,327
< 	return false;
---
> 	*lambda = 0;
> 	return e_startsInsideCollide;
306c330
< void b2PolygonShape::ComputeAABB(b2AABB* aabb, const b2Transform& xf, int32 childIndex) const
---
> void b2PolygonShape::ComputeAABB(b2AABB* aabb, const b2XForm& xf) const
308,318c332,338
< 	B2_NOT_USED(childIndex);
< 
< 	b2Vec2 lower = b2Mul(xf, m_vertices[0]);
< 	b2Vec2 upper = lower;
< 
< 	for (int32 i = 1; i < m_count; ++i)
< 	{
< 		b2Vec2 v = b2Mul(xf, m_vertices[i]);
< 		lower = b2Min(lower, v);
< 		upper = b2Max(upper, v);
< 	}
---
> 	b2Mat22 R = b2Mul(xf.R, m_obb.R);
> 	b2Mat22 absR = b2Abs(R);
> 	b2Vec2 h = b2Mul(absR, m_obb.extents);
> 	b2Vec2 position = xf.position + b2Mul(xf.R, m_obb.center);
> 	aabb->lowerBound = position - h;
> 	aabb->upperBound = position + h;
> }
320,322c340,348
< 	b2Vec2 r(m_radius, m_radius);
< 	aabb->lowerBound = lower - r;
< 	aabb->upperBound = upper + r;
---
> void b2PolygonShape::ComputeSweptAABB(b2AABB* aabb,
> 					  const b2XForm& transform1,
> 					  const b2XForm& transform2) const
> {
> 	b2AABB aabb1, aabb2;
> 	ComputeAABB(&aabb1, transform1);
> 	ComputeAABB(&aabb2, transform2);
> 	aabb->lowerBound = b2Min(aabb1.lowerBound, aabb2.lowerBound);
> 	aabb->upperBound = b2Max(aabb1.upperBound, aabb2.upperBound);
325c351
< void b2PolygonShape::ComputeMass(b2MassData* massData, float32 density) const
---
> void b2PolygonShape::ComputeMass(b2MassData* massData) const
351c377
< 	b2Assert(m_count >= 3);
---
> 	b2Assert(m_vertexCount >= 3);
357c383
< 	// s is the reference point for forming triangles.
---
> 	// pRef is the reference point for forming triangles.
359,360c385,386
< 	b2Vec2 s(0.0f, 0.0f);
< 
---
> 	b2Vec2 pRef(0.0f, 0.0f);
> #if 0
362c388
< 	for (int32 i = 0; i < m_count; ++i)
---
> 	for (int32 i = 0; i < m_vertexCount; ++i)
364c390
< 		s += m_vertices[i];
---
> 		pRef += m_vertices[i];
366c392,393
< 	s *= 1.0f / m_count;
---
> 	pRef *= 1.0f / count;
> #endif
370c397
< 	for (int32 i = 0; i < m_count; ++i)
---
> 	for (int32 i = 0; i < m_vertexCount; ++i)
373,374c400,405
< 		b2Vec2 e1 = m_vertices[i] - s;
< 		b2Vec2 e2 = i + 1 < m_count ? m_vertices[i+1] - s : m_vertices[0] - s;
---
> 		b2Vec2 p1 = pRef;
> 		b2Vec2 p2 = m_vertices[i];
> 		b2Vec2 p3 = i + 1 < m_vertexCount ? m_vertices[i+1] : m_vertices[0];
> 
> 		b2Vec2 e1 = p2 - p1;
> 		b2Vec2 e2 = p3 - p1;
382c413
< 		center += triangleArea * k_inv3 * (e1 + e2);
---
> 		center += triangleArea * k_inv3 * (p1 + p2 + p3);
383a415
> 		float32 px = p1.x, py = p1.y;
387,388c419,420
< 		float32 intx2 = ex1*ex1 + ex2*ex1 + ex2*ex2;
< 		float32 inty2 = ey1*ey1 + ey2*ey1 + ey2*ey2;
---
> 		float32 intx2 = k_inv3 * (0.25f * (ex1*ex1 + ex2*ex1 + ex2*ex2) + (px*ex1 + px*ex2)) + 0.5f*px*px;
> 		float32 inty2 = k_inv3 * (0.25f * (ey1*ey1 + ey2*ey1 + ey2*ey2) + (py*ey1 + py*ey2)) + 0.5f*py*py;
390c422
< 		I += (0.25f * k_inv3 * D) * (intx2 + inty2);
---
> 		I += D * (intx2 + inty2);
394c426
< 	massData->mass = density * area;
---
> 	massData->mass = m_density * area;
397c429
< 	b2Assert(area > b2_epsilon);
---
> 	b2Assert(area > B2_FLT_EPSILON);
399c431,436
< 	massData->center = center + s;
---
> 	massData->center = center;
> 
> 	// Inertia tensor relative to the local origin.
> 	massData->I = m_density * I;
> }
> 
401,402c438,450
< 	// Inertia tensor relative to the local origin (point s).
< 	massData->I = density * I;
---
> float32 b2PolygonShape::ComputeSubmergedArea(	const b2Vec2& normal,
> 												float32 offset,
> 												const b2XForm& xf, 
> 												b2Vec2* c) const
> {
> 	//Transform plane into shape co-ordinates
> 	b2Vec2 normalL = b2MulT(xf.R,normal);
> 	float32 offsetL = offset - b2Dot(normal,xf.position);
> 	
> 	float32 depths[b2_maxPolygonVertices];
> 	int32 diveCount = 0;
> 	int32 intoIndex = -1;
> 	int32 outoIndex = -1;
404,405c452,544
< 	// Shift to center of mass then to original body origin.
< 	massData->I += massData->mass * (b2Dot(massData->center, massData->center) - b2Dot(center, center));
---
> 	bool lastSubmerged = false;
> 	int32 i;
> 	for(i=0;i<m_vertexCount;i++){
> 		depths[i] = b2Dot(normalL,m_vertices[i]) - offsetL;
> 		bool isSubmerged = depths[i]<-B2_FLT_EPSILON;
> 		if(i>0){
> 			if(isSubmerged){
> 				if(!lastSubmerged){
> 					intoIndex = i-1;
> 					diveCount++;
> 				}
> 			}else{
> 				if(lastSubmerged){
> 					outoIndex = i-1;
> 					diveCount++;
> 				}
> 			}
> 		}
> 		lastSubmerged = isSubmerged;
> 	}
> 	switch(diveCount){
> 		case 0:
> 			if(lastSubmerged){
> 				//Completely submerged
> 				b2MassData md;
> 				ComputeMass(&md);
> 				*c = b2Mul(xf,md.center);
> 				return md.mass/m_density;
> 			}else{
> 				//Completely dry
> 				return 0;
> 			}
> 			break;
> 		case 1:
> 			if(intoIndex==-1){
> 				intoIndex = m_vertexCount-1;
> 			}else{
> 				outoIndex = m_vertexCount-1;
> 			}
> 			break;
> 	}
> 	int32 intoIndex2 = (intoIndex+1)%m_vertexCount;
> 	int32 outoIndex2 = (outoIndex+1)%m_vertexCount;
> 	
> 	float32 intoLambda = (0 - depths[intoIndex]) / (depths[intoIndex2] - depths[intoIndex]);
> 	float32 outoLambda = (0 - depths[outoIndex]) / (depths[outoIndex2] - depths[outoIndex]);
> 	
> 	b2Vec2 intoVec(	m_vertices[intoIndex].x*(1-intoLambda)+m_vertices[intoIndex2].x*intoLambda,
> 					m_vertices[intoIndex].y*(1-intoLambda)+m_vertices[intoIndex2].y*intoLambda);
> 	b2Vec2 outoVec(	m_vertices[outoIndex].x*(1-outoLambda)+m_vertices[outoIndex2].x*outoLambda,
> 					m_vertices[outoIndex].y*(1-outoLambda)+m_vertices[outoIndex2].y*outoLambda);
> 	
> 	//Initialize accumulator
> 	float32 area = 0;
> 	b2Vec2 center(0,0);
> 	b2Vec2 p2 = m_vertices[intoIndex2];
> 	b2Vec2 p3;
> 	
> 	float32 k_inv3 = 1.0f / 3.0f;
> 	
> 	//An awkward loop from intoIndex2+1 to outIndex2
> 	i = intoIndex2;
> 	while(i!=outoIndex2){
> 		i=(i+1)%m_vertexCount;
> 		if(i==outoIndex2)
> 			p3 = outoVec;
> 		else
> 			p3 = m_vertices[i];
> 		//Add the triangle formed by intoVec,p2,p3
> 		{
> 			b2Vec2 e1 = p2 - intoVec;
> 			b2Vec2 e2 = p3 - intoVec;
> 			
> 			float32 D = b2Cross(e1, e2);
> 			
> 			float32 triangleArea = 0.5f * D;
> 
> 			area += triangleArea;
> 			
> 			// Area weighted centroid
> 			center += triangleArea * k_inv3 * (intoVec + p2 + p3);
> 
> 		}
> 		//
> 		p2=p3;
> 	}
> 	
> 	//Normalize and transform centroid
> 	center *= 1.0f/area;
> 	
> 	*c = b2Mul(xf,center);
> 	
> 	return area;
408c547
< bool b2PolygonShape::Validate() const
---
> b2Vec2 b2PolygonShape::Centroid(const b2XForm& xf) const
410,415c549,550
< 	for (int32 i = 0; i < m_count; ++i)
< 	{
< 		int32 i1 = i;
< 		int32 i2 = i < m_count - 1 ? i1 + 1 : 0;
< 		b2Vec2 p = m_vertices[i1];
< 		b2Vec2 e = m_vertices[i2] - p;
---
> 	return b2Mul(xf, m_centroid);
> }
417,422c552,554
< 		for (int32 j = 0; j < m_count; ++j)
< 		{
< 			if (j == i1 || j == i2)
< 			{
< 				continue;
< 			}
---
> b2Vec2 b2PolygonShape::Support(const b2XForm& xf, const b2Vec2& d) const
> {
> 	b2Vec2 dLocal = b2MulT(xf.R, d);
424,429c556,564
< 			b2Vec2 v = m_vertices[j] - p;
< 			float32 c = b2Cross(e, v);
< 			if (c < 0.0f)
< 			{
< 				return false;
< 			}
---
> 	int32 bestIndex = 0;
> 	float32 bestValue = b2Dot(m_coreVertices[0], dLocal);
> 	for (int32 i = 1; i < m_vertexCount; ++i)
> 	{
> 		float32 value = b2Dot(m_coreVertices[i], dLocal);
> 		if (value > bestValue)
> 		{
> 			bestIndex = i;
> 			bestValue = value;
433c568
< 	return true;
---
> 	return b2Mul(xf, m_coreVertices[bestIndex]);
diff -r -x './svn/*' native/Box2D/Collision/Shapes/.svn/text-base/b2PolygonShape.h.svn-base ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Collision/Shapes/.svn/text-base/b2PolygonShape.h.svn-base
2c2
< * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
22c22
< #include <Box2D/Collision/Shapes/b2Shape.h>
---
> #include "b2Shape.h"
24,28c24,26
< /// A convex polygon. It is assumed that the interior of the polygon is to
< /// the left of each edge.
< /// Polygons have a maximum number of vertices equal to b2_maxPolygonVertices.
< /// In most cases you should not need many vertices for a convex polygon.
< class b2PolygonShape : public b2Shape
---
> /// Convex polygon. The vertices must be in CCW order for a right-handed
> /// coordinate system with the z-axis coming out of the screen.
> struct b2PolygonDef : public b2ShapeDef
30,34c28,32
< public:
< 	b2PolygonShape();
< 
< 	/// Implement b2Shape.
< 	b2Shape* Clone(b2BlockAllocator* allocator) const;
---
> 	b2PolygonDef()
> 	{
> 		type = e_polygonShape;
> 		vertexCount = 0;
> 	}
36,46c34
< 	/// @see b2Shape::GetChildCount
< 	int32 GetChildCount() const;
< 
< 	/// Create a convex hull from the given array of local points.
< 	/// The count must be in the range [3, b2_maxPolygonVertices].
< 	/// @warning the points may be re-ordered, even if they form a convex polygon
< 	/// @warning collinear points are handled but not removed. Collinear points
< 	/// may lead to poor stacking behavior.
< 	void Set(const b2Vec2* points, int32 count);
< 
< 	/// Build vertices to represent an axis-aligned box centered on the local origin.
---
> 	/// Build vertices to represent an axis-aligned box.
57a46,57
> 	/// The polygon vertices in local coordinates.
> 	b2Vec2 vertices[b2_maxPolygonVertices];
> 
> 	/// The number of polygon vertices.
> 	int32 vertexCount;
> };
> 
> 
> /// A convex polygon.
> class b2PolygonShape : public b2Shape
> {
> public:
59c59
< 	bool TestPoint(const b2Transform& transform, const b2Vec2& p) const;
---
> 	bool TestPoint(const b2XForm& transform, const b2Vec2& p) const;
61,63c61,66
< 	/// Implement b2Shape.
< 	bool RayCast(b2RayCastOutput* output, const b2RayCastInput& input,
< 					const b2Transform& transform, int32 childIndex) const;
---
> 	/// @see b2Shape::TestSegment
> 	b2SegmentCollide TestSegment(	const b2XForm& transform,
> 		float32* lambda,
> 		b2Vec2* normal,
> 		const b2Segment& segment,
> 		float32 maxLambda) const;
66c69,74
< 	void ComputeAABB(b2AABB* aabb, const b2Transform& transform, int32 childIndex) const;
---
> 	void ComputeAABB(b2AABB* aabb, const b2XForm& transform) const;
> 
> 	/// @see b2Shape::ComputeSweptAABB
> 	void ComputeSweptAABB(	b2AABB* aabb,
> 		const b2XForm& transform1,
> 		const b2XForm& transform2) const;
69c77,89
< 	void ComputeMass(b2MassData* massData, float32 density) const;
---
> 	void ComputeMass(b2MassData* massData) const;
> 
> 	/// @see b2Shape::ComputeSubmergedArea
> 	float32 ComputeSubmergedArea(	const b2Vec2& normal,
> 									float32 offset,
> 									const b2XForm& xf, 
> 									b2Vec2* c) const;
> 
> 	/// Get the oriented bounding box relative to the parent body.
> 	const b2OBB& GetOBB() const;
> 
> 	/// Get local centroid relative to the parent body.
> 	const b2Vec2& GetCentroid() const;
72c92,109
< 	int32 GetVertexCount() const { return m_count; }
---
> 	int32 GetVertexCount() const;
> 
> 	/// Get the vertices in local coordinates.
> 	const b2Vec2* GetVertices() const;
> 
> 	/// Get the core vertices in local coordinates. These vertices
> 	/// represent a smaller polygon that is used for time of impact
> 	/// computations.
> 	const b2Vec2* GetCoreVertices() const;
> 
> 	/// Get the edge normal vectors. There is one for each vertex.
> 	const b2Vec2* GetNormals() const;
> 
> 	/// Get the first vertex and apply the supplied transform.
> 	b2Vec2 GetFirstVertex(const b2XForm& xf) const;
> 
> 	/// Get the centroid and apply the supplied transform.
> 	b2Vec2 Centroid(const b2XForm& xf) const;
74,75c111,113
< 	/// Get a vertex by index.
< 	const b2Vec2& GetVertex(int32 index) const;
---
> 	/// Get the support point in the given world direction.
> 	/// Use the supplied transform.
> 	b2Vec2 Support(const b2XForm& xf, const b2Vec2& d) const;
77,79c115
< 	/// Validate convexity. This is a very time consuming operation.
< 	/// @returns true if valid
< 	bool Validate() const;
---
> private:
80a117,123
> 	friend class b2Shape;
> 
> 	b2PolygonShape(const b2ShapeDef* def);
> 
> 	void UpdateSweepRadius(const b2Vec2& center);
> 
> 	// Local position of the polygon centroid.
81a125,127
> 
> 	b2OBB m_obb;
> 
84c130,131
< 	int32 m_count;
---
> 	b2Vec2 m_coreVertices[b2_maxPolygonVertices];
> 	int32 m_vertexCount;
87c134,159
< inline b2PolygonShape::b2PolygonShape()
---
> inline b2Vec2 b2PolygonShape::GetFirstVertex(const b2XForm& xf) const
> {
> 	return b2Mul(xf, m_coreVertices[0]);
> }
> 
> inline const b2OBB& b2PolygonShape::GetOBB() const
> {
> 	return m_obb;
> }
> 
> inline const b2Vec2& b2PolygonShape::GetCentroid() const
> {
> 	return m_centroid;
> }
> 
> inline int32 b2PolygonShape::GetVertexCount() const
> {
> 	return m_vertexCount;
> }
> 
> inline const b2Vec2* b2PolygonShape::GetVertices() const
> {
> 	return m_vertices;
> }
> 
> inline const b2Vec2* b2PolygonShape::GetCoreVertices() const
89,92c161
< 	m_type = e_polygon;
< 	m_radius = b2_polygonRadius;
< 	m_count = 0;
< 	m_centroid.SetZero();
---
> 	return m_coreVertices;
95c164
< inline const b2Vec2& b2PolygonShape::GetVertex(int32 index) const
---
> inline const b2Vec2* b2PolygonShape::GetNormals() const
97,98c166
< 	b2Assert(0 <= index && index < m_count);
< 	return m_vertices[index];
---
> 	return m_normals;
Only in ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Collision/Shapes/.svn/text-base: b2Shape.cpp.svn-base
diff -r -x './svn/*' native/Box2D/Collision/Shapes/.svn/text-base/b2Shape.h.svn-base ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Collision/Shapes/.svn/text-base/b2Shape.h.svn-base
2c2
< * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
22,24c22,27
< #include <Box2D/Common/b2BlockAllocator.h>
< #include <Box2D/Common/b2Math.h>
< #include <Box2D/Collision/b2Collision.h>
---
> #include "../../Common/b2Math.h"
> #include "../b2Collision.h"
> 
> class b2BlockAllocator;
> class b2Body;
> class b2BroadPhase;
35c38
< 	/// The rotational inertia of the shape about the local origin.
---
> 	/// The rotational inertia of the shape.
39,42c42,43
< /// A shape is used for collision detection. You can create a shape however you like.
< /// Shapes used for simulation in b2World are created automatically when a b2Fixture
< /// is created. Shapes may encapsulate a one or more child shapes.
< class b2Shape
---
> /// This holds contact filtering data.
> struct b2FilterData
44,53c45,56
< public:
< 	
< 	enum Type
< 	{
< 		e_circle = 0,
< 		e_edge = 1,
< 		e_polygon = 2,
< 		e_chain = 3,
< 		e_typeCount = 4
< 	};
---
> 	/// The collision category bits. Normally you would just set one bit.
> 	uint16 categoryBits;
> 
> 	/// The collision mask bits. This states the categories that this
> 	/// shape would accept for collision.
> 	uint16 maskBits;
> 
> 	/// Collision groups allow a certain group of objects to never collide (negative)
> 	/// or always collide (positive). Zero means no collision group. Non-zero group
> 	/// filtering always wins against the mask bits.
> 	int16 groupIndex;
> };
55c58,66
< 	virtual ~b2Shape() {}
---
> /// The various collision shape types supported by Box2D.
> enum b2ShapeType
> {
> 	e_unknownShape = -1,
> 	e_circleShape,
> 	e_polygonShape,
> 	e_edgeShape,
> 	e_shapeTypeCount,
> };
57,58c68,74
< 	/// Clone the concrete shape using the provided allocator.
< 	virtual b2Shape* Clone(b2BlockAllocator* allocator) const = 0;
---
> /// Return codes from TestSegment
> enum b2SegmentCollide
> {
> 	e_startsInsideCollide = -1,
> 	e_missCollide = 0,
> 	e_hitCollide = 1
> };
59a76,124
> /// A shape definition is used to construct a shape. This class defines an
> /// abstract shape definition. You can reuse shape definitions safely.
> struct b2ShapeDef
> {
> 	/// The constructor sets the default shape definition values.
> 	b2ShapeDef()
> 	{
> 		type = e_unknownShape;
> 		userData = NULL;
> 		friction = 0.2f;
> 		restitution = 0.0f;
> 		density = 0.0f;
> 		filter.categoryBits = 0x0001;
> 		filter.maskBits = 0xFFFF;
> 		filter.groupIndex = 0;
> 		isSensor = false;
> 	}
> 
> 	virtual ~b2ShapeDef() {}
> 
> 	/// Holds the shape type for down-casting.
> 	b2ShapeType type;
> 
> 	/// Use this to store application specify shape data.
> 	void* userData;
> 
> 	/// The shape's friction coefficient, usually in the range [0,1].
> 	float32 friction;
> 
> 	/// The shape's restitution (elasticity) usually in the range [0,1].
> 	float32 restitution;
> 
> 	/// The shape's density, usually in kg/m^2.
> 	float32 density;
> 
> 	/// A sensor shape collects contact information but never generates a collision
> 	/// response.
> 	bool isSensor;
> 
> 	/// Contact filtering data.
> 	b2FilterData filter;
> };
> 
> /// A shape is used for collision detection. Shapes are created in b2World.
> /// You can use shape for collision detection before they are attached to the world.
> /// @warning you cannot reuse shapes.
> class b2Shape
> {
> public:
62c127,146
< 	Type GetType() const;
---
> 	b2ShapeType GetType() const;
> 
> 	/// Is this shape a sensor (non-solid)?
> 	/// @return the true if the shape is a sensor.
> 	bool IsSensor() const;
> 
> 	/// Set the contact filtering data. You must call b2World::Refilter to correct
> 	/// existing contacts/non-contacts.
> 	void SetFilterData(const b2FilterData& filter);
> 
> 	/// Get the contact filtering data.
> 	const b2FilterData& GetFilterData() const;
> 
> 	/// Get the parent body of this shape. This is NULL if the shape is not attached.
> 	/// @return the parent body.
> 	b2Body* GetBody();
> 
> 	/// Get the next shape in the parent body's shape list.
> 	/// @return the next shape.
> 	b2Shape* GetNext();
64,65c148,153
< 	/// Get the number of child primitives.
< 	virtual int32 GetChildCount() const = 0;
---
> 	/// Get the user data that was assigned in the shape definition. Use this to
> 	/// store your application specific data.
> 	void* GetUserData();
> 
> 	/// Set the user data. Use this to store your application specific data.
> 	void SetUserData(void* data);
70c158
< 	virtual bool TestPoint(const b2Transform& xf, const b2Vec2& p) const = 0;
---
> 	virtual bool TestPoint(const b2XForm& xf, const b2Vec2& p) const = 0;
72,78c160,172
< 	/// Cast a ray against a child shape.
< 	/// @param output the ray-cast results.
< 	/// @param input the ray-cast input parameters.
< 	/// @param transform the transform to be applied to the shape.
< 	/// @param childIndex the child shape index
< 	virtual bool RayCast(b2RayCastOutput* output, const b2RayCastInput& input,
< 						const b2Transform& transform, int32 childIndex) const = 0;
---
> 	/// Perform a ray cast against this shape.
> 	/// @param xf the shape world transform.
> 	/// @param lambda returns the hit fraction. You can use this to compute the contact point
> 	/// p = (1 - lambda) * segment.p1 + lambda * segment.p2.
> 	/// @param normal returns the normal at the contact point. If there is no intersection, the normal
> 	/// is not set.
> 	/// @param segment defines the begin and end point of the ray cast.
> 	/// @param maxLambda a number typically in the range [0,1].
> 	virtual b2SegmentCollide TestSegment(	const b2XForm& xf,
> 											float32* lambda,
> 											b2Vec2* normal,
> 											const b2Segment& segment,
> 											float32 maxLambda) const = 0;
80c174
< 	/// Given a transform, compute the associated axis aligned bounding box for a child shape.
---
> 	/// Given a transform, compute the associated axis aligned bounding box for this shape.
83,84c177,185
< 	/// @param childIndex the child shape
< 	virtual void ComputeAABB(b2AABB* aabb, const b2Transform& xf, int32 childIndex) const = 0;
---
> 	virtual void ComputeAABB(b2AABB* aabb, const b2XForm& xf) const = 0;
> 
> 	/// Given two transforms, compute the associated swept axis aligned bounding box for this shape.
> 	/// @param aabb returns the axis aligned box.
> 	/// @param xf1 the starting shape world transform.
> 	/// @param xf2 the ending shape world transform.
> 	virtual void ComputeSweptAABB(	b2AABB* aabb,
> 									const b2XForm& xf1,
> 									const b2XForm& xf2) const = 0;
87c188
< 	/// The inertia tensor is computed about the local origin.
---
> 	/// The inertia tensor is computed about the local origin, not the centroid.
89,90c190,254
< 	/// @param density the density in kilograms per meter squared.
< 	virtual void ComputeMass(b2MassData* massData, float32 density) const = 0;
---
> 	virtual void ComputeMass(b2MassData* massData) const = 0;
> 
> 	/// Compute the volume and centroid of this shape intersected with a half plane
> 	/// @param normal the surface normal
> 	/// @param offset the surface offset along normal
> 	/// @param xf the shape transform
> 	/// @param c returns the centroid
> 	/// @return the total volume less than offset along normal
> 	virtual float32 ComputeSubmergedArea(	const b2Vec2& normal,
> 											float32 offset,
> 											const b2XForm& xf, 
> 											b2Vec2* c) const = 0;
> 
> 	/// Get the maximum radius about the parent body's center of mass.
> 	float32 GetSweepRadius() const;
> 
> 	/// Get the coefficient of friction.
> 	float32 GetFriction() const;
> 
> 	/// Set the coefficient of friction.
> 	void SetFriction(float32 friction);
> 
> 	/// Get the coefficient of restitution.
> 	float32 GetRestitution() const;
> 
> 	/// Set the coefficient of restitution.
> 	void SetRestitution(float32 restitution);
> 
> 	/// Get the density of the shape.
> 	float32 GetDensity() const;
> 
> 	/// Set the density of the shape.
> 	void SetDensity(float32 density);
> 
> protected:
> 
> 	friend class b2Body;
> 	friend class b2World;
> 
> 	static b2Shape* Create(const b2ShapeDef* def, b2BlockAllocator* allocator);
> 	static void Destroy(b2Shape* shape, b2BlockAllocator* allocator);
> 
> 	b2Shape(const b2ShapeDef* def);
> 	virtual ~b2Shape();
> 
> 	void CreateProxy(b2BroadPhase* broadPhase, const b2XForm& xf);
> 	void DestroyProxy(b2BroadPhase* broadPhase);
> 	bool Synchronize(b2BroadPhase* broadPhase, const b2XForm& xf1, const b2XForm& xf2);
> 	void RefilterProxy(b2BroadPhase* broadPhase, const b2XForm& xf);
> 
> 	virtual void UpdateSweepRadius(const b2Vec2& center) = 0;
> 
> 	b2ShapeType m_type;
> 	b2Shape* m_next;
> 	b2Body* m_body;
> 
> 	// Sweep radius relative to the parent body's center of mass.
> 	float32 m_sweepRadius;
> 
> 	float32 m_density;
> 	float32 m_friction;
> 	float32 m_restitution;
> 
> 	uint16 m_proxyId;
> 	b2FilterData m_filter;
92,93c256,258
< 	Type m_type;
< 	float32 m_radius;
---
> 	bool m_isSensor;
> 
> 	void* m_userData;
96c261
< inline b2Shape::Type b2Shape::GetType() const
---
> inline b2ShapeType b2Shape::GetType() const
100a266,336
> inline bool b2Shape::IsSensor() const
> {
> 	return m_isSensor;
> }
> 
> inline void b2Shape::SetFilterData(const b2FilterData& filter)
> {
> 	m_filter = filter;
> }
> 
> inline const b2FilterData& b2Shape::GetFilterData() const
> {
> 	return m_filter;
> }
> 
> inline void* b2Shape::GetUserData()
> {
> 	return m_userData;
> }
> 
> inline void b2Shape::SetUserData(void* data)
> {
> 	m_userData = data;
> }
> 
> inline b2Body* b2Shape::GetBody()
> {
> 	return m_body;
> }
> 
> inline b2Shape* b2Shape::GetNext()
> {
> 	return m_next;
> }
> 
> inline float32 b2Shape::GetSweepRadius() const
> {
> 	return m_sweepRadius;
> }
> 
> inline float32 b2Shape::GetFriction() const
> {
> 	return m_friction;
> }
> 
> inline void b2Shape::SetFriction(float32 friction)
> {
> 	m_friction = friction;
> }
> 
> inline float32 b2Shape::GetRestitution() const
> {
> 	return m_restitution;
> }
> 
> inline void b2Shape::SetRestitution(float32 restitution)
> {
> 	m_restitution = restitution;
> }
> 
> 
> inline float32 b2Shape::GetDensity() const
> {
> 	return m_density;
> }
> 
> inline void b2Shape::SetDensity(float32 density)
> {
> 	m_density = density;
> }
> 
Only in native/Box2D/Collision/Shapes: b2ChainShape.cpp
Only in native/Box2D/Collision/Shapes: b2ChainShape.h
diff -r -x './svn/*' native/Box2D/Collision/Shapes/b2CircleShape.cpp ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Collision/Shapes/b2CircleShape.cpp
2c2
< * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
19,21c19
< #include <Box2D/Collision/Shapes/b2CircleShape.h>
< #include <new>
< using namespace std;
---
> #include "b2CircleShape.h"
23c21,22
< b2Shape* b2CircleShape::Clone(b2BlockAllocator* allocator) const
---
> b2CircleShape::b2CircleShape(const b2ShapeDef* def)
> : b2Shape(def)
25,28c24,29
< 	void* mem = allocator->Allocate(sizeof(b2CircleShape));
< 	b2CircleShape* clone = new (mem) b2CircleShape;
< 	*clone = *this;
< 	return clone;
---
> 	b2Assert(def->type == e_circleShape);
> 	const b2CircleDef* circleDef = (const b2CircleDef*)def;
> 
> 	m_type = e_circleShape;
> 	m_localPosition = circleDef->localPosition;
> 	m_radius = circleDef->radius;
31c32
< int32 b2CircleShape::GetChildCount() const
---
> void b2CircleShape::UpdateSweepRadius(const b2Vec2& center)
33c34,37
< 	return 1;
---
> 	// Update the sweep radius (maximum radius) as measured from
> 	// a local center point.
> 	b2Vec2 d = m_localPosition - center;
> 	m_sweepRadius = d.Length() + m_radius - b2_toiSlop;
36c40
< bool b2CircleShape::TestPoint(const b2Transform& transform, const b2Vec2& p) const
---
> bool b2CircleShape::TestPoint(const b2XForm& transform, const b2Vec2& p) const
38c42
< 	b2Vec2 center = transform.p + b2Mul(transform.q, m_p);
---
> 	b2Vec2 center = transform.position + b2Mul(transform.R, m_localPosition);
47,48c51,55
< bool b2CircleShape::RayCast(b2RayCastOutput* output, const b2RayCastInput& input,
< 							const b2Transform& transform, int32 childIndex) const
---
> b2SegmentCollide b2CircleShape::TestSegment(const b2XForm& transform,
> 								float32* lambda,
> 								b2Vec2* normal,
> 								const b2Segment& segment,
> 								float32 maxLambda) const
50,53c57,58
< 	B2_NOT_USED(childIndex);
< 
< 	b2Vec2 position = transform.p + b2Mul(transform.q, m_p);
< 	b2Vec2 s = input.p1 - position;
---
> 	b2Vec2 position = transform.position + b2Mul(transform.R, m_localPosition);
> 	b2Vec2 s = segment.p1 - position;
55a61,67
> 	// Does the segment start inside the circle?
> 	if (b < 0.0f)
> 	{
> 		*lambda = 0;
> 		return e_startsInsideCollide;
> 	}
> 
57c69
< 	b2Vec2 r = input.p2 - input.p1;
---
> 	b2Vec2 r = segment.p2 - segment.p1;
63c75
< 	if (sigma < 0.0f || rr < b2_epsilon)
---
> 	if (sigma < 0.0f || rr < B2_FLT_EPSILON)
65c77
< 		return false;
---
> 		return e_missCollide;
72c84
< 	if (0.0f <= a && a <= input.maxFraction * rr)
---
> 	if (0.0f <= a && a <= maxLambda * rr)
75,78c87,90
< 		output->fraction = a;
< 		output->normal = s + a * r;
< 		output->normal.Normalize();
< 		return true;
---
> 		*lambda = a;
> 		*normal = s + a * r;
> 		normal->Normalize();
> 		return e_hitCollide;
81c93
< 	return false;
---
> 	return e_missCollide;
84c96
< void b2CircleShape::ComputeAABB(b2AABB* aabb, const b2Transform& transform, int32 childIndex) const
---
> void b2CircleShape::ComputeAABB(b2AABB* aabb, const b2XForm& transform) const
86,88c98
< 	B2_NOT_USED(childIndex);
< 
< 	b2Vec2 p = transform.p + b2Mul(transform.q, m_p);
---
> 	b2Vec2 p = transform.position + b2Mul(transform.R, m_localPosition);
93c103,114
< void b2CircleShape::ComputeMass(b2MassData* massData, float32 density) const
---
> void b2CircleShape::ComputeSweptAABB(b2AABB* aabb, const b2XForm& transform1, const b2XForm& transform2) const
> {
> 	b2Vec2 p1 = transform1.position + b2Mul(transform1.R, m_localPosition);
> 	b2Vec2 p2 = transform2.position + b2Mul(transform2.R, m_localPosition);
> 	b2Vec2 lower = b2Min(p1, p2);
> 	b2Vec2 upper = b2Max(p1, p2);
> 
> 	aabb->lowerBound.Set(lower.x - m_radius, lower.y - m_radius);
> 	aabb->upperBound.Set(upper.x + m_radius, upper.y + m_radius);
> }
> 
> void b2CircleShape::ComputeMass(b2MassData* massData) const
95,96c116,117
< 	massData->mass = density * b2_pi * m_radius * m_radius;
< 	massData->center = m_p;
---
> 	massData->mass = m_density * b2_pi * m_radius * m_radius;
> 	massData->center = m_localPosition;
99c120,150
< 	massData->I = massData->mass * (0.5f * m_radius * m_radius + b2Dot(m_p, m_p));
---
> 	massData->I = massData->mass * (0.5f * m_radius * m_radius + b2Dot(m_localPosition, m_localPosition));
> }
> 
> float32 b2CircleShape::ComputeSubmergedArea(	const b2Vec2& normal,
> 												float32 offset,
> 												const b2XForm& xf, 
> 												b2Vec2* c) const
> {
> 	b2Vec2 p = b2Mul(xf,m_localPosition);
> 	float32 l = -(b2Dot(normal,p) - offset);
> 	if(l<-m_radius+B2_FLT_EPSILON){
> 		//Completely dry
> 		return 0;
> 	}
> 	if(l>m_radius){
> 		//Completely wet
> 		*c = p;
> 		return b2_pi*m_radius*m_radius;
> 	}
> 	
> 	//Magic
> 	float32 r2 = m_radius*m_radius;
> 	float32 l2 = l*l;
>     //TODO: write b2Sqrt to handle fixed point case.
> 	float32 area = r2 * (asin(l/m_radius) + b2_pi/2.0f)+ l * b2Sqrt(r2 - l2);
> 	float32 com = -2.0f/3.0f*pow(r2-l2,1.5f)/area;
> 	
> 	c->x = p.x + normal.x * com;
> 	c->y = p.y + normal.y * com;
> 	
> 	return area;
diff -r -x './svn/*' native/Box2D/Collision/Shapes/b2CircleShape.h ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Collision/Shapes/b2CircleShape.h
2c2
< * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
22c22,36
< #include <Box2D/Collision/Shapes/b2Shape.h>
---
> #include "b2Shape.h"
> 
> /// This structure is used to build circle shapes.
> struct b2CircleDef : public b2ShapeDef
> {
> 	b2CircleDef()
> 	{
> 		type = e_circleShape;
> 		localPosition.SetZero();
> 		radius = 1.0f;
> 	}
> 
> 	b2Vec2 localPosition;
> 	float32 radius;
> };
28c42,43
< 	b2CircleShape();
---
> 	/// @see b2Shape::TestPoint
> 	bool TestPoint(const b2XForm& transform, const b2Vec2& p) const;
30,41c45,50
< 	/// Implement b2Shape.
< 	b2Shape* Clone(b2BlockAllocator* allocator) const;
< 
< 	/// @see b2Shape::GetChildCount
< 	int32 GetChildCount() const;
< 
< 	/// Implement b2Shape.
< 	bool TestPoint(const b2Transform& transform, const b2Vec2& p) const;
< 
< 	/// Implement b2Shape.
< 	bool RayCast(b2RayCastOutput* output, const b2RayCastInput& input,
< 				const b2Transform& transform, int32 childIndex) const;
---
> 	/// @see b2Shape::TestSegment
> 	b2SegmentCollide TestSegment(	const b2XForm& transform,
> 						float32* lambda,
> 						b2Vec2* normal,
> 						const b2Segment& segment,
> 						float32 maxLambda) const;
44c53,58
< 	void ComputeAABB(b2AABB* aabb, const b2Transform& transform, int32 childIndex) const;
---
> 	void ComputeAABB(b2AABB* aabb, const b2XForm& transform) const;
> 
> 	/// @see b2Shape::ComputeSweptAABB
> 	void ComputeSweptAABB(	b2AABB* aabb,
> 							const b2XForm& transform1,
> 							const b2XForm& transform2) const;
47c61
< 	void ComputeMass(b2MassData* massData, float32 density) const;
---
> 	void ComputeMass(b2MassData* massData) const;
49,50c63,67
< 	/// Get the supporting vertex index in the given direction.
< 	int32 GetSupport(const b2Vec2& d) const;
---
> 	/// @see b2Shape::ComputeSubmergedArea
> 	float32 ComputeSubmergedArea(	const b2Vec2& normal,
> 									float32 offset,
> 									const b2XForm& xf, 
> 									b2Vec2* c) const;
52,53c69,70
< 	/// Get the supporting vertex in the given direction.
< 	const b2Vec2& GetSupportVertex(const b2Vec2& d) const;
---
> 	/// Get the local position of this circle in its parent body.
> 	const b2Vec2& GetLocalPosition() const;
55,56c72,73
< 	/// Get the vertex count.
< 	int32 GetVertexCount() const { return 1; }
---
> 	/// Get the radius of this circle.
> 	float32 GetRadius() const;
58,59c75
< 	/// Get a vertex by index. Used by b2Distance.
< 	const b2Vec2& GetVertex(int32 index) const;
---
> private:
61,63c77
< 	/// Position
< 	b2Vec2 m_p;
< };
---
> 	friend class b2Shape;
65,70c79
< inline b2CircleShape::b2CircleShape()
< {
< 	m_type = e_circle;
< 	m_radius = 0.0f;
< 	m_p.SetZero();
< }
---
> 	b2CircleShape(const b2ShapeDef* def);
72,76c81,86
< inline int32 b2CircleShape::GetSupport(const b2Vec2 &d) const
< {
< 	B2_NOT_USED(d);
< 	return 0;
< }
---
> 	void UpdateSweepRadius(const b2Vec2& center);
> 
> 	// Local position in parent body
> 	b2Vec2 m_localPosition;
> 	float32 m_radius;
> };
78c88
< inline const b2Vec2& b2CircleShape::GetSupportVertex(const b2Vec2 &d) const
---
> inline const b2Vec2& b2CircleShape::GetLocalPosition() const
80,81c90
< 	B2_NOT_USED(d);
< 	return m_p;
---
> 	return m_localPosition;
84c93
< inline const b2Vec2& b2CircleShape::GetVertex(int32 index) const
---
> inline float32 b2CircleShape::GetRadius() const
86,88c95
< 	B2_NOT_USED(index);
< 	b2Assert(index == 0);
< 	return m_p;
---
> 	return m_radius;
diff -r -x './svn/*' native/Box2D/Collision/Shapes/b2EdgeShape.cpp ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Collision/Shapes/b2EdgeShape.cpp
1,108c1,178
< /*
< * Copyright (c) 2006-2010 Erin Catto http://www.box2d.org
< *
< * This software is provided 'as-is', without any express or implied
< * warranty.  In no event will the authors be held liable for any damages
< * arising from the use of this software.
< * Permission is granted to anyone to use this software for any purpose,
< * including commercial applications, and to alter it and redistribute it
< * freely, subject to the following restrictions:
< * 1. The origin of this software must not be misrepresented; you must not
< * claim that you wrote the original software. If you use this software
< * in a product, an acknowledgment in the product documentation would be
< * appreciated but is not required.
< * 2. Altered source versions must be plainly marked as such, and must not be
< * misrepresented as being the original software.
< * 3. This notice may not be removed or altered from any source distribution.
< */
< 
< #include <Box2D/Collision/Shapes/b2EdgeShape.h>
< #include <new>
< using namespace std;
< 
< void b2EdgeShape::Set(const b2Vec2& v1, const b2Vec2& v2)
< {
< 	m_vertex1 = v1;
< 	m_vertex2 = v2;
< 	m_hasVertex0 = false;
< 	m_hasVertex3 = false;
< }
< 
< b2Shape* b2EdgeShape::Clone(b2BlockAllocator* allocator) const
< {
< 	void* mem = allocator->Allocate(sizeof(b2EdgeShape));
< 	b2EdgeShape* clone = new (mem) b2EdgeShape;
< 	*clone = *this;
< 	return clone;
< }
< 
< int32 b2EdgeShape::GetChildCount() const
< {
< 	return 1;
< }
< 
< bool b2EdgeShape::TestPoint(const b2Transform& xf, const b2Vec2& p) const
< {
< 	B2_NOT_USED(xf);
< 	B2_NOT_USED(p);
< 	return false;
< }
< 
< // p = p1 + t * d
< // v = v1 + s * e
< // p1 + t * d = v1 + s * e
< // s * e - t * d = p1 - v1
< bool b2EdgeShape::RayCast(b2RayCastOutput* output, const b2RayCastInput& input,
< 							const b2Transform& xf, int32 childIndex) const
< {
< 	B2_NOT_USED(childIndex);
< 
< 	// Put the ray into the edge's frame of reference.
< 	b2Vec2 p1 = b2MulT(xf.q, input.p1 - xf.p);
< 	b2Vec2 p2 = b2MulT(xf.q, input.p2 - xf.p);
< 	b2Vec2 d = p2 - p1;
< 
< 	b2Vec2 v1 = m_vertex1;
< 	b2Vec2 v2 = m_vertex2;
< 	b2Vec2 e = v2 - v1;
< 	b2Vec2 normal(e.y, -e.x);
< 	normal.Normalize();
< 
< 	// q = p1 + t * d
< 	// dot(normal, q - v1) = 0
< 	// dot(normal, p1 - v1) + t * dot(normal, d) = 0
< 	float32 numerator = b2Dot(normal, v1 - p1);
< 	float32 denominator = b2Dot(normal, d);
< 
< 	if (denominator == 0.0f)
< 	{
< 		return false;
< 	}
< 
< 	float32 t = numerator / denominator;
< 	if (t < 0.0f || input.maxFraction < t)
< 	{
< 		return false;
< 	}
< 
< 	b2Vec2 q = p1 + t * d;
< 
< 	// q = v1 + s * r
< 	// s = dot(q - v1, r) / dot(r, r)
< 	b2Vec2 r = v2 - v1;
< 	float32 rr = b2Dot(r, r);
< 	if (rr == 0.0f)
< 	{
< 		return false;
< 	}
< 
< 	float32 s = b2Dot(q - v1, r) / rr;
< 	if (s < 0.0f || 1.0f < s)
< 	{
< 		return false;
< 	}
< 
< 	output->fraction = t;
< 	if (numerator > 0.0f)
< 	{
< 		output->normal = -normal;
---
> /*
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
> *
> * This software is provided 'as-is', without any express or implied
> * warranty.  In no event will the authors be held liable for any damages
> * arising from the use of this software.
> * Permission is granted to anyone to use this software for any purpose,
> * including commercial applications, and to alter it and redistribute it
> * freely, subject to the following restrictions:
> * 1. The origin of this software must not be misrepresented; you must not
> * claim that you wrote the original software. If you use this software
> * in a product, an acknowledgment in the product documentation would be
> * appreciated but is not required.
> * 2. Altered source versions must be plainly marked as such, and must not be
> * misrepresented as being the original software.
> * 3. This notice may not be removed or altered from any source distribution.
> */
> 
> #include "b2EdgeShape.h"
> 
> b2EdgeShape::b2EdgeShape(const b2Vec2& v1, const b2Vec2& v2, const b2ShapeDef* def)
> : b2Shape(def)
> {
> 	b2Assert(def->type == e_edgeShape);
> 
> 	m_type = e_edgeShape;
> 	
> 	m_prevEdge = NULL;
> 	m_nextEdge = NULL;
> 	
> 	m_v1 = v1;
> 	m_v2 = v2;
> 	
> 	m_direction = m_v2 - m_v1;
> 	m_length = m_direction.Normalize();
> 	m_normal.Set(m_direction.y, -m_direction.x);
> 	
> 	m_coreV1 = -b2_toiSlop * (m_normal - m_direction) + m_v1;
> 	m_coreV2 = -b2_toiSlop * (m_normal + m_direction) + m_v2;
> 	
> 	m_cornerDir1 = m_normal;
> 	m_cornerDir2 = -1.0f * m_normal;
> }
> 
> void b2EdgeShape::UpdateSweepRadius(const b2Vec2& center)
> {
> 	// Update the sweep radius (maximum radius) as measured from
> 	// a local center point.
> 	b2Vec2 d = m_coreV1 - center;
> 	float32 d1 = b2Dot(d,d);
> 	d = m_coreV2 - center;
> 	float32 d2 = b2Dot(d,d);
> 	m_sweepRadius = b2Sqrt(d1 > d2 ? d1 : d2);
> }
> 
> bool b2EdgeShape::TestPoint(const b2XForm& transform, const b2Vec2& p) const
> {
> 	B2_NOT_USED(transform);
> 	B2_NOT_USED(p);
> 	return false;
> }
> 
> b2SegmentCollide b2EdgeShape::TestSegment(const b2XForm& transform,
> 								float32* lambda,
> 								b2Vec2* normal,
> 								const b2Segment& segment,
> 								float32 maxLambda) const
> {
> 	b2Vec2 r = segment.p2 - segment.p1;
> 	b2Vec2 v1 = b2Mul(transform, m_v1);
> 	b2Vec2 d = b2Mul(transform, m_v2) - v1;
> 	b2Vec2 n = b2Cross(d, 1.0f);
> 
> 	const float32 k_slop = 100.0f * B2_FLT_EPSILON;
> 	float32 denom = -b2Dot(r, n);
> 
> 	// Cull back facing collision and ignore parallel segments.
> 	if (denom > k_slop)
> 	{
> 		// Does the segment intersect the infinite line associated with this segment?
> 		b2Vec2 b = segment.p1 - v1;
> 		float32 a = b2Dot(b, n);
> 
> 		if (0.0f <= a && a <= maxLambda * denom)
> 		{
> 			float32 mu2 = -r.x * b.y + r.y * b.x;
> 
> 			// Does the segment intersect this segment?
> 			if (-k_slop * denom <= mu2 && mu2 <= denom * (1.0f + k_slop))
> 			{
> 				a /= denom;
> 				n.Normalize();
> 				*lambda = a;
> 				*normal = n;
> 				return e_hitCollide;
> 			}
> 		}
> 	}
> 
> 	return e_missCollide;
> }
> 
> void b2EdgeShape::ComputeAABB(b2AABB* aabb, const b2XForm& transform) const
> {
> 	b2Vec2 v1 = b2Mul(transform, m_v1);
> 	b2Vec2 v2 = b2Mul(transform, m_v2);
> 	aabb->lowerBound = b2Min(v1, v2);
> 	aabb->upperBound = b2Max(v1, v2);
> }
> 
> void b2EdgeShape::ComputeSweptAABB(b2AABB* aabb, const b2XForm& transform1, const b2XForm& transform2) const
> {
> 	b2Vec2 v1 = b2Mul(transform1, m_v1);
> 	b2Vec2 v2 = b2Mul(transform1, m_v2);
> 	b2Vec2 v3 = b2Mul(transform2, m_v1);
> 	b2Vec2 v4 = b2Mul(transform2, m_v2);
> 	aabb->lowerBound = b2Min(b2Min(b2Min(v1, v2), v3), v4);
> 	aabb->upperBound = b2Max(b2Max(b2Max(v1, v2), v3), v4);
> }
> 
> void b2EdgeShape::ComputeMass(b2MassData* massData) const
> {
> 	massData->mass = 0;
> 	massData->center = m_v1;
> 
> 	// inertia about the local origin
> 	massData->I = 0;
> }
> 
> b2Vec2 b2EdgeShape::Support(const b2XForm& xf, const b2Vec2& d) const
> {
> 	b2Vec2 v1 = b2Mul(xf, m_coreV1);
> 	b2Vec2 v2 = b2Mul(xf, m_coreV2);
> 	return b2Dot(v1, d) > b2Dot(v2, d) ? v1 : v2;
> }
> 
> void b2EdgeShape::SetPrevEdge(b2EdgeShape* edge, const b2Vec2& core, const b2Vec2& cornerDir, bool convex)
> {
> 	m_prevEdge = edge;
> 	m_coreV1 = core;
> 	m_cornerDir1 = cornerDir;
> 	m_cornerConvex1 = convex;
> }
> 
> void b2EdgeShape::SetNextEdge(b2EdgeShape* edge, const b2Vec2& core, const b2Vec2& cornerDir, bool convex)
> {
> 	m_nextEdge = edge;
> 	m_coreV2 = core;
> 	m_cornerDir2 = cornerDir;
> 	m_cornerConvex2 = convex;
> }
> 
> float32 b2EdgeShape::ComputeSubmergedArea(	const b2Vec2& normal,
> 												float32 offset,
> 												const b2XForm& xf, 
> 												b2Vec2* c) const
> {
> 	//Note that v0 is independant of any details of the specific edge
> 	//We are relying on v0 being consistent between multiple edges of the same body
> 	b2Vec2 v0 = offset * normal;
> 	//b2Vec2 v0 = xf.position + (offset - b2Dot(normal, xf.position)) * normal;
> 
> 	b2Vec2 v1 = b2Mul(xf, m_v1);
> 	b2Vec2 v2 = b2Mul(xf, m_v2);
> 
> 	float32 d1 = b2Dot(normal, v1) - offset;
> 	float32 d2 = b2Dot(normal, v2) - offset;
> 
> 	if(d1>0)
> 	{
> 		if(d2>0)
> 		{
> 			return 0;
> 		}
> 		else
> 		{
> 			v1 = -d2 / (d1 - d2) * v1 + d1 / (d1 - d2) * v2;
> 		}
112,139c182,203
< 		output->normal = normal;
< 	}
< 	return true;
< }
< 
< void b2EdgeShape::ComputeAABB(b2AABB* aabb, const b2Transform& xf, int32 childIndex) const
< {
< 	B2_NOT_USED(childIndex);
< 
< 	b2Vec2 v1 = b2Mul(xf, m_vertex1);
< 	b2Vec2 v2 = b2Mul(xf, m_vertex2);
< 
< 	b2Vec2 lower = b2Min(v1, v2);
< 	b2Vec2 upper = b2Max(v1, v2);
< 
< 	b2Vec2 r(m_radius, m_radius);
< 	aabb->lowerBound = lower - r;
< 	aabb->upperBound = upper + r;
< }
< 
< void b2EdgeShape::ComputeMass(b2MassData* massData, float32 density) const
< {
< 	B2_NOT_USED(density);
< 
< 	massData->mass = 0.0f;
< 	massData->center = 0.5f * (m_vertex1 + m_vertex2);
< 	massData->I = 0.0f;
< }
---
> 		if(d2>0)
> 		{
> 			v2 = -d2 / (d1 - d2) * v1 + d1 / (d1 - d2) * v2;
> 		}
> 		else
> 		{
> 			//Nothing
> 		}
> 	}
> 
> 	// v0,v1,v2 represents a fully submerged triangle
> 	float32 k_inv3 = 1.0f / 3.0f;
> 
> 	// Area weighted centroid
> 	*c = k_inv3 * (v0 + v1 + v2);
> 
> 	b2Vec2 e1 = v1 - v0;
> 	b2Vec2 e2 = v2 - v0;
> 
> 	return 0.5f * b2Cross(e1, e2);
> }
> 
diff -r -x './svn/*' native/Box2D/Collision/Shapes/b2EdgeShape.h ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Collision/Shapes/b2EdgeShape.h
1,74c1,222
< /*
< * Copyright (c) 2006-2010 Erin Catto http://www.box2d.org
< *
< * This software is provided 'as-is', without any express or implied
< * warranty.  In no event will the authors be held liable for any damages
< * arising from the use of this software.
< * Permission is granted to anyone to use this software for any purpose,
< * including commercial applications, and to alter it and redistribute it
< * freely, subject to the following restrictions:
< * 1. The origin of this software must not be misrepresented; you must not
< * claim that you wrote the original software. If you use this software
< * in a product, an acknowledgment in the product documentation would be
< * appreciated but is not required.
< * 2. Altered source versions must be plainly marked as such, and must not be
< * misrepresented as being the original software.
< * 3. This notice may not be removed or altered from any source distribution.
< */
< 
< #ifndef B2_EDGE_SHAPE_H
< #define B2_EDGE_SHAPE_H
< 
< #include <Box2D/Collision/Shapes/b2Shape.h>
< 
< /// A line segment (edge) shape. These can be connected in chains or loops
< /// to other edge shapes. The connectivity information is used to ensure
< /// correct contact normals.
< class b2EdgeShape : public b2Shape
< {
< public:
< 	b2EdgeShape();
< 
< 	/// Set this as an isolated edge.
< 	void Set(const b2Vec2& v1, const b2Vec2& v2);
< 
< 	/// Implement b2Shape.
< 	b2Shape* Clone(b2BlockAllocator* allocator) const;
< 
< 	/// @see b2Shape::GetChildCount
< 	int32 GetChildCount() const;
< 
< 	/// @see b2Shape::TestPoint
< 	bool TestPoint(const b2Transform& transform, const b2Vec2& p) const;
< 
< 	/// Implement b2Shape.
< 	bool RayCast(b2RayCastOutput* output, const b2RayCastInput& input,
< 				const b2Transform& transform, int32 childIndex) const;
< 
< 	/// @see b2Shape::ComputeAABB
< 	void ComputeAABB(b2AABB* aabb, const b2Transform& transform, int32 childIndex) const;
< 
< 	/// @see b2Shape::ComputeMass
< 	void ComputeMass(b2MassData* massData, float32 density) const;
< 	
< 	/// These are the edge vertices
< 	b2Vec2 m_vertex1, m_vertex2;
< 
< 	/// Optional adjacent vertices. These are used for smooth collision.
< 	b2Vec2 m_vertex0, m_vertex3;
< 	bool m_hasVertex0, m_hasVertex3;
< };
< 
< inline b2EdgeShape::b2EdgeShape()
< {
< 	m_type = e_edge;
< 	m_radius = b2_polygonRadius;
< 	m_vertex0.x = 0.0f;
< 	m_vertex0.y = 0.0f;
< 	m_vertex3.x = 0.0f;
< 	m_vertex3.y = 0.0f;
< 	m_hasVertex0 = false;
< 	m_hasVertex3 = false;
< }
< 
< #endif
---
> /*
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
> *
> * This software is provided 'as-is', without any express or implied
> * warranty.  In no event will the authors be held liable for any damages
> * arising from the use of this software.
> * Permission is granted to anyone to use this software for any purpose,
> * including commercial applications, and to alter it and redistribute it
> * freely, subject to the following restrictions:
> * 1. The origin of this software must not be misrepresented; you must not
> * claim that you wrote the original software. If you use this software
> * in a product, an acknowledgment in the product documentation would be
> * appreciated but is not required.
> * 2. Altered source versions must be plainly marked as such, and must not be
> * misrepresented as being the original software.
> * 3. This notice may not be removed or altered from any source distribution.
> */
> 
> #ifndef B2_EDGE_SHAPE_H
> #define B2_EDGE_SHAPE_H
> 
> #include "b2Shape.h"
> 
> /// This structure is used to build circle shapes.
> struct b2EdgeChainDef : public b2ShapeDef
> {
> 	b2EdgeChainDef()
> 	{
> 		type = e_edgeShape;
> 		vertexCount = 0;
> 		isALoop = true;
> 		vertices = NULL;
> 	}
> 	/// The vertices in local coordinates. You must manage the memory
> 	/// of this array on your own, outside of Box2D. 
> 	b2Vec2* vertices;
> 	
> 	/// The number of vertices in the chain. 
> 	int32 vertexCount;
> 	
> 	/// Whether to create an extra edge between the first and last vertices:
> 	bool isALoop;
> };
> 
> /// A circle shape.
> class b2EdgeShape : public b2Shape
> {
> public:
> 	/// @see b2Shape::TestPoint
> 	bool TestPoint(const b2XForm& transform, const b2Vec2& p) const;
> 
> 	/// @see b2Shape::TestSegment
> 	b2SegmentCollide TestSegment(	const b2XForm& transform,
> 						float32* lambda,
> 						b2Vec2* normal,
> 						const b2Segment& segment,
> 						float32 maxLambda) const;
> 
> 	/// @see b2Shape::ComputeAABB
> 	void ComputeAABB(b2AABB* aabb, const b2XForm& transform) const;
> 
> 	/// @see b2Shape::ComputeSweptAABB
> 	void ComputeSweptAABB(	b2AABB* aabb,
> 							const b2XForm& transform1,
> 							const b2XForm& transform2) const;
> 
> 	/// @see b2Shape::ComputeMass
> 	void ComputeMass(b2MassData* massData) const;
> 
> 	/// @warning This only gives a consistent and sensible answer when when summed over a body only contains loops of edges
> 	/// @see b2Shape::ComputeSubmergedArea
> 	float32 ComputeSubmergedArea(	const b2Vec2& normal,
> 									float32 offset,
> 									const b2XForm& xf, 
> 									b2Vec2* c) const;
> 	
> 	/// Linear distance from vertex1 to vertex2:
> 	float32 GetLength() const;
> 
> 	/// Local position of vertex in parent body
> 	const b2Vec2& GetVertex1() const;
> 
> 	/// Local position of vertex in parent body
> 	const b2Vec2& GetVertex2() const;
> 
> 	/// "Core" vertex with TOI slop for b2Distance functions:
> 	const b2Vec2& GetCoreVertex1() const;
> 
> 	/// "Core" vertex with TOI slop for b2Distance functions:
> 	const b2Vec2& GetCoreVertex2() const;
> 	
> 	/// Perpendicular unit vector point, pointing from the solid side to the empty side: 
> 	const b2Vec2& GetNormalVector() const;
> 	
> 	/// Parallel unit vector, pointing from vertex1 to vertex2:
> 	const b2Vec2& GetDirectionVector() const;
> 	
> 	const b2Vec2& GetCorner1Vector() const;
> 	
> 	const b2Vec2& GetCorner2Vector() const;
> 	
> 	bool Corner1IsConvex() const;
> 	
> 	bool Corner2IsConvex() const;
> 
> 	b2Vec2 GetFirstVertex(const b2XForm& xf) const;
> 
> 	b2Vec2 Support(const b2XForm& xf, const b2Vec2& d) const;
> 	
> 	/// Get the next edge in the chain.
> 	b2EdgeShape* GetNextEdge() const;
> 	
> 	/// Get the previous edge in the chain.
> 	b2EdgeShape* GetPrevEdge() const;
> 
> 	void SetPrevEdge(b2EdgeShape* edge, const b2Vec2& core, const b2Vec2& cornerDir, bool convex);
> 	void SetNextEdge(b2EdgeShape* edge, const b2Vec2& core, const b2Vec2& cornerDir, bool convex);
> 	
> private:
> 
> 	friend class b2Shape;
> 	friend class b2Body;
> 
> 	b2EdgeShape(const b2Vec2& v1, const b2Vec2& v2, const b2ShapeDef* def);
> 
> 	void UpdateSweepRadius(const b2Vec2& center);
> 
> 	b2Vec2 m_v1;
> 	b2Vec2 m_v2;
> 	
> 	b2Vec2 m_coreV1;
> 	b2Vec2 m_coreV2;
> 	
> 	float32 m_length;
> 	
> 	b2Vec2 m_normal;
> 	
> 	b2Vec2 m_direction;
> 	
> 	// Unit vector halfway between m_direction and m_prevEdge.m_direction:
> 	b2Vec2 m_cornerDir1;
> 	
> 	// Unit vector halfway between m_direction and m_nextEdge.m_direction:
> 	b2Vec2 m_cornerDir2;
> 	
> 	bool m_cornerConvex1;
> 	bool m_cornerConvex2;
> 	
> 	b2EdgeShape* m_nextEdge;
> 	b2EdgeShape* m_prevEdge;
> };
> 
> inline float32 b2EdgeShape::GetLength() const
> {
> 	return m_length;
> }
> 
> inline const b2Vec2& b2EdgeShape::GetVertex1() const
> {
> 	return m_v1;
> }
> 
> inline const b2Vec2& b2EdgeShape::GetVertex2() const
> {
> 	return m_v2;
> }
> 
> inline const b2Vec2& b2EdgeShape::GetCoreVertex1() const
> {
> 	return m_coreV1;
> }
> 
> inline const b2Vec2& b2EdgeShape::GetCoreVertex2() const
> {
> 	return m_coreV2;
> }
> 
> inline const b2Vec2& b2EdgeShape::GetNormalVector() const
> {
> 	return m_normal;
> }
> 
> inline const b2Vec2& b2EdgeShape::GetDirectionVector() const
> {
> 	return m_direction;
> }
> 
> inline const b2Vec2& b2EdgeShape::GetCorner1Vector() const
> {
> 	return m_cornerDir1;
> }
> 
> inline const b2Vec2& b2EdgeShape::GetCorner2Vector() const
> {
> 	return m_cornerDir2;
> }
> 
> inline b2EdgeShape* b2EdgeShape::GetNextEdge() const
> {
> 	return m_nextEdge;
> }
> 
> inline b2EdgeShape* b2EdgeShape::GetPrevEdge() const
> {
> 	return m_prevEdge;
> }
> 
> inline b2Vec2 b2EdgeShape::GetFirstVertex(const b2XForm& xf) const
> {
> 	return b2Mul(xf, m_coreV1);
> }
> 
> inline bool b2EdgeShape::Corner1IsConvex() const
> {
> 	return m_cornerConvex1;
> }
> 
> inline bool b2EdgeShape::Corner2IsConvex() const
> {
> 	return m_cornerConvex2;
> }
> #endif
diff -r -x './svn/*' native/Box2D/Collision/Shapes/b2PolygonShape.cpp ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Collision/Shapes/b2PolygonShape.cpp
0a1
> 
2c3
< * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
19,28c20
< #include <Box2D/Collision/Shapes/b2PolygonShape.h>
< #include <new>
< 
< b2Shape* b2PolygonShape::Clone(b2BlockAllocator* allocator) const
< {
< 	void* mem = allocator->Allocate(sizeof(b2PolygonShape));
< 	b2PolygonShape* clone = new (mem) b2PolygonShape;
< 	*clone = *this;
< 	return clone;
< }
---
> #include "b2PolygonShape.h"
30c22
< void b2PolygonShape::SetAsBox(float32 hx, float32 hy)
---
> void b2PolygonDef::SetAsBox(float32 hx, float32 hy)
32,41c24,28
< 	m_count = 4;
< 	m_vertices[0].Set(-hx, -hy);
< 	m_vertices[1].Set( hx, -hy);
< 	m_vertices[2].Set( hx,  hy);
< 	m_vertices[3].Set(-hx,  hy);
< 	m_normals[0].Set(0.0f, -1.0f);
< 	m_normals[1].Set(1.0f, 0.0f);
< 	m_normals[2].Set(0.0f, 1.0f);
< 	m_normals[3].Set(-1.0f, 0.0f);
< 	m_centroid.SetZero();
---
> 	vertexCount = 4;
> 	vertices[0].Set(-hx, -hy);
> 	vertices[1].Set( hx, -hy);
> 	vertices[2].Set( hx,  hy);
> 	vertices[3].Set(-hx,  hy);
44c31
< void b2PolygonShape::SetAsBox(float32 hx, float32 hy, const b2Vec2& center, float32 angle)
---
> void b2PolygonDef::SetAsBox(float32 hx, float32 hy, const b2Vec2& center, float32 angle)
46,55c33,36
< 	m_count = 4;
< 	m_vertices[0].Set(-hx, -hy);
< 	m_vertices[1].Set( hx, -hy);
< 	m_vertices[2].Set( hx,  hy);
< 	m_vertices[3].Set(-hx,  hy);
< 	m_normals[0].Set(0.0f, -1.0f);
< 	m_normals[1].Set(1.0f, 0.0f);
< 	m_normals[2].Set(0.0f, 1.0f);
< 	m_normals[3].Set(-1.0f, 0.0f);
< 	m_centroid = center;
---
> 	SetAsBox(hx, hy);
> 	b2XForm xf;
> 	xf.position = center;
> 	xf.R.Set(angle);
57,62c38
< 	b2Transform xf;
< 	xf.p = center;
< 	xf.q.Set(angle);
< 
< 	// Transform vertices and normals.
< 	for (int32 i = 0; i < m_count; ++i)
---
> 	for (int32 i = 0; i < vertexCount; ++i)
64,65c40
< 		m_vertices[i] = b2Mul(xf, m_vertices[i]);
< 		m_normals[i] = b2Mul(xf.q, m_normals[i]);
---
> 		vertices[i] = b2Mul(xf, vertices[i]);
69,73d43
< int32 b2PolygonShape::GetChildCount() const
< {
< 	return 1;
< }
< 
115c85
< 	b2Assert(area > b2_epsilon);
---
> 	b2Assert(area > B2_FLT_EPSILON);
120c90,91
< void b2PolygonShape::Set(const b2Vec2* vertices, int32 count)
---
> // http://www.geometrictools.com/Documentation/MinimumAreaRectangle.pdf
> static void ComputeOBB(b2OBB* obb, const b2Vec2* vs, int32 count)
122,123c93,95
< 	b2Assert(3 <= count && count <= b2_maxPolygonVertices);
< 	if (count < 3)
---
> 	b2Assert(count <= b2_maxPolygonVertices);
> 	b2Vec2 p[b2_maxPolygonVertices + 1];
> 	for (int32 i = 0; i < count; ++i)
125,126c97
< 		SetAsBox(1.0f, 1.0f);
< 		return;
---
> 		p[i] = vs[i];
128,129c99
< 	
< 	int32 n = b2Min(count, b2_maxPolygonVertices);
---
> 	p[count] = p[0];
131,133c101,103
< 	// Copy vertices into local buffer
< 	b2Vec2 ps[b2_maxPolygonVertices];
< 	for (int32 i = 0; i < n; ++i)
---
> 	float32 minArea = B2_FLT_MAX;
> 	
> 	for (int32 i = 1; i <= count; ++i)
135,136c105,111
< 		ps[i] = vertices[i];
< 	}
---
> 		b2Vec2 root = p[i-1];
> 		b2Vec2 ux = p[i] - root;
> 		float32 length = ux.Normalize();
> 		b2Assert(length > B2_FLT_EPSILON);
> 		b2Vec2 uy(-ux.y, ux.x);
> 		b2Vec2 lower(B2_FLT_MAX, B2_FLT_MAX);
> 		b2Vec2 upper(-B2_FLT_MAX, -B2_FLT_MAX);
138,139c113,121
< 	// Create the convex hull using the Gift wrapping algorithm
< 	// http://en.wikipedia.org/wiki/Gift_wrapping_algorithm
---
> 		for (int32 j = 0; j < count; ++j)
> 		{
> 			b2Vec2 d = p[j] - root;
> 			b2Vec2 r;
> 			r.x = b2Dot(ux, d);
> 			r.y = b2Dot(uy, d);
> 			lower = b2Min(lower, r);
> 			upper = b2Max(upper, r);
> 		}
141,147c123,124
< 	// Find the right most point on the hull
< 	int32 i0 = 0;
< 	float32 x0 = ps[0].x;
< 	for (int32 i = 1; i < count; ++i)
< 	{
< 		float32 x = ps[i].x;
< 		if (x > x0 || (x == x0 && ps[i].y < ps[i0].y))
---
> 		float32 area = (upper.x - lower.x) * (upper.y - lower.y);
> 		if (area < 0.95f * minArea)
149,150c126,131
< 			i0 = i;
< 			x0 = x;
---
> 			minArea = area;
> 			obb->R.col1 = ux;
> 			obb->R.col2 = uy;
> 			b2Vec2 center = 0.5f * (lower + upper);
> 			obb->center = root + b2Mul(obb->R, center);
> 			obb->extents = 0.5f * (upper - lower);
154,156c135,147
< 	int32 hull[b2_maxPolygonVertices];
< 	int32 m = 0;
< 	int32 ih = i0;
---
> 	b2Assert(minArea < B2_FLT_MAX);
> }
> 
> b2PolygonShape::b2PolygonShape(const b2ShapeDef* def)
> 	 : b2Shape(def)
> {
> 	b2Assert(def->type == e_polygonShape);
> 	m_type = e_polygonShape;
> 	const b2PolygonDef* poly = (const b2PolygonDef*)def;
> 
> 	// Get the vertices transformed into the body frame.
> 	m_vertexCount = poly->vertexCount;
> 	b2Assert(3 <= m_vertexCount && m_vertexCount <= b2_maxPolygonVertices);
158c149,150
< 	for (;;)
---
> 	// Copy vertices.
> 	for (int32 i = 0; i < m_vertexCount; ++i)
160c152,153
< 		hull[m] = ih;
---
> 		m_vertices[i] = poly->vertices[i];
> 	}
162,163c155,170
< 		int32 ie = 0;
< 		for (int32 j = 1; j < n; ++j)
---
> 	// Compute normals. Ensure the edges have non-zero length.
> 	for (int32 i = 0; i < m_vertexCount; ++i)
> 	{
> 		int32 i1 = i;
> 		int32 i2 = i + 1 < m_vertexCount ? i + 1 : 0;
> 		b2Vec2 edge = m_vertices[i2] - m_vertices[i1];
> 		b2Assert(edge.LengthSquared() > B2_FLT_EPSILON * B2_FLT_EPSILON);
> 		m_normals[i] = b2Cross(edge, 1.0f);
> 		m_normals[i].Normalize();
> 	}
> 
> #ifdef _DEBUG
> 	// Ensure the polygon is convex.
> 	for (int32 i = 0; i < m_vertexCount; ++i)
> 	{
> 		for (int32 j = 0; j < m_vertexCount; ++j)
165c172,173
< 			if (ie == ih)
---
> 			// Don't check vertices on the current edge.
> 			if (j == i || j == (i + 1) % m_vertexCount)
167d174
< 				ie = j;
170,183c177,181
< 
< 			b2Vec2 r = ps[ie] - ps[hull[m]];
< 			b2Vec2 v = ps[j] - ps[hull[m]];
< 			float32 c = b2Cross(r, v);
< 			if (c < 0.0f)
< 			{
< 				ie = j;
< 			}
< 
< 			// Collinearity check
< 			if (c == 0.0f && v.LengthSquared() > r.LengthSquared())
< 			{
< 				ie = j;
< 			}
---
> 			
> 			// Your polygon is non-convex (it has an indentation).
> 			// Or your polygon is too skinny.
> 			float32 s = b2Dot(m_normals[i], m_vertices[j] - m_vertices[i]);
> 			b2Assert(s < -b2_linearSlop);
184a183
> 	}
186,187c185,188
< 		++m;
< 		ih = ie;
---
> 	// Ensure the polygon is counter-clockwise.
> 	for (int32 i = 1; i < m_vertexCount; ++i)
> 	{
> 		float32 cross = b2Cross(m_normals[i-1], m_normals[i]);
189,192c190,195
< 		if (ie == i0)
< 		{
< 			break;
< 		}
---
> 		// Keep asinf happy.
> 		cross = b2Clamp(cross, -1.0f, 1.0f);
> 
> 		// You have consecutive edges that are almost parallel on your polygon.
> 		float32 angle = asinf(cross);
> 		b2Assert(angle > b2_angularSlop);
194,195c197
< 	
< 	m_count = m;
---
> #endif
197,198c199,207
< 	// Copy vertices.
< 	for (int32 i = 0; i < m; ++i)
---
> 	// Compute the polygon centroid.
> 	m_centroid = ComputeCentroid(poly->vertices, poly->vertexCount);
> 
> 	// Compute the oriented bounding box.
> 	ComputeOBB(&m_obb, m_vertices, m_vertexCount);
> 
> 	// Create core polygon shape by shifting edges inward.
> 	// Also compute the min/max radius for CCD.
> 	for (int32 i = 0; i < m_vertexCount; ++i)
200c209,229
< 		m_vertices[i] = ps[hull[i]];
---
> 		int32 i1 = i - 1 >= 0 ? i - 1 : m_vertexCount - 1;
> 		int32 i2 = i;
> 
> 		b2Vec2 n1 = m_normals[i1];
> 		b2Vec2 n2 = m_normals[i2];
> 		b2Vec2 v = m_vertices[i] - m_centroid;;
> 
> 		b2Vec2 d;
> 		d.x = b2Dot(n1, v) - b2_toiSlop;
> 		d.y = b2Dot(n2, v) - b2_toiSlop;
> 
> 		// Shifting the edge inward by b2_toiSlop should
> 		// not cause the plane to pass the centroid.
> 
> 		// Your shape has a radius/extent less than b2_toiSlop.
> 		b2Assert(d.x >= 0.0f);
> 		b2Assert(d.y >= 0.0f);
> 		b2Mat22 A;
> 		A.col1.x = n1.x; A.col2.x = n1.y;
> 		A.col1.y = n2.x; A.col2.y = n2.y;
> 		m_coreVertices[i] = A.Solve(d) + m_centroid;
201a231
> }
203,204c233,238
< 	// Compute normals. Ensure the edges have non-zero length.
< 	for (int32 i = 0; i < m; ++i)
---
> void b2PolygonShape::UpdateSweepRadius(const b2Vec2& center)
> {
> 	// Update the sweep radius (maximum radius) as measured from
> 	// a local center point.
> 	m_sweepRadius = 0.0f;
> 	for (int32 i = 0; i < m_vertexCount; ++i)
206,211c240,241
< 		int32 i1 = i;
< 		int32 i2 = i + 1 < m ? i + 1 : 0;
< 		b2Vec2 edge = m_vertices[i2] - m_vertices[i1];
< 		b2Assert(edge.LengthSquared() > b2_epsilon * b2_epsilon);
< 		m_normals[i] = b2Cross(edge, 1.0f);
< 		m_normals[i].Normalize();
---
> 		b2Vec2 d = m_coreVertices[i] - center;
> 		m_sweepRadius = b2Max(m_sweepRadius, d.Length());
213,215d242
< 
< 	// Compute the polygon centroid.
< 	m_centroid = ComputeCentroid(m_vertices, m);
218c245
< bool b2PolygonShape::TestPoint(const b2Transform& xf, const b2Vec2& p) const
---
> bool b2PolygonShape::TestPoint(const b2XForm& xf, const b2Vec2& p) const
220c247
< 	b2Vec2 pLocal = b2MulT(xf.q, p - xf.p);
---
> 	b2Vec2 pLocal = b2MulT(xf.R, p - xf.position);
222c249
< 	for (int32 i = 0; i < m_count; ++i)
---
> 	for (int32 i = 0; i < m_vertexCount; ++i)
234,235c261,266
< bool b2PolygonShape::RayCast(b2RayCastOutput* output, const b2RayCastInput& input,
< 								const b2Transform& xf, int32 childIndex) const
---
> b2SegmentCollide b2PolygonShape::TestSegment(
> 	const b2XForm& xf,
> 	float32* lambda,
> 	b2Vec2* normal,
> 	const b2Segment& segment,
> 	float32 maxLambda) const
237c268
< 	B2_NOT_USED(childIndex);
---
> 	float32 lower = 0.0f, upper = maxLambda;
239,241c270,271
< 	// Put the ray into the polygon's frame of reference.
< 	b2Vec2 p1 = b2MulT(xf.q, input.p1 - xf.p);
< 	b2Vec2 p2 = b2MulT(xf.q, input.p2 - xf.p);
---
> 	b2Vec2 p1 = b2MulT(xf.R, segment.p1 - xf.position);
> 	b2Vec2 p2 = b2MulT(xf.R, segment.p2 - xf.position);
243,245d272
< 
< 	float32 lower = 0.0f, upper = input.maxFraction;
< 
248c275
< 	for (int32 i = 0; i < m_count; ++i)
---
> 	for (int32 i = 0; i < m_vertexCount; ++i)
260c287
< 				return false;
---
> 				return e_missCollide;
284,287d310
< 		// The use of epsilon here causes the assert on lower to trip
< 		// in some cases. Apparently the use of epsilon was to make edge
< 		// shapes work, but now those are handled separately.
< 		//if (upper < lower - b2_epsilon)
290c313
< 			return false;
---
> 			return e_missCollide;
294c317
< 	b2Assert(0.0f <= lower && lower <= input.maxFraction);
---
> 	b2Assert(0.0f <= lower && lower <= maxLambda);
298,300c321,323
< 		output->fraction = lower;
< 		output->normal = b2Mul(xf.q, m_normals[index]);
< 		return true;
---
> 		*lambda = lower;
> 		*normal = b2Mul(xf.R, m_normals[index]);
> 		return e_hitCollide;
303c326,327
< 	return false;
---
> 	*lambda = 0;
> 	return e_startsInsideCollide;
306c330
< void b2PolygonShape::ComputeAABB(b2AABB* aabb, const b2Transform& xf, int32 childIndex) const
---
> void b2PolygonShape::ComputeAABB(b2AABB* aabb, const b2XForm& xf) const
308,318c332,338
< 	B2_NOT_USED(childIndex);
< 
< 	b2Vec2 lower = b2Mul(xf, m_vertices[0]);
< 	b2Vec2 upper = lower;
< 
< 	for (int32 i = 1; i < m_count; ++i)
< 	{
< 		b2Vec2 v = b2Mul(xf, m_vertices[i]);
< 		lower = b2Min(lower, v);
< 		upper = b2Max(upper, v);
< 	}
---
> 	b2Mat22 R = b2Mul(xf.R, m_obb.R);
> 	b2Mat22 absR = b2Abs(R);
> 	b2Vec2 h = b2Mul(absR, m_obb.extents);
> 	b2Vec2 position = xf.position + b2Mul(xf.R, m_obb.center);
> 	aabb->lowerBound = position - h;
> 	aabb->upperBound = position + h;
> }
320,322c340,348
< 	b2Vec2 r(m_radius, m_radius);
< 	aabb->lowerBound = lower - r;
< 	aabb->upperBound = upper + r;
---
> void b2PolygonShape::ComputeSweptAABB(b2AABB* aabb,
> 					  const b2XForm& transform1,
> 					  const b2XForm& transform2) const
> {
> 	b2AABB aabb1, aabb2;
> 	ComputeAABB(&aabb1, transform1);
> 	ComputeAABB(&aabb2, transform2);
> 	aabb->lowerBound = b2Min(aabb1.lowerBound, aabb2.lowerBound);
> 	aabb->upperBound = b2Max(aabb1.upperBound, aabb2.upperBound);
325c351
< void b2PolygonShape::ComputeMass(b2MassData* massData, float32 density) const
---
> void b2PolygonShape::ComputeMass(b2MassData* massData) const
351c377
< 	b2Assert(m_count >= 3);
---
> 	b2Assert(m_vertexCount >= 3);
357c383
< 	// s is the reference point for forming triangles.
---
> 	// pRef is the reference point for forming triangles.
359,360c385,386
< 	b2Vec2 s(0.0f, 0.0f);
< 
---
> 	b2Vec2 pRef(0.0f, 0.0f);
> #if 0
362c388
< 	for (int32 i = 0; i < m_count; ++i)
---
> 	for (int32 i = 0; i < m_vertexCount; ++i)
364c390
< 		s += m_vertices[i];
---
> 		pRef += m_vertices[i];
366c392,393
< 	s *= 1.0f / m_count;
---
> 	pRef *= 1.0f / count;
> #endif
370c397
< 	for (int32 i = 0; i < m_count; ++i)
---
> 	for (int32 i = 0; i < m_vertexCount; ++i)
373,374c400,405
< 		b2Vec2 e1 = m_vertices[i] - s;
< 		b2Vec2 e2 = i + 1 < m_count ? m_vertices[i+1] - s : m_vertices[0] - s;
---
> 		b2Vec2 p1 = pRef;
> 		b2Vec2 p2 = m_vertices[i];
> 		b2Vec2 p3 = i + 1 < m_vertexCount ? m_vertices[i+1] : m_vertices[0];
> 
> 		b2Vec2 e1 = p2 - p1;
> 		b2Vec2 e2 = p3 - p1;
382c413
< 		center += triangleArea * k_inv3 * (e1 + e2);
---
> 		center += triangleArea * k_inv3 * (p1 + p2 + p3);
383a415
> 		float32 px = p1.x, py = p1.y;
387,388c419,420
< 		float32 intx2 = ex1*ex1 + ex2*ex1 + ex2*ex2;
< 		float32 inty2 = ey1*ey1 + ey2*ey1 + ey2*ey2;
---
> 		float32 intx2 = k_inv3 * (0.25f * (ex1*ex1 + ex2*ex1 + ex2*ex2) + (px*ex1 + px*ex2)) + 0.5f*px*px;
> 		float32 inty2 = k_inv3 * (0.25f * (ey1*ey1 + ey2*ey1 + ey2*ey2) + (py*ey1 + py*ey2)) + 0.5f*py*py;
390c422
< 		I += (0.25f * k_inv3 * D) * (intx2 + inty2);
---
> 		I += D * (intx2 + inty2);
394c426
< 	massData->mass = density * area;
---
> 	massData->mass = m_density * area;
397c429
< 	b2Assert(area > b2_epsilon);
---
> 	b2Assert(area > B2_FLT_EPSILON);
399c431,436
< 	massData->center = center + s;
---
> 	massData->center = center;
> 
> 	// Inertia tensor relative to the local origin.
> 	massData->I = m_density * I;
> }
> 
401,402c438,450
< 	// Inertia tensor relative to the local origin (point s).
< 	massData->I = density * I;
---
> float32 b2PolygonShape::ComputeSubmergedArea(	const b2Vec2& normal,
> 												float32 offset,
> 												const b2XForm& xf, 
> 												b2Vec2* c) const
> {
> 	//Transform plane into shape co-ordinates
> 	b2Vec2 normalL = b2MulT(xf.R,normal);
> 	float32 offsetL = offset - b2Dot(normal,xf.position);
> 	
> 	float32 depths[b2_maxPolygonVertices];
> 	int32 diveCount = 0;
> 	int32 intoIndex = -1;
> 	int32 outoIndex = -1;
404,405c452,544
< 	// Shift to center of mass then to original body origin.
< 	massData->I += massData->mass * (b2Dot(massData->center, massData->center) - b2Dot(center, center));
---
> 	bool lastSubmerged = false;
> 	int32 i;
> 	for(i=0;i<m_vertexCount;i++){
> 		depths[i] = b2Dot(normalL,m_vertices[i]) - offsetL;
> 		bool isSubmerged = depths[i]<-B2_FLT_EPSILON;
> 		if(i>0){
> 			if(isSubmerged){
> 				if(!lastSubmerged){
> 					intoIndex = i-1;
> 					diveCount++;
> 				}
> 			}else{
> 				if(lastSubmerged){
> 					outoIndex = i-1;
> 					diveCount++;
> 				}
> 			}
> 		}
> 		lastSubmerged = isSubmerged;
> 	}
> 	switch(diveCount){
> 		case 0:
> 			if(lastSubmerged){
> 				//Completely submerged
> 				b2MassData md;
> 				ComputeMass(&md);
> 				*c = b2Mul(xf,md.center);
> 				return md.mass/m_density;
> 			}else{
> 				//Completely dry
> 				return 0;
> 			}
> 			break;
> 		case 1:
> 			if(intoIndex==-1){
> 				intoIndex = m_vertexCount-1;
> 			}else{
> 				outoIndex = m_vertexCount-1;
> 			}
> 			break;
> 	}
> 	int32 intoIndex2 = (intoIndex+1)%m_vertexCount;
> 	int32 outoIndex2 = (outoIndex+1)%m_vertexCount;
> 	
> 	float32 intoLambda = (0 - depths[intoIndex]) / (depths[intoIndex2] - depths[intoIndex]);
> 	float32 outoLambda = (0 - depths[outoIndex]) / (depths[outoIndex2] - depths[outoIndex]);
> 	
> 	b2Vec2 intoVec(	m_vertices[intoIndex].x*(1-intoLambda)+m_vertices[intoIndex2].x*intoLambda,
> 					m_vertices[intoIndex].y*(1-intoLambda)+m_vertices[intoIndex2].y*intoLambda);
> 	b2Vec2 outoVec(	m_vertices[outoIndex].x*(1-outoLambda)+m_vertices[outoIndex2].x*outoLambda,
> 					m_vertices[outoIndex].y*(1-outoLambda)+m_vertices[outoIndex2].y*outoLambda);
> 	
> 	//Initialize accumulator
> 	float32 area = 0;
> 	b2Vec2 center(0,0);
> 	b2Vec2 p2 = m_vertices[intoIndex2];
> 	b2Vec2 p3;
> 	
> 	float32 k_inv3 = 1.0f / 3.0f;
> 	
> 	//An awkward loop from intoIndex2+1 to outIndex2
> 	i = intoIndex2;
> 	while(i!=outoIndex2){
> 		i=(i+1)%m_vertexCount;
> 		if(i==outoIndex2)
> 			p3 = outoVec;
> 		else
> 			p3 = m_vertices[i];
> 		//Add the triangle formed by intoVec,p2,p3
> 		{
> 			b2Vec2 e1 = p2 - intoVec;
> 			b2Vec2 e2 = p3 - intoVec;
> 			
> 			float32 D = b2Cross(e1, e2);
> 			
> 			float32 triangleArea = 0.5f * D;
> 
> 			area += triangleArea;
> 			
> 			// Area weighted centroid
> 			center += triangleArea * k_inv3 * (intoVec + p2 + p3);
> 
> 		}
> 		//
> 		p2=p3;
> 	}
> 	
> 	//Normalize and transform centroid
> 	center *= 1.0f/area;
> 	
> 	*c = b2Mul(xf,center);
> 	
> 	return area;
408c547
< bool b2PolygonShape::Validate() const
---
> b2Vec2 b2PolygonShape::Centroid(const b2XForm& xf) const
410,415c549,550
< 	for (int32 i = 0; i < m_count; ++i)
< 	{
< 		int32 i1 = i;
< 		int32 i2 = i < m_count - 1 ? i1 + 1 : 0;
< 		b2Vec2 p = m_vertices[i1];
< 		b2Vec2 e = m_vertices[i2] - p;
---
> 	return b2Mul(xf, m_centroid);
> }
417,422c552,554
< 		for (int32 j = 0; j < m_count; ++j)
< 		{
< 			if (j == i1 || j == i2)
< 			{
< 				continue;
< 			}
---
> b2Vec2 b2PolygonShape::Support(const b2XForm& xf, const b2Vec2& d) const
> {
> 	b2Vec2 dLocal = b2MulT(xf.R, d);
424,429c556,564
< 			b2Vec2 v = m_vertices[j] - p;
< 			float32 c = b2Cross(e, v);
< 			if (c < 0.0f)
< 			{
< 				return false;
< 			}
---
> 	int32 bestIndex = 0;
> 	float32 bestValue = b2Dot(m_coreVertices[0], dLocal);
> 	for (int32 i = 1; i < m_vertexCount; ++i)
> 	{
> 		float32 value = b2Dot(m_coreVertices[i], dLocal);
> 		if (value > bestValue)
> 		{
> 			bestIndex = i;
> 			bestValue = value;
433c568
< 	return true;
---
> 	return b2Mul(xf, m_coreVertices[bestIndex]);
diff -r -x './svn/*' native/Box2D/Collision/Shapes/b2PolygonShape.h ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Collision/Shapes/b2PolygonShape.h
2c2
< * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
22c22
< #include <Box2D/Collision/Shapes/b2Shape.h>
---
> #include "b2Shape.h"
24,28c24,26
< /// A convex polygon. It is assumed that the interior of the polygon is to
< /// the left of each edge.
< /// Polygons have a maximum number of vertices equal to b2_maxPolygonVertices.
< /// In most cases you should not need many vertices for a convex polygon.
< class b2PolygonShape : public b2Shape
---
> /// Convex polygon. The vertices must be in CCW order for a right-handed
> /// coordinate system with the z-axis coming out of the screen.
> struct b2PolygonDef : public b2ShapeDef
30,34c28,32
< public:
< 	b2PolygonShape();
< 
< 	/// Implement b2Shape.
< 	b2Shape* Clone(b2BlockAllocator* allocator) const;
---
> 	b2PolygonDef()
> 	{
> 		type = e_polygonShape;
> 		vertexCount = 0;
> 	}
36,46c34
< 	/// @see b2Shape::GetChildCount
< 	int32 GetChildCount() const;
< 
< 	/// Create a convex hull from the given array of local points.
< 	/// The count must be in the range [3, b2_maxPolygonVertices].
< 	/// @warning the points may be re-ordered, even if they form a convex polygon
< 	/// @warning collinear points are handled but not removed. Collinear points
< 	/// may lead to poor stacking behavior.
< 	void Set(const b2Vec2* points, int32 count);
< 
< 	/// Build vertices to represent an axis-aligned box centered on the local origin.
---
> 	/// Build vertices to represent an axis-aligned box.
57a46,57
> 	/// The polygon vertices in local coordinates.
> 	b2Vec2 vertices[b2_maxPolygonVertices];
> 
> 	/// The number of polygon vertices.
> 	int32 vertexCount;
> };
> 
> 
> /// A convex polygon.
> class b2PolygonShape : public b2Shape
> {
> public:
59c59
< 	bool TestPoint(const b2Transform& transform, const b2Vec2& p) const;
---
> 	bool TestPoint(const b2XForm& transform, const b2Vec2& p) const;
61,63c61,66
< 	/// Implement b2Shape.
< 	bool RayCast(b2RayCastOutput* output, const b2RayCastInput& input,
< 					const b2Transform& transform, int32 childIndex) const;
---
> 	/// @see b2Shape::TestSegment
> 	b2SegmentCollide TestSegment(	const b2XForm& transform,
> 		float32* lambda,
> 		b2Vec2* normal,
> 		const b2Segment& segment,
> 		float32 maxLambda) const;
66c69,74
< 	void ComputeAABB(b2AABB* aabb, const b2Transform& transform, int32 childIndex) const;
---
> 	void ComputeAABB(b2AABB* aabb, const b2XForm& transform) const;
> 
> 	/// @see b2Shape::ComputeSweptAABB
> 	void ComputeSweptAABB(	b2AABB* aabb,
> 		const b2XForm& transform1,
> 		const b2XForm& transform2) const;
69c77,89
< 	void ComputeMass(b2MassData* massData, float32 density) const;
---
> 	void ComputeMass(b2MassData* massData) const;
> 
> 	/// @see b2Shape::ComputeSubmergedArea
> 	float32 ComputeSubmergedArea(	const b2Vec2& normal,
> 									float32 offset,
> 									const b2XForm& xf, 
> 									b2Vec2* c) const;
> 
> 	/// Get the oriented bounding box relative to the parent body.
> 	const b2OBB& GetOBB() const;
> 
> 	/// Get local centroid relative to the parent body.
> 	const b2Vec2& GetCentroid() const;
72c92,109
< 	int32 GetVertexCount() const { return m_count; }
---
> 	int32 GetVertexCount() const;
> 
> 	/// Get the vertices in local coordinates.
> 	const b2Vec2* GetVertices() const;
> 
> 	/// Get the core vertices in local coordinates. These vertices
> 	/// represent a smaller polygon that is used for time of impact
> 	/// computations.
> 	const b2Vec2* GetCoreVertices() const;
> 
> 	/// Get the edge normal vectors. There is one for each vertex.
> 	const b2Vec2* GetNormals() const;
> 
> 	/// Get the first vertex and apply the supplied transform.
> 	b2Vec2 GetFirstVertex(const b2XForm& xf) const;
> 
> 	/// Get the centroid and apply the supplied transform.
> 	b2Vec2 Centroid(const b2XForm& xf) const;
74,75c111,113
< 	/// Get a vertex by index.
< 	const b2Vec2& GetVertex(int32 index) const;
---
> 	/// Get the support point in the given world direction.
> 	/// Use the supplied transform.
> 	b2Vec2 Support(const b2XForm& xf, const b2Vec2& d) const;
77,79c115
< 	/// Validate convexity. This is a very time consuming operation.
< 	/// @returns true if valid
< 	bool Validate() const;
---
> private:
80a117,123
> 	friend class b2Shape;
> 
> 	b2PolygonShape(const b2ShapeDef* def);
> 
> 	void UpdateSweepRadius(const b2Vec2& center);
> 
> 	// Local position of the polygon centroid.
81a125,127
> 
> 	b2OBB m_obb;
> 
84c130,131
< 	int32 m_count;
---
> 	b2Vec2 m_coreVertices[b2_maxPolygonVertices];
> 	int32 m_vertexCount;
87c134,159
< inline b2PolygonShape::b2PolygonShape()
---
> inline b2Vec2 b2PolygonShape::GetFirstVertex(const b2XForm& xf) const
> {
> 	return b2Mul(xf, m_coreVertices[0]);
> }
> 
> inline const b2OBB& b2PolygonShape::GetOBB() const
> {
> 	return m_obb;
> }
> 
> inline const b2Vec2& b2PolygonShape::GetCentroid() const
> {
> 	return m_centroid;
> }
> 
> inline int32 b2PolygonShape::GetVertexCount() const
> {
> 	return m_vertexCount;
> }
> 
> inline const b2Vec2* b2PolygonShape::GetVertices() const
> {
> 	return m_vertices;
> }
> 
> inline const b2Vec2* b2PolygonShape::GetCoreVertices() const
89,92c161
< 	m_type = e_polygon;
< 	m_radius = b2_polygonRadius;
< 	m_count = 0;
< 	m_centroid.SetZero();
---
> 	return m_coreVertices;
95c164
< inline const b2Vec2& b2PolygonShape::GetVertex(int32 index) const
---
> inline const b2Vec2* b2PolygonShape::GetNormals() const
97,98c166
< 	b2Assert(0 <= index && index < m_count);
< 	return m_vertices[index];
---
> 	return m_normals;
Only in ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Collision/Shapes: b2Shape.cpp
diff -r -x './svn/*' native/Box2D/Collision/Shapes/b2Shape.h ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Collision/Shapes/b2Shape.h
2c2
< * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
22,24c22,27
< #include <Box2D/Common/b2BlockAllocator.h>
< #include <Box2D/Common/b2Math.h>
< #include <Box2D/Collision/b2Collision.h>
---
> #include "../../Common/b2Math.h"
> #include "../b2Collision.h"
> 
> class b2BlockAllocator;
> class b2Body;
> class b2BroadPhase;
35c38
< 	/// The rotational inertia of the shape about the local origin.
---
> 	/// The rotational inertia of the shape.
39,42c42,43
< /// A shape is used for collision detection. You can create a shape however you like.
< /// Shapes used for simulation in b2World are created automatically when a b2Fixture
< /// is created. Shapes may encapsulate a one or more child shapes.
< class b2Shape
---
> /// This holds contact filtering data.
> struct b2FilterData
44,53c45,56
< public:
< 	
< 	enum Type
< 	{
< 		e_circle = 0,
< 		e_edge = 1,
< 		e_polygon = 2,
< 		e_chain = 3,
< 		e_typeCount = 4
< 	};
---
> 	/// The collision category bits. Normally you would just set one bit.
> 	uint16 categoryBits;
> 
> 	/// The collision mask bits. This states the categories that this
> 	/// shape would accept for collision.
> 	uint16 maskBits;
> 
> 	/// Collision groups allow a certain group of objects to never collide (negative)
> 	/// or always collide (positive). Zero means no collision group. Non-zero group
> 	/// filtering always wins against the mask bits.
> 	int16 groupIndex;
> };
55c58,66
< 	virtual ~b2Shape() {}
---
> /// The various collision shape types supported by Box2D.
> enum b2ShapeType
> {
> 	e_unknownShape = -1,
> 	e_circleShape,
> 	e_polygonShape,
> 	e_edgeShape,
> 	e_shapeTypeCount,
> };
57,58c68,74
< 	/// Clone the concrete shape using the provided allocator.
< 	virtual b2Shape* Clone(b2BlockAllocator* allocator) const = 0;
---
> /// Return codes from TestSegment
> enum b2SegmentCollide
> {
> 	e_startsInsideCollide = -1,
> 	e_missCollide = 0,
> 	e_hitCollide = 1
> };
59a76,124
> /// A shape definition is used to construct a shape. This class defines an
> /// abstract shape definition. You can reuse shape definitions safely.
> struct b2ShapeDef
> {
> 	/// The constructor sets the default shape definition values.
> 	b2ShapeDef()
> 	{
> 		type = e_unknownShape;
> 		userData = NULL;
> 		friction = 0.2f;
> 		restitution = 0.0f;
> 		density = 0.0f;
> 		filter.categoryBits = 0x0001;
> 		filter.maskBits = 0xFFFF;
> 		filter.groupIndex = 0;
> 		isSensor = false;
> 	}
> 
> 	virtual ~b2ShapeDef() {}
> 
> 	/// Holds the shape type for down-casting.
> 	b2ShapeType type;
> 
> 	/// Use this to store application specify shape data.
> 	void* userData;
> 
> 	/// The shape's friction coefficient, usually in the range [0,1].
> 	float32 friction;
> 
> 	/// The shape's restitution (elasticity) usually in the range [0,1].
> 	float32 restitution;
> 
> 	/// The shape's density, usually in kg/m^2.
> 	float32 density;
> 
> 	/// A sensor shape collects contact information but never generates a collision
> 	/// response.
> 	bool isSensor;
> 
> 	/// Contact filtering data.
> 	b2FilterData filter;
> };
> 
> /// A shape is used for collision detection. Shapes are created in b2World.
> /// You can use shape for collision detection before they are attached to the world.
> /// @warning you cannot reuse shapes.
> class b2Shape
> {
> public:
62c127,146
< 	Type GetType() const;
---
> 	b2ShapeType GetType() const;
> 
> 	/// Is this shape a sensor (non-solid)?
> 	/// @return the true if the shape is a sensor.
> 	bool IsSensor() const;
> 
> 	/// Set the contact filtering data. You must call b2World::Refilter to correct
> 	/// existing contacts/non-contacts.
> 	void SetFilterData(const b2FilterData& filter);
> 
> 	/// Get the contact filtering data.
> 	const b2FilterData& GetFilterData() const;
> 
> 	/// Get the parent body of this shape. This is NULL if the shape is not attached.
> 	/// @return the parent body.
> 	b2Body* GetBody();
> 
> 	/// Get the next shape in the parent body's shape list.
> 	/// @return the next shape.
> 	b2Shape* GetNext();
64,65c148,153
< 	/// Get the number of child primitives.
< 	virtual int32 GetChildCount() const = 0;
---
> 	/// Get the user data that was assigned in the shape definition. Use this to
> 	/// store your application specific data.
> 	void* GetUserData();
> 
> 	/// Set the user data. Use this to store your application specific data.
> 	void SetUserData(void* data);
70c158
< 	virtual bool TestPoint(const b2Transform& xf, const b2Vec2& p) const = 0;
---
> 	virtual bool TestPoint(const b2XForm& xf, const b2Vec2& p) const = 0;
72,78c160,172
< 	/// Cast a ray against a child shape.
< 	/// @param output the ray-cast results.
< 	/// @param input the ray-cast input parameters.
< 	/// @param transform the transform to be applied to the shape.
< 	/// @param childIndex the child shape index
< 	virtual bool RayCast(b2RayCastOutput* output, const b2RayCastInput& input,
< 						const b2Transform& transform, int32 childIndex) const = 0;
---
> 	/// Perform a ray cast against this shape.
> 	/// @param xf the shape world transform.
> 	/// @param lambda returns the hit fraction. You can use this to compute the contact point
> 	/// p = (1 - lambda) * segment.p1 + lambda * segment.p2.
> 	/// @param normal returns the normal at the contact point. If there is no intersection, the normal
> 	/// is not set.
> 	/// @param segment defines the begin and end point of the ray cast.
> 	/// @param maxLambda a number typically in the range [0,1].
> 	virtual b2SegmentCollide TestSegment(	const b2XForm& xf,
> 											float32* lambda,
> 											b2Vec2* normal,
> 											const b2Segment& segment,
> 											float32 maxLambda) const = 0;
80c174
< 	/// Given a transform, compute the associated axis aligned bounding box for a child shape.
---
> 	/// Given a transform, compute the associated axis aligned bounding box for this shape.
83,84c177,185
< 	/// @param childIndex the child shape
< 	virtual void ComputeAABB(b2AABB* aabb, const b2Transform& xf, int32 childIndex) const = 0;
---
> 	virtual void ComputeAABB(b2AABB* aabb, const b2XForm& xf) const = 0;
> 
> 	/// Given two transforms, compute the associated swept axis aligned bounding box for this shape.
> 	/// @param aabb returns the axis aligned box.
> 	/// @param xf1 the starting shape world transform.
> 	/// @param xf2 the ending shape world transform.
> 	virtual void ComputeSweptAABB(	b2AABB* aabb,
> 									const b2XForm& xf1,
> 									const b2XForm& xf2) const = 0;
87c188
< 	/// The inertia tensor is computed about the local origin.
---
> 	/// The inertia tensor is computed about the local origin, not the centroid.
89,90c190,254
< 	/// @param density the density in kilograms per meter squared.
< 	virtual void ComputeMass(b2MassData* massData, float32 density) const = 0;
---
> 	virtual void ComputeMass(b2MassData* massData) const = 0;
> 
> 	/// Compute the volume and centroid of this shape intersected with a half plane
> 	/// @param normal the surface normal
> 	/// @param offset the surface offset along normal
> 	/// @param xf the shape transform
> 	/// @param c returns the centroid
> 	/// @return the total volume less than offset along normal
> 	virtual float32 ComputeSubmergedArea(	const b2Vec2& normal,
> 											float32 offset,
> 											const b2XForm& xf, 
> 											b2Vec2* c) const = 0;
> 
> 	/// Get the maximum radius about the parent body's center of mass.
> 	float32 GetSweepRadius() const;
> 
> 	/// Get the coefficient of friction.
> 	float32 GetFriction() const;
> 
> 	/// Set the coefficient of friction.
> 	void SetFriction(float32 friction);
> 
> 	/// Get the coefficient of restitution.
> 	float32 GetRestitution() const;
> 
> 	/// Set the coefficient of restitution.
> 	void SetRestitution(float32 restitution);
> 
> 	/// Get the density of the shape.
> 	float32 GetDensity() const;
> 
> 	/// Set the density of the shape.
> 	void SetDensity(float32 density);
> 
> protected:
> 
> 	friend class b2Body;
> 	friend class b2World;
> 
> 	static b2Shape* Create(const b2ShapeDef* def, b2BlockAllocator* allocator);
> 	static void Destroy(b2Shape* shape, b2BlockAllocator* allocator);
> 
> 	b2Shape(const b2ShapeDef* def);
> 	virtual ~b2Shape();
> 
> 	void CreateProxy(b2BroadPhase* broadPhase, const b2XForm& xf);
> 	void DestroyProxy(b2BroadPhase* broadPhase);
> 	bool Synchronize(b2BroadPhase* broadPhase, const b2XForm& xf1, const b2XForm& xf2);
> 	void RefilterProxy(b2BroadPhase* broadPhase, const b2XForm& xf);
> 
> 	virtual void UpdateSweepRadius(const b2Vec2& center) = 0;
> 
> 	b2ShapeType m_type;
> 	b2Shape* m_next;
> 	b2Body* m_body;
> 
> 	// Sweep radius relative to the parent body's center of mass.
> 	float32 m_sweepRadius;
> 
> 	float32 m_density;
> 	float32 m_friction;
> 	float32 m_restitution;
> 
> 	uint16 m_proxyId;
> 	b2FilterData m_filter;
92,93c256,258
< 	Type m_type;
< 	float32 m_radius;
---
> 	bool m_isSensor;
> 
> 	void* m_userData;
96c261
< inline b2Shape::Type b2Shape::GetType() const
---
> inline b2ShapeType b2Shape::GetType() const
100a266,336
> inline bool b2Shape::IsSensor() const
> {
> 	return m_isSensor;
> }
> 
> inline void b2Shape::SetFilterData(const b2FilterData& filter)
> {
> 	m_filter = filter;
> }
> 
> inline const b2FilterData& b2Shape::GetFilterData() const
> {
> 	return m_filter;
> }
> 
> inline void* b2Shape::GetUserData()
> {
> 	return m_userData;
> }
> 
> inline void b2Shape::SetUserData(void* data)
> {
> 	m_userData = data;
> }
> 
> inline b2Body* b2Shape::GetBody()
> {
> 	return m_body;
> }
> 
> inline b2Shape* b2Shape::GetNext()
> {
> 	return m_next;
> }
> 
> inline float32 b2Shape::GetSweepRadius() const
> {
> 	return m_sweepRadius;
> }
> 
> inline float32 b2Shape::GetFriction() const
> {
> 	return m_friction;
> }
> 
> inline void b2Shape::SetFriction(float32 friction)
> {
> 	m_friction = friction;
> }
> 
> inline float32 b2Shape::GetRestitution() const
> {
> 	return m_restitution;
> }
> 
> inline void b2Shape::SetRestitution(float32 restitution)
> {
> 	m_restitution = restitution;
> }
> 
> 
> inline float32 b2Shape::GetDensity() const
> {
> 	return m_density;
> }
> 
> inline void b2Shape::SetDensity(float32 density)
> {
> 	m_density = density;
> }
> 
diff -r -x './svn/*' native/Box2D/Collision/b2BroadPhase.cpp ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Collision/b2BroadPhase.cpp
2c2
< * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
19,21c19
< #include <Box2D/Collision/b2BroadPhase.h>
< #include <cstring>
< using namespace std;
---
> #include "b2BroadPhase.h"
23c21,67
< b2BroadPhase::b2BroadPhase()
---
> #include <string.h>
> 
> // Notes:
> // - we use bound arrays instead of linked lists for cache coherence.
> // - we use quantized integral values for fast compares.
> // - we use short indices rather than pointers to save memory.
> // - we use a stabbing count for fast overlap queries (less than order N).
> // - we also use a time stamp on each proxy to speed up the registration of
> //   overlap query results.
> // - where possible, we compare bound indices instead of values to reduce
> //   cache misses (TODO_ERIN).
> // - no broadphase is perfect and neither is this one: it is not great for huge
> //   worlds (use a multi-SAP instead), it is not great for large objects.
> 
> bool b2BroadPhase::s_validate = false;
> 
> struct b2BoundValues
> {
> 	uint16 lowerValues[2];
> 	uint16 upperValues[2];
> };
> 
> static int32 BinarySearch(b2Bound* bounds, int32 count, uint16 value)
> {
> 	int32 low = 0;
> 	int32 high = count - 1;
> 	while (low <= high)
> 	{
> 		int32 mid = (low + high) >> 1;
> 		if (bounds[mid].value > value)
> 		{
> 			high = mid - 1;
> 		}
> 		else if (bounds[mid].value < value)
> 		{
> 			low = mid + 1;
> 		}
> 		else
> 		{
> 			return (uint16)mid;
> 		}
> 	}
> 	
> 	return low;
> }
> 
> b2BroadPhase::b2BroadPhase(const b2AABB& worldAABB, b2PairCallback* callback)
24a69,72
> 	m_pairManager.Initialize(this, callback);
> 
> 	b2Assert(worldAABB.IsValid());
> 	m_worldAABB = worldAABB;
27,33c75,93
< 	m_pairCapacity = 16;
< 	m_pairCount = 0;
< 	m_pairBuffer = (b2Pair*)b2Alloc(m_pairCapacity * sizeof(b2Pair));
< 
< 	m_moveCapacity = 16;
< 	m_moveCount = 0;
< 	m_moveBuffer = (int32*)b2Alloc(m_moveCapacity * sizeof(int32));
---
> 	b2Vec2 d = worldAABB.upperBound - worldAABB.lowerBound;
> 	m_quantizationFactor.x = float32(B2BROADPHASE_MAX) / d.x;
> 	m_quantizationFactor.y = float32(B2BROADPHASE_MAX) / d.y;
> 
> 	for (uint16 i = 0; i < b2_maxProxies - 1; ++i)
> 	{
> 		m_proxyPool[i].SetNext(i + 1);
> 		m_proxyPool[i].timeStamp = 0;
> 		m_proxyPool[i].overlapCount = b2_invalid;
> 		m_proxyPool[i].userData = NULL;
> 	}
> 	m_proxyPool[b2_maxProxies-1].SetNext(b2_nullProxy);
> 	m_proxyPool[b2_maxProxies-1].timeStamp = 0;
> 	m_proxyPool[b2_maxProxies-1].overlapCount = b2_invalid;
> 	m_proxyPool[b2_maxProxies-1].userData = NULL;
> 	m_freeProxy = 0;
> 
> 	m_timeStamp = 1;
> 	m_queryResultCount = 0;
38,39d97
< 	b2Free(m_moveBuffer);
< 	b2Free(m_pairBuffer);
42c100,159
< int32 b2BroadPhase::CreateProxy(const b2AABB& aabb, void* userData)
---
> // This one is only used for validation.
> bool b2BroadPhase::TestOverlap(b2Proxy* p1, b2Proxy* p2)
> {
> 	for (int32 axis = 0; axis < 2; ++axis)
> 	{
> 		b2Bound* bounds = m_bounds[axis];
> 
> 		b2Assert(p1->lowerBounds[axis] < 2 * m_proxyCount);
> 		b2Assert(p1->upperBounds[axis] < 2 * m_proxyCount);
> 		b2Assert(p2->lowerBounds[axis] < 2 * m_proxyCount);
> 		b2Assert(p2->upperBounds[axis] < 2 * m_proxyCount);
> 
> 		if (bounds[p1->lowerBounds[axis]].value > bounds[p2->upperBounds[axis]].value)
> 			return false;
> 
> 		if (bounds[p1->upperBounds[axis]].value < bounds[p2->lowerBounds[axis]].value)
> 			return false;
> 	}
> 
> 	return true;
> }
> 
> bool b2BroadPhase::TestOverlap(const b2BoundValues& b, b2Proxy* p)
> {
> 	for (int32 axis = 0; axis < 2; ++axis)
> 	{
> 		b2Bound* bounds = m_bounds[axis];
> 
> 		b2Assert(p->lowerBounds[axis] < 2 * m_proxyCount);
> 		b2Assert(p->upperBounds[axis] < 2 * m_proxyCount);
> 
> 		if (b.lowerValues[axis] > bounds[p->upperBounds[axis]].value)
> 			return false;
> 
> 		if (b.upperValues[axis] < bounds[p->lowerBounds[axis]].value)
> 			return false;
> 	}
> 
> 	return true;
> }
> 
> void b2BroadPhase::ComputeBounds(uint16* lowerValues, uint16* upperValues, const b2AABB& aabb)
> {
> 	b2Assert(aabb.upperBound.x >= aabb.lowerBound.x);
> 	b2Assert(aabb.upperBound.y >= aabb.lowerBound.y);
> 
> 	b2Vec2 minVertex = b2Clamp(aabb.lowerBound, m_worldAABB.lowerBound, m_worldAABB.upperBound);
> 	b2Vec2 maxVertex = b2Clamp(aabb.upperBound, m_worldAABB.lowerBound, m_worldAABB.upperBound);
> 
> 	// Bump lower bounds downs and upper bounds up. This ensures correct sorting of
> 	// lower/upper bounds that would have equal values.
> 	// TODO_ERIN implement fast float to uint16 conversion.
> 	lowerValues[0] = (uint16)(m_quantizationFactor.x * (minVertex.x - m_worldAABB.lowerBound.x)) & (B2BROADPHASE_MAX - 1);
> 	upperValues[0] = (uint16)(m_quantizationFactor.x * (maxVertex.x - m_worldAABB.lowerBound.x)) | 1;
> 
> 	lowerValues[1] = (uint16)(m_quantizationFactor.y * (minVertex.y - m_worldAABB.lowerBound.y)) & (B2BROADPHASE_MAX - 1);
> 	upperValues[1] = (uint16)(m_quantizationFactor.y * (maxVertex.y - m_worldAABB.lowerBound.y)) | 1;
> }
> 
> void b2BroadPhase::IncrementTimeStamp()
44c161,296
< 	int32 proxyId = m_tree.CreateProxy(aabb, userData);
---
> 	if (m_timeStamp == B2BROADPHASE_MAX)
> 	{
> 		for (uint16 i = 0; i < b2_maxProxies; ++i)
> 		{
> 			m_proxyPool[i].timeStamp = 0;
> 		}
> 		m_timeStamp = 1;
> 	}
> 	else
> 	{
> 		++m_timeStamp;
> 	}
> }
> 
> void b2BroadPhase::IncrementOverlapCount(int32 proxyId)
> {
> 	b2Proxy* proxy = m_proxyPool + proxyId;
> 	if (proxy->timeStamp < m_timeStamp)
> 	{
> 		proxy->timeStamp = m_timeStamp;
> 		proxy->overlapCount = 1;
> 	}
> 	else
> 	{
> 		proxy->overlapCount = 2;
> 		b2Assert(m_queryResultCount < b2_maxProxies);
> 		m_queryResults[m_queryResultCount] = (uint16)proxyId;
> 		++m_queryResultCount;
> 	}
> }
> 
> void b2BroadPhase::Query(int32* lowerQueryOut, int32* upperQueryOut,
> 					   uint16 lowerValue, uint16 upperValue,
> 					   b2Bound* bounds, int32 boundCount, int32 axis)
> {
> 	int32 lowerQuery = BinarySearch(bounds, boundCount, lowerValue);
> 	int32 upperQuery = BinarySearch(bounds, boundCount, upperValue);
> 
> 	// Easy case: lowerQuery <= lowerIndex(i) < upperQuery
> 	// Solution: search query range for min bounds.
> 	for (int32 i = lowerQuery; i < upperQuery; ++i)
> 	{
> 		if (bounds[i].IsLower())
> 		{
> 			IncrementOverlapCount(bounds[i].proxyId);
> 		}
> 	}
> 
> 	// Hard case: lowerIndex(i) < lowerQuery < upperIndex(i)
> 	// Solution: use the stabbing count to search down the bound array.
> 	if (lowerQuery > 0)
> 	{
> 		int32 i = lowerQuery - 1;
> 		int32 s = bounds[i].stabbingCount;
> 
> 		// Find the s overlaps.
> 		while (s)
> 		{
> 			b2Assert(i >= 0);
> 
> 			if (bounds[i].IsLower())
> 			{
> 				b2Proxy* proxy = m_proxyPool + bounds[i].proxyId;
> 				if (lowerQuery <= proxy->upperBounds[axis])
> 				{
> 					IncrementOverlapCount(bounds[i].proxyId);
> 					--s;
> 				}
> 			}
> 			--i;
> 		}
> 	}
> 
> 	*lowerQueryOut = lowerQuery;
> 	*upperQueryOut = upperQuery;
> }
> 
> uint16 b2BroadPhase::CreateProxy(const b2AABB& aabb, void* userData)
> {
> 	b2Assert(m_proxyCount < b2_maxProxies);
> 	b2Assert(m_freeProxy != b2_nullProxy);
> 
> 	uint16 proxyId = m_freeProxy;
> 	b2Proxy* proxy = m_proxyPool + proxyId;
> 	m_freeProxy = proxy->GetNext();
> 
> 	proxy->overlapCount = 0;
> 	proxy->userData = userData;
> 
> 	int32 boundCount = 2 * m_proxyCount;
> 
> 	uint16 lowerValues[2], upperValues[2];
> 	ComputeBounds(lowerValues, upperValues, aabb);
> 
> 	for (int32 axis = 0; axis < 2; ++axis)
> 	{
> 		b2Bound* bounds = m_bounds[axis];
> 		int32 lowerIndex, upperIndex;
> 		Query(&lowerIndex, &upperIndex, lowerValues[axis], upperValues[axis], bounds, boundCount, axis);
> 
> 		memmove(bounds + upperIndex + 2, bounds + upperIndex, (boundCount - upperIndex) * sizeof(b2Bound));
> 		memmove(bounds + lowerIndex + 1, bounds + lowerIndex, (upperIndex - lowerIndex) * sizeof(b2Bound));
> 
> 		// The upper index has increased because of the lower bound insertion.
> 		++upperIndex;
> 
> 		// Copy in the new bounds.
> 		bounds[lowerIndex].value = lowerValues[axis];
> 		bounds[lowerIndex].proxyId = proxyId;
> 		bounds[upperIndex].value = upperValues[axis];
> 		bounds[upperIndex].proxyId = proxyId;
> 
> 		bounds[lowerIndex].stabbingCount = lowerIndex == 0 ? 0 : bounds[lowerIndex-1].stabbingCount;
> 		bounds[upperIndex].stabbingCount = bounds[upperIndex-1].stabbingCount;
> 
> 		// Adjust the stabbing count between the new bounds.
> 		for (int32 index = lowerIndex; index < upperIndex; ++index)
> 		{
> 			++bounds[index].stabbingCount;
> 		}
> 
> 		// Adjust the all the affected bound indices.
> 		for (int32 index = lowerIndex; index < boundCount + 2; ++index)
> 		{
> 			b2Proxy* proxy = m_proxyPool + bounds[index].proxyId;
> 			if (bounds[index].IsLower())
> 			{
> 				proxy->lowerBounds[axis] = (uint16)index;
> 			}
> 			else
> 			{
> 				proxy->upperBounds[axis] = (uint16)index;
> 			}
> 		}
> 	}
> 
46c298,320
< 	BufferMove(proxyId);
---
> 
> 	b2Assert(m_queryResultCount < b2_maxProxies);
> 
> 	// Create pairs if the AABB is in range.
> 	for (int32 i = 0; i < m_queryResultCount; ++i)
> 	{
> 		b2Assert(m_queryResults[i] < b2_maxProxies);
> 		b2Assert(m_proxyPool[m_queryResults[i]].IsValid());
> 
> 		m_pairManager.AddBufferedPair(proxyId, m_queryResults[i]);
> 	}
> 
> 	m_pairManager.Commit();
> 
> 	if (s_validate)
> 	{
> 		Validate();
> 	}
> 
> 	// Prepare for next query.
> 	m_queryResultCount = 0;
> 	IncrementTimeStamp();
> 
52c326,391
< 	UnBufferMove(proxyId);
---
> 	b2Assert(0 < m_proxyCount && m_proxyCount <= b2_maxProxies);
> 	b2Proxy* proxy = m_proxyPool + proxyId;
> 	b2Assert(proxy->IsValid());
> 
> 	int32 boundCount = 2 * m_proxyCount;
> 
> 	for (int32 axis = 0; axis < 2; ++axis)
> 	{
> 		b2Bound* bounds = m_bounds[axis];
> 
> 		int32 lowerIndex = proxy->lowerBounds[axis];
> 		int32 upperIndex = proxy->upperBounds[axis];
> 		uint16 lowerValue = bounds[lowerIndex].value;
> 		uint16 upperValue = bounds[upperIndex].value;
> 
> 		memmove(bounds + lowerIndex, bounds + lowerIndex + 1, (upperIndex - lowerIndex - 1) * sizeof(b2Bound));
> 		memmove(bounds + upperIndex-1, bounds + upperIndex + 1, (boundCount - upperIndex - 1) * sizeof(b2Bound));
> 
> 		// Fix bound indices.
> 		for (int32 index = lowerIndex; index < boundCount - 2; ++index)
> 		{
> 			b2Proxy* proxy = m_proxyPool + bounds[index].proxyId;
> 			if (bounds[index].IsLower())
> 			{
> 				proxy->lowerBounds[axis] = (uint16)index;
> 			}
> 			else
> 			{
> 				proxy->upperBounds[axis] = (uint16)index;
> 			}
> 		}
> 
> 		// Fix stabbing count.
> 		for (int32 index = lowerIndex; index < upperIndex - 1; ++index)
> 		{
> 			--bounds[index].stabbingCount;
> 		}
> 
> 		// Query for pairs to be removed. lowerIndex and upperIndex are not needed.
> 		Query(&lowerIndex, &upperIndex, lowerValue, upperValue, bounds, boundCount - 2, axis);
> 	}
> 
> 	b2Assert(m_queryResultCount < b2_maxProxies);
> 
> 	for (int32 i = 0; i < m_queryResultCount; ++i)
> 	{
> 		b2Assert(m_proxyPool[m_queryResults[i]].IsValid());
> 		m_pairManager.RemoveBufferedPair(proxyId, m_queryResults[i]);
> 	}
> 
> 	m_pairManager.Commit();
> 
> 	// Prepare for next query.
> 	m_queryResultCount = 0;
> 	IncrementTimeStamp();
> 
> 	// Return the proxy to the pool.
> 	proxy->userData = NULL;
> 	proxy->overlapCount = b2_invalid;
> 	proxy->lowerBounds[0] = b2_invalid;
> 	proxy->lowerBounds[1] = b2_invalid;
> 	proxy->upperBounds[0] = b2_invalid;
> 	proxy->upperBounds[1] = b2_invalid;
> 
> 	proxy->SetNext(m_freeProxy);
> 	m_freeProxy = (uint16)proxyId;
54c393,397
< 	m_tree.DestroyProxy(proxyId);
---
> 
> 	if (s_validate)
> 	{
> 		Validate();
> 	}
57c400
< void b2BroadPhase::MoveProxy(int32 proxyId, const b2AABB& aabb, const b2Vec2& displacement)
---
> void b2BroadPhase::MoveProxy(int32 proxyId, const b2AABB& aabb)
59,60c402,598
< 	bool buffer = m_tree.MoveProxy(proxyId, aabb, displacement);
< 	if (buffer)
---
> 	if (proxyId == b2_nullProxy || b2_maxProxies <= proxyId)
> 	{
> 		b2Assert(false);
> 		return;
> 	}
> 
> 	if (aabb.IsValid() == false)
> 	{
> 		b2Assert(false);
> 		return;
> 	}
> 
> 	int32 boundCount = 2 * m_proxyCount;
> 
> 	b2Proxy* proxy = m_proxyPool + proxyId;
> 
> 	// Get new bound values
> 	b2BoundValues newValues;
> 	ComputeBounds(newValues.lowerValues, newValues.upperValues, aabb);
> 
> 	// Get old bound values
> 	b2BoundValues oldValues;
> 	for (int32 axis = 0; axis < 2; ++axis)
> 	{
> 		oldValues.lowerValues[axis] = m_bounds[axis][proxy->lowerBounds[axis]].value;
> 		oldValues.upperValues[axis] = m_bounds[axis][proxy->upperBounds[axis]].value;
> 	}
> 
> 	for (int32 axis = 0; axis < 2; ++axis)
> 	{
> 		b2Bound* bounds = m_bounds[axis];
> 
> 		int32 lowerIndex = proxy->lowerBounds[axis];
> 		int32 upperIndex = proxy->upperBounds[axis];
> 
> 		uint16 lowerValue = newValues.lowerValues[axis];
> 		uint16 upperValue = newValues.upperValues[axis];
> 
> 		int32 deltaLower = lowerValue - bounds[lowerIndex].value;
> 		int32 deltaUpper = upperValue - bounds[upperIndex].value;
> 
> 		bounds[lowerIndex].value = lowerValue;
> 		bounds[upperIndex].value = upperValue;
> 
> 		//
> 		// Expanding adds overlaps
> 		//
> 
> 		// Should we move the lower bound down?
> 		if (deltaLower < 0)
> 		{
> 			int32 index = lowerIndex;
> 			while (index > 0 && lowerValue < bounds[index-1].value)
> 			{
> 				b2Bound* bound = bounds + index;
> 				b2Bound* prevBound = bound - 1;
> 
> 				int32 prevProxyId = prevBound->proxyId;
> 				b2Proxy* prevProxy = m_proxyPool + prevBound->proxyId;
> 
> 				++prevBound->stabbingCount;
> 
> 				if (prevBound->IsUpper() == true)
> 				{
> 					if (TestOverlap(newValues, prevProxy))
> 					{
> 						m_pairManager.AddBufferedPair(proxyId, prevProxyId);
> 					}
> 
> 					++prevProxy->upperBounds[axis];
> 					++bound->stabbingCount;
> 				}
> 				else
> 				{
> 					++prevProxy->lowerBounds[axis];
> 					--bound->stabbingCount;
> 				}
> 
> 				--proxy->lowerBounds[axis];
> 				b2Swap(*bound, *prevBound);
> 				--index;
> 			}
> 		}
> 
> 		// Should we move the upper bound up?
> 		if (deltaUpper > 0)
> 		{
> 			int32 index = upperIndex;
> 			while (index < boundCount-1 && bounds[index+1].value <= upperValue)
> 			{
> 				b2Bound* bound = bounds + index;
> 				b2Bound* nextBound = bound + 1;
> 				int32 nextProxyId = nextBound->proxyId;
> 				b2Proxy* nextProxy = m_proxyPool + nextProxyId;
> 
> 				++nextBound->stabbingCount;
> 
> 				if (nextBound->IsLower() == true)
> 				{
> 					if (TestOverlap(newValues, nextProxy))
> 					{
> 						m_pairManager.AddBufferedPair(proxyId, nextProxyId);
> 					}
> 
> 					--nextProxy->lowerBounds[axis];
> 					++bound->stabbingCount;
> 				}
> 				else
> 				{
> 					--nextProxy->upperBounds[axis];
> 					--bound->stabbingCount;
> 				}
> 
> 				++proxy->upperBounds[axis];
> 				b2Swap(*bound, *nextBound);
> 				++index;
> 			}
> 		}
> 
> 		//
> 		// Shrinking removes overlaps
> 		//
> 
> 		// Should we move the lower bound up?
> 		if (deltaLower > 0)
> 		{
> 			int32 index = lowerIndex;
> 			while (index < boundCount-1 && bounds[index+1].value <= lowerValue)
> 			{
> 				b2Bound* bound = bounds + index;
> 				b2Bound* nextBound = bound + 1;
> 
> 				int32 nextProxyId = nextBound->proxyId;
> 				b2Proxy* nextProxy = m_proxyPool + nextProxyId;
> 
> 				--nextBound->stabbingCount;
> 
> 				if (nextBound->IsUpper())
> 				{
> 					if (TestOverlap(oldValues, nextProxy))
> 					{
> 						m_pairManager.RemoveBufferedPair(proxyId, nextProxyId);
> 					}
> 
> 					--nextProxy->upperBounds[axis];
> 					--bound->stabbingCount;
> 				}
> 				else
> 				{
> 					--nextProxy->lowerBounds[axis];
> 					++bound->stabbingCount;
> 				}
> 
> 				++proxy->lowerBounds[axis];
> 				b2Swap(*bound, *nextBound);
> 				++index;
> 			}
> 		}
> 
> 		// Should we move the upper bound down?
> 		if (deltaUpper < 0)
> 		{
> 			int32 index = upperIndex;
> 			while (index > 0 && upperValue < bounds[index-1].value)
> 			{
> 				b2Bound* bound = bounds + index;
> 				b2Bound* prevBound = bound - 1;
> 
> 				int32 prevProxyId = prevBound->proxyId;
> 				b2Proxy* prevProxy = m_proxyPool + prevProxyId;
> 
> 				--prevBound->stabbingCount;
> 
> 				if (prevBound->IsLower() == true)
> 				{
> 					if (TestOverlap(oldValues, prevProxy))
> 					{
> 						m_pairManager.RemoveBufferedPair(proxyId, prevProxyId);
> 					}
> 
> 					++prevProxy->lowerBounds[axis];
> 					--bound->stabbingCount;
> 				}
> 				else
> 				{
> 					++prevProxy->upperBounds[axis];
> 					++bound->stabbingCount;
> 				}
> 
> 				--proxy->upperBounds[axis];
> 				b2Swap(*bound, *prevBound);
> 				--index;
> 			}
> 		}
> 	}
> 
> 	if (s_validate)
62c600
< 		BufferMove(proxyId);
---
> 		Validate();
66c604
< void b2BroadPhase::TouchProxy(int32 proxyId)
---
> void b2BroadPhase::Commit()
68c606
< 	BufferMove(proxyId);
---
> 	m_pairManager.Commit();
71c609
< void b2BroadPhase::BufferMove(int32 proxyId)
---
> int32 b2BroadPhase::Query(const b2AABB& aabb, void** userData, int32 maxCount)
73c611,623
< 	if (m_moveCount == m_moveCapacity)
---
> 	uint16 lowerValues[2];
> 	uint16 upperValues[2];
> 	ComputeBounds(lowerValues, upperValues, aabb);
> 
> 	int32 lowerIndex, upperIndex;
> 
> 	Query(&lowerIndex, &upperIndex, lowerValues[0], upperValues[0], m_bounds[0], 2*m_proxyCount, 0);
> 	Query(&lowerIndex, &upperIndex, lowerValues[1], upperValues[1], m_bounds[1], 2*m_proxyCount, 1);
> 
> 	b2Assert(m_queryResultCount < b2_maxProxies);
> 
> 	int32 count = 0;
> 	for (int32 i = 0; i < m_queryResultCount && count < maxCount; ++i, ++count)
75,79c625,628
< 		int32* oldBuffer = m_moveBuffer;
< 		m_moveCapacity *= 2;
< 		m_moveBuffer = (int32*)b2Alloc(m_moveCapacity * sizeof(int32));
< 		memcpy(m_moveBuffer, oldBuffer, m_moveCount * sizeof(int32));
< 		b2Free(oldBuffer);
---
> 		b2Assert(m_queryResults[i] < b2_maxProxies);
> 		b2Proxy* proxy = m_proxyPool + m_queryResults[i];
> 		b2Assert(proxy->IsValid());
> 		userData[i] = proxy->userData;
82,83c631,635
< 	m_moveBuffer[m_moveCount] = proxyId;
< 	++m_moveCount;
---
> 	// Prepare for next query.
> 	m_queryResultCount = 0;
> 	IncrementTimeStamp();
> 
> 	return count;
86c638
< void b2BroadPhase::UnBufferMove(int32 proxyId)
---
> void b2BroadPhase::Validate()
88c640
< 	for (int32 i = 0; i < m_moveCount; ++i)
---
> 	for (int32 axis = 0; axis < 2; ++axis)
90c642,647
< 		if (m_moveBuffer[i] == proxyId)
---
> 		b2Bound* bounds = m_bounds[axis];
> 
> 		int32 boundCount = 2 * m_proxyCount;
> 		uint16 stabbingCount = 0;
> 
> 		for (int32 i = 0; i < boundCount; ++i)
92c649,665
< 			m_moveBuffer[i] = e_nullProxy;
---
> 			b2Bound* bound = bounds + i;
> 			b2Assert(i == 0 || bounds[i-1].value <= bound->value);
> 			b2Assert(bound->proxyId != b2_nullProxy);
> 			b2Assert(m_proxyPool[bound->proxyId].IsValid());
> 
> 			if (bound->IsLower() == true)
> 			{
> 				b2Assert(m_proxyPool[bound->proxyId].lowerBounds[axis] == i);
> 				++stabbingCount;
> 			}
> 			else
> 			{
> 				b2Assert(m_proxyPool[bound->proxyId].upperBounds[axis] == i);
> 				--stabbingCount;
> 			}
> 
> 			b2Assert(bound->stabbingCount == stabbingCount);
97,98c670,671
< // This is called from b2DynamicTree::Query when we are gathering pairs.
< bool b2BroadPhase::QueryCallback(int32 proxyId)
---
> 
> int32 b2BroadPhase::QuerySegment(const b2Segment& segment, void** userData, int32 maxCount, SortKeyFunc sortKey)
100,101c673,713
< 	// A proxy cannot form a pair with itself.
< 	if (proxyId == m_queryProxyId)
---
> 	float32 maxLambda = 1;
> 
> 	float32 dx = (segment.p2.x-segment.p1.x)*m_quantizationFactor.x;
> 	float32 dy = (segment.p2.y-segment.p1.y)*m_quantizationFactor.y;
> 
> 	int32 sx = dx<-B2_FLT_EPSILON ? -1 : (dx>B2_FLT_EPSILON ? 1 : 0);
> 	int32 sy = dy<-B2_FLT_EPSILON ? -1 : (dy>B2_FLT_EPSILON ? 1 : 0);
> 
> 	b2Assert(sx!=0||sy!=0);
> 
> 	float32 p1x = (segment.p1.x-m_worldAABB.lowerBound.x)*m_quantizationFactor.x;
> 	float32 p1y = (segment.p1.y-m_worldAABB.lowerBound.y)*m_quantizationFactor.y;
> 
> 	uint16 startValues[2];
> 	uint16 startValues2[2];
> 
> 	int32 xIndex;
> 	int32 yIndex;
> 
> 	uint16 proxyId;
> 	b2Proxy* proxy;
> 	
> 	// TODO_ERIN implement fast float to uint16 conversion.
> 	startValues[0] = (uint16)(p1x) & (B2BROADPHASE_MAX - 1);
> 	startValues2[0] = (uint16)(p1x) | 1;
> 
> 	startValues[1] = (uint16)(p1y) & (B2BROADPHASE_MAX - 1);
> 	startValues2[1] = (uint16)(p1y) | 1;
> 
> 	//First deal with all the proxies that contain segment.p1
> 	int32 lowerIndex;
> 	int32 upperIndex;
> 	Query(&lowerIndex,&upperIndex,startValues[0],startValues2[0],m_bounds[0],2*m_proxyCount,0);
> 	if(sx>=0)	xIndex = upperIndex-1;
> 	else		xIndex = lowerIndex;
> 	Query(&lowerIndex,&upperIndex,startValues[1],startValues2[1],m_bounds[1],2*m_proxyCount,1);
> 	if(sy>=0)	yIndex = upperIndex-1;
> 	else		yIndex = lowerIndex;
> 
> 	//If we are using sortKey, then sort what we have so far, filtering negative keys
> 	if(sortKey)
103c715,744
< 		return true;
---
> 		//Fill keys
> 		for(int32 i=0;i<m_queryResultCount;i++)
> 		{
> 			m_querySortKeys[i] = sortKey(m_proxyPool[m_queryResults[i]].userData);
> 		}
> 		//Bubble sort keys
> 		//Sorting negative values to the top, so we can easily remove them
> 		int32 i = 0;
> 		while(i<m_queryResultCount-1)
> 		{
> 			float32 a = m_querySortKeys[i];
> 			float32 b = m_querySortKeys[i+1];
> 			if((a<0)?(b>=0):(a>b&&b>=0))
> 			{
> 				m_querySortKeys[i+1] = a;
> 				m_querySortKeys[i]   = b;
> 				uint16 tempValue = m_queryResults[i+1];
> 				m_queryResults[i+1] = m_queryResults[i];
> 				m_queryResults[i] = tempValue;
> 				i--;
> 				if(i==-1) i=1;
> 			}
> 			else
> 			{
> 				i++;
> 			}
> 		}
> 		//Skim off negative values
> 		while(m_queryResultCount>0 && m_querySortKeys[m_queryResultCount-1]<0)
> 			m_queryResultCount--;
106,107c747,748
< 	// Grow the pair buffer as needed.
< 	if (m_pairCount == m_pairCapacity)
---
> 	//Now work through the rest of the segment
> 	for (;;)
109,113c750,894
< 		b2Pair* oldBuffer = m_pairBuffer;
< 		m_pairCapacity *= 2;
< 		m_pairBuffer = (b2Pair*)b2Alloc(m_pairCapacity * sizeof(b2Pair));
< 		memcpy(m_pairBuffer, oldBuffer, m_pairCount * sizeof(b2Pair));
< 		b2Free(oldBuffer);
---
> 		float32 xProgress = 0;
> 		float32 yProgress = 0;
> 		//Move on to the next bound
> 		xIndex += sx>=0?1:-1;
> 		if(xIndex<0||xIndex>=m_proxyCount*2)
> 			break;
> 		if(sx!=0)
> 			xProgress = ((float32)m_bounds[0][xIndex].value-p1x)/dx;
> 		//Move on to the next bound
> 		yIndex += sy>=0?1:-1;
> 		if(yIndex<0||yIndex>=m_proxyCount*2)
> 			break;
> 		if(sy!=0)
> 			yProgress = ((float32)m_bounds[1][yIndex].value-p1y)/dy;
> 		for(;;)
> 		{
> 			if(sy==0||(sx!=0&&xProgress<yProgress))
> 			{
> 				if(xProgress>maxLambda)
> 					break;
> 
> 				//Check that we are entering a proxy, not leaving
> 				if(sx>0?m_bounds[0][xIndex].IsLower():m_bounds[0][xIndex].IsUpper()){
> 					//Check the other axis of the proxy
> 					proxyId = m_bounds[0][xIndex].proxyId;
> 					proxy = m_proxyPool+proxyId;
> 					if(sy>=0)
> 					{
> 						if(proxy->lowerBounds[1]<=yIndex-1&&proxy->upperBounds[1]>=yIndex)
> 						{
> 							//Add the proxy
> 							if(sortKey)
> 							{
> 								AddProxyResult(proxyId,proxy,maxCount,sortKey);
> 							}
> 							else
> 							{
> 								m_queryResults[m_queryResultCount] = proxyId;
> 								++m_queryResultCount;
> 							}
> 						}
> 					}
> 					else
> 					{
> 						if(proxy->lowerBounds[1]<=yIndex&&proxy->upperBounds[1]>=yIndex+1)
> 						{
> 							//Add the proxy
> 							if(sortKey)
> 							{
> 								AddProxyResult(proxyId,proxy,maxCount,sortKey);
> 							}
> 							else
> 							{
> 								m_queryResults[m_queryResultCount] = proxyId;
> 								++m_queryResultCount;
> 							}
> 						}
> 					}
> 				}
> 
> 				//Early out
> 				if(sortKey && m_queryResultCount==maxCount && m_queryResultCount>0 && xProgress>m_querySortKeys[m_queryResultCount-1])
> 					break;
> 
> 				//Move on to the next bound
> 				if(sx>0)
> 				{
> 					xIndex++;
> 					if(xIndex==m_proxyCount*2)
> 						break;
> 				}
> 				else
> 				{
> 					xIndex--;
> 					if(xIndex<0)
> 						break;
> 				}
> 				xProgress = ((float32)m_bounds[0][xIndex].value - p1x) / dx;
> 			}
> 			else
> 			{
> 				if(yProgress>maxLambda)
> 					break;
> 
> 				//Check that we are entering a proxy, not leaving
> 				if(sy>0?m_bounds[1][yIndex].IsLower():m_bounds[1][yIndex].IsUpper()){
> 					//Check the other axis of the proxy
> 					proxyId = m_bounds[1][yIndex].proxyId;
> 					proxy = m_proxyPool+proxyId;
> 					if(sx>=0)
> 					{
> 						if(proxy->lowerBounds[0]<=xIndex-1&&proxy->upperBounds[0]>=xIndex)
> 						{
> 							//Add the proxy
> 							if(sortKey)
> 							{
> 								AddProxyResult(proxyId,proxy,maxCount,sortKey);
> 							}
> 							else
> 							{
> 								m_queryResults[m_queryResultCount] = proxyId;
> 								++m_queryResultCount;
> 							}
> 						}
> 					}
> 					else
> 					{
> 						if(proxy->lowerBounds[0]<=xIndex&&proxy->upperBounds[0]>=xIndex+1)
> 						{
> 							//Add the proxy
> 							if(sortKey)
> 							{
> 								AddProxyResult(proxyId,proxy,maxCount,sortKey);
> 							}
> 							else
> 							{
> 								m_queryResults[m_queryResultCount] = proxyId;
> 								++m_queryResultCount;
> 							}
> 						}
> 					}
> 				}
> 
> 				//Early out
> 				if(sortKey && m_queryResultCount==maxCount && m_queryResultCount>0 && yProgress>m_querySortKeys[m_queryResultCount-1])
> 					break;
> 
> 				//Move on to the next bound
> 				if(sy>0)
> 				{
> 					yIndex++;
> 					if(yIndex==m_proxyCount*2)
> 						break;
> 				}
> 				else
> 				{
> 					yIndex--;
> 					if(yIndex<0)
> 						break;
> 				}
> 				yProgress = ((float32)m_bounds[1][yIndex].value - p1y) / dy;
> 			}
> 		}
> 
> 		break;
116,118c897,910
< 	m_pairBuffer[m_pairCount].proxyIdA = b2Min(proxyId, m_queryProxyId);
< 	m_pairBuffer[m_pairCount].proxyIdB = b2Max(proxyId, m_queryProxyId);
< 	++m_pairCount;
---
> 	int32 count = 0;
> 	for(int32 i=0;i < m_queryResultCount && count<maxCount; ++i, ++count)
> 	{
> 		b2Assert(m_queryResults[i] < b2_maxProxies);
> 		b2Proxy* proxy = m_proxyPool + m_queryResults[i];
> 		b2Assert(proxy->IsValid());
> 		userData[i] = proxy->userData;
> 	}
> 
> 	// Prepare for next query.
> 	m_queryResultCount = 0;
> 	IncrementTimeStamp();
> 	
> 	return count;
120d911
< 	return true;
121a913,938
> void b2BroadPhase::AddProxyResult(uint16 proxyId, b2Proxy* proxy, int32 maxCount, SortKeyFunc sortKey)
> {
> 	float32 key = sortKey(proxy->userData);
> 	//Filter proxies on positive keys
> 	if(key<0)
> 		return;
> 	//Merge the new key into the sorted list.
> 	//float32* p = std::lower_bound(m_querySortKeys,m_querySortKeys+m_queryResultCount,key);
> 	float32* p = m_querySortKeys;
> 	while(*p<key&&p<m_querySortKeys+m_queryResultCount)
> 		p++;
> 	int32 i = (int32)(p-m_querySortKeys);
> 	if(maxCount==m_queryResultCount&&i==m_queryResultCount)
> 		return;
> 	if(maxCount==m_queryResultCount)
> 		m_queryResultCount--;
> 	//std::copy_backward
> 	for(int32 j=m_queryResultCount+1;j>i;--j){
> 		m_querySortKeys[j] = m_querySortKeys[j-1];
> 		m_queryResults[j]  = m_queryResults[j-1];
> 	}
> 	m_querySortKeys[i] = key;
> 	m_queryResults[i] = proxyId;
> 	m_queryResultCount++;
> }
> 
diff -r -x './svn/*' native/Box2D/Collision/b2BroadPhase.h ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Collision/b2BroadPhase.h
2c2
< * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
22,25c22,39
< #include <Box2D/Common/b2Settings.h>
< #include <Box2D/Collision/b2Collision.h>
< #include <Box2D/Collision/b2DynamicTree.h>
< #include <algorithm>
---
> /*
> This broad phase uses the Sweep and Prune algorithm as described in:
> Collision Detection in Interactive 3D Environments by Gino van den Bergen
> Also, some ideas, such as using integral values for fast compares comes from
> Bullet (http:/www.bulletphysics.com).
> */
> 
> #include "../Common/b2Settings.h"
> #include "b2Collision.h"
> #include "b2PairManager.h"
> #include <limits.h>
> 
> #ifdef TARGET_FLOAT32_IS_FIXED
> #define	B2BROADPHASE_MAX	(USHRT_MAX/2)
> #else
> #define	B2BROADPHASE_MAX	USHRT_MAX
> 
> #endif
27c41,55
< struct b2Pair
---
> const uint16 b2_invalid = B2BROADPHASE_MAX;
> const uint16 b2_nullEdge = B2BROADPHASE_MAX;
> struct b2BoundValues;
> 
> struct b2Bound
> {
> 	bool IsLower() const { return (value & 1) == 0; }
> 	bool IsUpper() const { return (value & 1) == 1; }
> 
> 	uint16 value;
> 	uint16 proxyId;
> 	uint16 stabbingCount;
> };
> 
> struct b2Proxy
29,30c57,64
< 	int32 proxyIdA;
< 	int32 proxyIdB;
---
> 	uint16 GetNext() const { return lowerBounds[0]; }
> 	void SetNext(uint16 next) { lowerBounds[0] = next; }
> 	bool IsValid() const { return overlapCount != b2_invalid; }
> 
> 	uint16 lowerBounds[2], upperBounds[2];
> 	uint16 overlapCount;
> 	uint16 timeStamp;
> 	void* userData;
33,35c67,68
< /// The broad-phase is used for computing pairs and performing volume queries and ray casts.
< /// This broad-phase does not persist pairs. Instead, this reports potentially new pairs.
< /// It is up to the client to consume the new pairs and to track subsequent overlap.
---
> typedef float32 (*SortKeyFunc)(void* shape);
> 
39,45c72
< 
< 	enum
< 	{
< 		e_nullProxy = -1
< 	};
< 
< 	b2BroadPhase();
---
> 	b2BroadPhase(const b2AABB& worldAABB, b2PairCallback* callback);
48,50c75,78
< 	/// Create a proxy with an initial AABB. Pairs are not reported until
< 	/// UpdatePairs is called.
< 	int32 CreateProxy(const b2AABB& aabb, void* userData);
---
> 	// Use this to see if your proxy is in range. If it is not in range,
> 	// it should be destroyed. Otherwise you may get O(m^2) pairs, where m
> 	// is the number of proxies that are out of range.
> 	bool InRange(const b2AABB& aabb) const;
52c80,81
< 	/// Destroy a proxy. It is up to the client to remove any pairs.
---
> 	// Create and destroy proxies. These call Flush first.
> 	uint16 CreateProxy(const b2AABB& aabb, void* userData);
55,112c84,102
< 	/// Call MoveProxy as many times as you like, then when you are done
< 	/// call UpdatePairs to finalized the proxy pairs (for your time step).
< 	void MoveProxy(int32 proxyId, const b2AABB& aabb, const b2Vec2& displacement);
< 
< 	/// Call to trigger a re-processing of it's pairs on the next call to UpdatePairs.
< 	void TouchProxy(int32 proxyId);
< 
< 	/// Get the fat AABB for a proxy.
< 	const b2AABB& GetFatAABB(int32 proxyId) const;
< 
< 	/// Get user data from a proxy. Returns NULL if the id is invalid.
< 	void* GetUserData(int32 proxyId) const;
< 
< 	/// Test overlap of fat AABBs.
< 	bool TestOverlap(int32 proxyIdA, int32 proxyIdB) const;
< 
< 	/// Get the number of proxies.
< 	int32 GetProxyCount() const;
< 
< 	/// Update the pairs. This results in pair callbacks. This can only add pairs.
< 	template <typename T>
< 	void UpdatePairs(T* callback);
< 
< 	/// Query an AABB for overlapping proxies. The callback class
< 	/// is called for each proxy that overlaps the supplied AABB.
< 	template <typename T>
< 	void Query(T* callback, const b2AABB& aabb) const;
< 
< 	/// Ray-cast against the proxies in the tree. This relies on the callback
< 	/// to perform a exact ray-cast in the case were the proxy contains a shape.
< 	/// The callback also performs the any collision filtering. This has performance
< 	/// roughly equal to k * log(n), where k is the number of collisions and n is the
< 	/// number of proxies in the tree.
< 	/// @param input the ray-cast input data. The ray extends from p1 to p1 + maxFraction * (p2 - p1).
< 	/// @param callback a callback class that is called for each proxy that is hit by the ray.
< 	template <typename T>
< 	void RayCast(T* callback, const b2RayCastInput& input) const;
< 
< 	/// Get the height of the embedded tree.
< 	int32 GetTreeHeight() const;
< 
< 	/// Get the balance of the embedded tree.
< 	int32 GetTreeBalance() const;
< 
< 	/// Get the quality metric of the embedded tree.
< 	float32 GetTreeQuality() const;
< 
< 	/// Shift the world origin. Useful for large worlds.
< 	/// The shift formula is: position -= newOrigin
< 	/// @param newOrigin the new origin with respect to the old origin
< 	void ShiftOrigin(const b2Vec2& newOrigin);
< 
< private:
< 
< 	friend class b2DynamicTree;
< 
< 	void BufferMove(int32 proxyId);
< 	void UnBufferMove(int32 proxyId);
---
> 	// Call MoveProxy as many times as you like, then when you are done
> 	// call Commit to finalized the proxy pairs (for your time step).
> 	void MoveProxy(int32 proxyId, const b2AABB& aabb);
> 	void Commit();
> 
> 	// Get a single proxy. Returns NULL if the id is invalid.
> 	b2Proxy* GetProxy(int32 proxyId);
> 
> 	// Query an AABB for overlapping proxies, returns the user data and
> 	// the count, up to the supplied maximum count.
> 	int32 Query(const b2AABB& aabb, void** userData, int32 maxCount);
> 
> 	// Query a segment for overlapping proxies, returns the user data and
> 	// the count, up to the supplied maximum count.
> 	// If sortKey is provided, then it is a function mapping from proxy userDatas to distances along the segment (between 0 & 1)
> 	// Then the returned proxies are sorted on that, before being truncated to maxCount
> 	// The sortKey of a proxy is assumed to be larger than the closest point inside the proxy along the segment, this allows for early exits
> 	// Proxies with a negative sortKey are discarded
> 	int32 QuerySegment(const b2Segment& segment, void** userData, int32 maxCount, SortKeyFunc sortKey);
114c104,105
< 	bool QueryCallback(int32 proxyId);
---
> 	void Validate();
> 	void ValidatePairs();
116,118c107,108
< 	b2DynamicTree m_tree;
< 
< 	int32 m_proxyCount;
---
> private:
> 	void ComputeBounds(uint16* lowerValues, uint16* upperValues, const b2AABB& aabb);
120,126c110,111
< 	int32* m_moveBuffer;
< 	int32 m_moveCapacity;
< 	int32 m_moveCount;
< 
< 	b2Pair* m_pairBuffer;
< 	int32 m_pairCapacity;
< 	int32 m_pairCount;
---
> 	bool TestOverlap(b2Proxy* p1, b2Proxy* p2);
> 	bool TestOverlap(const b2BoundValues& b, b2Proxy* p);
128,137c113,117
< 	int32 m_queryProxyId;
< };
< 
< /// This is used to sort pairs.
< inline bool b2PairLessThan(const b2Pair& pair1, const b2Pair& pair2)
< {
< 	if (pair1.proxyIdA < pair2.proxyIdA)
< 	{
< 		return true;
< 	}
---
> 	void Query(int32* lowerIndex, int32* upperIndex, uint16 lowerValue, uint16 upperValue,
> 				b2Bound* bounds, int32 boundCount, int32 axis);
> 	void IncrementOverlapCount(int32 proxyId);
> 	void IncrementTimeStamp();
> 	void AddProxyResult(uint16 proxyId, b2Proxy* proxy, int32 maxCount, SortKeyFunc sortKey);
139,142c119,120
< 	if (pair1.proxyIdA == pair2.proxyIdA)
< 	{
< 		return pair1.proxyIdB < pair2.proxyIdB;
< 	}
---
> public:
> 	friend class b2PairManager;
144,145c122
< 	return false;
< }
---
> 	b2PairManager m_pairManager;
147,150c124,125
< inline void* b2BroadPhase::GetUserData(int32 proxyId) const
< {
< 	return m_tree.GetUserData(proxyId);
< }
---
> 	b2Proxy m_proxyPool[b2_maxProxies];
> 	uint16 m_freeProxy;
152,157c127
< inline bool b2BroadPhase::TestOverlap(int32 proxyIdA, int32 proxyIdB) const
< {
< 	const b2AABB& aabbA = m_tree.GetFatAABB(proxyIdA);
< 	const b2AABB& aabbB = m_tree.GetFatAABB(proxyIdB);
< 	return b2TestOverlap(aabbA, aabbB);
< }
---
> 	b2Bound m_bounds[2][2*b2_maxProxies];
159,162c129,131
< inline const b2AABB& b2BroadPhase::GetFatAABB(int32 proxyId) const
< {
< 	return m_tree.GetFatAABB(proxyId);
< }
---
> 	uint16 m_queryResults[b2_maxProxies];
> 	float32 m_querySortKeys[b2_maxProxies];
> 	int32 m_queryResultCount;
164,167c133,136
< inline int32 b2BroadPhase::GetProxyCount() const
< {
< 	return m_proxyCount;
< }
---
> 	b2AABB m_worldAABB;
> 	b2Vec2 m_quantizationFactor;
> 	int32 m_proxyCount;
> 	uint16 m_timeStamp;
169,172c138,139
< inline int32 b2BroadPhase::GetTreeHeight() const
< {
< 	return m_tree.GetHeight();
< }
---
> 	static bool s_validate;
> };
174,177d140
< inline int32 b2BroadPhase::GetTreeBalance() const
< {
< 	return m_tree.GetMaxBalance();
< }
179c142
< inline float32 b2BroadPhase::GetTreeQuality() const
---
> inline bool b2BroadPhase::InRange(const b2AABB& aabb) const
181c144,145
< 	return m_tree.GetAreaRatio();
---
> 	b2Vec2 d = b2Max(aabb.lowerBound - m_worldAABB.upperBound, m_worldAABB.lowerBound - aabb.upperBound);
> 	return b2Max(d.x, d.y) < 0.0f;
184,185c148
< template <typename T>
< void b2BroadPhase::UpdatePairs(T* callback)
---
> inline b2Proxy* b2BroadPhase::GetProxy(int32 proxyId)
187,215c150
< 	// Reset pair buffer
< 	m_pairCount = 0;
< 
< 	// Perform tree queries for all moving proxies.
< 	for (int32 i = 0; i < m_moveCount; ++i)
< 	{
< 		m_queryProxyId = m_moveBuffer[i];
< 		if (m_queryProxyId == e_nullProxy)
< 		{
< 			continue;
< 		}
< 
< 		// We have to query the tree with the fat AABB so that
< 		// we don't fail to create a pair that may touch later.
< 		const b2AABB& fatAABB = m_tree.GetFatAABB(m_queryProxyId);
< 
< 		// Query tree, create pairs and add them pair buffer.
< 		m_tree.Query(this, fatAABB);
< 	}
< 
< 	// Reset move buffer
< 	m_moveCount = 0;
< 
< 	// Sort the pair buffer to expose duplicates.
< 	std::sort(m_pairBuffer, m_pairBuffer + m_pairCount, b2PairLessThan);
< 
< 	// Send the pairs back to the client.
< 	int32 i = 0;
< 	while (i < m_pairCount)
---
> 	if (proxyId == b2_nullProxy || m_proxyPool[proxyId].IsValid() == false)
217,233c152
< 		b2Pair* primaryPair = m_pairBuffer + i;
< 		void* userDataA = m_tree.GetUserData(primaryPair->proxyIdA);
< 		void* userDataB = m_tree.GetUserData(primaryPair->proxyIdB);
< 
< 		callback->AddPair(userDataA, userDataB);
< 		++i;
< 
< 		// Skip any duplicate pairs.
< 		while (i < m_pairCount)
< 		{
< 			b2Pair* pair = m_pairBuffer + i;
< 			if (pair->proxyIdA != primaryPair->proxyIdA || pair->proxyIdB != primaryPair->proxyIdB)
< 			{
< 				break;
< 			}
< 			++i;
< 		}
---
> 		return NULL;
236,254c155
< 	// Try to keep the tree balanced.
< 	//m_tree.Rebalance(4);
< }
< 
< template <typename T>
< inline void b2BroadPhase::Query(T* callback, const b2AABB& aabb) const
< {
< 	m_tree.Query(callback, aabb);
< }
< 
< template <typename T>
< inline void b2BroadPhase::RayCast(T* callback, const b2RayCastInput& input) const
< {
< 	m_tree.RayCast(callback, input);
< }
< 
< inline void b2BroadPhase::ShiftOrigin(const b2Vec2& newOrigin)
< {
< 	m_tree.ShiftOrigin(newOrigin);
---
> 	return m_proxyPool + proxyId;
diff -r -x './svn/*' native/Box2D/Collision/b2CollideCircle.cpp ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Collision/b2CollideCircle.cpp
2c2
< * Copyright (c) 2007-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2007 Erin Catto http://www.gphysics.com
19,21c19,21
< #include <Box2D/Collision/b2Collision.h>
< #include <Box2D/Collision/Shapes/b2CircleShape.h>
< #include <Box2D/Collision/Shapes/b2PolygonShape.h>
---
> #include "b2Collision.h"
> #include "Shapes/b2CircleShape.h"
> #include "Shapes/b2PolygonShape.h"
25,26c25,26
< 	const b2CircleShape* circleA, const b2Transform& xfA,
< 	const b2CircleShape* circleB, const b2Transform& xfB)
---
> 	const b2CircleShape* circle1, const b2XForm& xf1,
> 	const b2CircleShape* circle2, const b2XForm& xf2)
30,31c30,31
< 	b2Vec2 pA = b2Mul(xfA, circleA->m_p);
< 	b2Vec2 pB = b2Mul(xfB, circleB->m_p);
---
> 	b2Vec2 p1 = b2Mul(xf1, circle1->GetLocalPosition());
> 	b2Vec2 p2 = b2Mul(xf2, circle2->GetLocalPosition());
33c33
< 	b2Vec2 d = pB - pA;
---
> 	b2Vec2 d = p2 - p1;
35,37c35,38
< 	float32 rA = circleA->m_radius, rB = circleB->m_radius;
< 	float32 radius = rA + rB;
< 	if (distSqr > radius * radius)
---
> 	float32 r1 = circle1->GetRadius();
> 	float32 r2 = circle2->GetRadius();
> 	float32 radiusSum = r1 + r2;
> 	if (distSqr > radiusSum * radiusSum)
42,45c43,56
< 	manifold->type = b2Manifold::e_circles;
< 	manifold->localPoint = circleA->m_p;
< 	manifold->localNormal.SetZero();
< 	manifold->pointCount = 1;
---
> 	float32 separation;
> 	if (distSqr < B2_FLT_EPSILON)
> 	{
> 		separation = -radiusSum;
> 		manifold->normal.Set(0.0f, 1.0f);
> 	}
> 	else
> 	{
> 		float32 dist = b2Sqrt(distSqr);
> 		separation = dist - radiusSum;
> 		float32 a = 1.0f / dist;
> 		manifold->normal.x = a * d.x;
> 		manifold->normal.y = a * d.y;
> 	}
47c58
< 	manifold->points[0].localPoint = circleB->m_p;
---
> 	manifold->pointCount = 1;
48a60,68
> 	manifold->points[0].separation = separation;
> 
> 	p1 += r1 * manifold->normal;
> 	p2 -= r2 * manifold->normal;
> 
> 	b2Vec2 p = 0.5f * (p1 + p2);
> 
> 	manifold->points[0].localPoint1 = b2MulT(xf1, p);
> 	manifold->points[0].localPoint2 = b2MulT(xf2, p);
53,54c73,74
< 	const b2PolygonShape* polygonA, const b2Transform& xfA,
< 	const b2CircleShape* circleB, const b2Transform& xfB)
---
> 	const b2PolygonShape* polygon, const b2XForm& xf1,
> 	const b2CircleShape* circle, const b2XForm& xf2)
59,60c79,80
< 	b2Vec2 c = b2Mul(xfB, circleB->m_p);
< 	b2Vec2 cLocal = b2MulT(xfA, c);
---
> 	b2Vec2 c = b2Mul(xf2, circle->GetLocalPosition());
> 	b2Vec2 cLocal = b2MulT(xf1, c);
64,68c84,88
< 	float32 separation = -b2_maxFloat;
< 	float32 radius = polygonA->m_radius + circleB->m_radius;
< 	int32 vertexCount = polygonA->m_count;
< 	const b2Vec2* vertices = polygonA->m_vertices;
< 	const b2Vec2* normals = polygonA->m_normals;
---
> 	float32 separation = -B2_FLT_MAX;
> 	float32 radius = circle->GetRadius();
> 	int32 vertexCount = polygon->GetVertexCount();
> 	const b2Vec2* vertices = polygon->GetVertices();
> 	const b2Vec2* normals = polygon->GetNormals();
87,92d106
< 	// Vertices that subtend the incident face.
< 	int32 vertIndex1 = normalIndex;
< 	int32 vertIndex2 = vertIndex1 + 1 < vertexCount ? vertIndex1 + 1 : 0;
< 	b2Vec2 v1 = vertices[vertIndex1];
< 	b2Vec2 v2 = vertices[vertIndex2];
< 
94c108
< 	if (separation < b2_epsilon)
---
> 	if (separation < B2_FLT_EPSILON)
97,101c111,119
< 		manifold->type = b2Manifold::e_faceA;
< 		manifold->localNormal = normals[normalIndex];
< 		manifold->localPoint = 0.5f * (v1 + v2);
< 		manifold->points[0].localPoint = circleB->m_p;
< 		manifold->points[0].id.key = 0;
---
> 		manifold->normal = b2Mul(xf1.R, normals[normalIndex]);
> 		manifold->points[0].id.features.incidentEdge = (uint8)normalIndex;
> 		manifold->points[0].id.features.incidentVertex = b2_nullFeature;
> 		manifold->points[0].id.features.referenceEdge = 0;
> 		manifold->points[0].id.features.flip = 0;
> 		b2Vec2 position = c - radius * manifold->normal;
> 		manifold->points[0].localPoint1 = b2MulT(xf1, position);
> 		manifold->points[0].localPoint2 = b2MulT(xf2, position);
> 		manifold->points[0].separation = separation - radius;
105,113c123,126
< 	// Compute barycentric coordinates
< 	float32 u1 = b2Dot(cLocal - v1, v2 - v1);
< 	float32 u2 = b2Dot(cLocal - v2, v1 - v2);
< 	if (u1 <= 0.0f)
< 	{
< 		if (b2DistanceSquared(cLocal, v1) > radius * radius)
< 		{
< 			return;
< 		}
---
> 	// Project the circle center onto the edge segment.
> 	int32 vertIndex1 = normalIndex;
> 	int32 vertIndex2 = vertIndex1 + 1 < vertexCount ? vertIndex1 + 1 : 0;
> 	b2Vec2 e = vertices[vertIndex2] - vertices[vertIndex1];
115,121c128,138
< 		manifold->pointCount = 1;
< 		manifold->type = b2Manifold::e_faceA;
< 		manifold->localNormal = cLocal - v1;
< 		manifold->localNormal.Normalize();
< 		manifold->localPoint = v1;
< 		manifold->points[0].localPoint = circleB->m_p;
< 		manifold->points[0].id.key = 0;
---
> 	float32 length = e.Normalize();
> 	b2Assert(length > B2_FLT_EPSILON);
> 
> 	// Project the center onto the edge.
> 	float32 u = b2Dot(cLocal - vertices[vertIndex1], e);
> 	b2Vec2 p;
> 	if (u <= 0.0f)
> 	{
> 		p = vertices[vertIndex1];
> 		manifold->points[0].id.features.incidentEdge = b2_nullFeature;
> 		manifold->points[0].id.features.incidentVertex = (uint8)vertIndex1;
123c140
< 	else if (u2 <= 0.0f)
---
> 	else if (u >= length)
125,136c142,144
< 		if (b2DistanceSquared(cLocal, v2) > radius * radius)
< 		{
< 			return;
< 		}
< 
< 		manifold->pointCount = 1;
< 		manifold->type = b2Manifold::e_faceA;
< 		manifold->localNormal = cLocal - v2;
< 		manifold->localNormal.Normalize();
< 		manifold->localPoint = v2;
< 		manifold->points[0].localPoint = circleB->m_p;
< 		manifold->points[0].id.key = 0;
---
> 		p = vertices[vertIndex2];
> 		manifold->points[0].id.features.incidentEdge = b2_nullFeature;
> 		manifold->points[0].id.features.incidentVertex = (uint8)vertIndex2;
140,145c148,151
< 		b2Vec2 faceCenter = 0.5f * (v1 + v2);
< 		float32 separation = b2Dot(cLocal - faceCenter, normals[vertIndex1]);
< 		if (separation > radius)
< 		{
< 			return;
< 		}
---
> 		p = vertices[vertIndex1] + u * e;
> 		manifold->points[0].id.features.incidentEdge = (uint8)normalIndex;
> 		manifold->points[0].id.features.incidentVertex = b2_nullFeature;
> 	}
147,152c153,157
< 		manifold->pointCount = 1;
< 		manifold->type = b2Manifold::e_faceA;
< 		manifold->localNormal = normals[vertIndex1];
< 		manifold->localPoint = faceCenter;
< 		manifold->points[0].localPoint = circleB->m_p;
< 		manifold->points[0].id.key = 0;
---
> 	b2Vec2 d = cLocal - p;
> 	float32 dist = d.Normalize();
> 	if (dist > radius)
> 	{
> 		return;
153a159,167
> 
> 	manifold->pointCount = 1;
> 	manifold->normal = b2Mul(xf1.R, d);
> 	b2Vec2 position = c - radius * manifold->normal;
> 	manifold->points[0].localPoint1 = b2MulT(xf1, position);
> 	manifold->points[0].localPoint2 = b2MulT(xf2, position);
> 	manifold->points[0].separation = dist - radius;
> 	manifold->points[0].id.features.referenceEdge = 0;
> 	manifold->points[0].id.features.flip = 0;
Only in native/Box2D/Collision: b2CollideEdge.cpp
Only in ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Collision: b2CollidePoly.cpp
Only in native/Box2D/Collision: b2CollidePolygon.cpp
diff -r -x './svn/*' native/Box2D/Collision/b2Collision.cpp ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Collision/b2Collision.cpp
2c2
< * Copyright (c) 2007-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2007 Erin Catto http://www.gphysics.com
19,20c19
< #include <Box2D/Collision/b2Collision.h>
< #include <Box2D/Collision/b2Distance.h>
---
> #include "b2Collision.h"
22,24c21,36
< void b2WorldManifold::Initialize(const b2Manifold* manifold,
< 						  const b2Transform& xfA, float32 radiusA,
< 						  const b2Transform& xfB, float32 radiusB)
---
> // Collision Detection in Interactive 3D Environments by Gino van den Bergen
> // From Section 3.4.1
> // x = mu1 * p1 + mu2 * p2
> // mu1 + mu2 = 1 && mu1 >= 0 && mu2 >= 0
> // mu1 = 1 - mu2;
> // x = (1 - mu2) * p1 + mu2 * p2
> //   = p1 + mu2 * (p2 - p1)
> // x = s + a * r (s := start, r := end - start)
> // s + a * r = p1 + mu2 * d (d := p2 - p1)
> // -a * r + mu2 * d = b (b := s - p1)
> // [-r d] * [a; mu2] = b
> // Cramer's rule:
> // denom = det[-r d]
> // a = det[b d] / denom
> // mu2 = det[-r b] / denom
> bool b2Segment::TestSegment(float32* lambda, b2Vec2* normal, const b2Segment& segment, float32 maxLambda) const
26,76c38,41
< 	if (manifold->pointCount == 0)
< 	{
< 		return;
< 	}
< 
< 	switch (manifold->type)
< 	{
< 	case b2Manifold::e_circles:
< 		{
< 			normal.Set(1.0f, 0.0f);
< 			b2Vec2 pointA = b2Mul(xfA, manifold->localPoint);
< 			b2Vec2 pointB = b2Mul(xfB, manifold->points[0].localPoint);
< 			if (b2DistanceSquared(pointA, pointB) > b2_epsilon * b2_epsilon)
< 			{
< 				normal = pointB - pointA;
< 				normal.Normalize();
< 			}
< 
< 			b2Vec2 cA = pointA + radiusA * normal;
< 			b2Vec2 cB = pointB - radiusB * normal;
< 			points[0] = 0.5f * (cA + cB);
< 		}
< 		break;
< 
< 	case b2Manifold::e_faceA:
< 		{
< 			normal = b2Mul(xfA.q, manifold->localNormal);
< 			b2Vec2 planePoint = b2Mul(xfA, manifold->localPoint);
< 			
< 			for (int32 i = 0; i < manifold->pointCount; ++i)
< 			{
< 				b2Vec2 clipPoint = b2Mul(xfB, manifold->points[i].localPoint);
< 				b2Vec2 cA = clipPoint + (radiusA - b2Dot(clipPoint - planePoint, normal)) * normal;
< 				b2Vec2 cB = clipPoint - radiusB * normal;
< 				points[i] = 0.5f * (cA + cB);
< 			}
< 		}
< 		break;
< 
< 	case b2Manifold::e_faceB:
< 		{
< 			normal = b2Mul(xfB.q, manifold->localNormal);
< 			b2Vec2 planePoint = b2Mul(xfB, manifold->localPoint);
< 
< 			for (int32 i = 0; i < manifold->pointCount; ++i)
< 			{
< 				b2Vec2 clipPoint = b2Mul(xfA, manifold->points[i].localPoint);
< 				b2Vec2 cB = clipPoint + (radiusB - b2Dot(clipPoint - planePoint, normal)) * normal;
< 				b2Vec2 cA = clipPoint - radiusA * normal;
< 				points[i] = 0.5f * (cA + cB);
< 			}
---
> 	b2Vec2 s = segment.p1;
> 	b2Vec2 r = segment.p2 - s;
> 	b2Vec2 d = p2 - p1;
> 	b2Vec2 n = b2Cross(d, 1.0f);
78,92c43,44
< 			// Ensure normal points from A to B.
< 			normal = -normal;
< 		}
< 		break;
< 	}
< }
< 
< void b2GetPointStates(b2PointState state1[b2_maxManifoldPoints], b2PointState state2[b2_maxManifoldPoints],
< 					  const b2Manifold* manifold1, const b2Manifold* manifold2)
< {
< 	for (int32 i = 0; i < b2_maxManifoldPoints; ++i)
< 	{
< 		state1[i] = b2_nullState;
< 		state2[i] = b2_nullState;
< 	}
---
> 	const float32 k_slop = 100.0f * B2_FLT_EPSILON;
> 	float32 denom = -b2Dot(r, n);
94,95c46,47
< 	// Detect persists and removes.
< 	for (int32 i = 0; i < manifold1->pointCount; ++i)
---
> 	// Cull back facing collision and ignore parallel segments.
> 	if (denom > k_slop)
97,127c49,51
< 		b2ContactID id = manifold1->points[i].id;
< 
< 		state1[i] = b2_removeState;
< 
< 		for (int32 j = 0; j < manifold2->pointCount; ++j)
< 		{
< 			if (manifold2->points[j].id.key == id.key)
< 			{
< 				state1[i] = b2_persistState;
< 				break;
< 			}
< 		}
< 	}
< 
< 	// Detect persists and adds.
< 	for (int32 i = 0; i < manifold2->pointCount; ++i)
< 	{
< 		b2ContactID id = manifold2->points[i].id;
< 
< 		state2[i] = b2_addState;
< 
< 		for (int32 j = 0; j < manifold1->pointCount; ++j)
< 		{
< 			if (manifold1->points[j].id.key == id.key)
< 			{
< 				state2[i] = b2_persistState;
< 				break;
< 			}
< 		}
< 	}
< }
---
> 		// Does the segment intersect the infinite line associated with this segment?
> 		b2Vec2 b = s - p1;
> 		float32 a = b2Dot(b, n);
129,143c53
< // From Real-time Collision Detection, p179.
< bool b2AABB::RayCast(b2RayCastOutput* output, const b2RayCastInput& input) const
< {
< 	float32 tmin = -b2_maxFloat;
< 	float32 tmax = b2_maxFloat;
< 
< 	b2Vec2 p = input.p1;
< 	b2Vec2 d = input.p2 - input.p1;
< 	b2Vec2 absD = b2Abs(d);
< 
< 	b2Vec2 normal;
< 
< 	for (int32 i = 0; i < 2; ++i)
< 	{
< 		if (absD(i) < b2_epsilon)
---
> 		if (0.0f <= a && a <= maxLambda * denom)
145,175c55
< 			// Parallel.
< 			if (p(i) < lowerBound(i) || upperBound(i) < p(i))
< 			{
< 				return false;
< 			}
< 		}
< 		else
< 		{
< 			float32 inv_d = 1.0f / d(i);
< 			float32 t1 = (lowerBound(i) - p(i)) * inv_d;
< 			float32 t2 = (upperBound(i) - p(i)) * inv_d;
< 
< 			// Sign of the normal vector.
< 			float32 s = -1.0f;
< 
< 			if (t1 > t2)
< 			{
< 				b2Swap(t1, t2);
< 				s = 1.0f;
< 			}
< 
< 			// Push the min up
< 			if (t1 > tmin)
< 			{
< 				normal.SetZero();
< 				normal(i) = s;
< 				tmin = t1;
< 			}
< 
< 			// Pull the max down
< 			tmax = b2Min(tmax, t2);
---
> 			float32 mu2 = -r.x * b.y + r.y * b.x;
177c57,58
< 			if (tmin > tmax)
---
> 			// Does the segment intersect this segment?
> 			if (-k_slop * denom <= mu2 && mu2 <= denom * (1.0f + k_slop))
179c60,64
< 				return false;
---
> 				a /= denom;
> 				n.Normalize();
> 				*lambda = a;
> 				*normal = n;
> 				return true;
184,194c69
< 	// Does the ray start inside the box?
< 	// Does the ray intersect beyond the max fraction?
< 	if (tmin < 0.0f || input.maxFraction < tmin)
< 	{
< 		return false;
< 	}
< 
< 	// Intersection.
< 	output->fraction = tmin;
< 	output->normal = normal;
< 	return true;
---
> 	return false;
197,210d71
< // Sutherland-Hodgman clipping.
< int32 b2ClipSegmentToLine(b2ClipVertex vOut[2], const b2ClipVertex vIn[2],
< 						const b2Vec2& normal, float32 offset, int32 vertexIndexA)
< {
< 	// Start with no output points
< 	int32 numOut = 0;
< 
< 	// Calculate the distance of end points to the line
< 	float32 distance0 = b2Dot(normal, vIn[0].v) - offset;
< 	float32 distance1 = b2Dot(normal, vIn[1].v) - offset;
< 
< 	// If the points are behind the plane
< 	if (distance0 <= 0.0f) vOut[numOut++] = vIn[0];
< 	if (distance1 <= 0.0f) vOut[numOut++] = vIn[1];
212,249d72
< 	// If the points are on different sides of the plane
< 	if (distance0 * distance1 < 0.0f)
< 	{
< 		// Find intersection point of edge and plane
< 		float32 interp = distance0 / (distance0 - distance1);
< 		vOut[numOut].v = vIn[0].v + interp * (vIn[1].v - vIn[0].v);
< 
< 		// VertexA is hitting edgeB.
< 		vOut[numOut].id.cf.indexA = vertexIndexA;
< 		vOut[numOut].id.cf.indexB = vIn[0].id.cf.indexB;
< 		vOut[numOut].id.cf.typeA = b2ContactFeature::e_vertex;
< 		vOut[numOut].id.cf.typeB = b2ContactFeature::e_face;
< 		++numOut;
< 	}
< 
< 	return numOut;
< }
< 
< bool b2TestOverlap(	const b2Shape* shapeA, int32 indexA,
< 					const b2Shape* shapeB, int32 indexB,
< 					const b2Transform& xfA, const b2Transform& xfB)
< {
< 	b2DistanceInput input;
< 	input.proxyA.Set(shapeA, indexA);
< 	input.proxyB.Set(shapeB, indexB);
< 	input.transformA = xfA;
< 	input.transformB = xfB;
< 	input.useRadii = true;
< 
< 	b2SimplexCache cache;
< 	cache.count = 0;
< 
< 	b2DistanceOutput output;
< 
< 	b2Distance(&output, &cache, &input);
< 
< 	return output.distance < 10.0f * b2_epsilon;
< }
diff -r -x './svn/*' native/Box2D/Collision/b2Collision.h ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Collision/b2Collision.h
2c2
< * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
22,23c22,23
< #include <Box2D/Common/b2Math.h>
< #include <climits>
---
> #include "../Common/b2Math.h"
> #include <limits.h>
31d30
< class b2EdgeShape;
32a32
> class b2EdgeShape;
36,51d35
< /// The features that intersect to form the contact point
< /// This must be 4 bytes or less.
< struct b2ContactFeature
< {
< 	enum Type
< 	{
< 		e_vertex = 0,
< 		e_face = 1
< 	};
< 
< 	uint8 indexA;		///< Feature index on shapeA
< 	uint8 indexB;		///< Feature index on shapeB
< 	uint8 typeA;		///< The feature type on shapeA
< 	uint8 typeB;		///< The feature type on shapeB
< };
< 
55c39,46
< 	b2ContactFeature cf;
---
> 	/// The features that intersect to form the contact point
> 	struct Features
> 	{
> 		uint8 referenceEdge;	///< The edge that defines the outward contact normal.
> 		uint8 incidentEdge;		///< The edge most anti-parallel to the reference edge.
> 		uint8 incidentVertex;	///< The vertex (0 or 1) on the incident edge that was clipped.
> 		uint8 flip;				///< A value of 1 indicates that the reference edge is on shape2.
> 	} features;
62,68c53,54
< /// The local point usage depends on the manifold type:
< /// -e_circles: the local center of circleB
< /// -e_faceA: the local center of cirlceB or the clip point of polygonB
< /// -e_faceB: the clip point of polygonA
< /// This structure is stored across time steps, so we keep it small.
< /// Note: the impulses are used for internal caching and may not
< /// provide reliable contact forces, especially for high speed collisions.
---
> /// The point is stored in local coordinates because CCD
> /// requires sub-stepping in which the separation is stale.
71c57,59
< 	b2Vec2 localPoint;		///< usage depends on manifold type
---
> 	b2Vec2 localPoint1;		///< local position of the contact point in body1
> 	b2Vec2 localPoint2;		///< local position of the contact point in body2
> 	float32 separation;		///< the separation of the shapes along the normal vector
78,92d65
< /// Box2D supports multiple types of contact:
< /// - clip point versus plane with radius
< /// - point versus point with radius (circles)
< /// The local point usage depends on the manifold type:
< /// -e_circles: the local center of circleA
< /// -e_faceA: the center of faceA
< /// -e_faceB: the center of faceB
< /// Similarly the local normal usage:
< /// -e_circles: not used
< /// -e_faceA: the normal on polygonA
< /// -e_faceB: the normal on polygonB
< /// We store contacts in this way so that position correction can
< /// account for movement, which is critical for continuous physics.
< /// All contact scenarios must be expressed in one of these types.
< /// This structure is stored across time steps, so we keep it small.
95,101d67
< 	enum Type
< 	{
< 		e_circles,
< 		e_faceA,
< 		e_faceB
< 	};
< 
103,142c69,70
< 	b2Vec2 localNormal;								///< not use for Type::e_points
< 	b2Vec2 localPoint;								///< usage depends on manifold type
< 	Type type;
< 	int32 pointCount;								///< the number of manifold points
< };
< 
< /// This is used to compute the current state of a contact manifold.
< struct b2WorldManifold
< {
< 	/// Evaluate the manifold with supplied transforms. This assumes
< 	/// modest motion from the original state. This does not change the
< 	/// point count, impulses, etc. The radii must come from the shapes
< 	/// that generated the manifold.
< 	void Initialize(const b2Manifold* manifold,
< 					const b2Transform& xfA, float32 radiusA,
< 					const b2Transform& xfB, float32 radiusB);
< 
< 	b2Vec2 normal;							///< world vector pointing from A to B
< 	b2Vec2 points[b2_maxManifoldPoints];	///< world contact point (point of intersection)
< };
< 
< /// This is used for determining the state of contact points.
< enum b2PointState
< {
< 	b2_nullState,		///< point does not exist
< 	b2_addState,		///< point was added in the update
< 	b2_persistState,	///< point persisted across the update
< 	b2_removeState		///< point was removed in the update
< };
< 
< /// Compute the point states given two manifolds. The states pertain to the transition from manifold1
< /// to manifold2. So state1 is either persist or remove while state2 is either add or persist.
< void b2GetPointStates(b2PointState state1[b2_maxManifoldPoints], b2PointState state2[b2_maxManifoldPoints],
< 					  const b2Manifold* manifold1, const b2Manifold* manifold2);
< 
< /// Used for computing contact manifolds.
< struct b2ClipVertex
< {
< 	b2Vec2 v;
< 	b2ContactID id;
---
> 	b2Vec2 normal;	///< the shared unit normal vector
> 	int32 pointCount;	///< the number of manifold points
145,146c73,74
< /// Ray-cast input data. The ray extends from p1 to p1 + maxFraction * (p2 - p1).
< struct b2RayCastInput
---
> /// A line segment.
> struct b2Segment
148,150c76,77
< 	b2Vec2 p1, p2;
< 	float32 maxFraction;
< };
---
> 	/// Ray cast against this segment with another segment.
> 	bool TestSegment(float32* lambda, b2Vec2* normal, const b2Segment& segment, float32 maxLambda) const;
152,157c79,80
< /// Ray-cast output data. The ray hits at p1 + fraction * (p2 - p1), where p1 and p2
< /// come from b2RayCastInput.
< struct b2RayCastOutput
< {
< 	b2Vec2 normal;
< 	float32 fraction;
---
> 	b2Vec2 p1;	///< the starting point
> 	b2Vec2 p2;	///< the ending point
166,212d88
< 	/// Get the center of the AABB.
< 	b2Vec2 GetCenter() const
< 	{
< 		return 0.5f * (lowerBound + upperBound);
< 	}
< 
< 	/// Get the extents of the AABB (half-widths).
< 	b2Vec2 GetExtents() const
< 	{
< 		return 0.5f * (upperBound - lowerBound);
< 	}
< 
< 	/// Get the perimeter length
< 	float32 GetPerimeter() const
< 	{
< 		float32 wx = upperBound.x - lowerBound.x;
< 		float32 wy = upperBound.y - lowerBound.y;
< 		return 2.0f * (wx + wy);
< 	}
< 
< 	/// Combine an AABB into this one.
< 	void Combine(const b2AABB& aabb)
< 	{
< 		lowerBound = b2Min(lowerBound, aabb.lowerBound);
< 		upperBound = b2Max(upperBound, aabb.upperBound);
< 	}
< 
< 	/// Combine two AABBs into this one.
< 	void Combine(const b2AABB& aabb1, const b2AABB& aabb2)
< 	{
< 		lowerBound = b2Min(aabb1.lowerBound, aabb2.lowerBound);
< 		upperBound = b2Max(aabb1.upperBound, aabb2.upperBound);
< 	}
< 
< 	/// Does this aabb contain the provided AABB.
< 	bool Contains(const b2AABB& aabb) const
< 	{
< 		bool result = true;
< 		result = result && lowerBound.x <= aabb.lowerBound.x;
< 		result = result && lowerBound.y <= aabb.lowerBound.y;
< 		result = result && aabb.upperBound.x <= upperBound.x;
< 		result = result && aabb.upperBound.y <= upperBound.y;
< 		return result;
< 	}
< 
< 	bool RayCast(b2RayCastOutput* output, const b2RayCastInput& input) const;
< 
216a93,100
> /// An oriented bounding box.
> struct b2OBB
> {
> 	b2Mat22 R;			///< the rotation matrix
> 	b2Vec2 center;		///< the local centroid
> 	b2Vec2 extents;		///< the half-widths
> };
> 
219,220c103,104
< 					  const b2CircleShape* circleA, const b2Transform& xfA,
< 					  const b2CircleShape* circleB, const b2Transform& xfB);
---
> 					  const b2CircleShape* circle1, const b2XForm& xf1,
> 					  const b2CircleShape* circle2, const b2XForm& xf2);
224,225c108,109
< 							   const b2PolygonShape* polygonA, const b2Transform& xfA,
< 							   const b2CircleShape* circleB, const b2Transform& xfB);
---
> 							   const b2PolygonShape* polygon, const b2XForm& xf1,
> 							   const b2CircleShape* circle, const b2XForm& xf2);
227c111
< /// Compute the collision manifold between two polygons.
---
> /// Compute the collision manifold between two circles.
229,230c113,127
< 					   const b2PolygonShape* polygonA, const b2Transform& xfA,
< 					   const b2PolygonShape* polygonB, const b2Transform& xfB);
---
> 					   const b2PolygonShape* polygon1, const b2XForm& xf1,
> 					   const b2PolygonShape* polygon2, const b2XForm& xf2);
> 
> /// Compute the distance between two shapes and the closest points.
> /// @return the distance between the shapes or zero if they are overlapped/touching.
> float32 b2Distance(b2Vec2* x1, b2Vec2* x2,
> 				   const b2Shape* shape1, const b2XForm& xf1,
> 				   const b2Shape* shape2, const b2XForm& xf2);
> 
> /// Compute the time when two shapes begin to touch or touch at a closer distance.
> /// @warning the sweeps must have the same time interval.
> /// @return the fraction between [0,1] in which the shapes first touch.
> /// fraction=0 means the shapes begin touching/overlapped, and fraction=1 means the shapes don't touch.
> float32 b2TimeOfImpact(const b2Shape* shape1, const b2Sweep& sweep1,
> 					   const b2Shape* shape2, const b2Sweep& sweep2);
232,249d128
< /// Compute the collision manifold between an edge and a circle.
< void b2CollideEdgeAndCircle(b2Manifold* manifold,
< 							   const b2EdgeShape* polygonA, const b2Transform& xfA,
< 							   const b2CircleShape* circleB, const b2Transform& xfB);
< 
< /// Compute the collision manifold between an edge and a circle.
< void b2CollideEdgeAndPolygon(b2Manifold* manifold,
< 							   const b2EdgeShape* edgeA, const b2Transform& xfA,
< 							   const b2PolygonShape* circleB, const b2Transform& xfB);
< 
< /// Clipping for contact manifolds.
< int32 b2ClipSegmentToLine(b2ClipVertex vOut[2], const b2ClipVertex vIn[2],
< 							const b2Vec2& normal, float32 offset, int32 vertexIndexA);
< 
< /// Determine if two generic shapes overlap.
< bool b2TestOverlap(	const b2Shape* shapeA, int32 indexA,
< 					const b2Shape* shapeB, int32 indexB,
< 					const b2Transform& xfA, const b2Transform& xfB);
diff -r -x './svn/*' native/Box2D/Collision/b2Distance.cpp ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Collision/b2Distance.cpp
2c2
< * Copyright (c) 2007-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2007 Erin Catto http://www.gphysics.com
19,23c19,54
< #include <Box2D/Collision/b2Distance.h>
< #include <Box2D/Collision/Shapes/b2CircleShape.h>
< #include <Box2D/Collision/Shapes/b2EdgeShape.h>
< #include <Box2D/Collision/Shapes/b2ChainShape.h>
< #include <Box2D/Collision/Shapes/b2PolygonShape.h>
---
> #include "b2Collision.h"
> #include "Shapes/b2CircleShape.h"
> #include "Shapes/b2PolygonShape.h"
> #include "Shapes/b2EdgeShape.h"
> 
> int32 g_GJK_Iterations = 0;
> 
> // GJK using Voronoi regions (Christer Ericson) and region selection
> // optimizations (Casey Muratori).
> 
> // The origin is either in the region of points[1] or in the edge region. The origin is
> // not in region of points[0] because that is the old point.
> static int32 ProcessTwo(b2Vec2* x1, b2Vec2* x2, b2Vec2* p1s, b2Vec2* p2s, b2Vec2* points)
> {
> 	// If in point[1] region
> 	b2Vec2 r = -points[1];
> 	b2Vec2 d = points[0] - points[1];
> 	float32 length = d.Normalize();
> 	float32 lambda = b2Dot(r, d);
> 	if (lambda <= 0.0f || length < B2_FLT_EPSILON)
> 	{
> 		// The simplex is reduced to a point.
> 		*x1 = p1s[1];
> 		*x2 = p2s[1];
> 		p1s[0] = p1s[1];
> 		p2s[0] = p2s[1];
> 		points[0] = points[1];
> 		return 1;
> 	}
> 
> 	// Else in edge region
> 	lambda /= length;
> 	*x1 = p1s[1] + lambda * (p1s[0] - p1s[1]);
> 	*x2 = p2s[1] + lambda * (p2s[0] - p2s[1]);
> 	return 2;
> }
25,26c56,147
< // GJK using Voronoi regions (Christer Ericson) and Barycentric coordinates.
< int32 b2_gjkCalls, b2_gjkIters, b2_gjkMaxIters;
---
> // Possible regions:
> // - points[2]
> // - edge points[0]-points[2]
> // - edge points[1]-points[2]
> // - inside the triangle
> static int32 ProcessThree(b2Vec2* x1, b2Vec2* x2, b2Vec2* p1s, b2Vec2* p2s, b2Vec2* points)
> {
> 	b2Vec2 a = points[0];
> 	b2Vec2 b = points[1];
> 	b2Vec2 c = points[2];
> 
> 	b2Vec2 ab = b - a;
> 	b2Vec2 ac = c - a;
> 	b2Vec2 bc = c - b;
> 
> 	float32 sn = -b2Dot(a, ab), sd = b2Dot(b, ab);
> 	float32 tn = -b2Dot(a, ac), td = b2Dot(c, ac);
> 	float32 un = -b2Dot(b, bc), ud = b2Dot(c, bc);
> 
> 	// In vertex c region?
> 	if (td <= 0.0f && ud <= 0.0f)
> 	{
> 		// Single point
> 		*x1 = p1s[2];
> 		*x2 = p2s[2];
> 		p1s[0] = p1s[2];
> 		p2s[0] = p2s[2];
> 		points[0] = points[2];
> 		return 1;
> 	}
> 
> 	// Should not be in vertex a or b region.
> 	B2_NOT_USED(sd);
> 	B2_NOT_USED(sn);
> 	b2Assert(sn > 0.0f || tn > 0.0f);
> 	b2Assert(sd > 0.0f || un > 0.0f);
> 
> 	float32 n = b2Cross(ab, ac);
> 
> #ifdef TARGET_FLOAT32_IS_FIXED
> 	n = (n < 0.0)? -1.0 : ((n > 0.0)? 1.0 : 0.0);
> #endif
> 
> 	// Should not be in edge ab region.
> 	float32 vc = n * b2Cross(a, b);
> 	b2Assert(vc > 0.0f || sn > 0.0f || sd > 0.0f);
> 
> 	// In edge bc region?
> 	float32 va = n * b2Cross(b, c);
> 	if (va <= 0.0f && un >= 0.0f && ud >= 0.0f && (un+ud) > 0.0f)
> 	{
> 		b2Assert(un + ud > 0.0f);
> 		float32 lambda = un / (un + ud);
> 		*x1 = p1s[1] + lambda * (p1s[2] - p1s[1]);
> 		*x2 = p2s[1] + lambda * (p2s[2] - p2s[1]);
> 		p1s[0] = p1s[2];
> 		p2s[0] = p2s[2];
> 		points[0] = points[2];
> 		return 2;
> 	}
> 
> 	// In edge ac region?
> 	float32 vb = n * b2Cross(c, a);
> 	if (vb <= 0.0f && tn >= 0.0f && td >= 0.0f && (tn+td) > 0.0f)
> 	{
> 		b2Assert(tn + td > 0.0f);
> 		float32 lambda = tn / (tn + td);
> 		*x1 = p1s[0] + lambda * (p1s[2] - p1s[0]);
> 		*x2 = p2s[0] + lambda * (p2s[2] - p2s[0]);
> 		p1s[1] = p1s[2];
> 		p2s[1] = p2s[2];
> 		points[1] = points[2];
> 		return 2;
> 	}
> 
> 	// Inside the triangle, compute barycentric coordinates
> 	float32 denom = va + vb + vc;
> 	b2Assert(denom > 0.0f);
> 	denom = 1.0f / denom;
> 
> #ifdef TARGET_FLOAT32_IS_FIXED
> 	*x1 = denom * (va * p1s[0] + vb * p1s[1] + vc * p1s[2]);
> 	*x2 = denom * (va * p2s[0] + vb * p2s[1] + vc * p2s[2]);
> #else
> 	float32 u = va * denom;
> 	float32 v = vb * denom;
> 	float32 w = 1.0f - u - v;
> 	*x1 = u * p1s[0] + v * p1s[1] + w * p1s[2];
> 	*x2 = u * p2s[0] + v * p2s[1] + w * p2s[2];
> #endif
> 	return 3;
> }
28c149
< void b2DistanceProxy::Set(const b2Shape* shape, int32 index)
---
> static bool InPoints(const b2Vec2& w, const b2Vec2* points, int32 pointCount)
30c151,152
< 	switch (shape->GetType())
---
> 	const float32 k_tolerance = 100.0f * B2_FLT_EPSILON;
> 	for (int32 i = 0; i < pointCount; ++i)
32c154,158
< 	case b2Shape::e_circle:
---
> 		b2Vec2 d = b2Abs(w - points[i]);
> 		b2Vec2 m = b2Max(b2Abs(w), b2Abs(points[i]));
> 		
> 		if (d.x < k_tolerance * (m.x + 1.0f) &&
> 			d.y < k_tolerance * (m.y + 1.0f))
34,37c160
< 			const b2CircleShape* circle = (b2CircleShape*)shape;
< 			m_vertices = &circle->m_p;
< 			m_count = 1;
< 			m_radius = circle->m_radius;
---
> 			return true;
39c162
< 		break;
---
> 	}
41,48c164,165
< 	case b2Shape::e_polygon:
< 		{
< 			const b2PolygonShape* polygon = (b2PolygonShape*)shape;
< 			m_vertices = polygon->m_vertices;
< 			m_count = polygon->m_count;
< 			m_radius = polygon->m_radius;
< 		}
< 		break;
---
> 	return false;
> }
50c167,190
< 	case b2Shape::e_chain:
---
> template <typename T1, typename T2>
> float32 DistanceGeneric(b2Vec2* x1, b2Vec2* x2,
> 				   const T1* shape1, const b2XForm& xf1,
> 				   const T2* shape2, const b2XForm& xf2)
> {
> 	b2Vec2 p1s[3], p2s[3];
> 	b2Vec2 points[3];
> 	int32 pointCount = 0;
> 
> 	*x1 = shape1->GetFirstVertex(xf1);
> 	*x2 = shape2->GetFirstVertex(xf2);
> 
> 	float32 vSqr = 0.0f;
> 	const int32 maxIterations = 20;
> 	for (int32 iter = 0; iter < maxIterations; ++iter)
> 	{
> 		b2Vec2 v = *x2 - *x1;
> 		b2Vec2 w1 = shape1->Support(xf1, v);
> 		b2Vec2 w2 = shape2->Support(xf2, -v);
> 
> 		vSqr = b2Dot(v, v);
> 		b2Vec2 w = w2 - w1;
> 		float32 vw = b2Dot(v, w);
> 		if (vSqr - vw <= 0.01f * vSqr || InPoints(w, points, pointCount)) // or w in points
52,56c192
< 			const b2ChainShape* chain = (b2ChainShape*)shape;
< 			b2Assert(0 <= index && index < chain->m_count);
< 
< 			m_buffer[0] = chain->m_vertices[index];
< 			if (index + 1 < chain->m_count)
---
> 			if (pointCount == 0)
58c194,195
< 				m_buffer[1] = chain->m_vertices[index + 1];
---
> 				*x1 = w1;
> 				*x2 = w2;
60,67c197,198
< 			else
< 			{
< 				m_buffer[1] = chain->m_vertices[0];
< 			}
< 
< 			m_vertices = m_buffer;
< 			m_count = 2;
< 			m_radius = chain->m_radius;
---
> 			g_GJK_Iterations = iter;
> 			return b2Sqrt(vSqr);
69d199
< 		break;
71c201
< 	case b2Shape::e_edge:
---
> 		switch (pointCount)
73,84c203,210
< 			const b2EdgeShape* edge = (b2EdgeShape*)shape;
< 			m_vertices = &edge->m_vertex1;
< 			m_count = 2;
< 			m_radius = edge->m_radius;
< 		}
< 		break;
< 
< 	default:
< 		b2Assert(false);
< 	}
< }
< 
---
> 		case 0:
> 			p1s[0] = w1;
> 			p2s[0] = w2;
> 			points[0] = w;
> 			*x1 = p1s[0];
> 			*x2 = p2s[0];
> 			++pointCount;
> 			break;
86,94c212,217
< struct b2SimplexVertex
< {
< 	b2Vec2 wA;		// support point in proxyA
< 	b2Vec2 wB;		// support point in proxyB
< 	b2Vec2 w;		// wB - wA
< 	float32 a;		// barycentric coordinate for closest point
< 	int32 indexA;	// wA index
< 	int32 indexB;	// wB index
< };
---
> 		case 1:
> 			p1s[1] = w1;
> 			p2s[1] = w2;
> 			points[1] = w;
> 			pointCount = ProcessTwo(x1, x2, p1s, p2s, points);
> 			break;
96,117c219,224
< struct b2Simplex
< {
< 	void ReadCache(	const b2SimplexCache* cache,
< 					const b2DistanceProxy* proxyA, const b2Transform& transformA,
< 					const b2DistanceProxy* proxyB, const b2Transform& transformB)
< 	{
< 		b2Assert(cache->count <= 3);
< 		
< 		// Copy data from cache.
< 		m_count = cache->count;
< 		b2SimplexVertex* vertices = &m_v1;
< 		for (int32 i = 0; i < m_count; ++i)
< 		{
< 			b2SimplexVertex* v = vertices + i;
< 			v->indexA = cache->indexA[i];
< 			v->indexB = cache->indexB[i];
< 			b2Vec2 wALocal = proxyA->GetVertex(v->indexA);
< 			b2Vec2 wBLocal = proxyB->GetVertex(v->indexB);
< 			v->wA = b2Mul(transformA, wALocal);
< 			v->wB = b2Mul(transformB, wBLocal);
< 			v->w = v->wB - v->wA;
< 			v->a = 0.0f;
---
> 		case 2:
> 			p1s[2] = w1;
> 			p2s[2] = w2;
> 			points[2] = w;
> 			pointCount = ProcessThree(x1, x2, p1s, p2s, points);
> 			break;
120,122c227,228
< 		// Compute the new simplex metric, if it is substantially different than
< 		// old metric then flush the simplex.
< 		if (m_count > 1)
---
> 		// If we have three points, then the origin is in the corresponding triangle.
> 		if (pointCount == 3)
124,130c230,231
< 			float32 metric1 = cache->metric;
< 			float32 metric2 = GetMetric();
< 			if (metric2 < 0.5f * metric1 || 2.0f * metric1 < metric2 || metric2 < b2_epsilon)
< 			{
< 				// Reset the simplex.
< 				m_count = 0;
< 			}
---
> 			g_GJK_Iterations = iter;
> 			return 0.0f;
133,134c234,235
< 		// If the cache is empty or invalid ...
< 		if (m_count == 0)
---
> 		float32 maxSqr = -B2_FLT_MAX;
> 		for (int32 i = 0; i < pointCount; ++i)
136,145c237
< 			b2SimplexVertex* v = vertices + 0;
< 			v->indexA = 0;
< 			v->indexB = 0;
< 			b2Vec2 wALocal = proxyA->GetVertex(0);
< 			b2Vec2 wBLocal = proxyB->GetVertex(0);
< 			v->wA = b2Mul(transformA, wALocal);
< 			v->wB = b2Mul(transformB, wBLocal);
< 			v->w = v->wB - v->wA;
< 			v->a = 1.0f;
< 			m_count = 1;
---
> 			maxSqr = b2Max(maxSqr, b2Dot(points[i], points[i]));
147d238
< 	}
149,154c240,244
< 	void WriteCache(b2SimplexCache* cache) const
< 	{
< 		cache->metric = GetMetric();
< 		cache->count = uint16(m_count);
< 		const b2SimplexVertex* vertices = &m_v1;
< 		for (int32 i = 0; i < m_count; ++i)
---
> #ifdef TARGET_FLOAT32_IS_FIXED
> 		if (pointCount == 3 || vSqr <= 5.0*B2_FLT_EPSILON * maxSqr)
> #else
> 		if (vSqr <= 100.0f * B2_FLT_EPSILON * maxSqr)
> #endif
156,157c246,249
< 			cache->indexA[i] = uint8(vertices[i].indexA);
< 			cache->indexB[i] = uint8(vertices[i].indexB);
---
> 			g_GJK_Iterations = iter;
> 			v = *x2 - *x1;
> 			vSqr = b2Dot(v, v);
> 			return b2Sqrt(vSqr);
161,166c253,255
< 	b2Vec2 GetSearchDirection() const
< 	{
< 		switch (m_count)
< 		{
< 		case 1:
< 			return -m_v1.w;
---
> 	g_GJK_Iterations = maxIterations;
> 	return b2Sqrt(vSqr);
> }
168,182c257,289
< 		case 2:
< 			{
< 				b2Vec2 e12 = m_v2.w - m_v1.w;
< 				float32 sgn = b2Cross(e12, -m_v1.w);
< 				if (sgn > 0.0f)
< 				{
< 					// Origin is left of e12.
< 					return b2Cross(1.0f, e12);
< 				}
< 				else
< 				{
< 					// Origin is right of e12.
< 					return b2Cross(e12, 1.0f);
< 				}
< 			}
---
> static float32 DistanceCC(
> 	b2Vec2* x1, b2Vec2* x2,
> 	const b2CircleShape* circle1, const b2XForm& xf1,
> 	const b2CircleShape* circle2, const b2XForm& xf2)
> {
> 	b2Vec2 p1 = b2Mul(xf1, circle1->GetLocalPosition());
> 	b2Vec2 p2 = b2Mul(xf2, circle2->GetLocalPosition());
> 
> 	b2Vec2 d = p2 - p1;
> 	float32 dSqr = b2Dot(d, d);
> 	float32 r1 = circle1->GetRadius() - b2_toiSlop;
> 	float32 r2 = circle2->GetRadius() - b2_toiSlop;
> 	float32 r = r1 + r2;
> 	if (dSqr > r * r)
> 	{
> 		float32 dLen = d.Normalize();
> 		float32 distance = dLen - r;
> 		*x1 = p1 + r1 * d;
> 		*x2 = p2 - r2 * d;
> 		return distance;
> 	}
> 	else if (dSqr > B2_FLT_EPSILON * B2_FLT_EPSILON)
> 	{
> 		d.Normalize();
> 		*x1 = p1 + r1 * d;
> 		*x2 = *x1;
> 		return 0.0f;
> 	}
> 
> 	*x1 = p1;
> 	*x2 = *x1;
> 	return 0.0f;
> }
184,186c291,326
< 		default:
< 			b2Assert(false);
< 			return b2Vec2_zero;
---
> static float32 DistanceEdgeCircle(
> 	b2Vec2* x1, b2Vec2* x2,
> 	const b2EdgeShape* edge, const b2XForm& xf1,
> 	const b2CircleShape* circle, const b2XForm& xf2)
> {
> 	b2Vec2 vWorld;
> 	b2Vec2 d;
> 	float32 dSqr;
> 	float32 dLen;
> 	float32 r = circle->GetRadius() - b2_toiSlop;
> 	b2Vec2 cWorld = b2Mul(xf2, circle->GetLocalPosition());
> 	b2Vec2 cLocal = b2MulT(xf1, cWorld);
> 	float32 dirDist = b2Dot(cLocal - edge->GetCoreVertex1(), edge->GetDirectionVector());
> 	if (dirDist <= 0.0f) {
> 		vWorld = b2Mul(xf1, edge->GetCoreVertex1());
> 	} else if (dirDist >= edge->GetLength()) {
> 		vWorld = b2Mul(xf1, edge->GetCoreVertex2());
> 	} else {
> 		*x1 = b2Mul(xf1, edge->GetCoreVertex1() + dirDist * edge->GetDirectionVector());
> 		dLen = b2Dot(cLocal - edge->GetCoreVertex1(), edge->GetNormalVector());
> 		if (dLen < 0.0f) {
> 			if (dLen < -r) {
> 				*x2 = b2Mul(xf1, cLocal + r * edge->GetNormalVector());
> 				return -dLen - r;
> 			} else {
> 				*x2 = *x1;
> 				return 0.0f;
> 			}
> 		} else {
> 			if (dLen > r) {
> 				*x2 = b2Mul(xf1, cLocal  - r * edge->GetNormalVector());
> 				return dLen - r;
> 			} else {
> 				*x2 = *x1;
> 				return 0.0f;
> 			}
188a329,341
> 	
> 	*x1 = vWorld;
> 	d = cWorld - vWorld;
> 	dSqr = b2Dot(d, d);
> 	if (dSqr > r * r) {
> 		dLen = d.Normalize();
> 		*x2 = cWorld - r * d;
> 		return dLen - r;
> 	} else {
> 		*x2 = vWorld;
> 		return 0.0f;
> 	}
> }
190c343,346
< 	b2Vec2 GetClosestPoint() const
---
> // This is used for polygon-vs-circle distance.
> struct Point
> {
> 	b2Vec2 Support(const b2XForm&, const b2Vec2&) const
192,210c348
< 		switch (m_count)
< 		{
< 		case 0:
< 			b2Assert(false);
< 			return b2Vec2_zero;
< 
< 		case 1:
< 			return m_v1.w;
< 
< 		case 2:
< 			return m_v1.a * m_v1.w + m_v2.a * m_v2.w;
< 
< 		case 3:
< 			return b2Vec2_zero;
< 
< 		default:
< 			b2Assert(false);
< 			return b2Vec2_zero;
< 		}
---
> 		return p;
213c351
< 	void GetWitnessPoints(b2Vec2* pA, b2Vec2* pB) const
---
> 	b2Vec2 GetFirstVertex(const b2XForm&) const
215,219c353,357
< 		switch (m_count)
< 		{
< 		case 0:
< 			b2Assert(false);
< 			break;
---
> 		return p;
> 	}
> 	
> 	b2Vec2 p;
> };
221,224c359,367
< 		case 1:
< 			*pA = m_v1.wA;
< 			*pB = m_v1.wB;
< 			break;
---
> // GJK is more robust with polygon-vs-point than polygon-vs-circle.
> // So we convert polygon-vs-circle to polygon-vs-point.
> static float32 DistancePC(
> 	b2Vec2* x1, b2Vec2* x2,
> 	const b2PolygonShape* polygon, const b2XForm& xf1,
> 	const b2CircleShape* circle, const b2XForm& xf2)
> {
> 	Point point;
> 	point.p = b2Mul(xf2, circle->GetLocalPosition());
226,229c369
< 		case 2:
< 			*pA = m_v1.a * m_v1.wA + m_v2.a * m_v2.wA;
< 			*pB = m_v1.a * m_v1.wB + m_v2.a * m_v2.wB;
< 			break;
---
> 	float32 distance = DistanceGeneric(x1, x2, polygon, xf1, &point, b2XForm_identity);
231,234c371
< 		case 3:
< 			*pA = m_v1.a * m_v1.wA + m_v2.a * m_v2.wA + m_v3.a * m_v3.wA;
< 			*pB = *pA;
< 			break;
---
> 	float32 r = circle->GetRadius() - b2_toiSlop;
236,239c373,378
< 		default:
< 			b2Assert(false);
< 			break;
< 		}
---
> 	if (distance > r)
> 	{
> 		distance -= r;
> 		b2Vec2 d = *x2 - *x1;
> 		d.Normalize();
> 		*x2 -= r * d;
241,242c380
< 
< 	float32 GetMetric() const
---
> 	else
244,262c382,383
< 		switch (m_count)
< 		{
< 		case 0:
< 			b2Assert(false);
< 			return 0.0f;
< 
< 		case 1:
< 			return 0.0f;
< 
< 		case 2:
< 			return b2Distance(m_v1.w, m_v2.w);
< 
< 		case 3:
< 			return b2Cross(m_v2.w - m_v1.w, m_v3.w - m_v1.w);
< 
< 		default:
< 			b2Assert(false);
< 			return 0.0f;
< 		}
---
> 		distance = 0.0f;
> 		*x2 = *x1;
265,327c386
< 	void Solve2();
< 	void Solve3();
< 
< 	b2SimplexVertex m_v1, m_v2, m_v3;
< 	int32 m_count;
< };
< 
< 
< // Solve a line segment using barycentric coordinates.
< //
< // p = a1 * w1 + a2 * w2
< // a1 + a2 = 1
< //
< // The vector from the origin to the closest point on the line is
< // perpendicular to the line.
< // e12 = w2 - w1
< // dot(p, e) = 0
< // a1 * dot(w1, e) + a2 * dot(w2, e) = 0
< //
< // 2-by-2 linear system
< // [1      1     ][a1] = [1]
< // [w1.e12 w2.e12][a2] = [0]
< //
< // Define
< // d12_1 =  dot(w2, e12)
< // d12_2 = -dot(w1, e12)
< // d12 = d12_1 + d12_2
< //
< // Solution
< // a1 = d12_1 / d12
< // a2 = d12_2 / d12
< void b2Simplex::Solve2()
< {
< 	b2Vec2 w1 = m_v1.w;
< 	b2Vec2 w2 = m_v2.w;
< 	b2Vec2 e12 = w2 - w1;
< 
< 	// w1 region
< 	float32 d12_2 = -b2Dot(w1, e12);
< 	if (d12_2 <= 0.0f)
< 	{
< 		// a2 <= 0, so we clamp it to 0
< 		m_v1.a = 1.0f;
< 		m_count = 1;
< 		return;
< 	}
< 
< 	// w2 region
< 	float32 d12_1 = b2Dot(w2, e12);
< 	if (d12_1 <= 0.0f)
< 	{
< 		// a1 <= 0, so we clamp it to 0
< 		m_v2.a = 1.0f;
< 		m_count = 1;
< 		m_v1 = m_v2;
< 		return;
< 	}
< 
< 	// Must be in e12 region.
< 	float32 inv_d12 = 1.0f / (d12_1 + d12_2);
< 	m_v1.a = d12_1 * inv_d12;
< 	m_v2.a = d12_2 * inv_d12;
< 	m_count = 2;
---
> 	return distance;
330,335c389,391
< // Possible regions:
< // - points[2]
< // - edge points[0]-points[2]
< // - edge points[1]-points[2]
< // - inside the triangle
< void b2Simplex::Solve3()
---
> float32 b2Distance(b2Vec2* x1, b2Vec2* x2,
> 				   const b2Shape* shape1, const b2XForm& xf1,
> 				   const b2Shape* shape2, const b2XForm& xf2)
337,376c393,394
< 	b2Vec2 w1 = m_v1.w;
< 	b2Vec2 w2 = m_v2.w;
< 	b2Vec2 w3 = m_v3.w;
< 
< 	// Edge12
< 	// [1      1     ][a1] = [1]
< 	// [w1.e12 w2.e12][a2] = [0]
< 	// a3 = 0
< 	b2Vec2 e12 = w2 - w1;
< 	float32 w1e12 = b2Dot(w1, e12);
< 	float32 w2e12 = b2Dot(w2, e12);
< 	float32 d12_1 = w2e12;
< 	float32 d12_2 = -w1e12;
< 
< 	// Edge13
< 	// [1      1     ][a1] = [1]
< 	// [w1.e13 w3.e13][a3] = [0]
< 	// a2 = 0
< 	b2Vec2 e13 = w3 - w1;
< 	float32 w1e13 = b2Dot(w1, e13);
< 	float32 w3e13 = b2Dot(w3, e13);
< 	float32 d13_1 = w3e13;
< 	float32 d13_2 = -w1e13;
< 
< 	// Edge23
< 	// [1      1     ][a2] = [1]
< 	// [w2.e23 w3.e23][a3] = [0]
< 	// a1 = 0
< 	b2Vec2 e23 = w3 - w2;
< 	float32 w2e23 = b2Dot(w2, e23);
< 	float32 w3e23 = b2Dot(w3, e23);
< 	float32 d23_1 = w3e23;
< 	float32 d23_2 = -w2e23;
< 	
< 	// Triangle123
< 	float32 n123 = b2Cross(e12, e13);
< 
< 	float32 d123_1 = n123 * b2Cross(w2, w3);
< 	float32 d123_2 = n123 * b2Cross(w3, w1);
< 	float32 d123_3 = n123 * b2Cross(w1, w2);
---
> 	b2ShapeType type1 = shape1->GetType();
> 	b2ShapeType type2 = shape2->GetType();
378,379c396
< 	// w1 region
< 	if (d12_2 <= 0.0f && d13_2 <= 0.0f)
---
> 	if (type1 == e_circleShape && type2 == e_circleShape)
381,383c398
< 		m_v1.a = 1.0f;
< 		m_count = 1;
< 		return;
---
> 		return DistanceCC(x1, x2, (b2CircleShape*)shape1, xf1, (b2CircleShape*)shape2, xf2);
385,387c400,401
< 
< 	// e12
< 	if (d12_1 > 0.0f && d12_2 > 0.0f && d123_3 <= 0.0f)
---
> 	
> 	if (type1 == e_polygonShape && type2 == e_circleShape)
389,393c403
< 		float32 inv_d12 = 1.0f / (d12_1 + d12_2);
< 		m_v1.a = d12_1 * inv_d12;
< 		m_v2.a = d12_2 * inv_d12;
< 		m_count = 2;
< 		return;
---
> 		return DistancePC(x1, x2, (b2PolygonShape*)shape1, xf1, (b2CircleShape*)shape2, xf2);
396,397c406
< 	// e13
< 	if (d13_1 > 0.0f && d13_2 > 0.0f && d123_2 <= 0.0f)
---
> 	if (type1 == e_circleShape && type2 == e_polygonShape)
399,404c408
< 		float32 inv_d13 = 1.0f / (d13_1 + d13_2);
< 		m_v1.a = d13_1 * inv_d13;
< 		m_v3.a = d13_2 * inv_d13;
< 		m_count = 2;
< 		m_v2 = m_v3;
< 		return;
---
> 		return DistancePC(x2, x1, (b2PolygonShape*)shape2, xf2, (b2CircleShape*)shape1, xf1);
407,408c411
< 	// w2 region
< 	if (d12_1 <= 0.0f && d23_2 <= 0.0f)
---
> 	if (type1 == e_polygonShape && type2 == e_polygonShape)
410,413c413
< 		m_v2.a = 1.0f;
< 		m_count = 1;
< 		m_v1 = m_v2;
< 		return;
---
> 		return DistanceGeneric(x1, x2, (b2PolygonShape*)shape1, xf1, (b2PolygonShape*)shape2, xf2);
416,417c416
< 	// w3 region
< 	if (d13_1 <= 0.0f && d23_1 <= 0.0f)
---
> 	if (type1 == e_edgeShape && type2 == e_circleShape)
419,422c418
< 		m_v3.a = 1.0f;
< 		m_count = 1;
< 		m_v1 = m_v3;
< 		return;
---
> 		return DistanceEdgeCircle(x1, x2, (b2EdgeShape*)shape1, xf1, (b2CircleShape*)shape2, xf2);
424,426c420,421
< 
< 	// e23
< 	if (d23_1 > 0.0f && d23_2 > 0.0f && d123_1 <= 0.0f)
---
> 	
> 	if (type1 == e_circleShape && type2 == e_edgeShape)
428,433c423
< 		float32 inv_d23 = 1.0f / (d23_1 + d23_2);
< 		m_v2.a = d23_1 * inv_d23;
< 		m_v3.a = d23_2 * inv_d23;
< 		m_count = 2;
< 		m_v1 = m_v3;
< 		return;
---
> 		return DistanceEdgeCircle(x2, x1, (b2EdgeShape*)shape2, xf2, (b2CircleShape*)shape1, xf1);
436,474c426
< 	// Must be in triangle123
< 	float32 inv_d123 = 1.0f / (d123_1 + d123_2 + d123_3);
< 	m_v1.a = d123_1 * inv_d123;
< 	m_v2.a = d123_2 * inv_d123;
< 	m_v3.a = d123_3 * inv_d123;
< 	m_count = 3;
< }
< 
< void b2Distance(b2DistanceOutput* output,
< 				b2SimplexCache* cache,
< 				const b2DistanceInput* input)
< {
< 	++b2_gjkCalls;
< 
< 	const b2DistanceProxy* proxyA = &input->proxyA;
< 	const b2DistanceProxy* proxyB = &input->proxyB;
< 
< 	b2Transform transformA = input->transformA;
< 	b2Transform transformB = input->transformB;
< 
< 	// Initialize the simplex.
< 	b2Simplex simplex;
< 	simplex.ReadCache(cache, proxyA, transformA, proxyB, transformB);
< 
< 	// Get simplex vertices as an array.
< 	b2SimplexVertex* vertices = &simplex.m_v1;
< 	const int32 k_maxIters = 20;
< 
< 	// These store the vertices of the last simplex so that we
< 	// can check for duplicates and prevent cycling.
< 	int32 saveA[3], saveB[3];
< 	int32 saveCount = 0;
< 
< 	float32 distanceSqr1 = b2_maxFloat;
< 	float32 distanceSqr2 = distanceSqr1;
< 
< 	// Main iteration loop.
< 	int32 iter = 0;
< 	while (iter < k_maxIters)
---
> 	if (type1 == e_polygonShape && type2 == e_edgeShape)
476,564c428
< 		// Copy simplex so we can identify duplicates.
< 		saveCount = simplex.m_count;
< 		for (int32 i = 0; i < saveCount; ++i)
< 		{
< 			saveA[i] = vertices[i].indexA;
< 			saveB[i] = vertices[i].indexB;
< 		}
< 
< 		switch (simplex.m_count)
< 		{
< 		case 1:
< 			break;
< 
< 		case 2:
< 			simplex.Solve2();
< 			break;
< 
< 		case 3:
< 			simplex.Solve3();
< 			break;
< 
< 		default:
< 			b2Assert(false);
< 		}
< 
< 		// If we have 3 points, then the origin is in the corresponding triangle.
< 		if (simplex.m_count == 3)
< 		{
< 			break;
< 		}
< 
< 		// Compute closest point.
< 		b2Vec2 p = simplex.GetClosestPoint();
< 		distanceSqr2 = p.LengthSquared();
< 
< 		// Ensure progress
< 		if (distanceSqr2 >= distanceSqr1)
< 		{
< 			//break;
< 		}
< 		distanceSqr1 = distanceSqr2;
< 
< 		// Get search direction.
< 		b2Vec2 d = simplex.GetSearchDirection();
< 
< 		// Ensure the search direction is numerically fit.
< 		if (d.LengthSquared() < b2_epsilon * b2_epsilon)
< 		{
< 			// The origin is probably contained by a line segment
< 			// or triangle. Thus the shapes are overlapped.
< 
< 			// We can't return zero here even though there may be overlap.
< 			// In case the simplex is a point, segment, or triangle it is difficult
< 			// to determine if the origin is contained in the CSO or very close to it.
< 			break;
< 		}
< 
< 		// Compute a tentative new simplex vertex using support points.
< 		b2SimplexVertex* vertex = vertices + simplex.m_count;
< 		vertex->indexA = proxyA->GetSupport(b2MulT(transformA.q, -d));
< 		vertex->wA = b2Mul(transformA, proxyA->GetVertex(vertex->indexA));
< 		b2Vec2 wBLocal;
< 		vertex->indexB = proxyB->GetSupport(b2MulT(transformB.q, d));
< 		vertex->wB = b2Mul(transformB, proxyB->GetVertex(vertex->indexB));
< 		vertex->w = vertex->wB - vertex->wA;
< 
< 		// Iteration count is equated to the number of support point calls.
< 		++iter;
< 		++b2_gjkIters;
< 
< 		// Check for duplicate support points. This is the main termination criteria.
< 		bool duplicate = false;
< 		for (int32 i = 0; i < saveCount; ++i)
< 		{
< 			if (vertex->indexA == saveA[i] && vertex->indexB == saveB[i])
< 			{
< 				duplicate = true;
< 				break;
< 			}
< 		}
< 
< 		// If we found a duplicate support point we must exit to avoid cycling.
< 		if (duplicate)
< 		{
< 			break;
< 		}
< 
< 		// New vertex is ok and needed.
< 		++simplex.m_count;
---
> 		return DistanceGeneric(x2, x1, (b2EdgeShape*)shape2, xf2, (b2PolygonShape*)shape1, xf1);
567,578c431
< 	b2_gjkMaxIters = b2Max(b2_gjkMaxIters, iter);
< 
< 	// Prepare output.
< 	simplex.GetWitnessPoints(&output->pointA, &output->pointB);
< 	output->distance = b2Distance(output->pointA, output->pointB);
< 	output->iterations = iter;
< 
< 	// Cache the simplex.
< 	simplex.WriteCache(cache);
< 
< 	// Apply radii if requested.
< 	if (input->useRadii)
---
> 	if (type1 == e_edgeShape && type2 == e_polygonShape)
580,601c433
< 		float32 rA = proxyA->m_radius;
< 		float32 rB = proxyB->m_radius;
< 
< 		if (output->distance > rA + rB && output->distance > b2_epsilon)
< 		{
< 			// Shapes are still no overlapped.
< 			// Move the witness points to the outer surface.
< 			output->distance -= rA + rB;
< 			b2Vec2 normal = output->pointB - output->pointA;
< 			normal.Normalize();
< 			output->pointA += rA * normal;
< 			output->pointB -= rB * normal;
< 		}
< 		else
< 		{
< 			// Shapes are overlapped when radii are considered.
< 			// Move the witness points to the middle.
< 			b2Vec2 p = 0.5f * (output->pointA + output->pointB);
< 			output->pointA = p;
< 			output->pointB = p;
< 			output->distance = 0.0f;
< 		}
---
> 		return DistanceGeneric(x1, x2, (b2EdgeShape*)shape1, xf1, (b2PolygonShape*)shape2, xf2);
602a435,436
> 
> 	return 0.0f;
Only in native/Box2D/Collision: b2Distance.h
Only in native/Box2D/Collision: b2DynamicTree.cpp
Only in native/Box2D/Collision: b2DynamicTree.h
Only in ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Collision: b2PairManager.cpp
Only in ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Collision: b2PairManager.h
diff -r -x './svn/*' native/Box2D/Collision/b2TimeOfImpact.cpp ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Collision/b2TimeOfImpact.cpp
2c2
< * Copyright (c) 2007-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2007 Erin Catto http://www.gphysics.com
19,31c19,20
< #include <Box2D/Collision/b2Collision.h>
< #include <Box2D/Collision/b2Distance.h>
< #include <Box2D/Collision/b2TimeOfImpact.h>
< #include <Box2D/Collision/Shapes/b2CircleShape.h>
< #include <Box2D/Collision/Shapes/b2PolygonShape.h>
< #include <Box2D/Common/b2Timer.h>
< 
< #include <cstdio>
< using namespace std;
< 
< float32 b2_toiTime, b2_toiMaxTime;
< int32 b2_toiCalls, b2_toiIters, b2_toiMaxIters;
< int32 b2_toiRootIters, b2_toiMaxRootIters;
---
> #include "b2Collision.h"
> #include "Shapes/b2Shape.h"
33,34c22,26
< //
< struct b2SeparationFunction
---
> // This algorithm uses conservative advancement to compute the time of
> // impact (TOI) of two shapes.
> // Refs: Bullet, Young Kim
> float32 b2TimeOfImpact(const b2Shape* shape1, const b2Sweep& sweep1,
> 					   const b2Shape* shape2, const b2Sweep& sweep2)
36,85c28,29
< 	enum Type
< 	{
< 		e_points,
< 		e_faceA,
< 		e_faceB
< 	};
< 
< 	// TODO_ERIN might not need to return the separation
< 
< 	float32 Initialize(const b2SimplexCache* cache,
< 		const b2DistanceProxy* proxyA, const b2Sweep& sweepA,
< 		const b2DistanceProxy* proxyB, const b2Sweep& sweepB,
< 		float32 t1)
< 	{
< 		m_proxyA = proxyA;
< 		m_proxyB = proxyB;
< 		int32 count = cache->count;
< 		b2Assert(0 < count && count < 3);
< 
< 		m_sweepA = sweepA;
< 		m_sweepB = sweepB;
< 
< 		b2Transform xfA, xfB;
< 		m_sweepA.GetTransform(&xfA, t1);
< 		m_sweepB.GetTransform(&xfB, t1);
< 
< 		if (count == 1)
< 		{
< 			m_type = e_points;
< 			b2Vec2 localPointA = m_proxyA->GetVertex(cache->indexA[0]);
< 			b2Vec2 localPointB = m_proxyB->GetVertex(cache->indexB[0]);
< 			b2Vec2 pointA = b2Mul(xfA, localPointA);
< 			b2Vec2 pointB = b2Mul(xfB, localPointB);
< 			m_axis = pointB - pointA;
< 			float32 s = m_axis.Normalize();
< 			return s;
< 		}
< 		else if (cache->indexA[0] == cache->indexA[1])
< 		{
< 			// Two points on B and one on A.
< 			m_type = e_faceB;
< 			b2Vec2 localPointB1 = proxyB->GetVertex(cache->indexB[0]);
< 			b2Vec2 localPointB2 = proxyB->GetVertex(cache->indexB[1]);
< 
< 			m_axis = b2Cross(localPointB2 - localPointB1, 1.0f);
< 			m_axis.Normalize();
< 			b2Vec2 normal = b2Mul(xfB.q, m_axis);
< 
< 			m_localPoint = 0.5f * (localPointB1 + localPointB2);
< 			b2Vec2 pointB = b2Mul(xfB, m_localPoint);
---
> 	float32 r1 = shape1->GetSweepRadius();
> 	float32 r2 = shape2->GetSweepRadius();
87,88c31,32
< 			b2Vec2 localPointA = proxyA->GetVertex(cache->indexA[0]);
< 			b2Vec2 pointA = b2Mul(xfA, localPointA);
---
> 	b2Assert(sweep1.t0 == sweep2.t0);
> 	b2Assert(1.0f - sweep1.t0 > B2_FLT_EPSILON);
90,107c34,38
< 			float32 s = b2Dot(pointA - pointB, normal);
< 			if (s < 0.0f)
< 			{
< 				m_axis = -m_axis;
< 				s = -s;
< 			}
< 			return s;
< 		}
< 		else
< 		{
< 			// Two points on A and one or two points on B.
< 			m_type = e_faceA;
< 			b2Vec2 localPointA1 = m_proxyA->GetVertex(cache->indexA[0]);
< 			b2Vec2 localPointA2 = m_proxyA->GetVertex(cache->indexA[1]);
< 			
< 			m_axis = b2Cross(localPointA2 - localPointA1, 1.0f);
< 			m_axis.Normalize();
< 			b2Vec2 normal = b2Mul(xfA.q, m_axis);
---
> 	float32 t0 = sweep1.t0;
> 	b2Vec2 v1 = sweep1.c - sweep1.c0;
> 	b2Vec2 v2 = sweep2.c - sweep2.c0;
> 	float32 omega1 = sweep1.a - sweep1.a0;
> 	float32 omega2 = sweep2.a - sweep2.a0;
109,123c40
< 			m_localPoint = 0.5f * (localPointA1 + localPointA2);
< 			b2Vec2 pointA = b2Mul(xfA, m_localPoint);
< 
< 			b2Vec2 localPointB = m_proxyB->GetVertex(cache->indexB[0]);
< 			b2Vec2 pointB = b2Mul(xfB, localPointB);
< 
< 			float32 s = b2Dot(pointB - pointA, normal);
< 			if (s < 0.0f)
< 			{
< 				m_axis = -m_axis;
< 				s = -s;
< 			}
< 			return s;
< 		}
< 	}
---
> 	float32 alpha = 0.0f;
125,126c42,48
< 	//
< 	float32 FindMinSeparation(int32* indexA, int32* indexB, float32 t) const
---
> 	b2Vec2 p1, p2;
> 	const int32 k_maxIterations = 20;	// TODO_ERIN b2Settings
> 	int32 iter = 0;
> 	b2Vec2 normal = b2Vec2_zero;
> 	float32 distance = 0.0f;
> 	float32 targetDistance = 0.0f;
> 	for(;;)
128,192c50,53
< 		b2Transform xfA, xfB;
< 		m_sweepA.GetTransform(&xfA, t);
< 		m_sweepB.GetTransform(&xfB, t);
< 
< 		switch (m_type)
< 		{
< 		case e_points:
< 			{
< 				b2Vec2 axisA = b2MulT(xfA.q,  m_axis);
< 				b2Vec2 axisB = b2MulT(xfB.q, -m_axis);
< 
< 				*indexA = m_proxyA->GetSupport(axisA);
< 				*indexB = m_proxyB->GetSupport(axisB);
< 
< 				b2Vec2 localPointA = m_proxyA->GetVertex(*indexA);
< 				b2Vec2 localPointB = m_proxyB->GetVertex(*indexB);
< 				
< 				b2Vec2 pointA = b2Mul(xfA, localPointA);
< 				b2Vec2 pointB = b2Mul(xfB, localPointB);
< 
< 				float32 separation = b2Dot(pointB - pointA, m_axis);
< 				return separation;
< 			}
< 
< 		case e_faceA:
< 			{
< 				b2Vec2 normal = b2Mul(xfA.q, m_axis);
< 				b2Vec2 pointA = b2Mul(xfA, m_localPoint);
< 
< 				b2Vec2 axisB = b2MulT(xfB.q, -normal);
< 				
< 				*indexA = -1;
< 				*indexB = m_proxyB->GetSupport(axisB);
< 
< 				b2Vec2 localPointB = m_proxyB->GetVertex(*indexB);
< 				b2Vec2 pointB = b2Mul(xfB, localPointB);
< 
< 				float32 separation = b2Dot(pointB - pointA, normal);
< 				return separation;
< 			}
< 
< 		case e_faceB:
< 			{
< 				b2Vec2 normal = b2Mul(xfB.q, m_axis);
< 				b2Vec2 pointB = b2Mul(xfB, m_localPoint);
< 
< 				b2Vec2 axisA = b2MulT(xfA.q, -normal);
< 
< 				*indexB = -1;
< 				*indexA = m_proxyA->GetSupport(axisA);
< 
< 				b2Vec2 localPointA = m_proxyA->GetVertex(*indexA);
< 				b2Vec2 pointA = b2Mul(xfA, localPointA);
< 
< 				float32 separation = b2Dot(pointA - pointB, normal);
< 				return separation;
< 			}
< 
< 		default:
< 			b2Assert(false);
< 			*indexA = -1;
< 			*indexB = -1;
< 			return 0.0f;
< 		}
< 	}
---
> 		float32 t = (1.0f - alpha) * t0 + alpha;
> 		b2XForm xf1, xf2;
> 		sweep1.GetXForm(&xf1, t);
> 		sweep2.GetXForm(&xf2, t);
194,199c55,56
< 	//
< 	float32 Evaluate(int32 indexA, int32 indexB, float32 t) const
< 	{
< 		b2Transform xfA, xfB;
< 		m_sweepA.GetTransform(&xfA, t);
< 		m_sweepB.GetTransform(&xfB, t);
---
> 		// Get the distance between shapes.
> 		distance = b2Distance(&p1, &p2, shape1, xf1, shape2, xf2);
201c58
< 		switch (m_type)
---
> 		if (iter == 0)
203,215c60,62
< 		case e_points:
< 			{
< 				b2Vec2 localPointA = m_proxyA->GetVertex(indexA);
< 				b2Vec2 localPointB = m_proxyB->GetVertex(indexB);
< 
< 				b2Vec2 pointA = b2Mul(xfA, localPointA);
< 				b2Vec2 pointB = b2Mul(xfB, localPointB);
< 				float32 separation = b2Dot(pointB - pointA, m_axis);
< 
< 				return separation;
< 			}
< 
< 		case e_faceA:
---
> 			// Compute a reasonable target distance to give some breathing room
> 			// for conservative advancement.
> 			if (distance > 2.0f * b2_toiSlop)
217,224c64
< 				b2Vec2 normal = b2Mul(xfA.q, m_axis);
< 				b2Vec2 pointA = b2Mul(xfA, m_localPoint);
< 
< 				b2Vec2 localPointB = m_proxyB->GetVertex(indexB);
< 				b2Vec2 pointB = b2Mul(xfB, localPointB);
< 
< 				float32 separation = b2Dot(pointB - pointA, normal);
< 				return separation;
---
> 				targetDistance = 1.5f * b2_toiSlop;
226,227c66
< 
< 		case e_faceB:
---
> 			else
229,236c68
< 				b2Vec2 normal = b2Mul(xfB.q, m_axis);
< 				b2Vec2 pointB = b2Mul(xfB, m_localPoint);
< 
< 				b2Vec2 localPointA = m_proxyA->GetVertex(indexA);
< 				b2Vec2 pointA = b2Mul(xfA, localPointA);
< 
< 				float32 separation = b2Dot(pointA - pointB, normal);
< 				return separation;
---
> 				targetDistance = b2Max(0.05f * b2_toiSlop, distance - 0.5f * b2_toiSlop);
238,315d69
< 
< 		default:
< 			b2Assert(false);
< 			return 0.0f;
< 		}
< 	}
< 
< 	const b2DistanceProxy* m_proxyA;
< 	const b2DistanceProxy* m_proxyB;
< 	b2Sweep m_sweepA, m_sweepB;
< 	Type m_type;
< 	b2Vec2 m_localPoint;
< 	b2Vec2 m_axis;
< };
< 
< // CCD via the local separating axis method. This seeks progression
< // by computing the largest time at which separation is maintained.
< void b2TimeOfImpact(b2TOIOutput* output, const b2TOIInput* input)
< {
< 	b2Timer timer;
< 
< 	++b2_toiCalls;
< 
< 	output->state = b2TOIOutput::e_unknown;
< 	output->t = input->tMax;
< 
< 	const b2DistanceProxy* proxyA = &input->proxyA;
< 	const b2DistanceProxy* proxyB = &input->proxyB;
< 
< 	b2Sweep sweepA = input->sweepA;
< 	b2Sweep sweepB = input->sweepB;
< 
< 	// Large rotations can make the root finder fail, so we normalize the
< 	// sweep angles.
< 	sweepA.Normalize();
< 	sweepB.Normalize();
< 
< 	float32 tMax = input->tMax;
< 
< 	float32 totalRadius = proxyA->m_radius + proxyB->m_radius;
< 	float32 target = b2Max(b2_linearSlop, totalRadius - 3.0f * b2_linearSlop);
< 	float32 tolerance = 0.25f * b2_linearSlop;
< 	b2Assert(target > tolerance);
< 
< 	float32 t1 = 0.0f;
< 	const int32 k_maxIterations = 20;	// TODO_ERIN b2Settings
< 	int32 iter = 0;
< 
< 	// Prepare input for distance query.
< 	b2SimplexCache cache;
< 	cache.count = 0;
< 	b2DistanceInput distanceInput;
< 	distanceInput.proxyA = input->proxyA;
< 	distanceInput.proxyB = input->proxyB;
< 	distanceInput.useRadii = false;
< 
< 	// The outer loop progressively attempts to compute new separating axes.
< 	// This loop terminates when an axis is repeated (no progress is made).
< 	for(;;)
< 	{
< 		b2Transform xfA, xfB;
< 		sweepA.GetTransform(&xfA, t1);
< 		sweepB.GetTransform(&xfB, t1);
< 
< 		// Get the distance between shapes. We can also use the results
< 		// to get a separating axis.
< 		distanceInput.transformA = xfA;
< 		distanceInput.transformB = xfB;
< 		b2DistanceOutput distanceOutput;
< 		b2Distance(&distanceOutput, &cache, &distanceInput);
< 
< 		// If the shapes are overlapped, we give up on continuous collision.
< 		if (distanceOutput.distance <= 0.0f)
< 		{
< 			// Failure!
< 			output->state = b2TOIOutput::e_overlapped;
< 			output->t = 0.0f;
< 			break;
318c72
< 		if (distanceOutput.distance < target + tolerance)
---
> 		if (distance - targetDistance < 0.05f * b2_toiSlop || iter == k_maxIterations)
320,322d73
< 			// Victory!
< 			output->state = b2TOIOutput::e_touching;
< 			output->t = t1;
326,353c77,78
< 		// Initialize the separating axis.
< 		b2SeparationFunction fcn;
< 		fcn.Initialize(&cache, proxyA, sweepA, proxyB, sweepB, t1);
< #if 0
< 		// Dump the curve seen by the root finder
< 		{
< 			const int32 N = 100;
< 			float32 dx = 1.0f / N;
< 			float32 xs[N+1];
< 			float32 fs[N+1];
< 
< 			float32 x = 0.0f;
< 
< 			for (int32 i = 0; i <= N; ++i)
< 			{
< 				sweepA.GetTransform(&xfA, x);
< 				sweepB.GetTransform(&xfB, x);
< 				float32 f = fcn.Evaluate(xfA, xfB) - target;
< 
< 				printf("%g %g\n", x, f);
< 
< 				xs[i] = x;
< 				fs[i] = f;
< 
< 				x += dx;
< 			}
< 		}
< #endif
---
> 		normal = p2 - p1;
> 		normal.Normalize();
355,360c80,82
< 		// Compute the TOI on the separating axis. We do this by successively
< 		// resolving the deepest point. This loop is bounded by the number of vertices.
< 		bool done = false;
< 		float32 t2 = tMax;
< 		int32 pushBackIter = 0;
< 		for (;;)
---
> 		// Compute upper bound on remaining movement.
> 		float32 approachVelocityBound = b2Dot(normal, v1 - v2) + b2Abs(omega1) * r1 + b2Abs(omega2) * r2;
> 		if (b2Abs(approachVelocityBound) < B2_FLT_EPSILON)
362,462c84,85
< 			// Find the deepest point at t2. Store the witness point indices.
< 			int32 indexA, indexB;
< 			float32 s2 = fcn.FindMinSeparation(&indexA, &indexB, t2);
< 
< 			// Is the final configuration separated?
< 			if (s2 > target + tolerance)
< 			{
< 				// Victory!
< 				output->state = b2TOIOutput::e_separated;
< 				output->t = tMax;
< 				done = true;
< 				break;
< 			}
< 
< 			// Has the separation reached tolerance?
< 			if (s2 > target - tolerance)
< 			{
< 				// Advance the sweeps
< 				t1 = t2;
< 				break;
< 			}
< 
< 			// Compute the initial separation of the witness points.
< 			float32 s1 = fcn.Evaluate(indexA, indexB, t1);
< 
< 			// Check for initial overlap. This might happen if the root finder
< 			// runs out of iterations.
< 			if (s1 < target - tolerance)
< 			{
< 				output->state = b2TOIOutput::e_failed;
< 				output->t = t1;
< 				done = true;
< 				break;
< 			}
< 
< 			// Check for touching
< 			if (s1 <= target + tolerance)
< 			{
< 				// Victory! t1 should hold the TOI (could be 0.0).
< 				output->state = b2TOIOutput::e_touching;
< 				output->t = t1;
< 				done = true;
< 				break;
< 			}
< 
< 			// Compute 1D root of: f(x) - target = 0
< 			int32 rootIterCount = 0;
< 			float32 a1 = t1, a2 = t2;
< 			for (;;)
< 			{
< 				// Use a mix of the secant rule and bisection.
< 				float32 t;
< 				if (rootIterCount & 1)
< 				{
< 					// Secant rule to improve convergence.
< 					t = a1 + (target - s1) * (a2 - a1) / (s2 - s1);
< 				}
< 				else
< 				{
< 					// Bisection to guarantee progress.
< 					t = 0.5f * (a1 + a2);
< 				}
< 
< 				++rootIterCount;
< 				++b2_toiRootIters;
< 
< 				float32 s = fcn.Evaluate(indexA, indexB, t);
< 
< 				if (b2Abs(s - target) < tolerance)
< 				{
< 					// t2 holds a tentative value for t1
< 					t2 = t;
< 					break;
< 				}
< 
< 				// Ensure we continue to bracket the root.
< 				if (s > target)
< 				{
< 					a1 = t;
< 					s1 = s;
< 				}
< 				else
< 				{
< 					a2 = t;
< 					s2 = s;
< 				}
< 				
< 				if (rootIterCount == 50)
< 				{
< 					break;
< 				}
< 			}
< 
< 			b2_toiMaxRootIters = b2Max(b2_toiMaxRootIters, rootIterCount);
< 
< 			++pushBackIter;
< 
< 			if (pushBackIter == b2_maxPolygonVertices)
< 			{
< 				break;
< 			}
---
> 			alpha = 1.0f;
> 			break;
465,466c88,91
< 		++iter;
< 		++b2_toiIters;
---
> 		// Get the conservative time increment. Don't advance all the way.
> 		float32 dAlpha = (distance - targetDistance) / approachVelocityBound;
> 		//float32 dt = (distance - 0.5f * b2_linearSlop) / approachVelocityBound;
> 		float32 newAlpha = alpha + dAlpha;
468c93,94
< 		if (done)
---
> 		// The shapes may be moving apart or a safe distance apart.
> 		if (newAlpha < 0.0f || 1.0f < newAlpha)
469a96
> 			alpha = 1.0f;
473c100,101
< 		if (iter == k_maxIterations)
---
> 		// Ensure significant advancement.
> 		if (newAlpha < (1.0f + 100.0f * B2_FLT_EPSILON) * alpha)
475,477d102
< 			// Root finder got stuck. Semi-victory.
< 			output->state = b2TOIOutput::e_failed;
< 			output->t = t1;
480d104
< 	}
482c106,109
< 	b2_toiMaxIters = b2Max(b2_toiMaxIters, iter);
---
> 		alpha = newAlpha;
> 
> 		++iter;
> 	}
484,486c111
< 	float32 time = timer.GetMilliseconds();
< 	b2_toiMaxTime = b2Max(b2_toiMaxTime, time);
< 	b2_toiTime += time;
---
> 	return alpha;
Only in native/Box2D/Collision: b2TimeOfImpact.h
diff -r -x './svn/*' native/Box2D/Common/.svn/all-wcprops ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Common/.svn/all-wcprops
3,4c3,4
< V 42
< /svn/!svn/ver/254/trunk/Box2D/Box2D/Common
---
> V 46
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Common
9,10c9,10
< V 61
< /svn/!svn/ver/158/trunk/Box2D/Box2D/Common/b2StackAllocator.h
---
> V 65
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Common/b2StackAllocator.h
15,28c15,16
< V 63
< /svn/!svn/ver/158/trunk/Box2D/Box2D/Common/b2BlockAllocator.cpp
< END
< b2GrowableStack.h
< K 25
< svn:wc:ra_dav:version-url
< V 60
< /svn/!svn/ver/158/trunk/Box2D/Box2D/Common/b2GrowableStack.h
< END
< b2Draw.cpp
< K 25
< svn:wc:ra_dav:version-url
< V 53
< /svn/!svn/ver/149/trunk/Box2D/Box2D/Common/b2Draw.cpp
---
> V 67
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Common/b2BlockAllocator.cpp
33,34c21,22
< V 51
< /svn/!svn/ver/216/trunk/Box2D/Box2D/Common/b2Math.h
---
> V 55
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Common/b2Math.h
36c24
< b2Timer.cpp
---
> jtypes.h
39,40c27,28
< V 54
< /svn/!svn/ver/254/trunk/Box2D/Box2D/Common/b2Timer.cpp
---
> V 55
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Common/jtypes.h
45,46c33,34
< V 61
< /svn/!svn/ver/158/trunk/Box2D/Box2D/Common/b2BlockAllocator.h
---
> V 65
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Common/b2BlockAllocator.h
51,52c39,40
< V 57
< /svn/!svn/ver/245/trunk/Box2D/Box2D/Common/b2Settings.cpp
---
> V 61
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Common/b2Settings.cpp
54c42
< b2Draw.h
---
> Fixed.h
57,58c45,46
< V 51
< /svn/!svn/ver/240/trunk/Box2D/Box2D/Common/b2Draw.h
---
> V 54
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Common/Fixed.h
63,70c51,52
< V 55
< /svn/!svn/ver/210/trunk/Box2D/Box2D/Common/b2Settings.h
< END
< b2Timer.h
< K 25
< svn:wc:ra_dav:version-url
< V 52
< /svn/!svn/ver/254/trunk/Box2D/Box2D/Common/b2Timer.h
---
> V 59
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Common/b2Settings.h
75,76c57,58
< V 63
< /svn/!svn/ver/158/trunk/Box2D/Box2D/Common/b2StackAllocator.cpp
---
> V 67
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Common/b2StackAllocator.cpp
81,82c63,64
< V 53
< /svn/!svn/ver/216/trunk/Box2D/Box2D/Common/b2Math.cpp
---
> V 57
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Common/b2Math.cpp
diff -r -x './svn/*' native/Box2D/Common/.svn/entries ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Common/.svn/entries
4,6c4,6
< 254
< http://box2d.googlecode.com/svn/trunk/Box2D/Box2D/Common
< http://box2d.googlecode.com/svn
---
> 7
> http://android-opengl-box2d-basics.googlecode.com/svn/trunk/rt-jnibox2d/box2d/Common
> http://android-opengl-box2d-basics.googlecode.com/svn
10,12c10,12
< 2013-02-19T07:02:35.722054Z
< 254
< erincatto@gmail.com
---
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
27c27
< cafe418c-1137-0410-84cc-357ec87a5d9b
---
> 5131c71c-dced-4c25-419c-0ca2576ce0a2
35,39c35,39
< 2013-06-18T12:51:08.000000Z
< 409662212d47538756bfaa52998823dd
< 2011-03-24T17:36:44.542193Z
< 158
< erincatto
---
> 2013-07-02T14:40:41.000000Z
> 9444b3b128fd3ee91ecbc0409000feaf
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
61c61
< 1732
---
> 1722
69,73c69,73
< 2013-06-18T12:51:08.000000Z
< 93afe1cccc9c52ae50606c1520d85f99
< 2011-03-24T17:36:44.542193Z
< 158
< erincatto
---
> 2013-07-02T14:40:41.000000Z
> a485c64adfbb4013e7b8943de4fcd1b0
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
95,163c95
< 5114
< 
< b2GrowableStack.h
< file
< 
< 
< 
< 
< 2013-06-18T12:51:08.000000Z
< 54f3fee39f60bdb96b845f548e8fe717
< 2011-03-24T17:36:44.542193Z
< 158
< erincatto
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 2024
< 
< b2Draw.cpp
< file
< 
< 
< 
< 
< 2013-06-18T12:51:08.000000Z
< 7d9650feb23f044b2c1e01871e85096b
< 2011-02-22T08:25:20.333661Z
< 149
< erincatto
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 1261
---
> 5084
171,175c103,107
< 2013-06-18T12:51:08.000000Z
< e84580ef4174ebbfecbbe9cc86ed7200
< 2011-09-04T02:09:56.694159Z
< 216
< erincatto@gmail.com
---
> 2013-07-02T14:40:41.000000Z
> 16135ac7576be4cd0bc25a7441596bb3
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
197c129
< 17300
---
> 16226
199c131
< b2Timer.cpp
---
> jtypes.h
205,209c137,141
< 2013-06-18T12:51:08.000000Z
< 6b72d3e062d926e177f563378c2a9295
< 2013-02-19T07:02:35.722054Z
< 254
< erincatto@gmail.com
---
> 2013-07-02T14:40:41.000000Z
> 580013d6d84c3aad222919bed66dc044
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
231c163
< 2366
---
> 4175
239,243c171,175
< 2013-06-18T12:51:08.000000Z
< 7079ae2a9f6139a18ca09b2d57e85eaa
< 2011-03-24T17:36:44.542193Z
< 158
< erincatto
---
> 2013-07-02T14:40:41.000000Z
> ea9c90b9866c62deb757709d8b79c5f4
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
265c197
< 2018
---
> 1825
273,277c205,209
< 2013-06-18T12:51:08.000000Z
< 56ecd29d3f53d4c56d2c0d9e6aa78f9e
< 2012-03-17T06:32:44.892106Z
< 245
< erincatto@gmail.com
---
> 2013-07-02T14:40:41.000000Z
> f81fed9dac12eb8bfea3eaba3bb353e3
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
299c231
< 1398
---
> 1468
301c233
< b2Draw.h
---
> Fixed.h
307,311c239,243
< 2013-06-18T12:51:08.000000Z
< fb804875e28a2ab94d5022cf363dacd2
< 2011-11-27T00:46:35.409210Z
< 240
< erincatto@gmail.com
---
> 2013-07-02T14:40:41.000000Z
> 36f7b05f73e177b2e70a8449105fddd8
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
333c265
< 2880
---
> 18569
341,379c273,277
< 2013-06-18T12:51:08.000000Z
< 6f9efd21775fbad0db5240f2a47eb340
< 2011-09-01T07:50:55.584099Z
< 210
< erincatto@gmail.com
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 5392
< 
< b2Timer.h
< file
< 
< 
< 
< 
< 2013-06-18T12:51:08.000000Z
< 9ffb6519dd775f9876cc3ce4a862e4e8
< 2013-02-19T07:02:35.722054Z
< 254
< erincatto@gmail.com
---
> 2013-07-02T14:40:41.000000Z
> 5f43c6ab0f3d994d7e1ff465f66b71d1
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
401c299
< 1500
---
> 6083
409,413c307,311
< 2013-06-18T12:51:08.000000Z
< 423cf63288f1fa9a9164d9fb4fd8b052
< 2011-03-24T17:36:44.542193Z
< 158
< erincatto
---
> 2013-07-02T14:40:41.000000Z
> 07bfe140eea5c747275ac97de1f2e583
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
435c333
< 2132
---
> 2109
443,447c341,345
< 2013-06-18T12:51:08.000000Z
< 64bb0b1b94d702e021debb1174e0807d
< 2011-09-04T02:09:56.694159Z
< 216
< erincatto@gmail.com
---
> 2013-07-02T14:40:41.000000Z
> ab707ecade5eafe96b24d6290a585c6c
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
469c367
< 2815
---
> 2619
Only in ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Common/.svn/text-base: Fixed.h.svn-base
diff -r -x './svn/*' native/Box2D/Common/.svn/text-base/b2BlockAllocator.cpp.svn-base ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Common/.svn/text-base/b2BlockAllocator.cpp.svn-base
2c2
< * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
19,24c19,22
< #include <Box2D/Common/b2BlockAllocator.h>
< #include <cstdlib>
< #include <climits>
< #include <cstring>
< #include <memory>
< using namespace std;
---
> #include "b2BlockAllocator.h"
> #include <stdlib.h>
> #include <memory.h>
> #include <limits.h>
25a24,25
> #include <string.h>
> 
104,109c104
< 	b2Assert(0 < size);
< 
< 	if (size > b2_maxBlockSize)
< 	{
< 		return b2Alloc(size);
< 	}
---
> 	b2Assert(0 < size && size <= b2_maxBlockSize);
164,170c159
< 	b2Assert(0 < size);
< 
< 	if (size > b2_maxBlockSize)
< 	{
< 		b2Free(p);
< 		return;
< 	}
---
> 	b2Assert(0 < size && size <= b2_maxBlockSize);
178a168
> 	int32 gap = (int32)((int8*)&m_chunks->blocks - (int8*)m_chunks);
185c175
< 						(int8*)chunk->blocks + b2_chunkSize <= (int8*)p);
---
> 						(int8*)chunk->blocks + b2_chunkSize + gap <= (int8*)p);
diff -r -x './svn/*' native/Box2D/Common/.svn/text-base/b2BlockAllocator.h.svn-base ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Common/.svn/text-base/b2BlockAllocator.h.svn-base
2c2
< * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
22c22
< #include <Box2D/Common/b2Settings.h>
---
> #include "b2Settings.h"
24c24
< const int32 b2_chunkSize = 16 * 1024;
---
> const int32 b2_chunkSize = 4096;
32,34c32,34
< /// This is a small object allocator used for allocating small
< /// objects that persist for more than one time step.
< /// See: http://www.codeproject.com/useritems/Small_Block_Allocator.asp
---
> // This is a small object allocator used for allocating small
> // objects that persist for more than one time step.
> // See: http://www.codeproject.com/useritems/Small_Block_Allocator.asp
41d40
< 	/// Allocate memory. This will use b2Alloc if the size is larger than b2_maxBlockSize.
43,44d41
< 
< 	/// Free memory. This will use b2Free if the size is larger than b2_maxBlockSize.
Only in native/Box2D/Common/.svn/text-base: b2Draw.cpp.svn-base
Only in native/Box2D/Common/.svn/text-base: b2Draw.h.svn-base
Only in native/Box2D/Common/.svn/text-base: b2GrowableStack.h.svn-base
diff -r -x './svn/*' native/Box2D/Common/.svn/text-base/b2Math.cpp.svn-base ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Common/.svn/text-base/b2Math.cpp.svn-base
2c2
< * Copyright (c) 2007-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2007 Erin Catto http://www.gphysics.com
19c19
< #include <Box2D/Common/b2Math.h>
---
> #include "b2Math.h"
21a22,23
> const b2Mat22 b2Mat22_identity(1.0f, 0.0f, 0.0f, 1.0f);
> const b2XForm b2XForm_identity(b2Vec2_zero, b2Mat22_identity);
27,31c29,31
< 	float32 det = b2Dot(ex, b2Cross(ey, ez));
< 	if (det != 0.0f)
< 	{
< 		det = 1.0f / det;
< 	}
---
> 	float32 det = b2Dot(col1, b2Cross(col2, col3));
> 	b2Assert(det != 0.0f);
> 	det = 1.0f / det;
33,35c33,35
< 	x.x = det * b2Dot(b, b2Cross(ey, ez));
< 	x.y = det * b2Dot(ex, b2Cross(b, ez));
< 	x.z = det * b2Dot(ex, b2Cross(ey, b));
---
> 	x.x = det * b2Dot(b, b2Cross(col2, col3));
> 	x.y = det * b2Dot(col1, b2Cross(b, col3));
> 	x.z = det * b2Dot(col1, b2Cross(col2, b));
43c43
< 	float32 a11 = ex.x, a12 = ey.x, a21 = ex.y, a22 = ey.y;
---
> 	float32 a11 = col1.x, a12 = col2.x, a21 = col1.y, a22 = col2.y;
45,48c45,46
< 	if (det != 0.0f)
< 	{
< 		det = 1.0f / det;
< 	}
---
> 	b2Assert(det != 0.0f);
> 	det = 1.0f / det;
55,56c53
< ///
< void b2Mat33::GetInverse22(b2Mat33* M) const
---
> void b2Sweep::GetXForm(b2XForm* xf, float32 t) const
58,60c55,56
< 	float32 a = ex.x, b = ey.x, c = ex.y, d = ey.y;
< 	float32 det = a * d - b * c;
< 	if (det != 0.0f)
---
> 	// center = p + R * localCenter
> 	if (1.0f - t0 > B2_FLT_EPSILON)
62c58,66
< 		det = 1.0f / det;
---
> 		float32 alpha = (t - t0) / (1.0f - t0);
> 		xf->position = (1.0f - alpha) * c0 + alpha * c;
> 		float32 angle = (1.0f - alpha) * a0 + alpha * a;
> 		xf->R.Set(angle);
> 	}
> 	else
> 	{
> 		xf->position = c;
> 		xf->R.Set(a);
65,67c69,70
< 	M->ex.x =  det * d;	M->ey.x = -det * b; M->ex.z = 0.0f;
< 	M->ex.y = -det * c;	M->ey.y =  det * a; M->ey.z = 0.0f;
< 	M->ez.x = 0.0f; M->ez.y = 0.0f; M->ez.z = 0.0f;
---
> 	// Shift to origin
> 	xf->position -= b2Mul(xf->R, localCenter);
70,71c73
< /// Returns the zero matrix if singular.
< void b2Mat33::GetSymInverse33(b2Mat33* M) const
---
> void b2Sweep::Advance(float32 t)
73,74c75
< 	float32 det = b2Dot(ex, b2Cross(ey, ez));
< 	if (det != 0.0f)
---
> 	if (t0 < t && 1.0f - t0 > B2_FLT_EPSILON)
76c77,80
< 		det = 1.0f / det;
---
> 		float32 alpha = (t - t0) / (1.0f - t0);
> 		c0 = (1.0f - alpha) * c0 + alpha * c;
> 		a0 = (1.0f - alpha) * a0 + alpha * a;
> 		t0 = t;
78,93d81
< 
< 	float32 a11 = ex.x, a12 = ey.x, a13 = ez.x;
< 	float32 a22 = ey.y, a23 = ez.y;
< 	float32 a33 = ez.z;
< 
< 	M->ex.x = det * (a22 * a33 - a23 * a23);
< 	M->ex.y = det * (a13 * a23 - a12 * a33);
< 	M->ex.z = det * (a12 * a23 - a13 * a22);
< 
< 	M->ey.x = M->ex.y;
< 	M->ey.y = det * (a11 * a33 - a13 * a13);
< 	M->ey.z = det * (a13 * a12 - a11 * a23);
< 
< 	M->ez.x = M->ex.z;
< 	M->ez.y = M->ey.z;
< 	M->ez.z = det * (a11 * a22 - a12 * a12);
diff -r -x './svn/*' native/Box2D/Common/.svn/text-base/b2Math.h.svn-base ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Common/.svn/text-base/b2Math.h.svn-base
1,731c1,716
< /*
< * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
< *
< * This software is provided 'as-is', without any express or implied
< * warranty.  In no event will the authors be held liable for any damages
< * arising from the use of this software.
< * Permission is granted to anyone to use this software for any purpose,
< * including commercial applications, and to alter it and redistribute it
< * freely, subject to the following restrictions:
< * 1. The origin of this software must not be misrepresented; you must not
< * claim that you wrote the original software. If you use this software
< * in a product, an acknowledgment in the product documentation would be
< * appreciated but is not required.
< * 2. Altered source versions must be plainly marked as such, and must not be
< * misrepresented as being the original software.
< * 3. This notice may not be removed or altered from any source distribution.
< */
< 
< #ifndef B2_MATH_H
< #define B2_MATH_H
< 
< #include <Box2D/Common/b2Settings.h>
< 
< #include <cmath>
< #include <cfloat>
< #include <cstddef>
< #include <limits>
< 
< /// This function is used to ensure that a floating point number is
< /// not a NaN or infinity.
< inline bool b2IsValid(float32 x)
< {
< 	if (x != x)
< 	{
< 		// NaN.
< 		return false;
< 	}
< 
< 	float32 infinity = std::numeric_limits<float32>::infinity();
< 	return -infinity < x && x < infinity;
< }
< 
< /// This is a approximate yet fast inverse square-root.
< inline float32 b2InvSqrt(float32 x)
< {
< 	union
< 	{
< 		float32 x;
< 		int32 i;
< 	} convert;
< 
< 	convert.x = x;
< 	float32 xhalf = 0.5f * x;
< 	convert.i = 0x5f3759df - (convert.i >> 1);
< 	x = convert.x;
< 	x = x * (1.5f - xhalf * x * x);
< 	return x;
< }
< 
< #define	b2Sqrt(x)	std::sqrt(x)
< #define	b2Atan2(y, x)	std::atan2(y, x)
< 
< /// A 2D column vector.
< struct b2Vec2
< {
< 	/// Default constructor does nothing (for performance).
< 	b2Vec2() {}
< 
< 	/// Construct using coordinates.
< 	b2Vec2(float32 x, float32 y) : x(x), y(y) {}
< 
< 	/// Set this vector to all zeros.
< 	void SetZero() { x = 0.0f; y = 0.0f; }
< 
< 	/// Set this vector to some specified coordinates.
< 	void Set(float32 x_, float32 y_) { x = x_; y = y_; }
< 
< 	/// Negate this vector.
< 	b2Vec2 operator -() const { b2Vec2 v; v.Set(-x, -y); return v; }
< 	
< 	/// Read from and indexed element.
< 	float32 operator () (int32 i) const
< 	{
< 		return (&x)[i];
< 	}
< 
< 	/// Write to an indexed element.
< 	float32& operator () (int32 i)
< 	{
< 		return (&x)[i];
< 	}
< 
< 	/// Add a vector to this vector.
< 	void operator += (const b2Vec2& v)
< 	{
< 		x += v.x; y += v.y;
< 	}
< 	
< 	/// Subtract a vector from this vector.
< 	void operator -= (const b2Vec2& v)
< 	{
< 		x -= v.x; y -= v.y;
< 	}
< 
< 	/// Multiply this vector by a scalar.
< 	void operator *= (float32 a)
< 	{
< 		x *= a; y *= a;
< 	}
< 
< 	/// Get the length of this vector (the norm).
< 	float32 Length() const
< 	{
< 		return b2Sqrt(x * x + y * y);
< 	}
< 
< 	/// Get the length squared. For performance, use this instead of
< 	/// b2Vec2::Length (if possible).
< 	float32 LengthSquared() const
< 	{
< 		return x * x + y * y;
< 	}
< 
< 	/// Convert this vector into a unit vector. Returns the length.
< 	float32 Normalize()
< 	{
< 		float32 length = Length();
< 		if (length < b2_epsilon)
< 		{
< 			return 0.0f;
< 		}
< 		float32 invLength = 1.0f / length;
< 		x *= invLength;
< 		y *= invLength;
< 
< 		return length;
< 	}
< 
< 	/// Does this vector contain finite coordinates?
< 	bool IsValid() const
< 	{
< 		return b2IsValid(x) && b2IsValid(y);
< 	}
< 
< 	/// Get the skew vector such that dot(skew_vec, other) == cross(vec, other)
< 	b2Vec2 Skew() const
< 	{
< 		return b2Vec2(-y, x);
< 	}
< 
< 	float32 x, y;
< };
< 
< /// A 2D column vector with 3 elements.
< struct b2Vec3
< {
< 	/// Default constructor does nothing (for performance).
< 	b2Vec3() {}
< 
< 	/// Construct using coordinates.
< 	b2Vec3(float32 x, float32 y, float32 z) : x(x), y(y), z(z) {}
< 
< 	/// Set this vector to all zeros.
< 	void SetZero() { x = 0.0f; y = 0.0f; z = 0.0f; }
< 
< 	/// Set this vector to some specified coordinates.
< 	void Set(float32 x_, float32 y_, float32 z_) { x = x_; y = y_; z = z_; }
< 
< 	/// Negate this vector.
< 	b2Vec3 operator -() const { b2Vec3 v; v.Set(-x, -y, -z); return v; }
< 
< 	/// Add a vector to this vector.
< 	void operator += (const b2Vec3& v)
< 	{
< 		x += v.x; y += v.y; z += v.z;
< 	}
< 
< 	/// Subtract a vector from this vector.
< 	void operator -= (const b2Vec3& v)
< 	{
< 		x -= v.x; y -= v.y; z -= v.z;
< 	}
< 
< 	/// Multiply this vector by a scalar.
< 	void operator *= (float32 s)
< 	{
< 		x *= s; y *= s; z *= s;
< 	}
< 
< 	float32 x, y, z;
< };
< 
< /// A 2-by-2 matrix. Stored in column-major order.
< struct b2Mat22
< {
< 	/// The default constructor does nothing (for performance).
< 	b2Mat22() {}
< 
< 	/// Construct this matrix using columns.
< 	b2Mat22(const b2Vec2& c1, const b2Vec2& c2)
< 	{
< 		ex = c1;
< 		ey = c2;
< 	}
< 
< 	/// Construct this matrix using scalars.
< 	b2Mat22(float32 a11, float32 a12, float32 a21, float32 a22)
< 	{
< 		ex.x = a11; ex.y = a21;
< 		ey.x = a12; ey.y = a22;
< 	}
< 
< 	/// Initialize this matrix using columns.
< 	void Set(const b2Vec2& c1, const b2Vec2& c2)
< 	{
< 		ex = c1;
< 		ey = c2;
< 	}
< 
< 	/// Set this to the identity matrix.
< 	void SetIdentity()
< 	{
< 		ex.x = 1.0f; ey.x = 0.0f;
< 		ex.y = 0.0f; ey.y = 1.0f;
< 	}
< 
< 	/// Set this matrix to all zeros.
< 	void SetZero()
< 	{
< 		ex.x = 0.0f; ey.x = 0.0f;
< 		ex.y = 0.0f; ey.y = 0.0f;
< 	}
< 
< 	b2Mat22 GetInverse() const
< 	{
< 		float32 a = ex.x, b = ey.x, c = ex.y, d = ey.y;
< 		b2Mat22 B;
< 		float32 det = a * d - b * c;
< 		if (det != 0.0f)
< 		{
< 			det = 1.0f / det;
< 		}
< 		B.ex.x =  det * d;	B.ey.x = -det * b;
< 		B.ex.y = -det * c;	B.ey.y =  det * a;
< 		return B;
< 	}
< 
< 	/// Solve A * x = b, where b is a column vector. This is more efficient
< 	/// than computing the inverse in one-shot cases.
< 	b2Vec2 Solve(const b2Vec2& b) const
< 	{
< 		float32 a11 = ex.x, a12 = ey.x, a21 = ex.y, a22 = ey.y;
< 		float32 det = a11 * a22 - a12 * a21;
< 		if (det != 0.0f)
< 		{
< 			det = 1.0f / det;
< 		}
< 		b2Vec2 x;
< 		x.x = det * (a22 * b.x - a12 * b.y);
< 		x.y = det * (a11 * b.y - a21 * b.x);
< 		return x;
< 	}
< 
< 	b2Vec2 ex, ey;
< };
< 
< /// A 3-by-3 matrix. Stored in column-major order.
< struct b2Mat33
< {
< 	/// The default constructor does nothing (for performance).
< 	b2Mat33() {}
< 
< 	/// Construct this matrix using columns.
< 	b2Mat33(const b2Vec3& c1, const b2Vec3& c2, const b2Vec3& c3)
< 	{
< 		ex = c1;
< 		ey = c2;
< 		ez = c3;
< 	}
< 
< 	/// Set this matrix to all zeros.
< 	void SetZero()
< 	{
< 		ex.SetZero();
< 		ey.SetZero();
< 		ez.SetZero();
< 	}
< 
< 	/// Solve A * x = b, where b is a column vector. This is more efficient
< 	/// than computing the inverse in one-shot cases.
< 	b2Vec3 Solve33(const b2Vec3& b) const;
< 
< 	/// Solve A * x = b, where b is a column vector. This is more efficient
< 	/// than computing the inverse in one-shot cases. Solve only the upper
< 	/// 2-by-2 matrix equation.
< 	b2Vec2 Solve22(const b2Vec2& b) const;
< 
< 	/// Get the inverse of this matrix as a 2-by-2.
< 	/// Returns the zero matrix if singular.
< 	void GetInverse22(b2Mat33* M) const;
< 
< 	/// Get the symmetric inverse of this matrix as a 3-by-3.
< 	/// Returns the zero matrix if singular.
< 	void GetSymInverse33(b2Mat33* M) const;
< 
< 	b2Vec3 ex, ey, ez;
< };
< 
< /// Rotation
< struct b2Rot
< {
< 	b2Rot() {}
< 
< 	/// Initialize from an angle in radians
< 	explicit b2Rot(float32 angle)
< 	{
< 		/// TODO_ERIN optimize
< 		s = sinf(angle);
< 		c = cosf(angle);
< 	}
< 
< 	/// Set using an angle in radians.
< 	void Set(float32 angle)
< 	{
< 		/// TODO_ERIN optimize
< 		s = sinf(angle);
< 		c = cosf(angle);
< 	}
< 
< 	/// Set to the identity rotation
< 	void SetIdentity()
< 	{
< 		s = 0.0f;
< 		c = 1.0f;
< 	}
< 
< 	/// Get the angle in radians
< 	float32 GetAngle() const
< 	{
< 		return b2Atan2(s, c);
< 	}
< 
< 	/// Get the x-axis
< 	b2Vec2 GetXAxis() const
< 	{
< 		return b2Vec2(c, s);
< 	}
< 
< 	/// Get the u-axis
< 	b2Vec2 GetYAxis() const
< 	{
< 		return b2Vec2(-s, c);
< 	}
< 
< 	/// Sine and cosine
< 	float32 s, c;
< };
< 
< /// A transform contains translation and rotation. It is used to represent
< /// the position and orientation of rigid frames.
< struct b2Transform
< {
< 	/// The default constructor does nothing.
< 	b2Transform() {}
< 
< 	/// Initialize using a position vector and a rotation.
< 	b2Transform(const b2Vec2& position, const b2Rot& rotation) : p(position), q(rotation) {}
< 
< 	/// Set this to the identity transform.
< 	void SetIdentity()
< 	{
< 		p.SetZero();
< 		q.SetIdentity();
< 	}
< 
< 	/// Set this based on the position and angle.
< 	void Set(const b2Vec2& position, float32 angle)
< 	{
< 		p = position;
< 		q.Set(angle);
< 	}
< 
< 	b2Vec2 p;
< 	b2Rot q;
< };
< 
< /// This describes the motion of a body/shape for TOI computation.
< /// Shapes are defined with respect to the body origin, which may
< /// no coincide with the center of mass. However, to support dynamics
< /// we must interpolate the center of mass position.
< struct b2Sweep
< {
< 	/// Get the interpolated transform at a specific time.
< 	/// @param beta is a factor in [0,1], where 0 indicates alpha0.
< 	void GetTransform(b2Transform* xfb, float32 beta) const;
< 
< 	/// Advance the sweep forward, yielding a new initial state.
< 	/// @param alpha the new initial time.
< 	void Advance(float32 alpha);
< 
< 	/// Normalize the angles.
< 	void Normalize();
< 
< 	b2Vec2 localCenter;	///< local center of mass position
< 	b2Vec2 c0, c;		///< center world positions
< 	float32 a0, a;		///< world angles
< 
< 	/// Fraction of the current time step in the range [0,1]
< 	/// c0 and a0 are the positions at alpha0.
< 	float32 alpha0;
< };
< 
< /// Useful constant
< extern const b2Vec2 b2Vec2_zero;
< 
< /// Perform the dot product on two vectors.
< inline float32 b2Dot(const b2Vec2& a, const b2Vec2& b)
< {
< 	return a.x * b.x + a.y * b.y;
< }
< 
< /// Perform the cross product on two vectors. In 2D this produces a scalar.
< inline float32 b2Cross(const b2Vec2& a, const b2Vec2& b)
< {
< 	return a.x * b.y - a.y * b.x;
< }
< 
< /// Perform the cross product on a vector and a scalar. In 2D this produces
< /// a vector.
< inline b2Vec2 b2Cross(const b2Vec2& a, float32 s)
< {
< 	return b2Vec2(s * a.y, -s * a.x);
< }
< 
< /// Perform the cross product on a scalar and a vector. In 2D this produces
< /// a vector.
< inline b2Vec2 b2Cross(float32 s, const b2Vec2& a)
< {
< 	return b2Vec2(-s * a.y, s * a.x);
< }
< 
< /// Multiply a matrix times a vector. If a rotation matrix is provided,
< /// then this transforms the vector from one frame to another.
< inline b2Vec2 b2Mul(const b2Mat22& A, const b2Vec2& v)
< {
< 	return b2Vec2(A.ex.x * v.x + A.ey.x * v.y, A.ex.y * v.x + A.ey.y * v.y);
< }
< 
< /// Multiply a matrix transpose times a vector. If a rotation matrix is provided,
< /// then this transforms the vector from one frame to another (inverse transform).
< inline b2Vec2 b2MulT(const b2Mat22& A, const b2Vec2& v)
< {
< 	return b2Vec2(b2Dot(v, A.ex), b2Dot(v, A.ey));
< }
< 
< /// Add two vectors component-wise.
< inline b2Vec2 operator + (const b2Vec2& a, const b2Vec2& b)
< {
< 	return b2Vec2(a.x + b.x, a.y + b.y);
< }
< 
< /// Subtract two vectors component-wise.
< inline b2Vec2 operator - (const b2Vec2& a, const b2Vec2& b)
< {
< 	return b2Vec2(a.x - b.x, a.y - b.y);
< }
< 
< inline b2Vec2 operator * (float32 s, const b2Vec2& a)
< {
< 	return b2Vec2(s * a.x, s * a.y);
< }
< 
< inline bool operator == (const b2Vec2& a, const b2Vec2& b)
< {
< 	return a.x == b.x && a.y == b.y;
< }
< 
< inline float32 b2Distance(const b2Vec2& a, const b2Vec2& b)
< {
< 	b2Vec2 c = a - b;
< 	return c.Length();
< }
< 
< inline float32 b2DistanceSquared(const b2Vec2& a, const b2Vec2& b)
< {
< 	b2Vec2 c = a - b;
< 	return b2Dot(c, c);
< }
< 
< inline b2Vec3 operator * (float32 s, const b2Vec3& a)
< {
< 	return b2Vec3(s * a.x, s * a.y, s * a.z);
< }
< 
< /// Add two vectors component-wise.
< inline b2Vec3 operator + (const b2Vec3& a, const b2Vec3& b)
< {
< 	return b2Vec3(a.x + b.x, a.y + b.y, a.z + b.z);
< }
< 
< /// Subtract two vectors component-wise.
< inline b2Vec3 operator - (const b2Vec3& a, const b2Vec3& b)
< {
< 	return b2Vec3(a.x - b.x, a.y - b.y, a.z - b.z);
< }
< 
< /// Perform the dot product on two vectors.
< inline float32 b2Dot(const b2Vec3& a, const b2Vec3& b)
< {
< 	return a.x * b.x + a.y * b.y + a.z * b.z;
< }
< 
< /// Perform the cross product on two vectors.
< inline b2Vec3 b2Cross(const b2Vec3& a, const b2Vec3& b)
< {
< 	return b2Vec3(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
< }
< 
< inline b2Mat22 operator + (const b2Mat22& A, const b2Mat22& B)
< {
< 	return b2Mat22(A.ex + B.ex, A.ey + B.ey);
< }
< 
< // A * B
< inline b2Mat22 b2Mul(const b2Mat22& A, const b2Mat22& B)
< {
< 	return b2Mat22(b2Mul(A, B.ex), b2Mul(A, B.ey));
< }
< 
< // A^T * B
< inline b2Mat22 b2MulT(const b2Mat22& A, const b2Mat22& B)
< {
< 	b2Vec2 c1(b2Dot(A.ex, B.ex), b2Dot(A.ey, B.ex));
< 	b2Vec2 c2(b2Dot(A.ex, B.ey), b2Dot(A.ey, B.ey));
< 	return b2Mat22(c1, c2);
< }
< 
< /// Multiply a matrix times a vector.
< inline b2Vec3 b2Mul(const b2Mat33& A, const b2Vec3& v)
< {
< 	return v.x * A.ex + v.y * A.ey + v.z * A.ez;
< }
< 
< /// Multiply a matrix times a vector.
< inline b2Vec2 b2Mul22(const b2Mat33& A, const b2Vec2& v)
< {
< 	return b2Vec2(A.ex.x * v.x + A.ey.x * v.y, A.ex.y * v.x + A.ey.y * v.y);
< }
< 
< /// Multiply two rotations: q * r
< inline b2Rot b2Mul(const b2Rot& q, const b2Rot& r)
< {
< 	// [qc -qs] * [rc -rs] = [qc*rc-qs*rs -qc*rs-qs*rc]
< 	// [qs  qc]   [rs  rc]   [qs*rc+qc*rs -qs*rs+qc*rc]
< 	// s = qs * rc + qc * rs
< 	// c = qc * rc - qs * rs
< 	b2Rot qr;
< 	qr.s = q.s * r.c + q.c * r.s;
< 	qr.c = q.c * r.c - q.s * r.s;
< 	return qr;
< }
< 
< /// Transpose multiply two rotations: qT * r
< inline b2Rot b2MulT(const b2Rot& q, const b2Rot& r)
< {
< 	// [ qc qs] * [rc -rs] = [qc*rc+qs*rs -qc*rs+qs*rc]
< 	// [-qs qc]   [rs  rc]   [-qs*rc+qc*rs qs*rs+qc*rc]
< 	// s = qc * rs - qs * rc
< 	// c = qc * rc + qs * rs
< 	b2Rot qr;
< 	qr.s = q.c * r.s - q.s * r.c;
< 	qr.c = q.c * r.c + q.s * r.s;
< 	return qr;
< }
< 
< /// Rotate a vector
< inline b2Vec2 b2Mul(const b2Rot& q, const b2Vec2& v)
< {
< 	return b2Vec2(q.c * v.x - q.s * v.y, q.s * v.x + q.c * v.y);
< }
< 
< /// Inverse rotate a vector
< inline b2Vec2 b2MulT(const b2Rot& q, const b2Vec2& v)
< {
< 	return b2Vec2(q.c * v.x + q.s * v.y, -q.s * v.x + q.c * v.y);
< }
< 
< inline b2Vec2 b2Mul(const b2Transform& T, const b2Vec2& v)
< {
< 	float32 x = (T.q.c * v.x - T.q.s * v.y) + T.p.x;
< 	float32 y = (T.q.s * v.x + T.q.c * v.y) + T.p.y;
< 
< 	return b2Vec2(x, y);
< }
< 
< inline b2Vec2 b2MulT(const b2Transform& T, const b2Vec2& v)
< {
< 	float32 px = v.x - T.p.x;
< 	float32 py = v.y - T.p.y;
< 	float32 x = (T.q.c * px + T.q.s * py);
< 	float32 y = (-T.q.s * px + T.q.c * py);
< 
< 	return b2Vec2(x, y);
< }
< 
< // v2 = A.q.Rot(B.q.Rot(v1) + B.p) + A.p
< //    = (A.q * B.q).Rot(v1) + A.q.Rot(B.p) + A.p
< inline b2Transform b2Mul(const b2Transform& A, const b2Transform& B)
< {
< 	b2Transform C;
< 	C.q = b2Mul(A.q, B.q);
< 	C.p = b2Mul(A.q, B.p) + A.p;
< 	return C;
< }
< 
< // v2 = A.q' * (B.q * v1 + B.p - A.p)
< //    = A.q' * B.q * v1 + A.q' * (B.p - A.p)
< inline b2Transform b2MulT(const b2Transform& A, const b2Transform& B)
< {
< 	b2Transform C;
< 	C.q = b2MulT(A.q, B.q);
< 	C.p = b2MulT(A.q, B.p - A.p);
< 	return C;
< }
< 
< template <typename T>
< inline T b2Abs(T a)
< {
< 	return a > T(0) ? a : -a;
< }
< 
< inline b2Vec2 b2Abs(const b2Vec2& a)
< {
< 	return b2Vec2(b2Abs(a.x), b2Abs(a.y));
< }
< 
< inline b2Mat22 b2Abs(const b2Mat22& A)
< {
< 	return b2Mat22(b2Abs(A.ex), b2Abs(A.ey));
< }
< 
< template <typename T>
< inline T b2Min(T a, T b)
< {
< 	return a < b ? a : b;
< }
< 
< inline b2Vec2 b2Min(const b2Vec2& a, const b2Vec2& b)
< {
< 	return b2Vec2(b2Min(a.x, b.x), b2Min(a.y, b.y));
< }
< 
< template <typename T>
< inline T b2Max(T a, T b)
< {
< 	return a > b ? a : b;
< }
< 
< inline b2Vec2 b2Max(const b2Vec2& a, const b2Vec2& b)
< {
< 	return b2Vec2(b2Max(a.x, b.x), b2Max(a.y, b.y));
< }
< 
< template <typename T>
< inline T b2Clamp(T a, T low, T high)
< {
< 	return b2Max(low, b2Min(a, high));
< }
< 
< inline b2Vec2 b2Clamp(const b2Vec2& a, const b2Vec2& low, const b2Vec2& high)
< {
< 	return b2Max(low, b2Min(a, high));
< }
< 
< template<typename T> inline void b2Swap(T& a, T& b)
< {
< 	T tmp = a;
< 	a = b;
< 	b = tmp;
< }
< 
< /// "Next Largest Power of 2
< /// Given a binary integer value x, the next largest power of 2 can be computed by a SWAR algorithm
< /// that recursively "folds" the upper bits into the lower bits. This process yields a bit vector with
< /// the same most significant 1 as x, but all 1's below it. Adding 1 to that value yields the next
< /// largest power of 2. For a 32-bit value:"
< inline uint32 b2NextPowerOfTwo(uint32 x)
< {
< 	x |= (x >> 1);
< 	x |= (x >> 2);
< 	x |= (x >> 4);
< 	x |= (x >> 8);
< 	x |= (x >> 16);
< 	return x + 1;
< }
< 
< inline bool b2IsPowerOfTwo(uint32 x)
< {
< 	bool result = x > 0 && (x & (x - 1)) == 0;
< 	return result;
< }
< 
< inline void b2Sweep::GetTransform(b2Transform* xf, float32 beta) const
< {
< 	xf->p = (1.0f - beta) * c0 + beta * c;
< 	float32 angle = (1.0f - beta) * a0 + beta * a;
< 	xf->q.Set(angle);
< 
< 	// Shift to origin
< 	xf->p -= b2Mul(xf->q, localCenter);
< }
< 
< inline void b2Sweep::Advance(float32 alpha)
< {
< 	b2Assert(alpha0 < 1.0f);
< 	float32 beta = (alpha - alpha0) / (1.0f - alpha0);
< 	c0 = (1.0f - beta) * c0 + beta * c;
< 	a0 = (1.0f - beta) * a0 + beta * a;
< 	alpha0 = alpha;
< }
< 
< /// Normalize an angle in radians to be between -pi and pi
< inline void b2Sweep::Normalize()
< {
< 	float32 twoPi = 2.0f * b2_pi;
< 	float32 d =  twoPi * floorf(a0 / twoPi);
< 	a0 -= d;
< 	a -= d;
< }
< 
< #endif
---
> /*
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
> *
> * This software is provided 'as-is', without any express or implied
> * warranty.  In no event will the authors be held liable for any damages
> * arising from the use of this software.
> * Permission is granted to anyone to use this software for any purpose,
> * including commercial applications, and to alter it and redistribute it
> * freely, subject to the following restrictions:
> * 1. The origin of this software must not be misrepresented; you must not
> * claim that you wrote the original software. If you use this software
> * in a product, an acknowledgment in the product documentation would be
> * appreciated but is not required.
> * 2. Altered source versions must be plainly marked as such, and must not be
> * misrepresented as being the original software.
> * 3. This notice may not be removed or altered from any source distribution.
> */
> 
> #ifndef B2_MATH_H
> #define B2_MATH_H
> 
> #include "b2Settings.h"
> 
> #ifdef TARGET_OS_IPHONE
> #include "math.h"
> #else
> #include <math.h>
> #endif
> 
> 
> 
> #include <float.h>
> #include <stdlib.h>
> 
> #include <stdio.h>
> 
> #ifdef TARGET_FLOAT32_IS_FIXED
> 
> inline Fixed b2Min(const Fixed& a, const Fixed& b)
> {
>   return a < b ? a : b;
> }
> 
> inline Fixed b2Max(const Fixed& a, const Fixed& b)
> {
>   return a > b ? a : b;
> }
> 
> inline Fixed b2Clamp(Fixed a, Fixed low, Fixed high)
> {
> 	return b2Max(low, b2Min(a, high));
> }
> 
> inline bool b2IsValid(Fixed x)
> {
> 	B2_NOT_USED(x);
> 	return true;
> }
> 
> #define	b2Sqrt(x)	sqrt(x)
> #define	b2Atan2(y, x)	atan2(y, x)
> 
> #else
> 
> /// This function is used to ensure that a floating point number is
> /// not a NaN or infinity.
> inline bool b2IsValid(float32 x)
> {
> #ifdef _MSC_VER
> 	return _finite(x) != 0;
> #else
> 	
> #ifdef TARGET_OS_IPHONE
> 	return isfinite(x);
> #else
> 	return finite(x) != 0;
> #endif
> 	
> 	
> #endif
> }
> 
> /// This is a approximate yet fast inverse square-root.
> inline float32 b2InvSqrt(float32 x)
> {
> 	union
> 	{
> 		float32 x;
> 		int32 i;
> 	} convert;
> 
> 	convert.x = x;
> 	float32 xhalf = 0.5f * x;
> 	convert.i = 0x5f3759df - (convert.i >> 1);
> 	x = convert.x;
> 	x = x * (1.5f - xhalf * x * x);
> 	return x;
> }
> 
> #define	b2Sqrt(x)	sqrtf(x)
> #define	b2Atan2(y, x)	atan2f(y, x)
> 
> #endif
> 
> inline float32 b2Abs(float32 a)
> {
> 	return a > 0.0f ? a : -a;
> }
> 
> /// A 2D column vector.
> struct b2Vec2
> {
> 	/// Default constructor does nothing (for performance).
> 	b2Vec2() {}
> 
> 	/// Construct using coordinates.
> 	b2Vec2(float32 x, float32 y) : x(x), y(y) {}
> 
> 	/// Set this vector to all zeros.
> 	void SetZero() { x = 0.0f; y = 0.0f; }
> 
> 	/// Set this vector to some specified coordinates.
> 	void Set(float32 x_, float32 y_) { x = x_; y = y_; }
> 
> 	/// Negate this vector.
> 	b2Vec2 operator -() const { b2Vec2 v; v.Set(-x, -y); return v; }
> 	
> 	/// Add a vector to this vector.
> 	void operator += (const b2Vec2& v)
> 	{
> 		x += v.x; y += v.y;
> 	}
> 	
> 	/// Subtract a vector from this vector.
> 	void operator -= (const b2Vec2& v)
> 	{
> 		x -= v.x; y -= v.y;
> 	}
> 
> 	/// Multiply this vector by a scalar.
> 	void operator *= (float32 a)
> 	{
> 		x *= a; y *= a;
> 	}
> 
> 	/// Get the length of this vector (the norm).
> 	float32 Length() const
> 	{
> #ifdef TARGET_FLOAT32_IS_FIXED
> 		float est = b2Abs(x) + b2Abs(y);
> 		if(est == 0.0f) {
> 			return 0.0;
> 		} else if(est < 0.1) {
> 			return (1.0/256.0) * b2Vec2(x<<8, y<<8).Length();
> 		} else if(est < 180.0f) {
> 			return b2Sqrt(x * x + y * y);
> 		} else {
> 			return 256.0 * (b2Vec2(x>>8, y>>8).Length());
> 		}
> #else
> 		return b2Sqrt(x * x + y * y);
> #endif 
> 	}
> 
> 	/// Get the length squared. For performance, use this instead of
> 	/// b2Vec2::Length (if possible).
> 	float32 LengthSquared() const
> 	{
> 		return x * x + y * y;
> 	}
> 
> 	/// Convert this vector into a unit vector. Returns the length.
> #ifdef TARGET_FLOAT32_IS_FIXED
> 	float32 Normalize()
> 	{
> 		float32 length = Length();
> 		if (length < B2_FLT_EPSILON)
> 		{
> 			return 0.0f;
> 		} 
> #ifdef NORMALIZE_BY_INVERT_MULTIPLY
> 		if (length < (1.0/16.0)) {
> 			x = x << 4;
> 			y = y << 4;
> 			return (1.0/16.0)*Normalize();
> 		} else if(length > 16.0) {
> 			x = x >> 4;
> 			y = y >> 4;
> 			return 16.0*Normalize();
> 		}
> 		float32 invLength = 1.0f / length;
> 		x *= invLength;
> 		y *= invLength;
> #else
> 		x /= length;
> 		y /= length;
> #endif
> 		return length;
> 	}
> #else
> 	float32 Normalize()
> 	{
> 		float32 length = Length();
> 		if (length < B2_FLT_EPSILON)
> 		{
> 			return 0.0f;
> 		}
> 		float32 invLength = 1.0f / length;
> 		x *= invLength;
> 		y *= invLength;
> 
> 		return length;
> 	}
> #endif
> 
> 	/// Does this vector contain finite coordinates?
> 	bool IsValid() const
> 	{
> 		return b2IsValid(x) && b2IsValid(y);
> 	}
> 
> 	float32 x, y;
> };
> 
> /// A 2D column vector with 3 elements.
> struct b2Vec3
> {
> 	/// Default constructor does nothing (for performance).
> 	b2Vec3() {}
> 
> 	/// Construct using coordinates.
> 	b2Vec3(float32 x, float32 y, float32 z) : x(x), y(y), z(z) {}
> 
> 	/// Set this vector to all zeros.
> 	void SetZero() { x = 0.0f; y = 0.0f; z = 0.0f; }
> 
> 	/// Set this vector to some specified coordinates.
> 	void Set(float32 x_, float32 y_, float32 z_) { x = x_; y = y_; z = z_; }
> 
> 	/// Negate this vector.
> 	b2Vec3 operator -() const { b2Vec3 v; v.Set(-x, -y, -z); return v; }
> 
> 	/// Add a vector to this vector.
> 	void operator += (const b2Vec3& v)
> 	{
> 		x += v.x; y += v.y; z += v.z;
> 	}
> 
> 	/// Subtract a vector from this vector.
> 	void operator -= (const b2Vec3& v)
> 	{
> 		x -= v.x; y -= v.y; z -= v.z;
> 	}
> 
> 	/// Multiply this vector by a scalar.
> 	void operator *= (float32 s)
> 	{
> 		x *= s; y *= s; z *= s;
> 	}
> 
> 	float32 x, y, z;
> };
> 
> /// A 2-by-2 matrix. Stored in column-major order.
> struct b2Mat22
> {
> 	/// The default constructor does nothing (for performance).
> 	b2Mat22() {}
> 
> 	/// Construct this matrix using columns.
> 	b2Mat22(const b2Vec2& c1, const b2Vec2& c2)
> 	{
> 		col1 = c1;
> 		col2 = c2;
> 	}
> 
> 	/// Construct this matrix using scalars.
> 	b2Mat22(float32 a11, float32 a12, float32 a21, float32 a22)
> 	{
> 		col1.x = a11; col1.y = a21;
> 		col2.x = a12; col2.y = a22;
> 	}
> 
> 	/// Construct this matrix using an angle. This matrix becomes
> 	/// an orthonormal rotation matrix.
> 	explicit b2Mat22(float32 angle)
> 	{
> 		// TODO_ERIN compute sin+cos together.
> 		float32 c = cosf(angle), s = sinf(angle);
> 		col1.x = c; col2.x = -s;
> 		col1.y = s; col2.y = c;
> 	}
> 
> 	/// Initialize this matrix using columns.
> 	void Set(const b2Vec2& c1, const b2Vec2& c2)
> 	{
> 		col1 = c1;
> 		col2 = c2;
> 	}
> 
> 	/// Initialize this matrix using an angle. This matrix becomes
> 	/// an orthonormal rotation matrix.
> 	void Set(float32 angle)
> 	{
> 		float32 c = cosf(angle), s = sinf(angle);
> 		col1.x = c; col2.x = -s;
> 		col1.y = s; col2.y = c;
> 	}
> 
> 	/// Set this to the identity matrix.
> 	void SetIdentity()
> 	{
> 		col1.x = 1.0f; col2.x = 0.0f;
> 		col1.y = 0.0f; col2.y = 1.0f;
> 	}
> 
> 	/// Set this matrix to all zeros.
> 	void SetZero()
> 	{
> 		col1.x = 0.0f; col2.x = 0.0f;
> 		col1.y = 0.0f; col2.y = 0.0f;
> 	}
> 
> 	/// Extract the angle from this matrix (assumed to be
> 	/// a rotation matrix).
> 	float32 GetAngle() const
> 	{
> 		return b2Atan2(col1.y, col1.x);
> 	}
> 
> #ifdef TARGET_FLOAT32_IS_FIXED
> 
> 	/// Compute the inverse of this matrix, such that inv(A) * A = identity.
> 	b2Mat22 GetInverse() const
> 	{
> 		float32 a = col1.x, b = col2.x, c = col1.y, d = col2.y;
> 		float32 det = a * d - b * c;
> 		b2Mat22 B;
> 		int n = 0;
> 
> 		if(b2Abs(det) <= (B2_FLT_EPSILON<<8))
> 		{
> 			n = 3;
> 			a = a<<n; b = b<<n; 
> 			c = c<<n; d = d<<n;
> 			det = a * d - b * c;
> 			b2Assert(det != 0.0f);
> 			det = float32(1) / det;
> 			B.col1.x = ( det * d) << n;	B.col2.x = (-det * b) << n;
> 			B.col1.y = (-det * c) << n;	B.col2.y = ( det * a) << n;
> 		} 
> 		else
> 		{
> 			n = (b2Abs(det) >= 16.0)? 4 : 0;
> 			b2Assert(det != 0.0f);
> 			det = float32(1<<n) / det;
> 			B.col1.x = ( det * d) >> n;	B.col2.x = (-det * b) >> n;
> 			B.col1.y = (-det * c) >> n;	B.col2.y = ( det * a) >> n;
> 		}
> 		
> 		return B;
> 	}
> 
> 	// Solve A * x = b
> 	b2Vec2 Solve(const b2Vec2& b) const
> 	{
> 		float32 a11 = col1.x, a12 = col2.x, a21 = col1.y, a22 = col2.y;
> 		float32 det = a11 * a22 - a12 * a21;
> 		int n = 0;
> 		b2Vec2 x;
> 
> 		
> 		if(b2Abs(det) <= (B2_FLT_EPSILON<<8))
> 		{
> 			n = 3;
> 			a11 = col1.x<<n; a12 = col2.x<<n;
> 			a21 = col1.y<<n; a22 = col2.y<<n;
> 			det = a11 * a22 - a12 * a21;
> 			b2Assert(det != 0.0f);
> 			det = float32(1) / det;
> 			x.x = (det * (a22 * b.x - a12 * b.y)) << n;
> 			x.y = (det * (a11 * b.y - a21 * b.x)) << n;
> 		} 
> 		else 
> 		{
> 			n = (b2Abs(det) >= 16.0) ? 4 : 0;
> 			b2Assert(det != 0.0f);
> 			det = float32(1<<n) / det;
> 			x.x = (det * (a22 * b.x - a12 * b.y)) >> n;
> 			x.y = (det * (a11 * b.y - a21 * b.x)) >> n;
> 		}
> 
> 		return x;
> 	}
> 
> #else
> 	b2Mat22 GetInverse() const
> 	{
> 		float32 a = col1.x, b = col2.x, c = col1.y, d = col2.y;
> 		b2Mat22 B;
> 		float32 det = a * d - b * c;
> 		b2Assert(det != 0.0f);
> 		det = float32(1.0f) / det;
> 		B.col1.x =  det * d;	B.col2.x = -det * b;
> 		B.col1.y = -det * c;	B.col2.y =  det * a;
> 		return B;
> 	}
> 
> 	/// Solve A * x = b, where b is a column vector. This is more efficient
> 	/// than computing the inverse in one-shot cases.
> 	b2Vec2 Solve(const b2Vec2& b) const
> 	{
> 		float32 a11 = col1.x, a12 = col2.x, a21 = col1.y, a22 = col2.y;
> 		float32 det = a11 * a22 - a12 * a21;
> 		b2Assert(det != 0.0f);
> 		det = 1.0f / det;
> 		b2Vec2 x;
> 		x.x = det * (a22 * b.x - a12 * b.y);
> 		x.y = det * (a11 * b.y - a21 * b.x);
> 		return x;
> 	}
> #endif
> 
> 	b2Vec2 col1, col2;
> };
> 
> /// A 3-by-3 matrix. Stored in column-major order.
> struct b2Mat33
> {
> 	/// The default constructor does nothing (for performance).
> 	b2Mat33() {}
> 
> 	/// Construct this matrix using columns.
> 	b2Mat33(const b2Vec3& c1, const b2Vec3& c2, const b2Vec3& c3)
> 	{
> 		col1 = c1;
> 		col2 = c2;
> 		col3 = c3;
> 	}
> 
> 	/// Set this matrix to all zeros.
> 	void SetZero()
> 	{
> 		col1.SetZero();
> 		col2.SetZero();
> 		col3.SetZero();
> 	}
> 
> 	/// Solve A * x = b, where b is a column vector. This is more efficient
> 	/// than computing the inverse in one-shot cases.
> 	b2Vec3 Solve33(const b2Vec3& b) const;
> 
> 	/// Solve A * x = b, where b is a column vector. This is more efficient
> 	/// than computing the inverse in one-shot cases. Solve only the upper
> 	/// 2-by-2 matrix equation.
> 	b2Vec2 Solve22(const b2Vec2& b) const;
> 
> 	b2Vec3 col1, col2, col3;
> };
> 
> /// A transform contains translation and rotation. It is used to represent
> /// the position and orientation of rigid frames.
> struct b2XForm
> {
> 	/// The default constructor does nothing (for performance).
> 	b2XForm() {}
> 
> 	/// Initialize using a position vector and a rotation matrix.
> 	b2XForm(const b2Vec2& position, const b2Mat22& R) : position(position), R(R) {}
> 
> 	/// Set this to the identity transform.
> 	void SetIdentity()
> 	{
> 		position.SetZero();
> 		R.SetIdentity();
> 	}
> 
> 	b2Vec2 position;
> 	b2Mat22 R;
> };
> 
> /// This describes the motion of a body/shape for TOI computation.
> /// Shapes are defined with respect to the body origin, which may
> /// no coincide with the center of mass. However, to support dynamics
> /// we must interpolate the center of mass position.
> struct b2Sweep
> {
> 	/// Get the interpolated transform at a specific time.
> 	/// @param t the normalized time in [0,1].
> 	void GetXForm(b2XForm* xf, float32 t) const;
> 
> 	/// Advance the sweep forward, yielding a new initial state.
> 	/// @param t the new initial time.
> 	void Advance(float32 t);
> 
> 	b2Vec2 localCenter;	///< local center of mass position
> 	b2Vec2 c0, c;		///< center world positions
> 	float32 a0, a;		///< world angles
> 	float32 t0;			///< time interval = [t0,1], where t0 is in [0,1]
> };
> 
> 
> extern const b2Vec2 b2Vec2_zero;
> extern const b2Mat22 b2Mat22_identity;
> extern const b2XForm b2XForm_identity;
> 
> /// Peform the dot product on two vectors.
> inline float32 b2Dot(const b2Vec2& a, const b2Vec2& b)
> {
> 	return a.x * b.x + a.y * b.y;
> }
> 
> /// Perform the cross product on two vectors. In 2D this produces a scalar.
> inline float32 b2Cross(const b2Vec2& a, const b2Vec2& b)
> {
> 	return a.x * b.y - a.y * b.x;
> }
> 
> /// Perform the cross product on a vector and a scalar. In 2D this produces
> /// a vector.
> inline b2Vec2 b2Cross(const b2Vec2& a, float32 s)
> {
> 	return b2Vec2(s * a.y, -s * a.x);
> }
> 
> /// Perform the cross product on a scalar and a vector. In 2D this produces
> /// a vector.
> inline b2Vec2 b2Cross(float32 s, const b2Vec2& a)
> {
> 	return b2Vec2(-s * a.y, s * a.x);
> }
> 
> /// Multiply a matrix times a vector. If a rotation matrix is provided,
> /// then this transforms the vector from one frame to another.
> inline b2Vec2 b2Mul(const b2Mat22& A, const b2Vec2& v)
> {
> 	return b2Vec2(A.col1.x * v.x + A.col2.x * v.y, A.col1.y * v.x + A.col2.y * v.y);
> }
> 
> /// Multiply a matrix transpose times a vector. If a rotation matrix is provided,
> /// then this transforms the vector from one frame to another (inverse transform).
> inline b2Vec2 b2MulT(const b2Mat22& A, const b2Vec2& v)
> {
> 	return b2Vec2(b2Dot(v, A.col1), b2Dot(v, A.col2));
> }
> 
> /// Add two vectors component-wise.
> inline b2Vec2 operator + (const b2Vec2& a, const b2Vec2& b)
> {
> 	return b2Vec2(a.x + b.x, a.y + b.y);
> }
> 
> /// Subtract two vectors component-wise.
> inline b2Vec2 operator - (const b2Vec2& a, const b2Vec2& b)
> {
> 	return b2Vec2(a.x - b.x, a.y - b.y);
> }
> 
> inline b2Vec2 operator * (float32 s, const b2Vec2& a)
> {
> 	return b2Vec2(s * a.x, s * a.y);
> }
> 
> inline bool operator == (const b2Vec2& a, const b2Vec2& b)
> {
> 	return a.x == b.x && a.y == b.y;
> }
> 
> inline float32 b2Distance(const b2Vec2& a, const b2Vec2& b)
> {
> 	b2Vec2 c = a - b;
> 	return c.Length();
> }
> 
> inline float32 b2DistanceSquared(const b2Vec2& a, const b2Vec2& b)
> {
> 	b2Vec2 c = a - b;
> 	return b2Dot(c, c);
> }
> 
> inline b2Vec3 operator * (float32 s, const b2Vec3& a)
> {
> 	return b2Vec3(s * a.x, s * a.y, s * a.z);
> }
> 
> /// Add two vectors component-wise.
> inline b2Vec3 operator + (const b2Vec3& a, const b2Vec3& b)
> {
> 	return b2Vec3(a.x + b.x, a.y + b.y, a.z + b.z);
> }
> 
> /// Subtract two vectors component-wise.
> inline b2Vec3 operator - (const b2Vec3& a, const b2Vec3& b)
> {
> 	return b2Vec3(a.x - b.x, a.y - b.y, a.z - b.z);
> }
> 
> /// Perform the dot product on two vectors.
> inline float32 b2Dot(const b2Vec3& a, const b2Vec3& b)
> {
> 	return a.x * b.x + a.y * b.y + a.z * b.z;
> }
> 
> /// Perform the cross product on two vectors.
> inline b2Vec3 b2Cross(const b2Vec3& a, const b2Vec3& b)
> {
> 	return b2Vec3(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
> }
> 
> inline b2Mat22 operator + (const b2Mat22& A, const b2Mat22& B)
> {
> 	return b2Mat22(A.col1 + B.col1, A.col2 + B.col2);
> }
> 
> // A * B
> inline b2Mat22 b2Mul(const b2Mat22& A, const b2Mat22& B)
> {
> 	return b2Mat22(b2Mul(A, B.col1), b2Mul(A, B.col2));
> }
> 
> // A^T * B
> inline b2Mat22 b2MulT(const b2Mat22& A, const b2Mat22& B)
> {
> 	b2Vec2 c1(b2Dot(A.col1, B.col1), b2Dot(A.col2, B.col1));
> 	b2Vec2 c2(b2Dot(A.col1, B.col2), b2Dot(A.col2, B.col2));
> 	return b2Mat22(c1, c2);
> }
> 
> /// Multiply a matrix times a vector.
> inline b2Vec3 b2Mul(const b2Mat33& A, const b2Vec3& v)
> {
> 	return v.x * A.col1 + v.y * A.col2 + v.z * A.col3;
> }
> 
> inline b2Vec2 b2Mul(const b2XForm& T, const b2Vec2& v)
> {
> 	return T.position + b2Mul(T.R, v);
> }
> 
> inline b2Vec2 b2MulT(const b2XForm& T, const b2Vec2& v)
> {
> 	return b2MulT(T.R, v - T.position);
> }
> 
> inline b2Vec2 b2Abs(const b2Vec2& a)
> {
> 	return b2Vec2(b2Abs(a.x), b2Abs(a.y));
> }
> 
> inline b2Mat22 b2Abs(const b2Mat22& A)
> {
> 	return b2Mat22(b2Abs(A.col1), b2Abs(A.col2));
> }
> 
> template <typename T>
> inline T b2Min(T a, T b)
> {
> 	return a < b ? a : b;
> }
> 
> inline b2Vec2 b2Min(const b2Vec2& a, const b2Vec2& b)
> {
> 	return b2Vec2(b2Min(a.x, b.x), b2Min(a.y, b.y));
> }
> 
> template <typename T>
> inline T b2Max(T a, T b)
> {
> 	return a > b ? a : b;
> }
> 
> inline b2Vec2 b2Max(const b2Vec2& a, const b2Vec2& b)
> {
> 	return b2Vec2(b2Max(a.x, b.x), b2Max(a.y, b.y));
> }
> 
> template <typename T>
> inline T b2Clamp(T a, T low, T high)
> {
> 	return b2Max(low, b2Min(a, high));
> }
> 
> inline b2Vec2 b2Clamp(const b2Vec2& a, const b2Vec2& low, const b2Vec2& high)
> {
> 	return b2Max(low, b2Min(a, high));
> }
> 
> template<typename T> inline void b2Swap(T& a, T& b)
> {
> 	T tmp = a;
> 	a = b;
> 	b = tmp;
> }
> 
> /// "Next Largest Power of 2
> /// Given a binary integer value x, the next largest power of 2 can be computed by a SWAR algorithm
> /// that recursively "folds" the upper bits into the lower bits. This process yields a bit vector with
> /// the same most significant 1 as x, but all 1's below it. Adding 1 to that value yields the next
> /// largest power of 2. For a 32-bit value:"
> inline uint32 b2NextPowerOfTwo(uint32 x)
> {
> 	x |= (x >> 1);
> 	x |= (x >> 2);
> 	x |= (x >> 4);
> 	x |= (x >> 8);
> 	x |= (x >> 16);
> 	return x + 1;
> }
> 
> inline bool b2IsPowerOfTwo(uint32 x)
> {
> 	bool result = x > 0 && (x & (x - 1)) == 0;
> 	return result;
> }
> 
> #endif
diff -r -x './svn/*' native/Box2D/Common/.svn/text-base/b2Settings.cpp.svn-base ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Common/.svn/text-base/b2Settings.cpp.svn-base
2c2
< * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
19,22c19,25
< #include <Box2D/Common/b2Settings.h>
< #include <cstdlib>
< #include <cstdio>
< #include <cstdarg>
---
> #include "b2Settings.h"
> #include <stdlib.h>
> 
> b2Version b2_version = {2, 0, 2};
> 
> int32 b2_byteCount = 0;
> 
24d26
< b2Version b2_version = {2, 3, 0};
29c31,35
< 	return malloc(size);
---
> 	size += 4;
> 	b2_byteCount += size;
> 	char* bytes = (char*)malloc(size);
> 	*(int32*)bytes = size;
> 	return bytes + 4;
34,35c40,43
< 	free(mem);
< }
---
> 	if (mem == NULL)
> 	{
> 		return;
> 	}
37,43c45,50
< // You can modify this to use your logging facility.
< void b2Log(const char* string, ...)
< {
< 	va_list args;
< 	va_start(args, string);
< 	vprintf(string, args);
< 	va_end(args);
---
> 	char* bytes = (char*)mem;
> 	bytes -= 4;
> 	int32 size = *(int32*)bytes;
> 	b2Assert(b2_byteCount >= size);
> 	b2_byteCount -= size;
> 	free(bytes);
diff -r -x './svn/*' native/Box2D/Common/.svn/text-base/b2Settings.h.svn-base ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Common/.svn/text-base/b2Settings.h.svn-base
2c2
< * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
22,23c22,23
< #include <cassert>
< #include <cmath>
---
> #include <assert.h>
> #include <math.h>
25c25
< #define B2_NOT_USED(x) ((void)(x))
---
> #define B2_NOT_USED(x) x
27a28,36
> // need to include NDS jtypes.h instead of 
> // usual typedefs because NDS jtypes defines
> // them slightly differently, oh well.
> #ifdef TARGET_IS_NDS
> 
> #include "jtypes.h"
> 
> #else
> 
33a43,57
> 
> #endif
> 
> #ifdef	TARGET_FLOAT32_IS_FIXED
> 
> #include "Fixed.h"
> 
> typedef Fixed float32;
> #define	B2_FLT_MAX	FIXED_MAX
> #define	B2_FLT_EPSILON	FIXED_EPSILON
> #define	B2FORCE_SCALE(x)	((x)<<7)
> #define	B2FORCE_INV_SCALE(x)	((x)>>7)
> 
> #else
> 
35c59,62
< typedef double float64;
---
> #define	B2_FLT_MAX	FLT_MAX
> #define	B2_FLT_EPSILON	FLT_EPSILON
> #define	B2FORCE_SCALE(x)	(x)
> #define	B2FORCE_INV_SCALE(x)	(x)
37,39c64,66
< #define	b2_maxFloat		FLT_MAX
< #define	b2_epsilon		FLT_EPSILON
< #define b2_pi			3.14159265359f
---
> #endif
> 
> const float32 b2_pi = 3.14159265359f;
45a73,76
> const int32 b2_maxManifoldPoints = 2;
> const int32 b2_maxPolygonVertices = 8;
> const int32 b2_maxProxies = 512;				// this must be a power of two
> const int32 b2_maxPairs = 8 * b2_maxProxies;	// this must be a power of two
47,63c78
< /// The maximum number of contact points between two convex shapes. Do
< /// not change this value.
< #define b2_maxManifoldPoints	2
< 
< /// The maximum number of vertices on a convex polygon. You cannot increase
< /// this too much because b2BlockAllocator has a maximum object size.
< #define b2_maxPolygonVertices	8
< 
< /// This is used to fatten AABBs in the dynamic tree. This allows proxies
< /// to move by a small amount without triggering a tree adjustment.
< /// This is in meters.
< #define b2_aabbExtension		0.1f
< 
< /// This is used to fatten AABBs in the dynamic tree. This is used to predict
< /// the future position based on the current displacement.
< /// This is a dimensionless multiplier.
< #define b2_aabbMultiplier		2.0f
---
> // Dynamics
67c82
< #define b2_linearSlop			0.005f
---
> const float32 b2_linearSlop = 0.005f;	// 0.5 cm
71c86
< #define b2_angularSlop			(2.0f / 180.0f * b2_pi)
---
> const float32 b2_angularSlop = 2.0f / 180.0f * b2_pi;			// 2 degrees
73,76c88,91
< /// The radius of the polygon/edge shape skin. This should not be modified. Making
< /// this smaller means polygons will have an insufficient buffer for continuous collision.
< /// Making it larger may create artifacts for vertex collision.
< #define b2_polygonRadius		(2.0f * b2_linearSlop)
---
> /// Continuous collision detection (CCD) works with core, shrunken shapes. This is the
> /// amount by which shapes are automatically shrunk to work with CCD. This must be
> /// larger than b2_linearSlop.
> const float32 b2_toiSlop = 8.0f * b2_linearSlop;
78,79c93,94
< /// Maximum number of sub-steps per contact in continuous physics simulation.
< #define b2_maxSubSteps			8
---
> /// Maximum number of contacts to be handled to solve a TOI island.
> const int32 b2_maxTOIContactsPerIsland = 32;
81,85c96,97
< 
< // Dynamics
< 
< /// Maximum number of contacts to be handled to solve a TOI impact.
< #define b2_maxTOIContacts			32
---
> /// Maximum number of joints to be handled to solve a TOI island.
> const int32 b2_maxTOIJointsPerIsland = 32;
89c101
< #define b2_velocityThreshold		1.0f
---
> const float32 b2_velocityThreshold = 1.0f;		// 1 m/s
93c105
< #define b2_maxLinearCorrection		0.2f
---
> const float32 b2_maxLinearCorrection = 0.2f;	// 20 cm
97c109
< #define b2_maxAngularCorrection		(8.0f / 180.0f * b2_pi)
---
> const float32 b2_maxAngularCorrection = 8.0f / 180.0f * b2_pi;			// 8 degrees
101,102c113,118
< #define b2_maxTranslation			2.0f
< #define b2_maxTranslationSquared	(b2_maxTranslation * b2_maxTranslation)
---
> #ifdef TARGET_FLOAT32_IS_FIXED
> const float32 b2_maxLinearVelocity = 100.0f;
> #else
> const float32 b2_maxLinearVelocity = 200.0f;
> const float32 b2_maxLinearVelocitySquared = b2_maxLinearVelocity * b2_maxLinearVelocity;
> #endif
106,107c122,125
< #define b2_maxRotation				(0.5f * b2_pi)
< #define b2_maxRotationSquared		(b2_maxRotation * b2_maxRotation)
---
> const float32 b2_maxAngularVelocity = 250.0f;
> #ifndef TARGET_FLOAT32_IS_FIXED
> const float32 b2_maxAngularVelocitySquared = b2_maxAngularVelocity * b2_maxAngularVelocity;
> #endif
112,114c130
< #define b2_baumgarte				0.2f
< #define b2_toiBaugarte				0.75f
< 
---
> const float32 b2_contactBaumgarte = 0.2f;
119c135
< #define b2_timeToSleep				0.5f
---
> const float32 b2_timeToSleep = 0.5f;									// half a second
122c138
< #define b2_linearSleepTolerance		0.01f
---
> const float32 b2_linearSleepTolerance = 0.01f;		// 1 cm/s
125c141
< #define b2_angularSleepTolerance	(2.0f / 180.0f * b2_pi)
---
> const float32 b2_angularSleepTolerance = 2.0f / 180.0f;		// 2 degrees/s
128a145,147
> /// The current number of bytes allocated through b2Alloc.
> extern int32 b2_byteCount;
> 
135,137d153
< /// Logging function.
< void b2Log(const char* string, ...);
< 
149a166,177
> /// Friction mixing law. Feel free to customize this.
> inline float32 b2MixFriction(float32 friction1, float32 friction2)
> {
> 	return sqrtf(friction1 * friction2);
> }
> 
> /// Restitution mixing law. Feel free to customize this.
> inline float32 b2MixRestitution(float32 restitution1, float32 restitution2)
> {
> 	return restitution1 > restitution2 ? restitution1 : restitution2;
> }
> 
diff -r -x './svn/*' native/Box2D/Common/.svn/text-base/b2StackAllocator.cpp.svn-base ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Common/.svn/text-base/b2StackAllocator.cpp.svn-base
2c2
< * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
19,20c19,20
< #include <Box2D/Common/b2StackAllocator.h>
< #include <Box2D/Common/b2Math.h>
---
> #include "b2StackAllocator.h"
> #include "b2Math.h"
diff -r -x './svn/*' native/Box2D/Common/.svn/text-base/b2StackAllocator.h.svn-base ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Common/.svn/text-base/b2StackAllocator.h.svn-base
2c2
< * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
22c22
< #include <Box2D/Common/b2Settings.h>
---
> #include "b2Settings.h"
Only in native/Box2D/Common/.svn/text-base: b2Timer.cpp.svn-base
Only in native/Box2D/Common/.svn/text-base: b2Timer.h.svn-base
Only in ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Common/.svn/text-base: jtypes.h.svn-base
Only in ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Common: Fixed.h
diff -r -x './svn/*' native/Box2D/Common/b2BlockAllocator.cpp ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Common/b2BlockAllocator.cpp
2c2
< * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
19,24c19,22
< #include <Box2D/Common/b2BlockAllocator.h>
< #include <cstdlib>
< #include <climits>
< #include <cstring>
< #include <memory>
< using namespace std;
---
> #include "b2BlockAllocator.h"
> #include <stdlib.h>
> #include <memory.h>
> #include <limits.h>
25a24,25
> #include <string.h>
> 
104,109c104
< 	b2Assert(0 < size);
< 
< 	if (size > b2_maxBlockSize)
< 	{
< 		return b2Alloc(size);
< 	}
---
> 	b2Assert(0 < size && size <= b2_maxBlockSize);
164,170c159
< 	b2Assert(0 < size);
< 
< 	if (size > b2_maxBlockSize)
< 	{
< 		b2Free(p);
< 		return;
< 	}
---
> 	b2Assert(0 < size && size <= b2_maxBlockSize);
178a168
> 	int32 gap = (int32)((int8*)&m_chunks->blocks - (int8*)m_chunks);
185c175
< 						(int8*)chunk->blocks + b2_chunkSize <= (int8*)p);
---
> 						(int8*)chunk->blocks + b2_chunkSize + gap <= (int8*)p);
diff -r -x './svn/*' native/Box2D/Common/b2BlockAllocator.h ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Common/b2BlockAllocator.h
2c2
< * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
22c22
< #include <Box2D/Common/b2Settings.h>
---
> #include "b2Settings.h"
24c24
< const int32 b2_chunkSize = 16 * 1024;
---
> const int32 b2_chunkSize = 4096;
32,34c32,34
< /// This is a small object allocator used for allocating small
< /// objects that persist for more than one time step.
< /// See: http://www.codeproject.com/useritems/Small_Block_Allocator.asp
---
> // This is a small object allocator used for allocating small
> // objects that persist for more than one time step.
> // See: http://www.codeproject.com/useritems/Small_Block_Allocator.asp
41d40
< 	/// Allocate memory. This will use b2Alloc if the size is larger than b2_maxBlockSize.
43,44d41
< 
< 	/// Free memory. This will use b2Free if the size is larger than b2_maxBlockSize.
Only in native/Box2D/Common: b2Draw.cpp
Only in native/Box2D/Common: b2Draw.h
Only in native/Box2D/Common: b2GrowableStack.h
diff -r -x './svn/*' native/Box2D/Common/b2Math.cpp ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Common/b2Math.cpp
2c2
< * Copyright (c) 2007-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2007 Erin Catto http://www.gphysics.com
19c19
< #include <Box2D/Common/b2Math.h>
---
> #include "b2Math.h"
21a22,23
> const b2Mat22 b2Mat22_identity(1.0f, 0.0f, 0.0f, 1.0f);
> const b2XForm b2XForm_identity(b2Vec2_zero, b2Mat22_identity);
27,31c29,31
< 	float32 det = b2Dot(ex, b2Cross(ey, ez));
< 	if (det != 0.0f)
< 	{
< 		det = 1.0f / det;
< 	}
---
> 	float32 det = b2Dot(col1, b2Cross(col2, col3));
> 	b2Assert(det != 0.0f);
> 	det = 1.0f / det;
33,35c33,35
< 	x.x = det * b2Dot(b, b2Cross(ey, ez));
< 	x.y = det * b2Dot(ex, b2Cross(b, ez));
< 	x.z = det * b2Dot(ex, b2Cross(ey, b));
---
> 	x.x = det * b2Dot(b, b2Cross(col2, col3));
> 	x.y = det * b2Dot(col1, b2Cross(b, col3));
> 	x.z = det * b2Dot(col1, b2Cross(col2, b));
43c43
< 	float32 a11 = ex.x, a12 = ey.x, a21 = ex.y, a22 = ey.y;
---
> 	float32 a11 = col1.x, a12 = col2.x, a21 = col1.y, a22 = col2.y;
45,48c45,46
< 	if (det != 0.0f)
< 	{
< 		det = 1.0f / det;
< 	}
---
> 	b2Assert(det != 0.0f);
> 	det = 1.0f / det;
55,56c53
< ///
< void b2Mat33::GetInverse22(b2Mat33* M) const
---
> void b2Sweep::GetXForm(b2XForm* xf, float32 t) const
58,60c55,56
< 	float32 a = ex.x, b = ey.x, c = ex.y, d = ey.y;
< 	float32 det = a * d - b * c;
< 	if (det != 0.0f)
---
> 	// center = p + R * localCenter
> 	if (1.0f - t0 > B2_FLT_EPSILON)
62c58,66
< 		det = 1.0f / det;
---
> 		float32 alpha = (t - t0) / (1.0f - t0);
> 		xf->position = (1.0f - alpha) * c0 + alpha * c;
> 		float32 angle = (1.0f - alpha) * a0 + alpha * a;
> 		xf->R.Set(angle);
> 	}
> 	else
> 	{
> 		xf->position = c;
> 		xf->R.Set(a);
65,67c69,70
< 	M->ex.x =  det * d;	M->ey.x = -det * b; M->ex.z = 0.0f;
< 	M->ex.y = -det * c;	M->ey.y =  det * a; M->ey.z = 0.0f;
< 	M->ez.x = 0.0f; M->ez.y = 0.0f; M->ez.z = 0.0f;
---
> 	// Shift to origin
> 	xf->position -= b2Mul(xf->R, localCenter);
70,71c73
< /// Returns the zero matrix if singular.
< void b2Mat33::GetSymInverse33(b2Mat33* M) const
---
> void b2Sweep::Advance(float32 t)
73,74c75
< 	float32 det = b2Dot(ex, b2Cross(ey, ez));
< 	if (det != 0.0f)
---
> 	if (t0 < t && 1.0f - t0 > B2_FLT_EPSILON)
76c77,80
< 		det = 1.0f / det;
---
> 		float32 alpha = (t - t0) / (1.0f - t0);
> 		c0 = (1.0f - alpha) * c0 + alpha * c;
> 		a0 = (1.0f - alpha) * a0 + alpha * a;
> 		t0 = t;
78,93d81
< 
< 	float32 a11 = ex.x, a12 = ey.x, a13 = ez.x;
< 	float32 a22 = ey.y, a23 = ez.y;
< 	float32 a33 = ez.z;
< 
< 	M->ex.x = det * (a22 * a33 - a23 * a23);
< 	M->ex.y = det * (a13 * a23 - a12 * a33);
< 	M->ex.z = det * (a12 * a23 - a13 * a22);
< 
< 	M->ey.x = M->ex.y;
< 	M->ey.y = det * (a11 * a33 - a13 * a13);
< 	M->ey.z = det * (a13 * a12 - a11 * a23);
< 
< 	M->ez.x = M->ex.z;
< 	M->ez.y = M->ey.z;
< 	M->ez.z = det * (a11 * a22 - a12 * a12);
diff -r -x './svn/*' native/Box2D/Common/b2Math.h ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Common/b2Math.h
1,731c1,716
< /*
< * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
< *
< * This software is provided 'as-is', without any express or implied
< * warranty.  In no event will the authors be held liable for any damages
< * arising from the use of this software.
< * Permission is granted to anyone to use this software for any purpose,
< * including commercial applications, and to alter it and redistribute it
< * freely, subject to the following restrictions:
< * 1. The origin of this software must not be misrepresented; you must not
< * claim that you wrote the original software. If you use this software
< * in a product, an acknowledgment in the product documentation would be
< * appreciated but is not required.
< * 2. Altered source versions must be plainly marked as such, and must not be
< * misrepresented as being the original software.
< * 3. This notice may not be removed or altered from any source distribution.
< */
< 
< #ifndef B2_MATH_H
< #define B2_MATH_H
< 
< #include <Box2D/Common/b2Settings.h>
< 
< #include <cmath>
< #include <cfloat>
< #include <cstddef>
< #include <limits>
< 
< /// This function is used to ensure that a floating point number is
< /// not a NaN or infinity.
< inline bool b2IsValid(float32 x)
< {
< 	if (x != x)
< 	{
< 		// NaN.
< 		return false;
< 	}
< 
< 	float32 infinity = std::numeric_limits<float32>::infinity();
< 	return -infinity < x && x < infinity;
< }
< 
< /// This is a approximate yet fast inverse square-root.
< inline float32 b2InvSqrt(float32 x)
< {
< 	union
< 	{
< 		float32 x;
< 		int32 i;
< 	} convert;
< 
< 	convert.x = x;
< 	float32 xhalf = 0.5f * x;
< 	convert.i = 0x5f3759df - (convert.i >> 1);
< 	x = convert.x;
< 	x = x * (1.5f - xhalf * x * x);
< 	return x;
< }
< 
< #define	b2Sqrt(x)	std::sqrt(x)
< #define	b2Atan2(y, x)	std::atan2(y, x)
< 
< /// A 2D column vector.
< struct b2Vec2
< {
< 	/// Default constructor does nothing (for performance).
< 	b2Vec2() {}
< 
< 	/// Construct using coordinates.
< 	b2Vec2(float32 x, float32 y) : x(x), y(y) {}
< 
< 	/// Set this vector to all zeros.
< 	void SetZero() { x = 0.0f; y = 0.0f; }
< 
< 	/// Set this vector to some specified coordinates.
< 	void Set(float32 x_, float32 y_) { x = x_; y = y_; }
< 
< 	/// Negate this vector.
< 	b2Vec2 operator -() const { b2Vec2 v; v.Set(-x, -y); return v; }
< 	
< 	/// Read from and indexed element.
< 	float32 operator () (int32 i) const
< 	{
< 		return (&x)[i];
< 	}
< 
< 	/// Write to an indexed element.
< 	float32& operator () (int32 i)
< 	{
< 		return (&x)[i];
< 	}
< 
< 	/// Add a vector to this vector.
< 	void operator += (const b2Vec2& v)
< 	{
< 		x += v.x; y += v.y;
< 	}
< 	
< 	/// Subtract a vector from this vector.
< 	void operator -= (const b2Vec2& v)
< 	{
< 		x -= v.x; y -= v.y;
< 	}
< 
< 	/// Multiply this vector by a scalar.
< 	void operator *= (float32 a)
< 	{
< 		x *= a; y *= a;
< 	}
< 
< 	/// Get the length of this vector (the norm).
< 	float32 Length() const
< 	{
< 		return b2Sqrt(x * x + y * y);
< 	}
< 
< 	/// Get the length squared. For performance, use this instead of
< 	/// b2Vec2::Length (if possible).
< 	float32 LengthSquared() const
< 	{
< 		return x * x + y * y;
< 	}
< 
< 	/// Convert this vector into a unit vector. Returns the length.
< 	float32 Normalize()
< 	{
< 		float32 length = Length();
< 		if (length < b2_epsilon)
< 		{
< 			return 0.0f;
< 		}
< 		float32 invLength = 1.0f / length;
< 		x *= invLength;
< 		y *= invLength;
< 
< 		return length;
< 	}
< 
< 	/// Does this vector contain finite coordinates?
< 	bool IsValid() const
< 	{
< 		return b2IsValid(x) && b2IsValid(y);
< 	}
< 
< 	/// Get the skew vector such that dot(skew_vec, other) == cross(vec, other)
< 	b2Vec2 Skew() const
< 	{
< 		return b2Vec2(-y, x);
< 	}
< 
< 	float32 x, y;
< };
< 
< /// A 2D column vector with 3 elements.
< struct b2Vec3
< {
< 	/// Default constructor does nothing (for performance).
< 	b2Vec3() {}
< 
< 	/// Construct using coordinates.
< 	b2Vec3(float32 x, float32 y, float32 z) : x(x), y(y), z(z) {}
< 
< 	/// Set this vector to all zeros.
< 	void SetZero() { x = 0.0f; y = 0.0f; z = 0.0f; }
< 
< 	/// Set this vector to some specified coordinates.
< 	void Set(float32 x_, float32 y_, float32 z_) { x = x_; y = y_; z = z_; }
< 
< 	/// Negate this vector.
< 	b2Vec3 operator -() const { b2Vec3 v; v.Set(-x, -y, -z); return v; }
< 
< 	/// Add a vector to this vector.
< 	void operator += (const b2Vec3& v)
< 	{
< 		x += v.x; y += v.y; z += v.z;
< 	}
< 
< 	/// Subtract a vector from this vector.
< 	void operator -= (const b2Vec3& v)
< 	{
< 		x -= v.x; y -= v.y; z -= v.z;
< 	}
< 
< 	/// Multiply this vector by a scalar.
< 	void operator *= (float32 s)
< 	{
< 		x *= s; y *= s; z *= s;
< 	}
< 
< 	float32 x, y, z;
< };
< 
< /// A 2-by-2 matrix. Stored in column-major order.
< struct b2Mat22
< {
< 	/// The default constructor does nothing (for performance).
< 	b2Mat22() {}
< 
< 	/// Construct this matrix using columns.
< 	b2Mat22(const b2Vec2& c1, const b2Vec2& c2)
< 	{
< 		ex = c1;
< 		ey = c2;
< 	}
< 
< 	/// Construct this matrix using scalars.
< 	b2Mat22(float32 a11, float32 a12, float32 a21, float32 a22)
< 	{
< 		ex.x = a11; ex.y = a21;
< 		ey.x = a12; ey.y = a22;
< 	}
< 
< 	/// Initialize this matrix using columns.
< 	void Set(const b2Vec2& c1, const b2Vec2& c2)
< 	{
< 		ex = c1;
< 		ey = c2;
< 	}
< 
< 	/// Set this to the identity matrix.
< 	void SetIdentity()
< 	{
< 		ex.x = 1.0f; ey.x = 0.0f;
< 		ex.y = 0.0f; ey.y = 1.0f;
< 	}
< 
< 	/// Set this matrix to all zeros.
< 	void SetZero()
< 	{
< 		ex.x = 0.0f; ey.x = 0.0f;
< 		ex.y = 0.0f; ey.y = 0.0f;
< 	}
< 
< 	b2Mat22 GetInverse() const
< 	{
< 		float32 a = ex.x, b = ey.x, c = ex.y, d = ey.y;
< 		b2Mat22 B;
< 		float32 det = a * d - b * c;
< 		if (det != 0.0f)
< 		{
< 			det = 1.0f / det;
< 		}
< 		B.ex.x =  det * d;	B.ey.x = -det * b;
< 		B.ex.y = -det * c;	B.ey.y =  det * a;
< 		return B;
< 	}
< 
< 	/// Solve A * x = b, where b is a column vector. This is more efficient
< 	/// than computing the inverse in one-shot cases.
< 	b2Vec2 Solve(const b2Vec2& b) const
< 	{
< 		float32 a11 = ex.x, a12 = ey.x, a21 = ex.y, a22 = ey.y;
< 		float32 det = a11 * a22 - a12 * a21;
< 		if (det != 0.0f)
< 		{
< 			det = 1.0f / det;
< 		}
< 		b2Vec2 x;
< 		x.x = det * (a22 * b.x - a12 * b.y);
< 		x.y = det * (a11 * b.y - a21 * b.x);
< 		return x;
< 	}
< 
< 	b2Vec2 ex, ey;
< };
< 
< /// A 3-by-3 matrix. Stored in column-major order.
< struct b2Mat33
< {
< 	/// The default constructor does nothing (for performance).
< 	b2Mat33() {}
< 
< 	/// Construct this matrix using columns.
< 	b2Mat33(const b2Vec3& c1, const b2Vec3& c2, const b2Vec3& c3)
< 	{
< 		ex = c1;
< 		ey = c2;
< 		ez = c3;
< 	}
< 
< 	/// Set this matrix to all zeros.
< 	void SetZero()
< 	{
< 		ex.SetZero();
< 		ey.SetZero();
< 		ez.SetZero();
< 	}
< 
< 	/// Solve A * x = b, where b is a column vector. This is more efficient
< 	/// than computing the inverse in one-shot cases.
< 	b2Vec3 Solve33(const b2Vec3& b) const;
< 
< 	/// Solve A * x = b, where b is a column vector. This is more efficient
< 	/// than computing the inverse in one-shot cases. Solve only the upper
< 	/// 2-by-2 matrix equation.
< 	b2Vec2 Solve22(const b2Vec2& b) const;
< 
< 	/// Get the inverse of this matrix as a 2-by-2.
< 	/// Returns the zero matrix if singular.
< 	void GetInverse22(b2Mat33* M) const;
< 
< 	/// Get the symmetric inverse of this matrix as a 3-by-3.
< 	/// Returns the zero matrix if singular.
< 	void GetSymInverse33(b2Mat33* M) const;
< 
< 	b2Vec3 ex, ey, ez;
< };
< 
< /// Rotation
< struct b2Rot
< {
< 	b2Rot() {}
< 
< 	/// Initialize from an angle in radians
< 	explicit b2Rot(float32 angle)
< 	{
< 		/// TODO_ERIN optimize
< 		s = sinf(angle);
< 		c = cosf(angle);
< 	}
< 
< 	/// Set using an angle in radians.
< 	void Set(float32 angle)
< 	{
< 		/// TODO_ERIN optimize
< 		s = sinf(angle);
< 		c = cosf(angle);
< 	}
< 
< 	/// Set to the identity rotation
< 	void SetIdentity()
< 	{
< 		s = 0.0f;
< 		c = 1.0f;
< 	}
< 
< 	/// Get the angle in radians
< 	float32 GetAngle() const
< 	{
< 		return b2Atan2(s, c);
< 	}
< 
< 	/// Get the x-axis
< 	b2Vec2 GetXAxis() const
< 	{
< 		return b2Vec2(c, s);
< 	}
< 
< 	/// Get the u-axis
< 	b2Vec2 GetYAxis() const
< 	{
< 		return b2Vec2(-s, c);
< 	}
< 
< 	/// Sine and cosine
< 	float32 s, c;
< };
< 
< /// A transform contains translation and rotation. It is used to represent
< /// the position and orientation of rigid frames.
< struct b2Transform
< {
< 	/// The default constructor does nothing.
< 	b2Transform() {}
< 
< 	/// Initialize using a position vector and a rotation.
< 	b2Transform(const b2Vec2& position, const b2Rot& rotation) : p(position), q(rotation) {}
< 
< 	/// Set this to the identity transform.
< 	void SetIdentity()
< 	{
< 		p.SetZero();
< 		q.SetIdentity();
< 	}
< 
< 	/// Set this based on the position and angle.
< 	void Set(const b2Vec2& position, float32 angle)
< 	{
< 		p = position;
< 		q.Set(angle);
< 	}
< 
< 	b2Vec2 p;
< 	b2Rot q;
< };
< 
< /// This describes the motion of a body/shape for TOI computation.
< /// Shapes are defined with respect to the body origin, which may
< /// no coincide with the center of mass. However, to support dynamics
< /// we must interpolate the center of mass position.
< struct b2Sweep
< {
< 	/// Get the interpolated transform at a specific time.
< 	/// @param beta is a factor in [0,1], where 0 indicates alpha0.
< 	void GetTransform(b2Transform* xfb, float32 beta) const;
< 
< 	/// Advance the sweep forward, yielding a new initial state.
< 	/// @param alpha the new initial time.
< 	void Advance(float32 alpha);
< 
< 	/// Normalize the angles.
< 	void Normalize();
< 
< 	b2Vec2 localCenter;	///< local center of mass position
< 	b2Vec2 c0, c;		///< center world positions
< 	float32 a0, a;		///< world angles
< 
< 	/// Fraction of the current time step in the range [0,1]
< 	/// c0 and a0 are the positions at alpha0.
< 	float32 alpha0;
< };
< 
< /// Useful constant
< extern const b2Vec2 b2Vec2_zero;
< 
< /// Perform the dot product on two vectors.
< inline float32 b2Dot(const b2Vec2& a, const b2Vec2& b)
< {
< 	return a.x * b.x + a.y * b.y;
< }
< 
< /// Perform the cross product on two vectors. In 2D this produces a scalar.
< inline float32 b2Cross(const b2Vec2& a, const b2Vec2& b)
< {
< 	return a.x * b.y - a.y * b.x;
< }
< 
< /// Perform the cross product on a vector and a scalar. In 2D this produces
< /// a vector.
< inline b2Vec2 b2Cross(const b2Vec2& a, float32 s)
< {
< 	return b2Vec2(s * a.y, -s * a.x);
< }
< 
< /// Perform the cross product on a scalar and a vector. In 2D this produces
< /// a vector.
< inline b2Vec2 b2Cross(float32 s, const b2Vec2& a)
< {
< 	return b2Vec2(-s * a.y, s * a.x);
< }
< 
< /// Multiply a matrix times a vector. If a rotation matrix is provided,
< /// then this transforms the vector from one frame to another.
< inline b2Vec2 b2Mul(const b2Mat22& A, const b2Vec2& v)
< {
< 	return b2Vec2(A.ex.x * v.x + A.ey.x * v.y, A.ex.y * v.x + A.ey.y * v.y);
< }
< 
< /// Multiply a matrix transpose times a vector. If a rotation matrix is provided,
< /// then this transforms the vector from one frame to another (inverse transform).
< inline b2Vec2 b2MulT(const b2Mat22& A, const b2Vec2& v)
< {
< 	return b2Vec2(b2Dot(v, A.ex), b2Dot(v, A.ey));
< }
< 
< /// Add two vectors component-wise.
< inline b2Vec2 operator + (const b2Vec2& a, const b2Vec2& b)
< {
< 	return b2Vec2(a.x + b.x, a.y + b.y);
< }
< 
< /// Subtract two vectors component-wise.
< inline b2Vec2 operator - (const b2Vec2& a, const b2Vec2& b)
< {
< 	return b2Vec2(a.x - b.x, a.y - b.y);
< }
< 
< inline b2Vec2 operator * (float32 s, const b2Vec2& a)
< {
< 	return b2Vec2(s * a.x, s * a.y);
< }
< 
< inline bool operator == (const b2Vec2& a, const b2Vec2& b)
< {
< 	return a.x == b.x && a.y == b.y;
< }
< 
< inline float32 b2Distance(const b2Vec2& a, const b2Vec2& b)
< {
< 	b2Vec2 c = a - b;
< 	return c.Length();
< }
< 
< inline float32 b2DistanceSquared(const b2Vec2& a, const b2Vec2& b)
< {
< 	b2Vec2 c = a - b;
< 	return b2Dot(c, c);
< }
< 
< inline b2Vec3 operator * (float32 s, const b2Vec3& a)
< {
< 	return b2Vec3(s * a.x, s * a.y, s * a.z);
< }
< 
< /// Add two vectors component-wise.
< inline b2Vec3 operator + (const b2Vec3& a, const b2Vec3& b)
< {
< 	return b2Vec3(a.x + b.x, a.y + b.y, a.z + b.z);
< }
< 
< /// Subtract two vectors component-wise.
< inline b2Vec3 operator - (const b2Vec3& a, const b2Vec3& b)
< {
< 	return b2Vec3(a.x - b.x, a.y - b.y, a.z - b.z);
< }
< 
< /// Perform the dot product on two vectors.
< inline float32 b2Dot(const b2Vec3& a, const b2Vec3& b)
< {
< 	return a.x * b.x + a.y * b.y + a.z * b.z;
< }
< 
< /// Perform the cross product on two vectors.
< inline b2Vec3 b2Cross(const b2Vec3& a, const b2Vec3& b)
< {
< 	return b2Vec3(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
< }
< 
< inline b2Mat22 operator + (const b2Mat22& A, const b2Mat22& B)
< {
< 	return b2Mat22(A.ex + B.ex, A.ey + B.ey);
< }
< 
< // A * B
< inline b2Mat22 b2Mul(const b2Mat22& A, const b2Mat22& B)
< {
< 	return b2Mat22(b2Mul(A, B.ex), b2Mul(A, B.ey));
< }
< 
< // A^T * B
< inline b2Mat22 b2MulT(const b2Mat22& A, const b2Mat22& B)
< {
< 	b2Vec2 c1(b2Dot(A.ex, B.ex), b2Dot(A.ey, B.ex));
< 	b2Vec2 c2(b2Dot(A.ex, B.ey), b2Dot(A.ey, B.ey));
< 	return b2Mat22(c1, c2);
< }
< 
< /// Multiply a matrix times a vector.
< inline b2Vec3 b2Mul(const b2Mat33& A, const b2Vec3& v)
< {
< 	return v.x * A.ex + v.y * A.ey + v.z * A.ez;
< }
< 
< /// Multiply a matrix times a vector.
< inline b2Vec2 b2Mul22(const b2Mat33& A, const b2Vec2& v)
< {
< 	return b2Vec2(A.ex.x * v.x + A.ey.x * v.y, A.ex.y * v.x + A.ey.y * v.y);
< }
< 
< /// Multiply two rotations: q * r
< inline b2Rot b2Mul(const b2Rot& q, const b2Rot& r)
< {
< 	// [qc -qs] * [rc -rs] = [qc*rc-qs*rs -qc*rs-qs*rc]
< 	// [qs  qc]   [rs  rc]   [qs*rc+qc*rs -qs*rs+qc*rc]
< 	// s = qs * rc + qc * rs
< 	// c = qc * rc - qs * rs
< 	b2Rot qr;
< 	qr.s = q.s * r.c + q.c * r.s;
< 	qr.c = q.c * r.c - q.s * r.s;
< 	return qr;
< }
< 
< /// Transpose multiply two rotations: qT * r
< inline b2Rot b2MulT(const b2Rot& q, const b2Rot& r)
< {
< 	// [ qc qs] * [rc -rs] = [qc*rc+qs*rs -qc*rs+qs*rc]
< 	// [-qs qc]   [rs  rc]   [-qs*rc+qc*rs qs*rs+qc*rc]
< 	// s = qc * rs - qs * rc
< 	// c = qc * rc + qs * rs
< 	b2Rot qr;
< 	qr.s = q.c * r.s - q.s * r.c;
< 	qr.c = q.c * r.c + q.s * r.s;
< 	return qr;
< }
< 
< /// Rotate a vector
< inline b2Vec2 b2Mul(const b2Rot& q, const b2Vec2& v)
< {
< 	return b2Vec2(q.c * v.x - q.s * v.y, q.s * v.x + q.c * v.y);
< }
< 
< /// Inverse rotate a vector
< inline b2Vec2 b2MulT(const b2Rot& q, const b2Vec2& v)
< {
< 	return b2Vec2(q.c * v.x + q.s * v.y, -q.s * v.x + q.c * v.y);
< }
< 
< inline b2Vec2 b2Mul(const b2Transform& T, const b2Vec2& v)
< {
< 	float32 x = (T.q.c * v.x - T.q.s * v.y) + T.p.x;
< 	float32 y = (T.q.s * v.x + T.q.c * v.y) + T.p.y;
< 
< 	return b2Vec2(x, y);
< }
< 
< inline b2Vec2 b2MulT(const b2Transform& T, const b2Vec2& v)
< {
< 	float32 px = v.x - T.p.x;
< 	float32 py = v.y - T.p.y;
< 	float32 x = (T.q.c * px + T.q.s * py);
< 	float32 y = (-T.q.s * px + T.q.c * py);
< 
< 	return b2Vec2(x, y);
< }
< 
< // v2 = A.q.Rot(B.q.Rot(v1) + B.p) + A.p
< //    = (A.q * B.q).Rot(v1) + A.q.Rot(B.p) + A.p
< inline b2Transform b2Mul(const b2Transform& A, const b2Transform& B)
< {
< 	b2Transform C;
< 	C.q = b2Mul(A.q, B.q);
< 	C.p = b2Mul(A.q, B.p) + A.p;
< 	return C;
< }
< 
< // v2 = A.q' * (B.q * v1 + B.p - A.p)
< //    = A.q' * B.q * v1 + A.q' * (B.p - A.p)
< inline b2Transform b2MulT(const b2Transform& A, const b2Transform& B)
< {
< 	b2Transform C;
< 	C.q = b2MulT(A.q, B.q);
< 	C.p = b2MulT(A.q, B.p - A.p);
< 	return C;
< }
< 
< template <typename T>
< inline T b2Abs(T a)
< {
< 	return a > T(0) ? a : -a;
< }
< 
< inline b2Vec2 b2Abs(const b2Vec2& a)
< {
< 	return b2Vec2(b2Abs(a.x), b2Abs(a.y));
< }
< 
< inline b2Mat22 b2Abs(const b2Mat22& A)
< {
< 	return b2Mat22(b2Abs(A.ex), b2Abs(A.ey));
< }
< 
< template <typename T>
< inline T b2Min(T a, T b)
< {
< 	return a < b ? a : b;
< }
< 
< inline b2Vec2 b2Min(const b2Vec2& a, const b2Vec2& b)
< {
< 	return b2Vec2(b2Min(a.x, b.x), b2Min(a.y, b.y));
< }
< 
< template <typename T>
< inline T b2Max(T a, T b)
< {
< 	return a > b ? a : b;
< }
< 
< inline b2Vec2 b2Max(const b2Vec2& a, const b2Vec2& b)
< {
< 	return b2Vec2(b2Max(a.x, b.x), b2Max(a.y, b.y));
< }
< 
< template <typename T>
< inline T b2Clamp(T a, T low, T high)
< {
< 	return b2Max(low, b2Min(a, high));
< }
< 
< inline b2Vec2 b2Clamp(const b2Vec2& a, const b2Vec2& low, const b2Vec2& high)
< {
< 	return b2Max(low, b2Min(a, high));
< }
< 
< template<typename T> inline void b2Swap(T& a, T& b)
< {
< 	T tmp = a;
< 	a = b;
< 	b = tmp;
< }
< 
< /// "Next Largest Power of 2
< /// Given a binary integer value x, the next largest power of 2 can be computed by a SWAR algorithm
< /// that recursively "folds" the upper bits into the lower bits. This process yields a bit vector with
< /// the same most significant 1 as x, but all 1's below it. Adding 1 to that value yields the next
< /// largest power of 2. For a 32-bit value:"
< inline uint32 b2NextPowerOfTwo(uint32 x)
< {
< 	x |= (x >> 1);
< 	x |= (x >> 2);
< 	x |= (x >> 4);
< 	x |= (x >> 8);
< 	x |= (x >> 16);
< 	return x + 1;
< }
< 
< inline bool b2IsPowerOfTwo(uint32 x)
< {
< 	bool result = x > 0 && (x & (x - 1)) == 0;
< 	return result;
< }
< 
< inline void b2Sweep::GetTransform(b2Transform* xf, float32 beta) const
< {
< 	xf->p = (1.0f - beta) * c0 + beta * c;
< 	float32 angle = (1.0f - beta) * a0 + beta * a;
< 	xf->q.Set(angle);
< 
< 	// Shift to origin
< 	xf->p -= b2Mul(xf->q, localCenter);
< }
< 
< inline void b2Sweep::Advance(float32 alpha)
< {
< 	b2Assert(alpha0 < 1.0f);
< 	float32 beta = (alpha - alpha0) / (1.0f - alpha0);
< 	c0 = (1.0f - beta) * c0 + beta * c;
< 	a0 = (1.0f - beta) * a0 + beta * a;
< 	alpha0 = alpha;
< }
< 
< /// Normalize an angle in radians to be between -pi and pi
< inline void b2Sweep::Normalize()
< {
< 	float32 twoPi = 2.0f * b2_pi;
< 	float32 d =  twoPi * floorf(a0 / twoPi);
< 	a0 -= d;
< 	a -= d;
< }
< 
< #endif
---
> /*
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
> *
> * This software is provided 'as-is', without any express or implied
> * warranty.  In no event will the authors be held liable for any damages
> * arising from the use of this software.
> * Permission is granted to anyone to use this software for any purpose,
> * including commercial applications, and to alter it and redistribute it
> * freely, subject to the following restrictions:
> * 1. The origin of this software must not be misrepresented; you must not
> * claim that you wrote the original software. If you use this software
> * in a product, an acknowledgment in the product documentation would be
> * appreciated but is not required.
> * 2. Altered source versions must be plainly marked as such, and must not be
> * misrepresented as being the original software.
> * 3. This notice may not be removed or altered from any source distribution.
> */
> 
> #ifndef B2_MATH_H
> #define B2_MATH_H
> 
> #include "b2Settings.h"
> 
> #ifdef TARGET_OS_IPHONE
> #include "math.h"
> #else
> #include <math.h>
> #endif
> 
> 
> 
> #include <float.h>
> #include <stdlib.h>
> 
> #include <stdio.h>
> 
> #ifdef TARGET_FLOAT32_IS_FIXED
> 
> inline Fixed b2Min(const Fixed& a, const Fixed& b)
> {
>   return a < b ? a : b;
> }
> 
> inline Fixed b2Max(const Fixed& a, const Fixed& b)
> {
>   return a > b ? a : b;
> }
> 
> inline Fixed b2Clamp(Fixed a, Fixed low, Fixed high)
> {
> 	return b2Max(low, b2Min(a, high));
> }
> 
> inline bool b2IsValid(Fixed x)
> {
> 	B2_NOT_USED(x);
> 	return true;
> }
> 
> #define	b2Sqrt(x)	sqrt(x)
> #define	b2Atan2(y, x)	atan2(y, x)
> 
> #else
> 
> /// This function is used to ensure that a floating point number is
> /// not a NaN or infinity.
> inline bool b2IsValid(float32 x)
> {
> #ifdef _MSC_VER
> 	return _finite(x) != 0;
> #else
> 	
> #ifdef TARGET_OS_IPHONE
> 	return isfinite(x);
> #else
> 	return finite(x) != 0;
> #endif
> 	
> 	
> #endif
> }
> 
> /// This is a approximate yet fast inverse square-root.
> inline float32 b2InvSqrt(float32 x)
> {
> 	union
> 	{
> 		float32 x;
> 		int32 i;
> 	} convert;
> 
> 	convert.x = x;
> 	float32 xhalf = 0.5f * x;
> 	convert.i = 0x5f3759df - (convert.i >> 1);
> 	x = convert.x;
> 	x = x * (1.5f - xhalf * x * x);
> 	return x;
> }
> 
> #define	b2Sqrt(x)	sqrtf(x)
> #define	b2Atan2(y, x)	atan2f(y, x)
> 
> #endif
> 
> inline float32 b2Abs(float32 a)
> {
> 	return a > 0.0f ? a : -a;
> }
> 
> /// A 2D column vector.
> struct b2Vec2
> {
> 	/// Default constructor does nothing (for performance).
> 	b2Vec2() {}
> 
> 	/// Construct using coordinates.
> 	b2Vec2(float32 x, float32 y) : x(x), y(y) {}
> 
> 	/// Set this vector to all zeros.
> 	void SetZero() { x = 0.0f; y = 0.0f; }
> 
> 	/// Set this vector to some specified coordinates.
> 	void Set(float32 x_, float32 y_) { x = x_; y = y_; }
> 
> 	/// Negate this vector.
> 	b2Vec2 operator -() const { b2Vec2 v; v.Set(-x, -y); return v; }
> 	
> 	/// Add a vector to this vector.
> 	void operator += (const b2Vec2& v)
> 	{
> 		x += v.x; y += v.y;
> 	}
> 	
> 	/// Subtract a vector from this vector.
> 	void operator -= (const b2Vec2& v)
> 	{
> 		x -= v.x; y -= v.y;
> 	}
> 
> 	/// Multiply this vector by a scalar.
> 	void operator *= (float32 a)
> 	{
> 		x *= a; y *= a;
> 	}
> 
> 	/// Get the length of this vector (the norm).
> 	float32 Length() const
> 	{
> #ifdef TARGET_FLOAT32_IS_FIXED
> 		float est = b2Abs(x) + b2Abs(y);
> 		if(est == 0.0f) {
> 			return 0.0;
> 		} else if(est < 0.1) {
> 			return (1.0/256.0) * b2Vec2(x<<8, y<<8).Length();
> 		} else if(est < 180.0f) {
> 			return b2Sqrt(x * x + y * y);
> 		} else {
> 			return 256.0 * (b2Vec2(x>>8, y>>8).Length());
> 		}
> #else
> 		return b2Sqrt(x * x + y * y);
> #endif 
> 	}
> 
> 	/// Get the length squared. For performance, use this instead of
> 	/// b2Vec2::Length (if possible).
> 	float32 LengthSquared() const
> 	{
> 		return x * x + y * y;
> 	}
> 
> 	/// Convert this vector into a unit vector. Returns the length.
> #ifdef TARGET_FLOAT32_IS_FIXED
> 	float32 Normalize()
> 	{
> 		float32 length = Length();
> 		if (length < B2_FLT_EPSILON)
> 		{
> 			return 0.0f;
> 		} 
> #ifdef NORMALIZE_BY_INVERT_MULTIPLY
> 		if (length < (1.0/16.0)) {
> 			x = x << 4;
> 			y = y << 4;
> 			return (1.0/16.0)*Normalize();
> 		} else if(length > 16.0) {
> 			x = x >> 4;
> 			y = y >> 4;
> 			return 16.0*Normalize();
> 		}
> 		float32 invLength = 1.0f / length;
> 		x *= invLength;
> 		y *= invLength;
> #else
> 		x /= length;
> 		y /= length;
> #endif
> 		return length;
> 	}
> #else
> 	float32 Normalize()
> 	{
> 		float32 length = Length();
> 		if (length < B2_FLT_EPSILON)
> 		{
> 			return 0.0f;
> 		}
> 		float32 invLength = 1.0f / length;
> 		x *= invLength;
> 		y *= invLength;
> 
> 		return length;
> 	}
> #endif
> 
> 	/// Does this vector contain finite coordinates?
> 	bool IsValid() const
> 	{
> 		return b2IsValid(x) && b2IsValid(y);
> 	}
> 
> 	float32 x, y;
> };
> 
> /// A 2D column vector with 3 elements.
> struct b2Vec3
> {
> 	/// Default constructor does nothing (for performance).
> 	b2Vec3() {}
> 
> 	/// Construct using coordinates.
> 	b2Vec3(float32 x, float32 y, float32 z) : x(x), y(y), z(z) {}
> 
> 	/// Set this vector to all zeros.
> 	void SetZero() { x = 0.0f; y = 0.0f; z = 0.0f; }
> 
> 	/// Set this vector to some specified coordinates.
> 	void Set(float32 x_, float32 y_, float32 z_) { x = x_; y = y_; z = z_; }
> 
> 	/// Negate this vector.
> 	b2Vec3 operator -() const { b2Vec3 v; v.Set(-x, -y, -z); return v; }
> 
> 	/// Add a vector to this vector.
> 	void operator += (const b2Vec3& v)
> 	{
> 		x += v.x; y += v.y; z += v.z;
> 	}
> 
> 	/// Subtract a vector from this vector.
> 	void operator -= (const b2Vec3& v)
> 	{
> 		x -= v.x; y -= v.y; z -= v.z;
> 	}
> 
> 	/// Multiply this vector by a scalar.
> 	void operator *= (float32 s)
> 	{
> 		x *= s; y *= s; z *= s;
> 	}
> 
> 	float32 x, y, z;
> };
> 
> /// A 2-by-2 matrix. Stored in column-major order.
> struct b2Mat22
> {
> 	/// The default constructor does nothing (for performance).
> 	b2Mat22() {}
> 
> 	/// Construct this matrix using columns.
> 	b2Mat22(const b2Vec2& c1, const b2Vec2& c2)
> 	{
> 		col1 = c1;
> 		col2 = c2;
> 	}
> 
> 	/// Construct this matrix using scalars.
> 	b2Mat22(float32 a11, float32 a12, float32 a21, float32 a22)
> 	{
> 		col1.x = a11; col1.y = a21;
> 		col2.x = a12; col2.y = a22;
> 	}
> 
> 	/// Construct this matrix using an angle. This matrix becomes
> 	/// an orthonormal rotation matrix.
> 	explicit b2Mat22(float32 angle)
> 	{
> 		// TODO_ERIN compute sin+cos together.
> 		float32 c = cosf(angle), s = sinf(angle);
> 		col1.x = c; col2.x = -s;
> 		col1.y = s; col2.y = c;
> 	}
> 
> 	/// Initialize this matrix using columns.
> 	void Set(const b2Vec2& c1, const b2Vec2& c2)
> 	{
> 		col1 = c1;
> 		col2 = c2;
> 	}
> 
> 	/// Initialize this matrix using an angle. This matrix becomes
> 	/// an orthonormal rotation matrix.
> 	void Set(float32 angle)
> 	{
> 		float32 c = cosf(angle), s = sinf(angle);
> 		col1.x = c; col2.x = -s;
> 		col1.y = s; col2.y = c;
> 	}
> 
> 	/// Set this to the identity matrix.
> 	void SetIdentity()
> 	{
> 		col1.x = 1.0f; col2.x = 0.0f;
> 		col1.y = 0.0f; col2.y = 1.0f;
> 	}
> 
> 	/// Set this matrix to all zeros.
> 	void SetZero()
> 	{
> 		col1.x = 0.0f; col2.x = 0.0f;
> 		col1.y = 0.0f; col2.y = 0.0f;
> 	}
> 
> 	/// Extract the angle from this matrix (assumed to be
> 	/// a rotation matrix).
> 	float32 GetAngle() const
> 	{
> 		return b2Atan2(col1.y, col1.x);
> 	}
> 
> #ifdef TARGET_FLOAT32_IS_FIXED
> 
> 	/// Compute the inverse of this matrix, such that inv(A) * A = identity.
> 	b2Mat22 GetInverse() const
> 	{
> 		float32 a = col1.x, b = col2.x, c = col1.y, d = col2.y;
> 		float32 det = a * d - b * c;
> 		b2Mat22 B;
> 		int n = 0;
> 
> 		if(b2Abs(det) <= (B2_FLT_EPSILON<<8))
> 		{
> 			n = 3;
> 			a = a<<n; b = b<<n; 
> 			c = c<<n; d = d<<n;
> 			det = a * d - b * c;
> 			b2Assert(det != 0.0f);
> 			det = float32(1) / det;
> 			B.col1.x = ( det * d) << n;	B.col2.x = (-det * b) << n;
> 			B.col1.y = (-det * c) << n;	B.col2.y = ( det * a) << n;
> 		} 
> 		else
> 		{
> 			n = (b2Abs(det) >= 16.0)? 4 : 0;
> 			b2Assert(det != 0.0f);
> 			det = float32(1<<n) / det;
> 			B.col1.x = ( det * d) >> n;	B.col2.x = (-det * b) >> n;
> 			B.col1.y = (-det * c) >> n;	B.col2.y = ( det * a) >> n;
> 		}
> 		
> 		return B;
> 	}
> 
> 	// Solve A * x = b
> 	b2Vec2 Solve(const b2Vec2& b) const
> 	{
> 		float32 a11 = col1.x, a12 = col2.x, a21 = col1.y, a22 = col2.y;
> 		float32 det = a11 * a22 - a12 * a21;
> 		int n = 0;
> 		b2Vec2 x;
> 
> 		
> 		if(b2Abs(det) <= (B2_FLT_EPSILON<<8))
> 		{
> 			n = 3;
> 			a11 = col1.x<<n; a12 = col2.x<<n;
> 			a21 = col1.y<<n; a22 = col2.y<<n;
> 			det = a11 * a22 - a12 * a21;
> 			b2Assert(det != 0.0f);
> 			det = float32(1) / det;
> 			x.x = (det * (a22 * b.x - a12 * b.y)) << n;
> 			x.y = (det * (a11 * b.y - a21 * b.x)) << n;
> 		} 
> 		else 
> 		{
> 			n = (b2Abs(det) >= 16.0) ? 4 : 0;
> 			b2Assert(det != 0.0f);
> 			det = float32(1<<n) / det;
> 			x.x = (det * (a22 * b.x - a12 * b.y)) >> n;
> 			x.y = (det * (a11 * b.y - a21 * b.x)) >> n;
> 		}
> 
> 		return x;
> 	}
> 
> #else
> 	b2Mat22 GetInverse() const
> 	{
> 		float32 a = col1.x, b = col2.x, c = col1.y, d = col2.y;
> 		b2Mat22 B;
> 		float32 det = a * d - b * c;
> 		b2Assert(det != 0.0f);
> 		det = float32(1.0f) / det;
> 		B.col1.x =  det * d;	B.col2.x = -det * b;
> 		B.col1.y = -det * c;	B.col2.y =  det * a;
> 		return B;
> 	}
> 
> 	/// Solve A * x = b, where b is a column vector. This is more efficient
> 	/// than computing the inverse in one-shot cases.
> 	b2Vec2 Solve(const b2Vec2& b) const
> 	{
> 		float32 a11 = col1.x, a12 = col2.x, a21 = col1.y, a22 = col2.y;
> 		float32 det = a11 * a22 - a12 * a21;
> 		b2Assert(det != 0.0f);
> 		det = 1.0f / det;
> 		b2Vec2 x;
> 		x.x = det * (a22 * b.x - a12 * b.y);
> 		x.y = det * (a11 * b.y - a21 * b.x);
> 		return x;
> 	}
> #endif
> 
> 	b2Vec2 col1, col2;
> };
> 
> /// A 3-by-3 matrix. Stored in column-major order.
> struct b2Mat33
> {
> 	/// The default constructor does nothing (for performance).
> 	b2Mat33() {}
> 
> 	/// Construct this matrix using columns.
> 	b2Mat33(const b2Vec3& c1, const b2Vec3& c2, const b2Vec3& c3)
> 	{
> 		col1 = c1;
> 		col2 = c2;
> 		col3 = c3;
> 	}
> 
> 	/// Set this matrix to all zeros.
> 	void SetZero()
> 	{
> 		col1.SetZero();
> 		col2.SetZero();
> 		col3.SetZero();
> 	}
> 
> 	/// Solve A * x = b, where b is a column vector. This is more efficient
> 	/// than computing the inverse in one-shot cases.
> 	b2Vec3 Solve33(const b2Vec3& b) const;
> 
> 	/// Solve A * x = b, where b is a column vector. This is more efficient
> 	/// than computing the inverse in one-shot cases. Solve only the upper
> 	/// 2-by-2 matrix equation.
> 	b2Vec2 Solve22(const b2Vec2& b) const;
> 
> 	b2Vec3 col1, col2, col3;
> };
> 
> /// A transform contains translation and rotation. It is used to represent
> /// the position and orientation of rigid frames.
> struct b2XForm
> {
> 	/// The default constructor does nothing (for performance).
> 	b2XForm() {}
> 
> 	/// Initialize using a position vector and a rotation matrix.
> 	b2XForm(const b2Vec2& position, const b2Mat22& R) : position(position), R(R) {}
> 
> 	/// Set this to the identity transform.
> 	void SetIdentity()
> 	{
> 		position.SetZero();
> 		R.SetIdentity();
> 	}
> 
> 	b2Vec2 position;
> 	b2Mat22 R;
> };
> 
> /// This describes the motion of a body/shape for TOI computation.
> /// Shapes are defined with respect to the body origin, which may
> /// no coincide with the center of mass. However, to support dynamics
> /// we must interpolate the center of mass position.
> struct b2Sweep
> {
> 	/// Get the interpolated transform at a specific time.
> 	/// @param t the normalized time in [0,1].
> 	void GetXForm(b2XForm* xf, float32 t) const;
> 
> 	/// Advance the sweep forward, yielding a new initial state.
> 	/// @param t the new initial time.
> 	void Advance(float32 t);
> 
> 	b2Vec2 localCenter;	///< local center of mass position
> 	b2Vec2 c0, c;		///< center world positions
> 	float32 a0, a;		///< world angles
> 	float32 t0;			///< time interval = [t0,1], where t0 is in [0,1]
> };
> 
> 
> extern const b2Vec2 b2Vec2_zero;
> extern const b2Mat22 b2Mat22_identity;
> extern const b2XForm b2XForm_identity;
> 
> /// Peform the dot product on two vectors.
> inline float32 b2Dot(const b2Vec2& a, const b2Vec2& b)
> {
> 	return a.x * b.x + a.y * b.y;
> }
> 
> /// Perform the cross product on two vectors. In 2D this produces a scalar.
> inline float32 b2Cross(const b2Vec2& a, const b2Vec2& b)
> {
> 	return a.x * b.y - a.y * b.x;
> }
> 
> /// Perform the cross product on a vector and a scalar. In 2D this produces
> /// a vector.
> inline b2Vec2 b2Cross(const b2Vec2& a, float32 s)
> {
> 	return b2Vec2(s * a.y, -s * a.x);
> }
> 
> /// Perform the cross product on a scalar and a vector. In 2D this produces
> /// a vector.
> inline b2Vec2 b2Cross(float32 s, const b2Vec2& a)
> {
> 	return b2Vec2(-s * a.y, s * a.x);
> }
> 
> /// Multiply a matrix times a vector. If a rotation matrix is provided,
> /// then this transforms the vector from one frame to another.
> inline b2Vec2 b2Mul(const b2Mat22& A, const b2Vec2& v)
> {
> 	return b2Vec2(A.col1.x * v.x + A.col2.x * v.y, A.col1.y * v.x + A.col2.y * v.y);
> }
> 
> /// Multiply a matrix transpose times a vector. If a rotation matrix is provided,
> /// then this transforms the vector from one frame to another (inverse transform).
> inline b2Vec2 b2MulT(const b2Mat22& A, const b2Vec2& v)
> {
> 	return b2Vec2(b2Dot(v, A.col1), b2Dot(v, A.col2));
> }
> 
> /// Add two vectors component-wise.
> inline b2Vec2 operator + (const b2Vec2& a, const b2Vec2& b)
> {
> 	return b2Vec2(a.x + b.x, a.y + b.y);
> }
> 
> /// Subtract two vectors component-wise.
> inline b2Vec2 operator - (const b2Vec2& a, const b2Vec2& b)
> {
> 	return b2Vec2(a.x - b.x, a.y - b.y);
> }
> 
> inline b2Vec2 operator * (float32 s, const b2Vec2& a)
> {
> 	return b2Vec2(s * a.x, s * a.y);
> }
> 
> inline bool operator == (const b2Vec2& a, const b2Vec2& b)
> {
> 	return a.x == b.x && a.y == b.y;
> }
> 
> inline float32 b2Distance(const b2Vec2& a, const b2Vec2& b)
> {
> 	b2Vec2 c = a - b;
> 	return c.Length();
> }
> 
> inline float32 b2DistanceSquared(const b2Vec2& a, const b2Vec2& b)
> {
> 	b2Vec2 c = a - b;
> 	return b2Dot(c, c);
> }
> 
> inline b2Vec3 operator * (float32 s, const b2Vec3& a)
> {
> 	return b2Vec3(s * a.x, s * a.y, s * a.z);
> }
> 
> /// Add two vectors component-wise.
> inline b2Vec3 operator + (const b2Vec3& a, const b2Vec3& b)
> {
> 	return b2Vec3(a.x + b.x, a.y + b.y, a.z + b.z);
> }
> 
> /// Subtract two vectors component-wise.
> inline b2Vec3 operator - (const b2Vec3& a, const b2Vec3& b)
> {
> 	return b2Vec3(a.x - b.x, a.y - b.y, a.z - b.z);
> }
> 
> /// Perform the dot product on two vectors.
> inline float32 b2Dot(const b2Vec3& a, const b2Vec3& b)
> {
> 	return a.x * b.x + a.y * b.y + a.z * b.z;
> }
> 
> /// Perform the cross product on two vectors.
> inline b2Vec3 b2Cross(const b2Vec3& a, const b2Vec3& b)
> {
> 	return b2Vec3(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
> }
> 
> inline b2Mat22 operator + (const b2Mat22& A, const b2Mat22& B)
> {
> 	return b2Mat22(A.col1 + B.col1, A.col2 + B.col2);
> }
> 
> // A * B
> inline b2Mat22 b2Mul(const b2Mat22& A, const b2Mat22& B)
> {
> 	return b2Mat22(b2Mul(A, B.col1), b2Mul(A, B.col2));
> }
> 
> // A^T * B
> inline b2Mat22 b2MulT(const b2Mat22& A, const b2Mat22& B)
> {
> 	b2Vec2 c1(b2Dot(A.col1, B.col1), b2Dot(A.col2, B.col1));
> 	b2Vec2 c2(b2Dot(A.col1, B.col2), b2Dot(A.col2, B.col2));
> 	return b2Mat22(c1, c2);
> }
> 
> /// Multiply a matrix times a vector.
> inline b2Vec3 b2Mul(const b2Mat33& A, const b2Vec3& v)
> {
> 	return v.x * A.col1 + v.y * A.col2 + v.z * A.col3;
> }
> 
> inline b2Vec2 b2Mul(const b2XForm& T, const b2Vec2& v)
> {
> 	return T.position + b2Mul(T.R, v);
> }
> 
> inline b2Vec2 b2MulT(const b2XForm& T, const b2Vec2& v)
> {
> 	return b2MulT(T.R, v - T.position);
> }
> 
> inline b2Vec2 b2Abs(const b2Vec2& a)
> {
> 	return b2Vec2(b2Abs(a.x), b2Abs(a.y));
> }
> 
> inline b2Mat22 b2Abs(const b2Mat22& A)
> {
> 	return b2Mat22(b2Abs(A.col1), b2Abs(A.col2));
> }
> 
> template <typename T>
> inline T b2Min(T a, T b)
> {
> 	return a < b ? a : b;
> }
> 
> inline b2Vec2 b2Min(const b2Vec2& a, const b2Vec2& b)
> {
> 	return b2Vec2(b2Min(a.x, b.x), b2Min(a.y, b.y));
> }
> 
> template <typename T>
> inline T b2Max(T a, T b)
> {
> 	return a > b ? a : b;
> }
> 
> inline b2Vec2 b2Max(const b2Vec2& a, const b2Vec2& b)
> {
> 	return b2Vec2(b2Max(a.x, b.x), b2Max(a.y, b.y));
> }
> 
> template <typename T>
> inline T b2Clamp(T a, T low, T high)
> {
> 	return b2Max(low, b2Min(a, high));
> }
> 
> inline b2Vec2 b2Clamp(const b2Vec2& a, const b2Vec2& low, const b2Vec2& high)
> {
> 	return b2Max(low, b2Min(a, high));
> }
> 
> template<typename T> inline void b2Swap(T& a, T& b)
> {
> 	T tmp = a;
> 	a = b;
> 	b = tmp;
> }
> 
> /// "Next Largest Power of 2
> /// Given a binary integer value x, the next largest power of 2 can be computed by a SWAR algorithm
> /// that recursively "folds" the upper bits into the lower bits. This process yields a bit vector with
> /// the same most significant 1 as x, but all 1's below it. Adding 1 to that value yields the next
> /// largest power of 2. For a 32-bit value:"
> inline uint32 b2NextPowerOfTwo(uint32 x)
> {
> 	x |= (x >> 1);
> 	x |= (x >> 2);
> 	x |= (x >> 4);
> 	x |= (x >> 8);
> 	x |= (x >> 16);
> 	return x + 1;
> }
> 
> inline bool b2IsPowerOfTwo(uint32 x)
> {
> 	bool result = x > 0 && (x & (x - 1)) == 0;
> 	return result;
> }
> 
> #endif
diff -r -x './svn/*' native/Box2D/Common/b2Settings.cpp ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Common/b2Settings.cpp
2c2
< * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
19,22c19,25
< #include <Box2D/Common/b2Settings.h>
< #include <cstdlib>
< #include <cstdio>
< #include <cstdarg>
---
> #include "b2Settings.h"
> #include <stdlib.h>
> 
> b2Version b2_version = {2, 0, 2};
> 
> int32 b2_byteCount = 0;
> 
24d26
< b2Version b2_version = {2, 3, 0};
29c31,35
< 	return malloc(size);
---
> 	size += 4;
> 	b2_byteCount += size;
> 	char* bytes = (char*)malloc(size);
> 	*(int32*)bytes = size;
> 	return bytes + 4;
34,35c40,43
< 	free(mem);
< }
---
> 	if (mem == NULL)
> 	{
> 		return;
> 	}
37,43c45,50
< // You can modify this to use your logging facility.
< void b2Log(const char* string, ...)
< {
< 	va_list args;
< 	va_start(args, string);
< 	vprintf(string, args);
< 	va_end(args);
---
> 	char* bytes = (char*)mem;
> 	bytes -= 4;
> 	int32 size = *(int32*)bytes;
> 	b2Assert(b2_byteCount >= size);
> 	b2_byteCount -= size;
> 	free(bytes);
diff -r -x './svn/*' native/Box2D/Common/b2Settings.h ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Common/b2Settings.h
2c2
< * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
22,23c22,23
< #include <cassert>
< #include <cmath>
---
> #include <assert.h>
> #include <math.h>
25c25
< #define B2_NOT_USED(x) ((void)(x))
---
> #define B2_NOT_USED(x) x
27a28,36
> // need to include NDS jtypes.h instead of 
> // usual typedefs because NDS jtypes defines
> // them slightly differently, oh well.
> #ifdef TARGET_IS_NDS
> 
> #include "jtypes.h"
> 
> #else
> 
33a43,57
> 
> #endif
> 
> #ifdef	TARGET_FLOAT32_IS_FIXED
> 
> #include "Fixed.h"
> 
> typedef Fixed float32;
> #define	B2_FLT_MAX	FIXED_MAX
> #define	B2_FLT_EPSILON	FIXED_EPSILON
> #define	B2FORCE_SCALE(x)	((x)<<7)
> #define	B2FORCE_INV_SCALE(x)	((x)>>7)
> 
> #else
> 
35c59,62
< typedef double float64;
---
> #define	B2_FLT_MAX	FLT_MAX
> #define	B2_FLT_EPSILON	FLT_EPSILON
> #define	B2FORCE_SCALE(x)	(x)
> #define	B2FORCE_INV_SCALE(x)	(x)
37,39c64,66
< #define	b2_maxFloat		FLT_MAX
< #define	b2_epsilon		FLT_EPSILON
< #define b2_pi			3.14159265359f
---
> #endif
> 
> const float32 b2_pi = 3.14159265359f;
45a73,76
> const int32 b2_maxManifoldPoints = 2;
> const int32 b2_maxPolygonVertices = 8;
> const int32 b2_maxProxies = 512;				// this must be a power of two
> const int32 b2_maxPairs = 8 * b2_maxProxies;	// this must be a power of two
47,63c78
< /// The maximum number of contact points between two convex shapes. Do
< /// not change this value.
< #define b2_maxManifoldPoints	2
< 
< /// The maximum number of vertices on a convex polygon. You cannot increase
< /// this too much because b2BlockAllocator has a maximum object size.
< #define b2_maxPolygonVertices	8
< 
< /// This is used to fatten AABBs in the dynamic tree. This allows proxies
< /// to move by a small amount without triggering a tree adjustment.
< /// This is in meters.
< #define b2_aabbExtension		0.1f
< 
< /// This is used to fatten AABBs in the dynamic tree. This is used to predict
< /// the future position based on the current displacement.
< /// This is a dimensionless multiplier.
< #define b2_aabbMultiplier		2.0f
---
> // Dynamics
67c82
< #define b2_linearSlop			0.005f
---
> const float32 b2_linearSlop = 0.005f;	// 0.5 cm
71c86
< #define b2_angularSlop			(2.0f / 180.0f * b2_pi)
---
> const float32 b2_angularSlop = 2.0f / 180.0f * b2_pi;			// 2 degrees
73,76c88,91
< /// The radius of the polygon/edge shape skin. This should not be modified. Making
< /// this smaller means polygons will have an insufficient buffer for continuous collision.
< /// Making it larger may create artifacts for vertex collision.
< #define b2_polygonRadius		(2.0f * b2_linearSlop)
---
> /// Continuous collision detection (CCD) works with core, shrunken shapes. This is the
> /// amount by which shapes are automatically shrunk to work with CCD. This must be
> /// larger than b2_linearSlop.
> const float32 b2_toiSlop = 8.0f * b2_linearSlop;
78,79c93,94
< /// Maximum number of sub-steps per contact in continuous physics simulation.
< #define b2_maxSubSteps			8
---
> /// Maximum number of contacts to be handled to solve a TOI island.
> const int32 b2_maxTOIContactsPerIsland = 32;
81,85c96,97
< 
< // Dynamics
< 
< /// Maximum number of contacts to be handled to solve a TOI impact.
< #define b2_maxTOIContacts			32
---
> /// Maximum number of joints to be handled to solve a TOI island.
> const int32 b2_maxTOIJointsPerIsland = 32;
89c101
< #define b2_velocityThreshold		1.0f
---
> const float32 b2_velocityThreshold = 1.0f;		// 1 m/s
93c105
< #define b2_maxLinearCorrection		0.2f
---
> const float32 b2_maxLinearCorrection = 0.2f;	// 20 cm
97c109
< #define b2_maxAngularCorrection		(8.0f / 180.0f * b2_pi)
---
> const float32 b2_maxAngularCorrection = 8.0f / 180.0f * b2_pi;			// 8 degrees
101,102c113,118
< #define b2_maxTranslation			2.0f
< #define b2_maxTranslationSquared	(b2_maxTranslation * b2_maxTranslation)
---
> #ifdef TARGET_FLOAT32_IS_FIXED
> const float32 b2_maxLinearVelocity = 100.0f;
> #else
> const float32 b2_maxLinearVelocity = 200.0f;
> const float32 b2_maxLinearVelocitySquared = b2_maxLinearVelocity * b2_maxLinearVelocity;
> #endif
106,107c122,125
< #define b2_maxRotation				(0.5f * b2_pi)
< #define b2_maxRotationSquared		(b2_maxRotation * b2_maxRotation)
---
> const float32 b2_maxAngularVelocity = 250.0f;
> #ifndef TARGET_FLOAT32_IS_FIXED
> const float32 b2_maxAngularVelocitySquared = b2_maxAngularVelocity * b2_maxAngularVelocity;
> #endif
112,114c130
< #define b2_baumgarte				0.2f
< #define b2_toiBaugarte				0.75f
< 
---
> const float32 b2_contactBaumgarte = 0.2f;
119c135
< #define b2_timeToSleep				0.5f
---
> const float32 b2_timeToSleep = 0.5f;									// half a second
122c138
< #define b2_linearSleepTolerance		0.01f
---
> const float32 b2_linearSleepTolerance = 0.01f;		// 1 cm/s
125c141
< #define b2_angularSleepTolerance	(2.0f / 180.0f * b2_pi)
---
> const float32 b2_angularSleepTolerance = 2.0f / 180.0f;		// 2 degrees/s
128a145,147
> /// The current number of bytes allocated through b2Alloc.
> extern int32 b2_byteCount;
> 
135,137d153
< /// Logging function.
< void b2Log(const char* string, ...);
< 
149a166,177
> /// Friction mixing law. Feel free to customize this.
> inline float32 b2MixFriction(float32 friction1, float32 friction2)
> {
> 	return sqrtf(friction1 * friction2);
> }
> 
> /// Restitution mixing law. Feel free to customize this.
> inline float32 b2MixRestitution(float32 restitution1, float32 restitution2)
> {
> 	return restitution1 > restitution2 ? restitution1 : restitution2;
> }
> 
diff -r -x './svn/*' native/Box2D/Common/b2StackAllocator.cpp ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Common/b2StackAllocator.cpp
2c2
< * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
19,20c19,20
< #include <Box2D/Common/b2StackAllocator.h>
< #include <Box2D/Common/b2Math.h>
---
> #include "b2StackAllocator.h"
> #include "b2Math.h"
diff -r -x './svn/*' native/Box2D/Common/b2StackAllocator.h ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Common/b2StackAllocator.h
2c2
< * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
22c22
< #include <Box2D/Common/b2Settings.h>
---
> #include "b2Settings.h"
Only in native/Box2D/Common: b2Timer.cpp
Only in native/Box2D/Common: b2Timer.h
Only in ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Common: jtypes.h
Only in ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics: .b2World.cpp.swp
diff -r -x './svn/*' native/Box2D/Dynamics/.svn/all-wcprops ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/.svn/all-wcprops
3,4c3,4
< V 44
< /svn/!svn/ver/250/trunk/Box2D/Box2D/Dynamics
---
> V 48
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Dynamics
9,10c9,10
< V 57
< /svn/!svn/ver/206/trunk/Box2D/Box2D/Dynamics/b2Island.cpp
---
> V 61
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Dynamics/b2Island.cpp
15,22c15,16
< V 63
< /svn/!svn/ver/158/trunk/Box2D/Box2D/Dynamics/b2ContactManager.h
< END
< b2Fixture.h
< K 25
< svn:wc:ra_dav:version-url
< V 56
< /svn/!svn/ver/214/trunk/Box2D/Box2D/Dynamics/b2Fixture.h
---
> V 67
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Dynamics/b2ContactManager.h
27,28c21,22
< V 63
< /svn/!svn/ver/206/trunk/Box2D/Box2D/Dynamics/b2WorldCallbacks.h
---
> V 67
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Dynamics/b2WorldCallbacks.h
33,34c27,28
< V 54
< /svn/!svn/ver/246/trunk/Box2D/Box2D/Dynamics/b2World.h
---
> V 58
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Dynamics/b2World.h
39,46c33,34
< V 55
< /svn/!svn/ver/245/trunk/Box2D/Box2D/Dynamics/b2Body.cpp
< END
< b2TimeStep.h
< K 25
< svn:wc:ra_dav:version-url
< V 57
< /svn/!svn/ver/225/trunk/Box2D/Box2D/Dynamics/b2TimeStep.h
---
> V 59
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Dynamics/b2Body.cpp
51,52c39,40
< V 55
< /svn/!svn/ver/186/trunk/Box2D/Box2D/Dynamics/b2Island.h
---
> V 59
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Dynamics/b2Island.h
57,64c45,46
< V 53
< /svn/!svn/ver/250/trunk/Box2D/Box2D/Dynamics/b2Body.h
< END
< b2Fixture.cpp
< K 25
< svn:wc:ra_dav:version-url
< V 58
< /svn/!svn/ver/233/trunk/Box2D/Box2D/Dynamics/b2Fixture.cpp
---
> V 57
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Dynamics/b2Body.h
69,70c51,52
< V 65
< /svn/!svn/ver/248/trunk/Box2D/Box2D/Dynamics/b2ContactManager.cpp
---
> V 69
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Dynamics/b2ContactManager.cpp
75,76c57,58
< V 65
< /svn/!svn/ver/158/trunk/Box2D/Box2D/Dynamics/b2WorldCallbacks.cpp
---
> V 69
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Dynamics/b2WorldCallbacks.cpp
81,82c63,64
< V 56
< /svn/!svn/ver/247/trunk/Box2D/Box2D/Dynamics/b2World.cpp
---
> V 60
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Dynamics/b2World.cpp
diff -r -x './svn/*' native/Box2D/Dynamics/.svn/entries ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/.svn/entries
4,6c4,6
< 254
< http://box2d.googlecode.com/svn/trunk/Box2D/Box2D/Dynamics
< http://box2d.googlecode.com/svn
---
> 7
> http://android-opengl-box2d-basics.googlecode.com/svn/trunk/rt-jnibox2d/box2d/Dynamics
> http://android-opengl-box2d-basics.googlecode.com/svn
10,12c10,12
< 2012-06-24T02:55:58.404098Z
< 250
< erincatto@gmail.com
---
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
27c27
< cafe418c-1137-0410-84cc-357ec87a5d9b
---
> 5131c71c-dced-4c25-419c-0ca2576ce0a2
35,39c35,39
< 2013-06-18T12:51:07.000000Z
< d87a5e8a154d058914f700ac81fe6a77
< 2011-08-23T04:29:13.130003Z
< 206
< erincatto@gmail.com
---
> 2013-07-02T14:40:41.000000Z
> d61d6d38abeed67d1e2eb8d20580c9e6
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
61c61
< 17156
---
> 15441
63,97c63
< b2Island.h
< file
< 
< 
< 
< 
< 2013-06-18T12:51:07.000000Z
< 639cdeb0cde2d7acb65292fde4f3fe0f
< 2011-06-18T08:05:55.703617Z
< 186
< erincatto@gmail.com
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 2538
< 
< b2ContactManager.cpp
---
> b2ContactManager.h
103,107c69,73
< 2013-06-18T12:51:07.000000Z
< 48b5d54cdbc193b911f4f38bd257f8ad
< 2012-04-04T06:42:01.588851Z
< 248
< erincatto@gmail.com
---
> 2013-07-02T14:40:41.000000Z
> ad48398ad066b6233165bd6313938d1d
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
129c95
< 7360
---
> 1737
131c97
< b2Fixture.cpp
---
> b2WorldCallbacks.h
137,141c103,107
< 2013-06-18T12:51:07.000000Z
< 8d1c33e28989e63732aa7ecab40f6261
< 2011-09-19T05:49:06.756419Z
< 233
< erincatto@gmail.com
---
> 2013-07-02T14:40:41.000000Z
> e02b52211741d936129a586da685a807
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
163c129
< 8554
---
> 6158
165c131
< b2World.cpp
---
> b2World.h
171,175c137,141
< 2013-06-18T12:51:07.000000Z
< 8b2abc37ddffbe27548af7a6fb3130a4
< 2012-03-19T06:31:22.740365Z
< 247
< erincatto@gmail.com
---
> 2013-07-02T14:40:41.000000Z
> 8fabebc0e68e2d91c19dc4c31a9755e7
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
197c163
< 31043
---
> 10642
199c165
< b2WorldCallbacks.cpp
---
> b2Body.cpp
205,209c171,175
< 2013-06-18T12:51:07.000000Z
< ec8fe155d577d25550e878ccdb284c53
< 2011-03-24T17:36:44.542193Z
< 158
< erincatto
---
> 2013-07-02T14:40:41.000000Z
> 402e678be491a1a55b98f9ca887ac2f3
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
231c197
< 1633
---
> 10095
233c199
< b2Fixture.h
---
> b2Island.h
239,243c205,209
< 2013-06-18T12:51:07.000000Z
< c5e4a65e58bd72cd4502a2fe93c9c32d
< 2011-09-03T19:05:05.780220Z
< 214
< erincatto@gmail.com
---
> 2013-07-02T14:40:41.000000Z
> 71fdab0bf085c1ae557f8d49306e7aa2
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
265c231
< 9579
---
> 2496
267,299c233,234
< b2ContactManager.h
< file
< 
< 
< 
< 
< 2013-06-18T12:51:07.000000Z
< 33e776b584f04106f425bd53ef346429
< 2011-03-24T17:36:44.542193Z
< 158
< erincatto
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 1588
---
> Joints
> dir
301,333c236,237
< b2World.h
< file
< 
< 
< 
< 
< 2013-06-18T12:51:07.000000Z
< 2d94757dcbb899bd625cbadca6ec53f2
< 2012-03-18T07:00:37.028153Z
< 246
< erincatto@gmail.com
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 10830
---
> Controllers
> dir
335c239
< b2WorldCallbacks.h
---
> b2Body.h
341,345c245,249
< 2013-06-18T12:51:07.000000Z
< 7a060e40bb2ed4847cf4fdc68b2aac85
< 2011-08-23T04:29:13.130003Z
< 206
< erincatto@gmail.com
---
> 2013-07-02T14:40:41.000000Z
> 7f052f4b6340228b7ba8a8d42919f139
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
367c271
< 5983
---
> 16846
369c273
< b2Body.cpp
---
> b2ContactManager.cpp
375,379c279,283
< 2013-06-18T12:51:07.000000Z
< e8e8d187bd6f97919cabf2e4da8e5a0a
< 2012-03-17T06:32:44.892106Z
< 245
< erincatto@gmail.com
---
> 2013-07-02T14:40:41.000000Z
> 59e914afb37b4254cf550a3e045c01e5
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
401c305
< 12535
---
> 6081
403c307
< b2TimeStep.h
---
> b2WorldCallbacks.cpp
409,413c313,317
< 2013-06-18T12:51:07.000000Z
< 77e0f5df4b7d9a7717fce0517fa7fb1a
< 2011-09-12T07:14:00.889832Z
< 225
< erincatto@gmail.com
---
> 2013-07-02T14:40:41.000000Z
> 3774b4fafff3cee14cc56fd9dba5b5bc
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
435,438c339
< 1806
< 
< Joints
< dir
---
> 2250
440c341
< b2Body.h
---
> b2World.cpp
446,450c347,351
< 2013-06-18T12:51:07.000000Z
< d2108f2f6391ba74219c26ff3889c714
< 2012-06-24T02:55:58.404098Z
< 250
< erincatto@gmail.com
---
> 2013-07-02T14:40:41.000000Z
> 8b03674ec77c75d69b6bbd0749b2aaaa
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
472c373
< 23587
---
> 31533
diff -r -x './svn/*' native/Box2D/Dynamics/.svn/text-base/b2Body.cpp.svn-base ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/.svn/text-base/b2Body.cpp.svn-base
2c2
< * Copyright (c) 2006-2007 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
19,23c19,25
< #include <Box2D/Dynamics/b2Body.h>
< #include <Box2D/Dynamics/b2Fixture.h>
< #include <Box2D/Dynamics/b2World.h>
< #include <Box2D/Dynamics/Contacts/b2Contact.h>
< #include <Box2D/Dynamics/Joints/b2Joint.h>
---
> #include "b2Body.h"
> #include "b2World.h"
> #include "Joints/b2Joint.h"
> #include "../Collision/Shapes/b2Shape.h"
> #include "../Collision/Shapes/b2EdgeShape.h"
> 
> 
27,32c29
< 	b2Assert(bd->position.IsValid());
< 	b2Assert(bd->linearVelocity.IsValid());
< 	b2Assert(b2IsValid(bd->angle));
< 	b2Assert(b2IsValid(bd->angularVelocity));
< 	b2Assert(b2IsValid(bd->angularDamping) && bd->angularDamping >= 0.0f);
< 	b2Assert(b2IsValid(bd->linearDamping) && bd->linearDamping >= 0.0f);
---
> 	b2Assert(world->m_lock == false);
36c33
< 	if (bd->bullet)
---
> 	if (bd->isBullet)
46,50c43
< 		m_flags |= e_autoSleepFlag;
< 	}
< 	if (bd->awake)
< 	{
< 		m_flags |= e_awakeFlag;
---
> 		m_flags |= e_allowSleepFlag;
52c45
< 	if (bd->active)
---
> 	if (bd->isSleeping)
54c47
< 		m_flags |= e_activeFlag;
---
> 		m_flags |= e_sleepFlag;
59,60c52,53
< 	m_xf.p = bd->position;
< 	m_xf.q.Set(bd->angle);
---
> 	m_xf.position = bd->position;
> 	m_xf.R.Set(bd->angle);
62,67c55,58
< 	m_sweep.localCenter.SetZero();
< 	m_sweep.c0 = m_xf.p;
< 	m_sweep.c = m_xf.p;
< 	m_sweep.a0 = bd->angle;
< 	m_sweep.a = bd->angle;
< 	m_sweep.alpha0 = 0.0f;
---
> 	m_sweep.localCenter = bd->massData.center;
> 	m_sweep.t0 = 1.0f;
> 	m_sweep.a0 = m_sweep.a = bd->angle;
> 	m_sweep.c0 = m_sweep.c = b2Mul(m_xf, m_sweep.localCenter);
70a62
> 	m_controllerList = NULL;
74,76d65
< 	m_linearVelocity = bd->linearVelocity;
< 	m_angularVelocity = bd->angularVelocity;
< 
79d67
< 	m_gravityScale = bd->gravityScale;
81c69
< 	m_force.SetZero();
---
> 	m_force.Set(0.0f, 0.0f);
83a72,74
> 	m_linearVelocity.SetZero();
> 	m_angularVelocity = 0.0f;
> 
86c77,81
< 	m_type = bd->type;
---
> 	m_invMass = 0.0f;
> 	m_I = 0.0f;
> 	m_invI = 0.0f;
> 
> 	m_mass = bd->massData.mass;
88c83
< 	if (m_type == b2_dynamicBody)
---
> 	if (m_mass > 0.0f)
90,91c85
< 		m_mass = 1.0f;
< 		m_invMass = 1.0f;
---
> 		m_invMass = 1.0f / m_mass;
93c87,88
< 	else
---
> 
> 	if ((m_flags & b2Body::e_fixedRotationFlag) == 0)
95,96c90,95
< 		m_mass = 0.0f;
< 		m_invMass = 0.0f;
---
> 		m_I = bd->massData.I;
> 	}
> 	
> 	if (m_I > 0.0f)
> 	{
> 		m_invI = 1.0f / m_I;
99,100c98,105
< 	m_I = 0.0f;
< 	m_invI = 0.0f;
---
> 	if (m_invMass == 0.0f && m_invI == 0.0f)
> 	{
> 		m_type = e_staticType;
> 	}
> 	else
> 	{
> 		m_type = e_dynamicType;
> 	}
104,105c109,110
< 	m_fixtureList = NULL;
< 	m_fixtureCount = 0;
---
> 	m_shapeList = NULL;
> 	m_shapeCount = 0;
109a115
> 	b2Assert(m_world->m_lock == false);
113,119d118
< void b2Body::SetType(b2BodyType type)
< {
< 	b2Assert(m_world->IsLocked() == false);
< 	if (m_world->IsLocked() == true)
< 	{
< 		return;
< 	}
121,163c120,130
< 	if (m_type == type)
< 	{
< 		return;
< 	}
< 
< 	m_type = type;
< 
< 	ResetMassData();
< 
< 	if (m_type == b2_staticBody)
< 	{
< 		m_linearVelocity.SetZero();
< 		m_angularVelocity = 0.0f;
< 		m_sweep.a0 = m_sweep.a;
< 		m_sweep.c0 = m_sweep.c;
< 		SynchronizeFixtures();
< 	}
< 
< 	SetAwake(true);
< 
< 	m_force.SetZero();
< 	m_torque = 0.0f;
< 
< 	// Delete the attached contacts.
< 	b2ContactEdge* ce = m_contactList;
< 	while (ce)
< 	{
< 		b2ContactEdge* ce0 = ce;
< 		ce = ce->next;
< 		m_world->m_contactManager.Destroy(ce0->contact);
< 	}
< 	m_contactList = NULL;
< 
< 	// Touch the proxies so that new contacts will be created (when appropriate)
< 	b2BroadPhase* broadPhase = &m_world->m_contactManager.m_broadPhase;
< 	for (b2Fixture* f = m_fixtureList; f; f = f->m_next)
< 	{
< 		int32 proxyCount = f->m_proxyCount;
< 		for (int32 i = 0; i < proxyCount; ++i)
< 		{
< 			broadPhase->TouchProxy(f->m_proxies[i].proxyId);
< 		}
< 	}
---
> float32 connectEdges(b2EdgeShape * const & s1, b2EdgeShape * const & s2, float32 angle1)
> {
> 	float32 angle2 = b2Atan2(s2->GetDirectionVector().y, s2->GetDirectionVector().x);
> 	b2Vec2 core = tanf((angle2 - angle1) * 0.5f) * s2->GetDirectionVector();
> 	core = b2_toiSlop * (core - s2->GetNormalVector()) + s2->GetVertex1();
> 	b2Vec2 cornerDir = s1->GetDirectionVector() + s2->GetDirectionVector();
> 	cornerDir.Normalize();
> 	bool convex = b2Dot(s1->GetDirectionVector(), s2->GetNormalVector()) > 0.0f;
> 	s1->SetNextEdge(s2, core, cornerDir, convex);
> 	s2->SetPrevEdge(s1, core, cornerDir, convex);
> 	return angle2;
166c133
< b2Fixture* b2Body::CreateFixture(const b2FixtureDef* def)
---
> b2Shape* b2Body::CreateShape(b2ShapeDef* def)
168,169c135,136
< 	b2Assert(m_world->IsLocked() == false);
< 	if (m_world->IsLocked() == true)
---
> 	b2Assert(m_world->m_lock == false);
> 	if (m_world->m_lock == true)
173,183c140,185
< 
< 	b2BlockAllocator* allocator = &m_world->m_blockAllocator;
< 
< 	void* memory = allocator->Allocate(sizeof(b2Fixture));
< 	b2Fixture* fixture = new (memory) b2Fixture;
< 	fixture->Create(allocator, this, def);
< 
< 	if (m_flags & e_activeFlag)
< 	{
< 		b2BroadPhase* broadPhase = &m_world->m_contactManager.m_broadPhase;
< 		fixture->CreateProxies(broadPhase, m_xf);
---
> 	
> 	
> 	// TODO: Decide on a better place to initialize edgeShapes. (b2Shape::Create() can't
> 	//       return more than one shape to add to parent body... maybe it should add
> 	//       shapes directly to the body instead of returning them?)
> 	if (def->type == e_edgeShape) {
> 		b2EdgeChainDef* edgeDef = (b2EdgeChainDef*)def;
> 		b2Vec2 v1;
> 		b2Vec2 v2;
> 		int i;
> 		
> 		if (edgeDef->isALoop) {
> 			v1 = edgeDef->vertices[edgeDef->vertexCount-1];
> 			i = 0;
> 		} else {
> 			v1 = edgeDef->vertices[0];
> 			i = 1;
> 		}
> 		
> 		b2EdgeShape* s0 = NULL;
> 		b2EdgeShape* s1 = NULL;
> 		b2EdgeShape* s2 = NULL;
> 		float32 angle = 0.0f;
> 		for (; i < edgeDef->vertexCount; i++) {
> 			v2 = edgeDef->vertices[i];
> 			
> 			void* mem = m_world->m_blockAllocator.Allocate(sizeof(b2EdgeShape));
> 			s2 = new (mem) b2EdgeShape(v1, v2, def);
> 			s2->m_next = m_shapeList;
> 			m_shapeList = s2;
> 			++m_shapeCount;
> 			s2->m_body = this;
> 			s2->CreateProxy(m_world->m_broadPhase, m_xf);
> 			s2->UpdateSweepRadius(m_sweep.localCenter);
> 			
> 			if (s1 == NULL) {
> 				s0 = s2;
> 				angle = b2Atan2(s2->GetDirectionVector().y, s2->GetDirectionVector().x);
> 			} else {
> 				angle = connectEdges(s1, s2, angle);
> 			}
> 			s1 = s2;
> 			v1 = v2;
> 		}
> 		if (edgeDef->isALoop) connectEdges(s1, s0, angle);
> 		return s0;
184a187,188
> 	
> 	b2Shape* s = b2Shape::Create(def, &m_world->m_blockAllocator);
186,188c190,192
< 	fixture->m_next = m_fixtureList;
< 	m_fixtureList = fixture;
< 	++m_fixtureCount;
---
> 	s->m_next = m_shapeList;
> 	m_shapeList = s;
> 	++m_shapeCount;
190c194
< 	fixture->m_body = this;
---
> 	s->m_body = this;
192,196c196,197
< 	// Adjust mass properties if needed.
< 	if (fixture->m_density > 0.0f)
< 	{
< 		ResetMassData();
< 	}
---
> 	// Add the shape to the world's broad-phase.
> 	s->CreateProxy(m_world->m_broadPhase, m_xf);
198,200c199,200
< 	// Let the world know we have a new fixture. This will cause new contacts
< 	// to be created at the beginning of the next time step.
< 	m_world->m_flags |= b2World::e_newFixture;
---
> 	// Compute the sweep radius for CCD.
> 	s->UpdateSweepRadius(m_sweep.localCenter);
202c202
< 	return fixture;
---
> 	return s;
205c205
< b2Fixture* b2Body::CreateFixture(const b2Shape* shape, float32 density)
---
> void b2Body::DestroyShape(b2Shape* s)
207,217c207,208
< 	b2FixtureDef def;
< 	def.shape = shape;
< 	def.density = density;
< 
< 	return CreateFixture(&def);
< }
< 
< void b2Body::DestroyFixture(b2Fixture* fixture)
< {
< 	b2Assert(m_world->IsLocked() == false);
< 	if (m_world->IsLocked() == true)
---
> 	b2Assert(m_world->m_lock == false);
> 	if (m_world->m_lock == true)
222c213,214
< 	b2Assert(fixture->m_body == this);
---
> 	b2Assert(s->GetBody() == this);
> 	s->DestroyProxy(m_world->m_broadPhase);
224,226c216,217
< 	// Remove the fixture from this body's singly linked list.
< 	b2Assert(m_fixtureCount > 0);
< 	b2Fixture** node = &m_fixtureList;
---
> 	b2Assert(m_shapeCount > 0);
> 	b2Shape** node = &m_shapeList;
230c221
< 		if (*node == fixture)
---
> 		if (*node == s)
232c223
< 			*node = fixture->m_next;
---
> 			*node = s->m_next;
243,251c234,235
< 	// Destroy any contacts associated with the fixture.
< 	b2ContactEdge* edge = m_contactList;
< 	while (edge)
< 	{
< 		b2Contact* c = edge->contact;
< 		edge = edge->next;
< 
< 		b2Fixture* fixtureA = c->GetFixtureA();
< 		b2Fixture* fixtureB = c->GetFixtureB();
---
> 	s->m_body = NULL;
> 	s->m_next = NULL;
253,259c237
< 		if (fixture == fixtureA || fixture == fixtureB)
< 		{
< 			// This destroys the contact and removes it from
< 			// this body's contact list.
< 			m_world->m_contactManager.Destroy(c);
< 		}
< 	}
---
> 	--m_shapeCount;
261c239,240
< 	b2BlockAllocator* allocator = &m_world->m_blockAllocator;
---
> 	b2Shape::Destroy(s, &m_world->m_blockAllocator);
> }
263c242,246
< 	if (m_flags & e_activeFlag)
---
> // TODO_ERIN adjust linear velocity and torque to account for movement of center.
> void b2Body::SetMass(const b2MassData* massData)
> {
> 	b2Assert(m_world->m_lock == false);
> 	if (m_world->m_lock == true)
265,266c248
< 		b2BroadPhase* broadPhase = &m_world->m_contactManager.m_broadPhase;
< 		fixture->DestroyProxies(broadPhase);
---
> 		return;
269,284d250
< 	fixture->Destroy(allocator);
< 	fixture->m_body = NULL;
< 	fixture->m_next = NULL;
< 	fixture->~b2Fixture();
< 	allocator->Free(fixture, sizeof(b2Fixture));
< 
< 	--m_fixtureCount;
< 
< 	// Reset the mass data.
< 	ResetMassData();
< }
< 
< void b2Body::ResetMassData()
< {
< 	// Compute mass data from shapes. Each shape has its own density.
< 	m_mass = 0.0f;
288d253
< 	m_sweep.localCenter.SetZero();
290,291c255,257
< 	// Static and kinematic bodies have zero mass.
< 	if (m_type == b2_staticBody || m_type == b2_kinematicBody)
---
> 	m_mass = massData->mass;
> 
> 	if (m_mass > 0.0f)
293,296c259
< 		m_sweep.c0 = m_xf.p;
< 		m_sweep.c = m_xf.p;
< 		m_sweep.a0 = m_sweep.a;
< 		return;
---
> 		m_invMass = 1.0f / m_mass;
299,303c262
< 	b2Assert(m_type == b2_dynamicBody);
< 
< 	// Accumulate mass over all fixtures.
< 	b2Vec2 localCenter = b2Vec2_zero;
< 	for (b2Fixture* f = m_fixtureList; f; f = f->m_next)
---
> 	if ((m_flags & b2Body::e_fixedRotationFlag) == 0)
305,314c264
< 		if (f->m_density == 0.0f)
< 		{
< 			continue;
< 		}
< 
< 		b2MassData massData;
< 		f->GetMassData(&massData);
< 		m_mass += massData.mass;
< 		localCenter += massData.mass * massData.center;
< 		m_I += massData.I;
---
> 		m_I = massData->I;
317,318c267
< 	// Compute center of mass.
< 	if (m_mass > 0.0f)
---
> 	if (m_I > 0.0f)
320,321c269
< 		m_invMass = 1.0f / m_mass;
< 		localCenter *= m_invMass;
---
> 		m_invI = 1.0f / m_I;
323c271,277
< 	else
---
> 
> 	// Move center of mass.
> 	m_sweep.localCenter = massData->center;
> 	m_sweep.c0 = m_sweep.c = b2Mul(m_xf, m_sweep.localCenter);
> 
> 	// Update the sweep radii of all child shapes.
> 	for (b2Shape* s = m_shapeList; s; s = s->m_next)
325,327c279
< 		// Force all dynamic bodies to have a positive mass.
< 		m_mass = 1.0f;
< 		m_invMass = 1.0f;
---
> 		s->UpdateSweepRadius(m_sweep.localCenter);
330c282,283
< 	if (m_I > 0.0f && (m_flags & e_fixedRotationFlag) == 0)
---
> 	int16 oldType = m_type;
> 	if (m_invMass == 0.0f && m_invI == 0.0f)
332,336c285
< 		// Center the inertia about the center of mass.
< 		m_I -= m_mass * b2Dot(localCenter, localCenter);
< 		b2Assert(m_I > 0.0f);
< 		m_invI = 1.0f / m_I;
< 
---
> 		m_type = e_staticType;
340,341c289
< 		m_I = 0.0f;
< 		m_invI = 0.0f;
---
> 		m_type = e_dynamicType;
344,356c292,293
< 	// Move center of mass.
< 	b2Vec2 oldCenter = m_sweep.c;
< 	m_sweep.localCenter = localCenter;
< 	m_sweep.c0 = m_sweep.c = b2Mul(m_xf, m_sweep.localCenter);
< 
< 	// Update center of mass velocity.
< 	m_linearVelocity += b2Cross(m_angularVelocity, m_sweep.c - oldCenter);
< }
< 
< void b2Body::SetMassData(const b2MassData* massData)
< {
< 	b2Assert(m_world->IsLocked() == false);
< 	if (m_world->IsLocked() == true)
---
> 	// If the body type changed, we need to refilter the broad-phase proxies.
> 	if (oldType != m_type)
358c295,298
< 		return;
---
> 		for (b2Shape* s = m_shapeList; s; s = s->m_next)
> 		{
> 			s->RefilterProxy(m_world->m_broadPhase, m_xf);
> 		}
359a300
> }
361c302,306
< 	if (m_type != b2_dynamicBody)
---
> // TODO_ERIN adjust linear velocity and torque to account for movement of center.
> void b2Body::SetMassFromShapes()
> {
> 	b2Assert(m_world->m_lock == false);
> 	if (m_world->m_lock == true)
365a311,312
> 	// Compute mass data from shapes. Each shape has its own density.
> 	m_mass = 0.0f;
370,371c317,318
< 	m_mass = massData->mass;
< 	if (m_mass <= 0.0f)
---
> 	b2Vec2 center = b2Vec2_zero;
> 	for (b2Shape* s = m_shapeList; s; s = s->m_next)
373c320,324
< 		m_mass = 1.0f;
---
> 		b2MassData massData;
> 		s->ComputeMass(&massData);
> 		m_mass += massData.mass;
> 		center += massData.mass * massData.center;
> 		m_I += massData.I;
376c327,332
< 	m_invMass = 1.0f / m_mass;
---
> 	// Compute center of mass, and shift the origin to the COM.
> 	if (m_mass > 0.0f)
> 	{
> 		m_invMass = 1.0f / m_mass;
> 		center *= m_invMass;
> 	}
378c334
< 	if (massData->I > 0.0f && (m_flags & b2Body::e_fixedRotationFlag) == 0)
---
> 	if (m_I > 0.0f && (m_flags & e_fixedRotationFlag) == 0)
380c336,337
< 		m_I = massData->I - m_mass * b2Dot(massData->center, massData->center);
---
> 		// Center the inertia about the center of mass.
> 		m_I -= m_mass * b2Dot(center, center);
383a341,345
> 	else
> 	{
> 		m_I = 0.0f;
> 		m_invI = 0.0f;
> 	}
386,387c348
< 	b2Vec2 oldCenter = m_sweep.c;
< 	m_sweep.localCenter =  massData->center;
---
> 	m_sweep.localCenter = center;
390,392c351,355
< 	// Update center of mass velocity.
< 	m_linearVelocity += b2Cross(m_angularVelocity, m_sweep.c - oldCenter);
< }
---
> 	// Update the sweep radii of all child shapes.
> 	for (b2Shape* s = m_shapeList; s; s = s->m_next)
> 	{
> 		s->UpdateSweepRadius(m_sweep.localCenter);
> 	}
394,397c357,358
< bool b2Body::ShouldCollide(const b2Body* other) const
< {
< 	// At least one body should be dynamic.
< 	if (m_type != b2_dynamicBody && other->m_type != b2_dynamicBody)
---
> 	int16 oldType = m_type;
> 	if (m_invMass == 0.0f && m_invI == 0.0f)
399c360,364
< 		return false;
---
> 		m_type = e_staticType;
> 	}
> 	else
> 	{
> 		m_type = e_dynamicType;
402,403c367,368
< 	// Does a joint prevent collision?
< 	for (b2JointEdge* jn = m_jointList; jn; jn = jn->next)
---
> 	// If the body type changed, we need to refilter the broad-phase proxies.
> 	if (oldType != m_type)
405c370
< 		if (jn->other == other)
---
> 		for (b2Shape* s = m_shapeList; s; s = s->m_next)
407,410c372
< 			if (jn->joint->m_collideConnected == false)
< 			{
< 				return false;
< 			}
---
> 			s->RefilterProxy(m_world->m_broadPhase, m_xf);
413,414d374
< 
< 	return true;
417c377
< void b2Body::SetTransform(const b2Vec2& position, float32 angle)
---
> bool b2Body::SetXForm(const b2Vec2& position, float32 angle)
419,420c379,380
< 	b2Assert(m_world->IsLocked() == false);
< 	if (m_world->IsLocked() == true)
---
> 	b2Assert(m_world->m_lock == false);
> 	if (m_world->m_lock == true)
422c382
< 		return;
---
> 		return true;
425,435c385
< 	m_xf.q.Set(angle);
< 	m_xf.p = position;
< 
< 	m_sweep.c = b2Mul(m_xf, m_sweep.localCenter);
< 	m_sweep.a = angle;
< 
< 	m_sweep.c0 = m_sweep.c;
< 	m_sweep.a0 = angle;
< 
< 	b2BroadPhase* broadPhase = &m_world->m_contactManager.m_broadPhase;
< 	for (b2Fixture* f = m_fixtureList; f; f = f->m_next)
---
> 	if (IsFrozen())
437c387
< 		f->Synchronize(broadPhase, m_xf, m_xf);
---
> 		return false;
440,441c390,391
< 	m_world->m_contactManager.FindNewContacts();
< }
---
> 	m_xf.R.Set(angle);
> 	m_xf.position = position;
443,447c393,394
< void b2Body::SynchronizeFixtures()
< {
< 	b2Transform xf1;
< 	xf1.q.Set(m_sweep.a0);
< 	xf1.p = m_sweep.c0 - b2Mul(xf1.q, m_sweep.localCenter);
---
> 	m_sweep.c0 = m_sweep.c = b2Mul(m_xf, m_sweep.localCenter);
> 	m_sweep.a0 = m_sweep.a = angle;
449,450c396,397
< 	b2BroadPhase* broadPhase = &m_world->m_contactManager.m_broadPhase;
< 	for (b2Fixture* f = m_fixtureList; f; f = f->m_next)
---
> 	bool freeze = false;
> 	for (b2Shape* s = m_shapeList; s; s = s->m_next)
452,454c399
< 		f->Synchronize(broadPhase, xf1, m_xf);
< 	}
< }
---
> 		bool inRange = s->Synchronize(m_world->m_broadPhase, m_xf, m_xf);
456,462c401,405
< void b2Body::SetActive(bool flag)
< {
< 	b2Assert(m_world->IsLocked() == false);
< 
< 	if (flag == IsActive())
< 	{
< 		return;
---
> 		if (inRange == false)
> 		{
> 			freeze = true;
> 			break;
> 		}
465c408
< 	if (flag)
---
> 	if (freeze == true)
467,471c410,413
< 		m_flags |= e_activeFlag;
< 
< 		// Create all proxies.
< 		b2BroadPhase* broadPhase = &m_world->m_contactManager.m_broadPhase;
< 		for (b2Fixture* f = m_fixtureList; f; f = f->m_next)
---
> 		m_flags |= e_frozenFlag;
> 		m_linearVelocity.SetZero();
> 		m_angularVelocity = 0.0f;
> 		for (b2Shape* s = m_shapeList; s; s = s->m_next)
473c415
< 			f->CreateProxies(broadPhase, m_xf);
---
> 			s->DestroyProxy(m_world->m_broadPhase);
476c418,419
< 		// Contacts are created the next time step.
---
> 		// Failure
> 		return false;
478,480d420
< 	else
< 	{
< 		m_flags &= ~e_activeFlag;
482,487c422,423
< 		// Destroy all proxies.
< 		b2BroadPhase* broadPhase = &m_world->m_contactManager.m_broadPhase;
< 		for (b2Fixture* f = m_fixtureList; f; f = f->m_next)
< 		{
< 			f->DestroyProxies(broadPhase);
< 		}
---
> 	// Success
> 	m_world->m_broadPhase->Commit();
489,498c425,427
< 		// Destroy the attached contacts.
< 		b2ContactEdge* ce = m_contactList;
< 		while (ce)
< 		{
< 			b2ContactEdge* ce0 = ce;
< 			ce = ce->next;
< 			m_world->m_contactManager.Destroy(ce0->contact);
< 		}
< 		m_contactList = NULL;
< 	}
---
> 	// make sure java objects are updated:
> 	ClearJNIUpdated();
> 	return true;
501c430
< void b2Body::SetFixedRotation(bool flag)
---
> bool b2Body::SynchronizeShapes()
503,507c432,434
< 	bool status = (m_flags & e_fixedRotationFlag) == e_fixedRotationFlag;
< 	if (status == flag)
< 	{
< 		return;
< 	}
---
> 	b2XForm xf1;
> 	xf1.R.Set(m_sweep.a0);
> 	xf1.position = m_sweep.c0 - b2Mul(xf1.R, m_sweep.localCenter);
509,513c436,437
< 	if (flag)
< 	{
< 		m_flags |= e_fixedRotationFlag;
< 	}
< 	else
---
> 	bool inRange = true;
> 	for (b2Shape* s = m_shapeList; s; s = s->m_next)
515c439,443
< 		m_flags &= ~e_fixedRotationFlag;
---
> 		inRange = s->Synchronize(m_world->m_broadPhase, xf1, m_xf);
> 		if (inRange == false)
> 		{
> 			break;
> 		}
518,525c446,454
< 	m_angularVelocity = 0.0f;
< 
< 	ResetMassData();
< }
< 
< void b2Body::Dump()
< {
< 	int32 bodyIndex = m_islandIndex;
---
> 	if (inRange == false)
> 	{
> 		m_flags |= e_frozenFlag;
> 		m_linearVelocity.SetZero();
> 		m_angularVelocity = 0.0f;
> 		for (b2Shape* s = m_shapeList; s; s = s->m_next)
> 		{
> 			s->DestroyProxy(m_world->m_broadPhase);
> 		}
527,548c456,457
< 	b2Log("{\n");
< 	b2Log("  b2BodyDef bd;\n");
< 	b2Log("  bd.type = b2BodyType(%d);\n", m_type);
< 	b2Log("  bd.position.Set(%.15lef, %.15lef);\n", m_xf.p.x, m_xf.p.y);
< 	b2Log("  bd.angle = %.15lef;\n", m_sweep.a);
< 	b2Log("  bd.linearVelocity.Set(%.15lef, %.15lef);\n", m_linearVelocity.x, m_linearVelocity.y);
< 	b2Log("  bd.angularVelocity = %.15lef;\n", m_angularVelocity);
< 	b2Log("  bd.linearDamping = %.15lef;\n", m_linearDamping);
< 	b2Log("  bd.angularDamping = %.15lef;\n", m_angularDamping);
< 	b2Log("  bd.allowSleep = bool(%d);\n", m_flags & e_autoSleepFlag);
< 	b2Log("  bd.awake = bool(%d);\n", m_flags & e_awakeFlag);
< 	b2Log("  bd.fixedRotation = bool(%d);\n", m_flags & e_fixedRotationFlag);
< 	b2Log("  bd.bullet = bool(%d);\n", m_flags & e_bulletFlag);
< 	b2Log("  bd.active = bool(%d);\n", m_flags & e_activeFlag);
< 	b2Log("  bd.gravityScale = %.15lef;\n", m_gravityScale);
< 	b2Log("  bodies[%d] = m_world->CreateBody(&bd);\n", m_islandIndex);
< 	b2Log("\n");
< 	for (b2Fixture* f = m_fixtureList; f; f = f->m_next)
< 	{
< 		b2Log("  {\n");
< 		f->Dump(bodyIndex);
< 		b2Log("  }\n");
---
> 		// Failure
> 		return false;
550c459,461
< 	b2Log("}\n");
---
> 
> 	// Success
> 	return true;
diff -r -x './svn/*' native/Box2D/Dynamics/.svn/text-base/b2Body.h.svn-base ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/.svn/text-base/b2Body.h.svn-base
2c2
< * Copyright (c) 2006-2011 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
22,24c22,27
< #include <Box2D/Common/b2Math.h>
< #include <Box2D/Collision/Shapes/b2Shape.h>
< #include <memory>
---
> #include "../Common/b2Math.h"
> #include "../Collision/Shapes/b2Shape.h"
> #include "Joints/b2Joint.h"
> #include "Controllers/b2Controller.h"
> 
> #include <new>
26d28
< class b2Fixture;
31d32
< struct b2FixtureDef;
34,47c35
< 
< /// The body type.
< /// static: zero mass, zero velocity, may be manually moved
< /// kinematic: zero mass, non-zero velocity set by user, moved by solver
< /// dynamic: positive mass, non-zero velocity determined by forces, moved by solver
< enum b2BodyType
< {
< 	b2_staticBody = 0,
< 	b2_kinematicBody,
< 	b2_dynamicBody
< 
< 	// TODO_ERIN
< 	//b2_bulletBody,
< };
---
> struct b2ControllerEdge;
50c38
< /// You can safely re-use body definitions. Shapes are added to a body after construction.
---
> /// You can safely re-use body definitions.
55a44,46
> 		massData.center.SetZero();
> 		massData.mass = 0.0f;
> 		massData.I = 0.0f;
59,60d49
< 		linearVelocity.Set(0.0f, 0.0f);
< 		angularVelocity = 0.0f;
64c53
< 		awake = true;
---
> 		isSleeping = false;
66,69c55
< 		bullet = false;
< 		type = b2_staticBody;
< 		active = true;
< 		gravityScale = 1.0f;
---
> 		isBullet = false;
72,74c58,64
< 	/// The body type: static, kinematic, or dynamic.
< 	/// Note: if a dynamic body would have zero mass, the mass is set to one.
< 	b2BodyType type;
---
> 	/// You can use this to initialized the mass properties of the body.
> 	/// If you prefer, you can set the mass properties after the shapes
> 	/// have been added using b2Body::SetMassFromShapes.
> 	b2MassData massData;
> 
> 	/// Use this to store application specific body data.
> 	void* userData;
83,88d72
< 	/// The linear velocity of the body's origin in world co-ordinates.
< 	b2Vec2 linearVelocity;
< 
< 	/// The angular velocity of the body.
< 	float32 angularVelocity;
< 
103,104c87,88
< 	/// Is this body initially awake or sleeping?
< 	bool awake;
---
> 	/// Is this body initially sleeping?
> 	bool isSleeping;
111c95
< 	/// kinematic and static bodies. This setting is only considered on dynamic bodies.
---
> 	/// static bodies.
113,122c97
< 	bool bullet;
< 
< 	/// Does this body start out active?
< 	bool active;
< 
< 	/// Use this to store application specific body data.
< 	void* userData;
< 
< 	/// Scale the gravity applied to this body.
< 	float32 gravityScale;
---
> 	bool isBullet;
125c100
< /// A rigid body. These are created via b2World::CreateBody.
---
> /// A rigid body.
129,134c104,105
< 	/// Creates a fixture and attach it to this body. Use this function if you need
< 	/// to set some fixture parameters, like friction. Otherwise you can create the
< 	/// fixture directly from a shape.
< 	/// If the density is non-zero, this function automatically updates the mass of the body.
< 	/// Contacts are not created until the next time step.
< 	/// @param def the fixture definition.
---
> 	/// Creates a shape and attach it to this body.
> 	/// @param shapeDef the shape definition.
136c107
< 	b2Fixture* CreateFixture(const b2FixtureDef* def);
---
> 	b2Shape* CreateShape(b2ShapeDef* shapeDef);
138,143c109,112
< 	/// Creates a fixture from a shape and attach it to this body.
< 	/// This is a convenience function. Use b2FixtureDef if you need to set parameters
< 	/// like friction, restitution, user data, or filtering.
< 	/// If the density is non-zero, this function automatically updates the mass of the body.
< 	/// @param shape the shape to be cloned.
< 	/// @param density the shape density (set to zero for static bodies).
---
> 	/// Destroy a shape. This removes the shape from the broad-phase and
> 	/// therefore destroys any contacts associated with this shape. All shapes
> 	/// attached to a body are implicitly destroyed when the body is destroyed.
> 	/// @param shape the shape to be removed.
145c114
< 	b2Fixture* CreateFixture(const b2Shape* shape, float32 density);
---
> 	void DestroyShape(b2Shape* shape);
147,154c116,120
< 	/// Destroy a fixture. This removes the fixture from the broad-phase and
< 	/// destroys all contacts associated with this fixture. This will
< 	/// automatically adjust the mass of the body if the body is dynamic and the
< 	/// fixture has positive density.
< 	/// All fixtures attached to a body are implicitly destroyed when the body is destroyed.
< 	/// @param fixture the fixture to be removed.
< 	/// @warning This function is locked during callbacks.
< 	void DestroyFixture(b2Fixture* fixture);
---
> 	/// Set the mass properties. Note that this changes the center of mass position.
> 	/// If you are not sure how to compute mass properties, use SetMassFromShapes.
> 	/// The inertia tensor is assumed to be relative to the center of mass.
> 	/// @param massData the mass properties.
> 	void SetMass(const b2MassData* massData);
156c122,127
< 	/// Set the position of the body's origin and rotation.
---
> 	/// Compute the mass properties from the attached shapes. You typically call this
> 	/// after adding all the shapes. If you add or remove shapes later, you may want
> 	/// to call this again. Note that this changes the center of mass position.
> 	void SetMassFromShapes();
> 
> 	/// Set the position of the body's origin and rotation (radians).
158,161c129,134
< 	/// Manipulating a body's transform may cause non-physical behavior.
< 	/// @param position the world position of the body's local origin.
< 	/// @param angle the world rotation in radians.
< 	void SetTransform(const b2Vec2& position, float32 angle);
---
> 	/// @param position the new world position of the body's origin (not necessarily
> 	/// the center of mass).
> 	/// @param angle the new world rotation angle of the body in radians.
> 	/// @return false if the movement put a shape outside the world. In this case the
> 	/// body is automatically frozen.
> 	bool SetXForm(const b2Vec2& position, float32 angle);
165c138
< 	const b2Transform& GetTransform() const;
---
> 	const b2XForm& GetXForm() const;
187c160
< 	const b2Vec2& GetLinearVelocity() const;
---
> 	b2Vec2 GetLinearVelocity() const;
202,208c175
< 	/// @param wake also wake up the body
< 	void ApplyForce(const b2Vec2& force, const b2Vec2& point, bool wake);
< 
< 	/// Apply a force to the center of mass. This wakes up the body.
< 	/// @param force the world force vector, usually in Newtons (N).
< 	/// @param wake also wake up the body
< 	void ApplyForceToCenter(const b2Vec2& force, bool wake);
---
> 	void ApplyForce(const b2Vec2& force, const b2Vec2& point);
214,215c181
< 	/// @param wake also wake up the body
< 	void ApplyTorque(float32 torque, bool wake);
---
> 	void ApplyTorque(float32 torque);
222,228c188
< 	/// @param wake also wake up the body
< 	void ApplyLinearImpulse(const b2Vec2& impulse, const b2Vec2& point, bool wake);
< 
< 	/// Apply an angular impulse.
< 	/// @param impulse the angular impulse in units of kg*m*m/s
< 	/// @param wake also wake up the body
< 	void ApplyAngularImpulse(float32 impulse, bool wake);
---
> 	void ApplyImpulse(const b2Vec2& impulse, const b2Vec2& point);
234c194
< 	/// Get the rotational inertia of the body about the local origin.
---
> 	/// Get the central rotational inertia of the body.
238,253d197
< 	/// Get the mass data of the body.
< 	/// @return a struct containing the mass, inertia and center of the body.
< 	void GetMassData(b2MassData* data) const;
< 
< 	/// Set the mass properties to override the mass properties of the fixtures.
< 	/// Note that this changes the center of mass position.
< 	/// Note that creating or destroying fixtures can also alter the mass.
< 	/// This function has no effect if the body isn't dynamic.
< 	/// @param massData the mass properties.
< 	void SetMassData(const b2MassData* data);
< 
< 	/// This resets the mass properties to the sum of the mass properties of the fixtures.
< 	/// This normally does not need to be called unless you called SetMassData to override
< 	/// the mass and you later want to reset the mass.
< 	void ResetMassData();
< 
284,285c228,229
< 	/// Get the linear damping of the body.
< 	float32 GetLinearDamping() const;
---
> 	/// Is this body treated like a bullet for continuous collision detection?
> 	bool IsBullet() const;
287,288c231,232
< 	/// Set the linear damping of the body.
< 	void SetLinearDamping(float32 linearDamping);
---
> 	/// Should this body be treated like a bullet for continuous collision detection?
> 	void SetBullet(bool flag);
290,291c234,235
< 	/// Get the angular damping of the body.
< 	float32 GetAngularDamping() const;
---
> 	/// Is this body static (immovable)?
> 	bool IsStatic() const;
293,294c237,238
< 	/// Set the angular damping of the body.
< 	void SetAngularDamping(float32 angularDamping);
---
> 	/// Is this body dynamic (movable)?
> 	bool IsDynamic() const;
296,297c240,241
< 	/// Get the gravity scale of the body.
< 	float32 GetGravityScale() const;
---
> 	/// Is this body frozen?
> 	bool IsFrozen() const;
299,300c243,244
< 	/// Set the gravity scale of the body.
< 	void SetGravityScale(float32 scale);
---
> 	/// Is this body sleeping (not simulating).
> 	bool IsSleeping() const;
302,303c246,247
< 	/// Set the type of this body. This may alter the mass and velocity.
< 	void SetType(b2BodyType type);
---
> 	// Is the JNI java object of this object aware of new position?
> 	bool IsJNIUpdated() const;
305,306c249,250
< 	/// Get the type of this body.
< 	b2BodyType GetType() const;
---
> 	/// You can disable sleeping on this body.
> 	void AllowSleeping(bool flag);
308,309c252,255
< 	/// Should this body be treated like a bullet for continuous collision detection?
< 	void SetBullet(bool flag);
---
> 	// inform body that JNI java object has been updated
> 	void SetJNIUpdated();
> 	// inform body that JNI java object is outdated
> 	void ClearJNIUpdated();
311,312c257,258
< 	/// Is this body treated like a bullet for continuous collision detection?
< 	bool IsBullet() const;
---
> 	/// Wake up this body so it will begin simulating.
> 	void WakeUp();
314,357c260,265
< 	/// You can disable sleeping on this body. If you disable sleeping, the
< 	/// body will be woken.
< 	void SetSleepingAllowed(bool flag);
< 
< 	/// Is this body allowed to sleep
< 	bool IsSleepingAllowed() const;
< 
< 	/// Set the sleep state of the body. A sleeping body has very
< 	/// low CPU cost.
< 	/// @param flag set to true to wake the body, false to put it to sleep.
< 	void SetAwake(bool flag);
< 
< 	/// Get the sleeping state of this body.
< 	/// @return true if the body is sleeping.
< 	bool IsAwake() const;
< 
< 	/// Set the active state of the body. An inactive body is not
< 	/// simulated and cannot be collided with or woken up.
< 	/// If you pass a flag of true, all fixtures will be added to the
< 	/// broad-phase.
< 	/// If you pass a flag of false, all fixtures will be removed from
< 	/// the broad-phase and all contacts will be destroyed.
< 	/// Fixtures and joints are otherwise unaffected. You may continue
< 	/// to create/destroy fixtures and joints on inactive bodies.
< 	/// Fixtures on an inactive body are implicitly inactive and will
< 	/// not participate in collisions, ray-casts, or queries.
< 	/// Joints connected to an inactive body are implicitly inactive.
< 	/// An inactive body is still owned by a b2World object and remains
< 	/// in the body list.
< 	void SetActive(bool flag);
< 
< 	/// Get the active state of the body.
< 	bool IsActive() const;
< 
< 	/// Set this body to have fixed rotation. This causes the mass
< 	/// to be reset.
< 	void SetFixedRotation(bool flag);
< 
< 	/// Does this body have fixed rotation?
< 	bool IsFixedRotation() const;
< 
< 	/// Get the list of all fixtures attached to this body.
< 	b2Fixture* GetFixtureList();
< 	const b2Fixture* GetFixtureList() const;
---
> 	/// Put this body to sleep so it will stop simulating.
> 	/// This also sets the velocity to zero.
> 	void PutToSleep();
> 
> 	/// Get the list of all shapes attached to this body.
> 	b2Shape* GetShapeList();
361d268
< 	const b2JointEdge* GetJointList() const;
363,367c270,271
< 	/// Get the list of all contacts attached to this body.
< 	/// @warning this list changes during the time step and you may
< 	/// miss some collisions if you don't use b2ContactListener.
< 	b2ContactEdge* GetContactList();
< 	const b2ContactEdge* GetContactList() const;
---
> 	/// Get the list of all controllers attached to this body.
> 	b2ControllerEdge* GetControllerList();
371d274
< 	const b2Body* GetNext() const;
374c277
< 	void* GetUserData() const;
---
> 	void* GetUserData();
381,384d283
< 	const b2World* GetWorld() const;
< 
< 	/// Dump this body to a log file
< 	void Dump();
392d290
< 	friend class b2Contact;
395d292
< 	friend class b2FrictionJoint;
397c294
< 	friend class b2MotorJoint;
---
> 	friend class b2LineJoint;
402,404c299,300
< 	friend class b2RopeJoint;
< 	friend class b2WeldJoint;
< 	friend class b2WheelJoint;
---
> 
> 	friend class b2Controller;
409,415c305,320
< 		e_islandFlag		= 0x0001,
< 		e_awakeFlag			= 0x0002,
< 		e_autoSleepFlag		= 0x0004,
< 		e_bulletFlag		= 0x0008,
< 		e_fixedRotationFlag	= 0x0010,
< 		e_activeFlag		= 0x0020,
< 		e_toiFlag			= 0x0040
---
> 		e_frozenFlag		= 0x0002,
> 		e_islandFlag		= 0x0004,
> 		e_sleepFlag			= 0x0008,
> 		e_allowSleepFlag	= 0x0010,
> 		e_bulletFlag		= 0x0020,
> 		e_fixedRotationFlag	= 0x0040,
> 
> 		e_jniUpdatedFlag	= 0x0080,
> 	};
> 
> 	// m_type
> 	enum
> 	{
> 		e_staticType,
> 		e_dynamicType,
> 		e_maxTypes,
421c326,327
< 	void SynchronizeFixtures();
---
> 	bool SynchronizeShapes();
> 
426c332
< 	bool ShouldCollide(const b2Body* other) const;
---
> 	bool IsConnected(const b2Body* other) const;
430,431d335
< 	b2BodyType m_type;
< 
432a337
> 	int16 m_type;
436,437c341,342
< 	b2Transform m_xf;		// the body origin transform
< 	b2Sweep m_sweep;		// the swept motion for CCD
---
> 	b2XForm m_xf;		// the body origin transform
> 	b2Sweep m_sweep;	// the swept motion for CCD
449,450c354,355
< 	b2Fixture* m_fixtureList;
< 	int32 m_fixtureCount;
---
> 	b2Shape* m_shapeList;
> 	int32 m_shapeCount;
455c360
< 	float32 m_mass, m_invMass;
---
> 	b2ControllerEdge* m_controllerList;
457c362
< 	// Rotational inertia about the center of mass.
---
> 	float32 m_mass, m_invMass;
459a365,366
> public:
> 
462d368
< 	float32 m_gravityScale;
463a370
> private:
469,474c376
< inline b2BodyType b2Body::GetType() const
< {
< 	return m_type;
< }
< 
< inline const b2Transform& b2Body::GetTransform() const
---
> inline const b2XForm& b2Body::GetXForm() const
481c383
< 	return m_xf.p;
---
> 	return m_xf.position;
501,510d402
< 	if (m_type == b2_staticBody)
< 	{
< 		return;
< 	}
< 
< 	if (b2Dot(v,v) > 0.0f)
< 	{
< 		SetAwake(true);
< 	}
< 
514c406
< inline const b2Vec2& b2Body::GetLinearVelocity() const
---
> inline b2Vec2 b2Body::GetLinearVelocity() const
521,530d412
< 	if (m_type == b2_staticBody)
< 	{
< 		return;
< 	}
< 
< 	if (w * w > 0.0f)
< 	{
< 		SetAwake(true);
< 	}
< 
546,553c428
< 	return m_I + m_mass * b2Dot(m_sweep.localCenter, m_sweep.localCenter);
< }
< 
< inline void b2Body::GetMassData(b2MassData* data) const
< {
< 	data->mass = m_mass;
< 	data->I = m_I + m_mass * b2Dot(m_sweep.localCenter, m_sweep.localCenter);
< 	data->center = m_sweep.localCenter;
---
> 	return m_I;
563c438
< 	return b2Mul(m_xf.q, localVector);
---
> 	return b2Mul(m_xf.R, localVector);
573c448
< 	return b2MulT(m_xf.q, worldVector);
---
> 	return b2MulT(m_xf.R, worldVector);
586,611c461
< inline float32 b2Body::GetLinearDamping() const
< {
< 	return m_linearDamping;
< }
< 
< inline void b2Body::SetLinearDamping(float32 linearDamping)
< {
< 	m_linearDamping = linearDamping;
< }
< 
< inline float32 b2Body::GetAngularDamping() const
< {
< 	return m_angularDamping;
< }
< 
< inline void b2Body::SetAngularDamping(float32 angularDamping)
< {
< 	m_angularDamping = angularDamping;
< }
< 
< inline float32 b2Body::GetGravityScale() const
< {
< 	return m_gravityScale;
< }
< 
< inline void b2Body::SetGravityScale(float32 scale)
---
> inline bool b2Body::IsBullet() const
613c463
< 	m_gravityScale = scale;
---
> 	return (m_flags & e_bulletFlag) == e_bulletFlag;
628c478
< inline bool b2Body::IsBullet() const
---
> inline bool b2Body::IsStatic() const
630c480
< 	return (m_flags & e_bulletFlag) == e_bulletFlag;
---
> 	return m_type == e_staticType;
633c483
< inline void b2Body::SetAwake(bool flag)
---
> inline bool b2Body::IsDynamic() const
635,651c485
< 	if (flag)
< 	{
< 		if ((m_flags & e_awakeFlag) == 0)
< 		{
< 			m_flags |= e_awakeFlag;
< 			m_sleepTime = 0.0f;
< 		}
< 	}
< 	else
< 	{
< 		m_flags &= ~e_awakeFlag;
< 		m_sleepTime = 0.0f;
< 		m_linearVelocity.SetZero();
< 		m_angularVelocity = 0.0f;
< 		m_force.SetZero();
< 		m_torque = 0.0f;
< 	}
---
> 	return m_type == e_dynamicType;
654c488
< inline bool b2Body::IsAwake() const
---
> inline bool b2Body::IsFrozen() const
656c490
< 	return (m_flags & e_awakeFlag) == e_awakeFlag;
---
> 	return (m_flags & e_frozenFlag) == e_frozenFlag;
659c493
< inline bool b2Body::IsActive() const
---
> inline bool b2Body::IsSleeping() const
661c495
< 	return (m_flags & e_activeFlag) == e_activeFlag;
---
> 	return (m_flags & e_sleepFlag) == e_sleepFlag;
664c498
< inline bool b2Body::IsFixedRotation() const
---
> inline bool b2Body::IsJNIUpdated() const
666c500
< 	return (m_flags & e_fixedRotationFlag) == e_fixedRotationFlag;
---
> 	return (m_flags & e_jniUpdatedFlag) == e_jniUpdatedFlag;
669c503
< inline void b2Body::SetSleepingAllowed(bool flag)
---
> inline void b2Body::AllowSleeping(bool flag)
673c507
< 		m_flags |= e_autoSleepFlag;
---
> 		m_flags |= e_allowSleepFlag;
677,678c511,512
< 		m_flags &= ~e_autoSleepFlag;
< 		SetAwake(true);
---
> 		m_flags &= ~e_allowSleepFlag;
> 		WakeUp();
682c516
< inline bool b2Body::IsSleepingAllowed() const
---
> inline void b2Body::SetJNIUpdated()
684c518
< 	return (m_flags & e_autoSleepFlag) == e_autoSleepFlag;
---
> 	m_flags |= e_jniUpdatedFlag;
686,687c520
< 
< inline b2Fixture* b2Body::GetFixtureList()
---
> inline void b2Body::ClearJNIUpdated()
689c522
< 	return m_fixtureList;
---
> 	m_flags &= ~e_jniUpdatedFlag;
692c525
< inline const b2Fixture* b2Body::GetFixtureList() const
---
> inline void b2Body::WakeUp()
694c527,529
< 	return m_fixtureList;
---
> 	m_flags &= ~e_sleepFlag;
> 	m_sleepTime = 0.0f;
> 	ClearJNIUpdated();
697c532
< inline b2JointEdge* b2Body::GetJointList()
---
> inline void b2Body::PutToSleep()
699c534,539
< 	return m_jointList;
---
> 	m_flags |= e_sleepFlag;
> 	m_sleepTime = 0.0f;
> 	m_linearVelocity.SetZero();
> 	m_angularVelocity = 0.0f;
> 	m_force.SetZero();
> 	m_torque = 0.0f;
702c542
< inline const b2JointEdge* b2Body::GetJointList() const
---
> inline b2Shape* b2Body::GetShapeList()
704c544
< 	return m_jointList;
---
> 	return m_shapeList;
707c547
< inline b2ContactEdge* b2Body::GetContactList()
---
> inline b2JointEdge* b2Body::GetJointList()
709c549
< 	return m_contactList;
---
> 	return m_jointList;
712c552
< inline const b2ContactEdge* b2Body::GetContactList() const
---
> inline b2ControllerEdge* b2Body::GetControllerList()
714c554
< 	return m_contactList;
---
> 	return m_controllerList;
722c562
< inline const b2Body* b2Body::GetNext() const
---
> inline void* b2Body::GetUserData()
724c564
< 	return m_next;
---
> 	return m_userData;
732c572
< inline void* b2Body::GetUserData() const
---
> inline bool b2Body::IsConnected(const b2Body* other) const
734,739c574
< 	return m_userData;
< }
< 
< inline void b2Body::ApplyForce(const b2Vec2& force, const b2Vec2& point, bool wake)
< {
< 	if (m_type != b2_dynamicBody)
---
> 	for (b2JointEdge* jn = m_jointList; jn; jn = jn->next)
741c576,577
< 		return;
---
> 		if (jn->other == other)
> 			return jn->joint->m_collideConnected == false;
744,754c580
< 	if (wake && (m_flags & e_awakeFlag) == 0)
< 	{
< 		SetAwake(true);
< 	}
< 
< 	// Don't accumulate a force if the body is sleeping.
< 	if (m_flags & e_awakeFlag)
< 	{
< 		m_force += force;
< 		m_torque += b2Cross(point - m_sweep.c, force);
< 	}
---
> 	return false;
757c583
< inline void b2Body::ApplyForceToCenter(const b2Vec2& force, bool wake)
---
> inline void b2Body::ApplyForce(const b2Vec2& force, const b2Vec2& point)
759,789c585
< 	if (m_type != b2_dynamicBody)
< 	{
< 		return;
< 	}
< 
< 	if (wake && (m_flags & e_awakeFlag) == 0)
< 	{
< 		SetAwake(true);
< 	}
< 
< 	// Don't accumulate a force if the body is sleeping
< 	if (m_flags & e_awakeFlag)
< 	{
< 		m_force += force;
< 	}
< }
< 
< inline void b2Body::ApplyTorque(float32 torque, bool wake)
< {
< 	if (m_type != b2_dynamicBody)
< 	{
< 		return;
< 	}
< 
< 	if (wake && (m_flags & e_awakeFlag) == 0)
< 	{
< 		SetAwake(true);
< 	}
< 
< 	// Don't accumulate a force if the body is sleeping
< 	if (m_flags & e_awakeFlag)
---
> 	if (IsSleeping())
791c587
< 		m_torque += torque;
---
> 		WakeUp();
792a589,590
> 	m_force += force;
> 	m_torque += b2Cross(point - m_sweep.c, force);
795c593
< inline void b2Body::ApplyLinearImpulse(const b2Vec2& impulse, const b2Vec2& point, bool wake)
---
> inline void b2Body::ApplyTorque(float32 torque)
797c595
< 	if (m_type != b2_dynamicBody)
---
> 	if (IsSleeping())
799,811c597
< 		return;
< 	}
< 
< 	if (wake && (m_flags & e_awakeFlag) == 0)
< 	{
< 		SetAwake(true);
< 	}
< 
< 	// Don't accumulate velocity if the body is sleeping
< 	if (m_flags & e_awakeFlag)
< 	{
< 		m_linearVelocity += m_invMass * impulse;
< 		m_angularVelocity += m_invI * b2Cross(point - m_sweep.c, impulse);
---
> 		WakeUp();
812a599
> 	m_torque += torque;
815c602
< inline void b2Body::ApplyAngularImpulse(float32 impulse, bool wake)
---
> inline void b2Body::ApplyImpulse(const b2Vec2& impulse, const b2Vec2& point)
817c604
< 	if (m_type != b2_dynamicBody)
---
> 	if (IsSleeping())
819,830c606
< 		return;
< 	}
< 
< 	if (wake && (m_flags & e_awakeFlag) == 0)
< 	{
< 		SetAwake(true);
< 	}
< 
< 	// Don't accumulate velocity if the body is sleeping
< 	if (m_flags & e_awakeFlag)
< 	{
< 		m_angularVelocity += m_invI * impulse;
---
> 		WakeUp();
831a608,609
> 	m_linearVelocity += m_invMass * impulse;
> 	m_angularVelocity += m_invI * b2Cross(point - m_sweep.c, impulse);
836,837c614,615
< 	m_xf.q.Set(m_sweep.a);
< 	m_xf.p = m_sweep.c - b2Mul(m_xf.q, m_sweep.localCenter);
---
> 	m_xf.R.Set(m_sweep.a);
> 	m_xf.position = m_sweep.c - b2Mul(m_xf.R, m_sweep.localCenter);
840c618
< inline void b2Body::Advance(float32 alpha)
---
> inline void b2Body::Advance(float32 t)
842,843c620,621
< 	// Advance to the new safe time. This doesn't sync the broad-phase.
< 	m_sweep.Advance(alpha);
---
> 	// Advance to the new safe time.
> 	m_sweep.Advance(t);
846,847c624
< 	m_xf.q.Set(m_sweep.a);
< 	m_xf.p = m_sweep.c - b2Mul(m_xf.q, m_sweep.localCenter);
---
> 	SynchronizeTransform();
855,859d631
< inline const b2World* b2Body::GetWorld() const
< {
< 	return m_world;
< }
< 
diff -r -x './svn/*' native/Box2D/Dynamics/.svn/text-base/b2ContactManager.cpp.svn-base ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/.svn/text-base/b2ContactManager.cpp.svn-base
2c2
< * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
19,28c19,25
< #include <Box2D/Dynamics/b2ContactManager.h>
< #include <Box2D/Dynamics/b2Body.h>
< #include <Box2D/Dynamics/b2Fixture.h>
< #include <Box2D/Dynamics/b2WorldCallbacks.h>
< #include <Box2D/Dynamics/Contacts/b2Contact.h>
< 
< b2ContactFilter b2_defaultFilter;
< b2ContactListener b2_defaultListener;
< 
< b2ContactManager::b2ContactManager()
---
> #include "b2ContactManager.h"
> #include "b2World.h"
> #include "b2Body.h"
> 
> // This is a callback from the broadphase when two AABB proxies begin
> // to overlap. We create a b2Contact to manage the narrow phase.
> void* b2ContactManager::PairAdded(void* proxyUserData1, void* proxyUserData2)
30,35c27,28
< 	m_contactList = NULL;
< 	m_contactCount = 0;
< 	m_contactFilter = &b2_defaultFilter;
< 	m_contactListener = &b2_defaultListener;
< 	m_allocator = NULL;
< }
---
> 	b2Shape* shape1 = (b2Shape*)proxyUserData1;
> 	b2Shape* shape2 = (b2Shape*)proxyUserData2;
37,42c30,31
< void b2ContactManager::Destroy(b2Contact* c)
< {
< 	b2Fixture* fixtureA = c->GetFixtureA();
< 	b2Fixture* fixtureB = c->GetFixtureB();
< 	b2Body* bodyA = fixtureA->GetBody();
< 	b2Body* bodyB = fixtureB->GetBody();
---
> 	b2Body* body1 = shape1->GetBody();
> 	b2Body* body2 = shape2->GetBody();
44c33
< 	if (m_contactListener && c->IsTouching())
---
> 	if (body1->IsStatic() && body2->IsStatic())
46c35
< 		m_contactListener->EndContact(c);
---
> 		return &m_nullContact;
49,50c38
< 	// Remove from the world.
< 	if (c->m_prev)
---
> 	if (shape1->GetBody() == shape2->GetBody())
52c40
< 		c->m_prev->m_next = c->m_next;
---
> 		return &m_nullContact;
55c43
< 	if (c->m_next)
---
> 	if (body2->IsConnected(body1))
57c45
< 		c->m_next->m_prev = c->m_prev;
---
> 		return &m_nullContact;
60c48
< 	if (c == m_contactList)
---
> 	if (m_world->m_contactFilter != NULL && m_world->m_contactFilter->ShouldCollide(shape1, shape2) == false)
62c50
< 		m_contactList = c->m_next;
---
> 		return &m_nullContact;
65,69c53,54
< 	// Remove from body 1
< 	if (c->m_nodeA.prev)
< 	{
< 		c->m_nodeA.prev->next = c->m_nodeA.next;
< 	}
---
> 	// Call the factory.
> 	b2Contact* c = b2Contact::Create(shape1, shape2, &m_world->m_blockAllocator);
71c56
< 	if (c->m_nodeA.next)
---
> 	if (c == NULL)
73c58
< 		c->m_nodeA.next->prev = c->m_nodeA.prev;
---
> 		return &m_nullContact;
76,79c61,65
< 	if (&c->m_nodeA == bodyA->m_contactList)
< 	{
< 		bodyA->m_contactList = c->m_nodeA.next;
< 	}
---
> 	// Contact creation may swap shapes.
> 	shape1 = c->GetShape1();
> 	shape2 = c->GetShape2();
> 	body1 = shape1->GetBody();
> 	body2 = shape2->GetBody();
81,82c67,70
< 	// Remove from body 2
< 	if (c->m_nodeB.prev)
---
> 	// Insert into the world.
> 	c->m_prev = NULL;
> 	c->m_next = m_world->m_contactList;
> 	if (m_world->m_contactList != NULL)
84c72
< 		c->m_nodeB.prev->next = c->m_nodeB.next;
---
> 		m_world->m_contactList->m_prev = c;
85a74
> 	m_world->m_contactList = c;
87,90c76
< 	if (c->m_nodeB.next)
< 	{
< 		c->m_nodeB.next->prev = c->m_nodeB.prev;
< 	}
---
> 	// Connect to island graph.
92c78,84
< 	if (&c->m_nodeB == bodyB->m_contactList)
---
> 	// Connect to body 1
> 	c->m_node1.contact = c;
> 	c->m_node1.other = body2;
> 
> 	c->m_node1.prev = NULL;
> 	c->m_node1.next = body1->m_contactList;
> 	if (body1->m_contactList != NULL)
94c86
< 		bodyB->m_contactList = c->m_nodeB.next;
---
> 		body1->m_contactList->prev = &c->m_node1;
95a88
> 	body1->m_contactList = &c->m_node1;
97,100c90,92
< 	// Call the factory.
< 	b2Contact::Destroy(c, m_allocator);
< 	--m_contactCount;
< }
---
> 	// Connect to body 2
> 	c->m_node2.contact = c;
> 	c->m_node2.other = body1;
102,109c94,96
< // This is the top level collision call for the time step. Here
< // all the narrow phase collision is processed for the world
< // contact list.
< void b2ContactManager::Collide()
< {
< 	// Update awake contacts.
< 	b2Contact* c = m_contactList;
< 	while (c)
---
> 	c->m_node2.prev = NULL;
> 	c->m_node2.next = body2->m_contactList;
> 	if (body2->m_contactList != NULL)
111,168c98
< 		b2Fixture* fixtureA = c->GetFixtureA();
< 		b2Fixture* fixtureB = c->GetFixtureB();
< 		int32 indexA = c->GetChildIndexA();
< 		int32 indexB = c->GetChildIndexB();
< 		b2Body* bodyA = fixtureA->GetBody();
< 		b2Body* bodyB = fixtureB->GetBody();
< 		 
< 		// Is this contact flagged for filtering?
< 		if (c->m_flags & b2Contact::e_filterFlag)
< 		{
< 			// Should these bodies collide?
< 			if (bodyB->ShouldCollide(bodyA) == false)
< 			{
< 				b2Contact* cNuke = c;
< 				c = cNuke->GetNext();
< 				Destroy(cNuke);
< 				continue;
< 			}
< 
< 			// Check user filtering.
< 			if (m_contactFilter && m_contactFilter->ShouldCollide(fixtureA, fixtureB) == false)
< 			{
< 				b2Contact* cNuke = c;
< 				c = cNuke->GetNext();
< 				Destroy(cNuke);
< 				continue;
< 			}
< 
< 			// Clear the filtering flag.
< 			c->m_flags &= ~b2Contact::e_filterFlag;
< 		}
< 
< 		bool activeA = bodyA->IsAwake() && bodyA->m_type != b2_staticBody;
< 		bool activeB = bodyB->IsAwake() && bodyB->m_type != b2_staticBody;
< 
< 		// At least one body must be awake and it must be dynamic or kinematic.
< 		if (activeA == false && activeB == false)
< 		{
< 			c = c->GetNext();
< 			continue;
< 		}
< 
< 		int32 proxyIdA = fixtureA->m_proxies[indexA].proxyId;
< 		int32 proxyIdB = fixtureB->m_proxies[indexB].proxyId;
< 		bool overlap = m_broadPhase.TestOverlap(proxyIdA, proxyIdB);
< 
< 		// Here we destroy contacts that cease to overlap in the broad-phase.
< 		if (overlap == false)
< 		{
< 			b2Contact* cNuke = c;
< 			c = cNuke->GetNext();
< 			Destroy(cNuke);
< 			continue;
< 		}
< 
< 		// The contact persists.
< 		c->Update(m_contactListener);
< 		c = c->GetNext();
---
> 		body2->m_contactList->prev = &c->m_node2;
170c100
< }
---
> 	body2->m_contactList = &c->m_node2;
172,174c102,103
< void b2ContactManager::FindNewContacts()
< {
< 	m_broadPhase.UpdatePairs(this);
---
> 	++m_world->m_contactCount;
> 	return c;
177c106,108
< void b2ContactManager::AddPair(void* proxyUserDataA, void* proxyUserDataB)
---
> // This is a callback from the broadphase when two AABB proxies cease
> // to overlap. We retire the b2Contact.
> void b2ContactManager::PairRemoved(void* proxyUserData1, void* proxyUserData2, void* pairUserData)
179,183c110,111
< 	b2FixtureProxy* proxyA = (b2FixtureProxy*)proxyUserDataA;
< 	b2FixtureProxy* proxyB = (b2FixtureProxy*)proxyUserDataB;
< 
< 	b2Fixture* fixtureA = proxyA->fixture;
< 	b2Fixture* fixtureB = proxyB->fixture;
---
> 	B2_NOT_USED(proxyUserData1);
> 	B2_NOT_USED(proxyUserData2);
185,189c113,116
< 	int32 indexA = proxyA->childIndex;
< 	int32 indexB = proxyB->childIndex;
< 
< 	b2Body* bodyA = fixtureA->GetBody();
< 	b2Body* bodyB = fixtureB->GetBody();
---
> 	if (pairUserData == NULL)
> 	{
> 		return;
> 	}
191,192c118,119
< 	// Are the fixtures on the same body?
< 	if (bodyA == bodyB)
---
> 	b2Contact* c = (b2Contact*)pairUserData;
> 	if (c == &m_nullContact)
197,201c124,144
< 	// TODO_ERIN use a hash table to remove a potential bottleneck when both
< 	// bodies have a lot of contacts.
< 	// Does a contact already exist?
< 	b2ContactEdge* edge = bodyB->GetContactList();
< 	while (edge)
---
> 	// An attached body is being destroyed, we must destroy this contact
> 	// immediately to avoid orphaned shape pointers.
> 	Destroy(c);
> }
> 
> void b2ContactManager::Destroy(b2Contact* c)
> {
> 	b2Shape* shape1 = c->GetShape1();
> 	b2Shape* shape2 = c->GetShape2();
> 	b2Body* body1 = shape1->GetBody();
> 	b2Body* body2 = shape2->GetBody();
> 
> 	b2ContactPoint cp;
> 	cp.shape1 = shape1;
> 	cp.shape2 = shape2;
> 	cp.friction = b2MixFriction(shape1->GetFriction(), shape2->GetFriction());
> 	cp.restitution = b2MixRestitution(shape1->GetRestitution(), shape2->GetRestitution());
> 
> 	// Inform the user that this contact is ending.
> 	int32 manifoldCount = c->GetManifoldCount();
> 	if (manifoldCount > 0 && m_world->m_contactListener)
203,208c146
< 		if (edge->other == bodyA)
< 		{
< 			b2Fixture* fA = edge->contact->GetFixtureA();
< 			b2Fixture* fB = edge->contact->GetFixtureB();
< 			int32 iA = edge->contact->GetChildIndexA();
< 			int32 iB = edge->contact->GetChildIndexB();
---
> 		b2Manifold* manifolds = c->GetManifolds();
210,214c148,151
< 			if (fA == fixtureA && fB == fixtureB && iA == indexA && iB == indexB)
< 			{
< 				// A contact already exists.
< 				return;
< 			}
---
> 		for (int32 i = 0; i < manifoldCount; ++i)
> 		{
> 			b2Manifold* manifold = manifolds + i;
> 			cp.normal = manifold->normal;
216c153
< 			if (fA == fixtureB && fB == fixtureA && iA == indexB && iB == indexA)
---
> 			for (int32 j = 0; j < manifold->pointCount; ++j)
218,219c155,162
< 				// A contact already exists.
< 				return;
---
> 				b2ManifoldPoint* mp = manifold->points + j;
> 				cp.position = body1->GetWorldPoint(mp->localPoint1);
> 				b2Vec2 v1 = body1->GetLinearVelocityFromLocalPoint(mp->localPoint1);
> 				b2Vec2 v2 = body2->GetLinearVelocityFromLocalPoint(mp->localPoint2);
> 				cp.velocity = v2 - v1;
> 				cp.separation = mp->separation;
> 				cp.id = mp->id;
> 				m_world->m_contactListener->Remove(&cp);
222,223d164
< 
< 		edge = edge->next;
226,227c167,168
< 	// Does a joint override collision? Is at least one body dynamic?
< 	if (bodyB->ShouldCollide(bodyA) == false)
---
> 	// Remove from the world.
> 	if (c->m_prev)
229c170
< 		return;
---
> 		c->m_prev->m_next = c->m_next;
232,233c173
< 	// Check user filtering.
< 	if (m_contactFilter && m_contactFilter->ShouldCollide(fixtureA, fixtureB) == false)
---
> 	if (c->m_next)
235c175
< 		return;
---
> 		c->m_next->m_prev = c->m_prev;
238,240c178
< 	// Call the factory.
< 	b2Contact* c = b2Contact::Create(fixtureA, indexA, fixtureB, indexB, m_allocator);
< 	if (c == NULL)
---
> 	if (c == m_world->m_contactList)
242c180
< 		return;
---
> 		m_world->m_contactList = c->m_next;
245,256c183,184
< 	// Contact creation may swap fixtures.
< 	fixtureA = c->GetFixtureA();
< 	fixtureB = c->GetFixtureB();
< 	indexA = c->GetChildIndexA();
< 	indexB = c->GetChildIndexB();
< 	bodyA = fixtureA->GetBody();
< 	bodyB = fixtureB->GetBody();
< 
< 	// Insert into the world.
< 	c->m_prev = NULL;
< 	c->m_next = m_contactList;
< 	if (m_contactList != NULL)
---
> 	// Remove from body 1
> 	if (c->m_node1.prev)
258c186
< 		m_contactList->m_prev = c;
---
> 		c->m_node1.prev->next = c->m_node1.next;
260d187
< 	m_contactList = c;
262,266c189,192
< 	// Connect to island graph.
< 
< 	// Connect to body A
< 	c->m_nodeA.contact = c;
< 	c->m_nodeA.other = bodyB;
---
> 	if (c->m_node1.next)
> 	{
> 		c->m_node1.next->prev = c->m_node1.prev;
> 	}
268,270c194
< 	c->m_nodeA.prev = NULL;
< 	c->m_nodeA.next = bodyA->m_contactList;
< 	if (bodyA->m_contactList != NULL)
---
> 	if (&c->m_node1 == body1->m_contactList)
272c196
< 		bodyA->m_contactList->prev = &c->m_nodeA;
---
> 		body1->m_contactList = c->m_node1.next;
274d197
< 	bodyA->m_contactList = &c->m_nodeA;
276,278c199,203
< 	// Connect to body B
< 	c->m_nodeB.contact = c;
< 	c->m_nodeB.other = bodyA;
---
> 	// Remove from body 2
> 	if (c->m_node2.prev)
> 	{
> 		c->m_node2.prev->next = c->m_node2.next;
> 	}
280,282c205
< 	c->m_nodeB.prev = NULL;
< 	c->m_nodeB.next = bodyB->m_contactList;
< 	if (bodyB->m_contactList != NULL)
---
> 	if (c->m_node2.next)
284c207
< 		bodyB->m_contactList->prev = &c->m_nodeB;
---
> 		c->m_node2.next->prev = c->m_node2.prev;
286d208
< 	bodyB->m_contactList = &c->m_nodeB;
288,289c210
< 	// Wake up the bodies
< 	if (fixtureA->IsSensor() == false && fixtureB->IsSensor() == false)
---
> 	if (&c->m_node2 == body2->m_contactList)
291,292c212
< 		bodyA->SetAwake(true);
< 		bodyB->SetAwake(true);
---
> 		body2->m_contactList = c->m_node2.next;
295c215,236
< 	++m_contactCount;
---
> 	// Call the factory.
> 	b2Contact::Destroy(c, &m_world->m_blockAllocator);
> 	--m_world->m_contactCount;
> }
> 
> // This is the top level collision call for the time step. Here
> // all the narrow phase collision is processed for the world
> // contact list.
> void b2ContactManager::Collide()
> {
> 	// Update awake contacts.
> 	for (b2Contact* c = m_world->m_contactList; c; c = c->GetNext())
> 	{
> 		b2Body* body1 = c->GetShape1()->GetBody();
> 		b2Body* body2 = c->GetShape2()->GetBody();
> 		if (body1->IsSleeping() && body2->IsSleeping())
> 		{
> 			continue;
> 		}
> 
> 		c->Update(m_world->m_contactListener);
> 	}
diff -r -x './svn/*' native/Box2D/Dynamics/.svn/text-base/b2ContactManager.h.svn-base ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/.svn/text-base/b2ContactManager.h.svn-base
2c2
< * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
22c22,23
< #include <Box2D/Collision/b2BroadPhase.h>
---
> #include "../Collision/b2BroadPhase.h"
> #include "../Dynamics/Contacts/b2NullContact.h"
23a25
> class b2World;
25,27c27
< class b2ContactFilter;
< class b2ContactListener;
< class b2BlockAllocator;
---
> struct b2TimeStep;
30c30
< class b2ContactManager
---
> class b2ContactManager : public b2PairCallback
33c33
< 	b2ContactManager();
---
> 	b2ContactManager() : m_world(NULL), m_destroyImmediate(false) {}
35,36c35,36
< 	// Broad-phase callback.
< 	void AddPair(void* proxyUserDataA, void* proxyUserDataB);
---
> 	// Implements PairCallback
> 	void* PairAdded(void* proxyUserData1, void* proxyUserData2);
38c38,39
< 	void FindNewContacts();
---
> 	// Implements PairCallback
> 	void PairRemoved(void* proxyUserData1, void* proxyUserData2, void* pairUserData);
43,49c44,51
<             
< 	b2BroadPhase m_broadPhase;
< 	b2Contact* m_contactList;
< 	int32 m_contactCount;
< 	b2ContactFilter* m_contactFilter;
< 	b2ContactListener* m_contactListener;
< 	b2BlockAllocator* m_allocator;
---
> 
> 	b2World* m_world;
> 
> 	// This lets us provide broadphase proxy pair user data for
> 	// contacts that shouldn't exist.
> 	b2NullContact m_nullContact;
> 
> 	bool m_destroyImmediate;
Only in native/Box2D/Dynamics/.svn/text-base: b2Fixture.cpp.svn-base
Only in native/Box2D/Dynamics/.svn/text-base: b2Fixture.h.svn-base
diff -r -x './svn/*' native/Box2D/Dynamics/.svn/text-base/b2Island.cpp.svn-base ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/.svn/text-base/b2Island.cpp.svn-base
2c2
< * Copyright (c) 2006-2011 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
19,28c19,25
< #include <Box2D/Collision/b2Distance.h>
< #include <Box2D/Dynamics/b2Island.h>
< #include <Box2D/Dynamics/b2Body.h>
< #include <Box2D/Dynamics/b2Fixture.h>
< #include <Box2D/Dynamics/b2World.h>
< #include <Box2D/Dynamics/Contacts/b2Contact.h>
< #include <Box2D/Dynamics/Contacts/b2ContactSolver.h>
< #include <Box2D/Dynamics/Joints/b2Joint.h>
< #include <Box2D/Common/b2StackAllocator.h>
< #include <Box2D/Common/b2Timer.h>
---
> #include "b2Island.h"
> #include "b2Body.h"
> #include "b2World.h"
> #include "Contacts/b2Contact.h"
> #include "Contacts/b2ContactSolver.h"
> #include "Joints/b2Joint.h"
> #include "../Common/b2StackAllocator.h"
183c180
< void b2Island::Solve(b2Profile* profile, const b2TimeStep& step, const b2Vec2& gravity, bool allowSleep)
---
> void b2Island::Solve(const b2TimeStep& step, const b2Vec2& gravity, bool allowSleep)
185,189c182
< 	b2Timer timer;
< 
< 	float32 h = step.dt;
< 
< 	// Integrate velocities and apply damping. Initialize the body state.
---
> 	// Integrate velocities and apply damping.
194,197c187,188
< 		b2Vec2 c = b->m_sweep.c;
< 		float32 a = b->m_sweep.a;
< 		b2Vec2 v = b->m_linearVelocity;
< 		float32 w = b->m_angularVelocity;
---
> 		if (b->IsStatic())
> 			continue;
199,201c190,196
< 		// Store positions for continuous collision.
< 		b->m_sweep.c0 = b->m_sweep.c;
< 		b->m_sweep.a0 = b->m_sweep.a;
---
> 		// Integrate velocities.
> 		b->m_linearVelocity += step.dt * (gravity + b->m_invMass * b->m_force);
> 		b->m_angularVelocity += step.dt * b->m_invI * b->m_torque;
> 
> 		// Reset forces.
> 		b->m_force.Set(0.0f, 0.0f);
> 		b->m_torque = 0.0f;
203c198,227
< 		if (b->m_type == b2_dynamicBody)
---
> 		// Apply damping.
> 		// ODE: dv/dt + c * v = 0
> 		// Solution: v(t) = v0 * exp(-c * t)
> 		// Time step: v(t + dt) = v0 * exp(-c * (t + dt)) = v0 * exp(-c * t) * exp(-c * dt) = v * exp(-c * dt)
> 		// v2 = exp(-c * dt) * v1
> 		// Taylor expansion:
> 		// v2 = (1.0f - c * dt) * v1
> 		b->m_linearVelocity *= b2Clamp(1.0f - step.dt * b->m_linearDamping, 0.0f, 1.0f);
> 		b->m_angularVelocity *= b2Clamp(1.0f - step.dt * b->m_angularDamping, 0.0f, 1.0f);
> 
> 		// Check for large velocities.
> #ifdef TARGET_FLOAT32_IS_FIXED
> 		// Fixed point code written this way to prevent
> 		// overflows, float code is optimized for speed
> 
> 		float32 vMagnitude = b->m_linearVelocity.Length();
> 		if(vMagnitude > b2_maxLinearVelocity) {
> 			b->m_linearVelocity *= b2_maxLinearVelocity/vMagnitude;
> 		}
> 		b->m_angularVelocity = b2Clamp(b->m_angularVelocity, 
> 			-b2_maxAngularVelocity, b2_maxAngularVelocity);
> 
> #else
> 
> 		if (b2Dot(b->m_linearVelocity, b->m_linearVelocity) > b2_maxLinearVelocitySquared)
> 		{
> 			b->m_linearVelocity.Normalize();
> 			b->m_linearVelocity *= b2_maxLinearVelocity;
> 		}
> 		if (b->m_angularVelocity * b->m_angularVelocity > b2_maxAngularVelocitySquared)
205,217c229,236
< 			// Integrate velocities.
< 			v += h * (b->m_gravityScale * gravity + b->m_invMass * b->m_force);
< 			w += h * b->m_invI * b->m_torque;
< 
< 			// Apply damping.
< 			// ODE: dv/dt + c * v = 0
< 			// Solution: v(t) = v0 * exp(-c * t)
< 			// Time step: v(t + dt) = v0 * exp(-c * (t + dt)) = v0 * exp(-c * t) * exp(-c * dt) = v * exp(-c * dt)
< 			// v2 = exp(-c * dt) * v1
< 			// Taylor expansion:
< 			// v2 = (1.0f - c * dt) * v1
< 			v *= b2Clamp(1.0f - h * b->m_linearDamping, 0.0f, 1.0f);
< 			w *= b2Clamp(1.0f - h * b->m_angularDamping, 0.0f, 1.0f);
---
> 			if (b->m_angularVelocity < 0.0f)
> 			{
> 				b->m_angularVelocity = -b2_maxAngularVelocity;
> 			}
> 			else
> 			{
> 				b->m_angularVelocity = b2_maxAngularVelocity;
> 			}
218a238
> #endif
220,223d239
< 		m_positions[i].c = c;
< 		m_positions[i].a = a;
< 		m_velocities[i].v = v;
< 		m_velocities[i].w = w;
226,232c242
< 	timer.Reset();
< 
< 	// Solver data
< 	b2SolverData solverData;
< 	solverData.step = step;
< 	solverData.positions = m_positions;
< 	solverData.velocities = m_velocities;
---
> 	b2ContactSolver contactSolver(step, m_contacts, m_contactCount, m_allocator);
235,244c245
< 	b2ContactSolverDef contactSolverDef;
< 	contactSolverDef.step = step;
< 	contactSolverDef.contacts = m_contacts;
< 	contactSolverDef.count = m_contactCount;
< 	contactSolverDef.positions = m_positions;
< 	contactSolverDef.velocities = m_velocities;
< 	contactSolverDef.allocator = m_allocator;
< 
< 	b2ContactSolver contactSolver(&contactSolverDef);
< 	contactSolver.InitializeVelocityConstraints();
---
> 	contactSolver.InitVelocityConstraints(step);
246,250d246
< 	if (step.warmStarting)
< 	{
< 		contactSolver.WarmStart();
< 	}
< 	
253c249
< 		m_joints[i]->InitVelocityConstraints(solverData);
---
> 		m_joints[i]->InitVelocityConstraints(step);
256,259c252
< 	profile->solveInit = timer.GetMilliseconds();
< 
< 	// Solve velocity constraints
< 	timer.Reset();
---
> 	// Solve velocity constraints.
264c257
< 			m_joints[j]->SolveVelocityConstraints(solverData);
---
> 			m_joints[j]->SolveVelocityConstraints(step);
270,272c263,264
< 	// Store impulses for warm starting
< 	contactSolver.StoreImpulses();
< 	profile->solveVelocity = timer.GetMilliseconds();
---
> 	// Post-solve (store impulses for warm starting).
> 	contactSolver.FinalizeVelocityConstraints();
274c266
< 	// Integrate positions
---
> 	// Integrate positions.
277,288c269
< 		b2Vec2 c = m_positions[i].c;
< 		float32 a = m_positions[i].a;
< 		b2Vec2 v = m_velocities[i].v;
< 		float32 w = m_velocities[i].w;
< 
< 		// Check for large velocities
< 		b2Vec2 translation = h * v;
< 		if (b2Dot(translation, translation) > b2_maxTranslationSquared)
< 		{
< 			float32 ratio = b2_maxTranslation / translation.Length();
< 			v *= ratio;
< 		}
---
> 		b2Body* b = m_bodies[i];
290,295c271,276
< 		float32 rotation = h * w;
< 		if (rotation * rotation > b2_maxRotationSquared)
< 		{
< 			float32 ratio = b2_maxRotation / b2Abs(rotation);
< 			w *= ratio;
< 		}
---
> 		if (b->IsStatic())
> 			continue;
> 
> 		// Store positions for continuous collision.
> 		b->m_sweep.c0 = b->m_sweep.c;
> 		b->m_sweep.a0 = b->m_sweep.a;
298,299c279,280
< 		c += h * v;
< 		a += h * w;
---
> 		b->m_sweep.c += step.dt * b->m_linearVelocity;
> 		b->m_sweep.a += step.dt * b->m_angularVelocity;
301,304c282,285
< 		m_positions[i].c = c;
< 		m_positions[i].a = a;
< 		m_velocities[i].v = v;
< 		m_velocities[i].w = w;
---
> 		// Compute new transform
> 		b->SynchronizeTransform();
> 
> 		// Note: shapes are synchronized later.
307,309c288
< 	// Solve position constraints
< 	timer.Reset();
< 	bool positionSolved = false;
---
> 	// Iterate over constraints.
312c291
< 		bool contactsOkay = contactSolver.SolvePositionConstraints();
---
> 		bool contactsOkay = contactSolver.SolvePositionConstraints(b2_contactBaumgarte);
317c296
< 			bool jointOkay = m_joints[i]->SolvePositionConstraints(solverData);
---
> 			bool jointOkay = m_joints[i]->SolvePositionConstraints(b2_contactBaumgarte);
324d302
< 			positionSolved = true;
329,342c307
< 	// Copy state buffers back to the bodies
< 	for (int32 i = 0; i < m_bodyCount; ++i)
< 	{
< 		b2Body* body = m_bodies[i];
< 		body->m_sweep.c = m_positions[i].c;
< 		body->m_sweep.a = m_positions[i].a;
< 		body->m_linearVelocity = m_velocities[i].v;
< 		body->m_angularVelocity = m_velocities[i].w;
< 		body->SynchronizeTransform();
< 	}
< 
< 	profile->solvePosition = timer.GetMilliseconds();
< 
< 	Report(contactSolver.m_velocityConstraints);
---
> 	Report(contactSolver.m_constraints);
346c311
< 		float32 minSleepTime = b2_maxFloat;
---
> 		float32 minSleepTime = B2_FLT_MAX;
347a313
> #ifndef TARGET_FLOAT32_IS_FIXED
349a316
> #endif
354c321
< 			if (b->GetType() == b2_staticBody)
---
> 			if (b->m_invMass == 0.0f)
359c326,337
< 			if ((b->m_flags & b2Body::e_autoSleepFlag) == 0 ||
---
> 			if ((b->m_flags & b2Body::e_allowSleepFlag) == 0)
> 			{
> 				b->m_sleepTime = 0.0f;
> 				minSleepTime = 0.0f;
> 			}
> 
> 			if ((b->m_flags & b2Body::e_allowSleepFlag) == 0 ||
> #ifdef TARGET_FLOAT32_IS_FIXED
> 				b2Abs(b->m_angularVelocity) > b2_angularSleepTolerance ||
> 				b2Abs(b->m_linearVelocity.x) > b2_linearSleepTolerance ||
> 				b2Abs(b->m_linearVelocity.y) > b2_linearSleepTolerance)
> #else
361a340
> #endif
368c347
< 				b->m_sleepTime += h;
---
> 				b->m_sleepTime += step.dt;
373c352
< 		if (minSleepTime >= b2_timeToSleep && positionSolved)
---
> 		if (minSleepTime >= b2_timeToSleep)
378c357,359
< 				b->SetAwake(false);
---
> 				b->m_flags |= b2Body::e_sleepFlag;
> 				b->m_linearVelocity = b2Vec2_zero;
> 				b->m_angularVelocity = 0.0f;
384c365
< void b2Island::SolveTOI(const b2TimeStep& subStep, int32 toiIndexA, int32 toiIndexB)
---
> void b2Island::SolveTOI(b2TimeStep& subStep)
386,387c367
< 	b2Assert(toiIndexA < m_bodyCount);
< 	b2Assert(toiIndexB < m_bodyCount);
---
> 	b2ContactSolver contactSolver(subStep, m_contacts, m_contactCount, m_allocator);
389,416c369
< 	// Initialize the body state.
< 	for (int32 i = 0; i < m_bodyCount; ++i)
< 	{
< 		b2Body* b = m_bodies[i];
< 		m_positions[i].c = b->m_sweep.c;
< 		m_positions[i].a = b->m_sweep.a;
< 		m_velocities[i].v = b->m_linearVelocity;
< 		m_velocities[i].w = b->m_angularVelocity;
< 	}
< 
< 	b2ContactSolverDef contactSolverDef;
< 	contactSolverDef.contacts = m_contacts;
< 	contactSolverDef.count = m_contactCount;
< 	contactSolverDef.allocator = m_allocator;
< 	contactSolverDef.step = subStep;
< 	contactSolverDef.positions = m_positions;
< 	contactSolverDef.velocities = m_velocities;
< 	b2ContactSolver contactSolver(&contactSolverDef);
< 
< 	// Solve position constraints.
< 	for (int32 i = 0; i < subStep.positionIterations; ++i)
< 	{
< 		bool contactsOkay = contactSolver.SolveTOIPositionConstraints(toiIndexA, toiIndexB);
< 		if (contactsOkay)
< 		{
< 			break;
< 		}
< 	}
---
> 	// No warm starting needed for TOI contact events.
418,420c371,373
< #if 0
< 	// Is the new position really safe?
< 	for (int32 i = 0; i < m_contactCount; ++i)
---
> 	// Warm starting for joints is off for now, but we need to
> 	// call this function to compute Jacobians.
> 	for (int32 i = 0; i < m_jointCount; ++i)
422,447c375
< 		b2Contact* c = m_contacts[i];
< 		b2Fixture* fA = c->GetFixtureA();
< 		b2Fixture* fB = c->GetFixtureB();
< 
< 		b2Body* bA = fA->GetBody();
< 		b2Body* bB = fB->GetBody();
< 
< 		int32 indexA = c->GetChildIndexA();
< 		int32 indexB = c->GetChildIndexB();
< 
< 		b2DistanceInput input;
< 		input.proxyA.Set(fA->GetShape(), indexA);
< 		input.proxyB.Set(fB->GetShape(), indexB);
< 		input.transformA = bA->GetTransform();
< 		input.transformB = bB->GetTransform();
< 		input.useRadii = false;
< 
< 		b2DistanceOutput output;
< 		b2SimplexCache cache;
< 		cache.count = 0;
< 		b2Distance(&output, &cache, &input);
< 
< 		if (output.distance == 0 || cache.count == 3)
< 		{
< 			cache.count += 0;
< 		}
---
> 		m_joints[i]->InitVelocityConstraints(subStep);
449,459d376
< #endif
< 
< 	// Leap of faith to new safe state.
< 	m_bodies[toiIndexA]->m_sweep.c0 = m_positions[toiIndexA].c;
< 	m_bodies[toiIndexA]->m_sweep.a0 = m_positions[toiIndexA].a;
< 	m_bodies[toiIndexB]->m_sweep.c0 = m_positions[toiIndexB].c;
< 	m_bodies[toiIndexB]->m_sweep.a0 = m_positions[toiIndexB].a;
< 
< 	// No warm starting is needed for TOI events because warm
< 	// starting impulses were applied in the discrete solver.
< 	contactSolver.InitializeVelocityConstraints();
464a382,385
> 		for (int32 j = 0; j < m_jointCount; ++j)
> 		{
> 			m_joints[j]->SolveVelocityConstraints(subStep);
> 		}
470,472c391
< 	float32 h = subStep.dt;
< 
< 	// Integrate positions
---
> 	// Integrate positions.
475,486c394
< 		b2Vec2 c = m_positions[i].c;
< 		float32 a = m_positions[i].a;
< 		b2Vec2 v = m_velocities[i].v;
< 		float32 w = m_velocities[i].w;
< 
< 		// Check for large velocities
< 		b2Vec2 translation = h * v;
< 		if (b2Dot(translation, translation) > b2_maxTranslationSquared)
< 		{
< 			float32 ratio = b2_maxTranslation / translation.Length();
< 			v *= ratio;
< 		}
---
> 		b2Body* b = m_bodies[i];
488,493c396,401
< 		float32 rotation = h * w;
< 		if (rotation * rotation > b2_maxRotationSquared)
< 		{
< 			float32 ratio = b2_maxRotation / b2Abs(rotation);
< 			w *= ratio;
< 		}
---
> 		if (b->IsStatic())
> 			continue;
> 
> 		// Store positions for continuous collision.
> 		b->m_sweep.c0 = b->m_sweep.c;
> 		b->m_sweep.a0 = b->m_sweep.a;
496,497c404,408
< 		c += h * v;
< 		a += h * w;
---
> 		b->m_sweep.c += subStep.dt * b->m_linearVelocity;
> 		b->m_sweep.a += subStep.dt * b->m_angularVelocity;
> 
> 		// Compute new transform
> 		b->SynchronizeTransform();
499,510c410
< 		m_positions[i].c = c;
< 		m_positions[i].a = a;
< 		m_velocities[i].v = v;
< 		m_velocities[i].w = w;
< 
< 		// Sync bodies
< 		b2Body* body = m_bodies[i];
< 		body->m_sweep.c = c;
< 		body->m_sweep.a = a;
< 		body->m_linearVelocity = v;
< 		body->m_angularVelocity = w;
< 		body->SynchronizeTransform();
---
> 		// Note: shapes are synchronized later.
513c413,431
< 	Report(contactSolver.m_velocityConstraints);
---
> 	// Solve position constraints.
> 	const float32 k_toiBaumgarte = 0.75f;
> 	for (int32 i = 0; i < subStep.positionIterations; ++i)
> 	{
> 		bool contactsOkay = contactSolver.SolvePositionConstraints(k_toiBaumgarte);
> 		bool jointsOkay = true;
> 		for (int32 j = 0; j < m_jointCount; ++j)
> 		{
> 			bool jointOkay = m_joints[j]->SolvePositionConstraints(k_toiBaumgarte);
> 			jointsOkay = jointsOkay && jointOkay;
> 		}
> 		
> 		if (contactsOkay && jointsOkay)
> 		{
> 			break;
> 		}
> 	}
> 
> 	Report(contactSolver.m_constraints);
516c434
< void b2Island::Report(const b2ContactVelocityConstraint* constraints)
---
> void b2Island::Report(b2ContactConstraint* constraints)
525a444,465
> 		b2ContactConstraint* cc = constraints + i;
> 		b2ContactResult cr;
> 		cr.shape1 = c->GetShape1();
> 		cr.shape2 = c->GetShape2();
> 		b2Body* b1 = cr.shape1->GetBody();
> 		int32 manifoldCount = c->GetManifoldCount();
> 		b2Manifold* manifolds = c->GetManifolds();
> 		for (int32 j = 0; j < manifoldCount; ++j)
> 		{
> 			b2Manifold* manifold = manifolds + j;
> 			cr.normal = manifold->normal;
> 			for (int32 k = 0; k < manifold->pointCount; ++k)
> 			{
> 				b2ManifoldPoint* point = manifold->points + k;
> 				b2ContactConstraintPoint* ccp = cc->points + k;
> 				cr.position = b1->GetWorldPoint(point->localPoint1);
> 
> 				// TOI constraint results are not stored, so get
> 				// the result from the constraint.
> 				cr.normalImpulse = ccp->normalImpulse;
> 				cr.tangentImpulse = ccp->tangentImpulse;
> 				cr.id = point->id;
527,534c467,468
< 		const b2ContactVelocityConstraint* vc = constraints + i;
< 		
< 		b2ContactImpulse impulse;
< 		impulse.count = vc->pointCount;
< 		for (int32 j = 0; j < vc->pointCount; ++j)
< 		{
< 			impulse.normalImpulses[j] = vc->points[j].normalImpulse;
< 			impulse.tangentImpulses[j] = vc->points[j].tangentImpulse;
---
> 				m_listener->Result(&cr);
> 			}
536,537d469
< 
< 		m_listener->PostSolve(c, &impulse);
diff -r -x './svn/*' native/Box2D/Dynamics/.svn/text-base/b2Island.h.svn-base ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/.svn/text-base/b2Island.h.svn-base
2c2
< * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
22,24c22,23
< #include <Box2D/Common/b2Math.h>
< #include <Box2D/Dynamics/b2Body.h>
< #include <Box2D/Dynamics/b2TimeStep.h>
---
> #include "../Common/b2Math.h"
> #include "b2Body.h"
30,31c29,42
< struct b2ContactVelocityConstraint;
< struct b2Profile;
---
> struct b2ContactConstraint;
> struct b2TimeStep;
> 
> struct b2Position
> {
> 	b2Vec2 x;
> 	float32 a;
> };
> 
> struct b2Velocity
> {
> 	b2Vec2 v;
> 	float32 w;
> };
33d43
< /// This is an internal class.
48c58
< 	void Solve(b2Profile* profile, const b2TimeStep& step, const b2Vec2& gravity, bool allowSleep);
---
> 	void Solve(const b2TimeStep& step, const b2Vec2& gravity, bool allowSleep);
50c60
< 	void SolveTOI(const b2TimeStep& subStep, int32 toiIndexA, int32 toiIndexB);
---
> 	void SolveTOI(b2TimeStep& subStep);
56,57c66
< 		m_bodies[m_bodyCount] = body;
< 		++m_bodyCount;
---
> 		m_bodies[m_bodyCount++] = body;
72c81
< 	void Report(const b2ContactVelocityConstraint* constraints);
---
> 	void Report(b2ContactConstraint* constraints);
90a100,101
> 
> 	int32 m_positionIterationCount;
Only in native/Box2D/Dynamics/.svn/text-base: b2TimeStep.h.svn-base
diff -r -x './svn/*' native/Box2D/Dynamics/.svn/text-base/b2World.cpp.svn-base ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/.svn/text-base/b2World.cpp.svn-base
2c2
< * Copyright (c) 2006-2011 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
19,34c19,29
< #include <Box2D/Dynamics/b2World.h>
< #include <Box2D/Dynamics/b2Body.h>
< #include <Box2D/Dynamics/b2Fixture.h>
< #include <Box2D/Dynamics/b2Island.h>
< #include <Box2D/Dynamics/Joints/b2PulleyJoint.h>
< #include <Box2D/Dynamics/Contacts/b2Contact.h>
< #include <Box2D/Dynamics/Contacts/b2ContactSolver.h>
< #include <Box2D/Collision/b2Collision.h>
< #include <Box2D/Collision/b2BroadPhase.h>
< #include <Box2D/Collision/Shapes/b2CircleShape.h>
< #include <Box2D/Collision/Shapes/b2EdgeShape.h>
< #include <Box2D/Collision/Shapes/b2ChainShape.h>
< #include <Box2D/Collision/Shapes/b2PolygonShape.h>
< #include <Box2D/Collision/b2TimeOfImpact.h>
< #include <Box2D/Common/b2Draw.h>
< #include <Box2D/Common/b2Timer.h>
---
> #include "b2World.h"
> #include "b2Body.h"
> #include "b2Island.h"
> #include "Joints/b2PulleyJoint.h"
> #include "Contacts/b2Contact.h"
> #include "Contacts/b2ContactSolver.h"
> #include "../Collision/b2Collision.h"
> #include "../Collision/Shapes/b2CircleShape.h"
> #include "../Collision/Shapes/b2PolygonShape.h"
> #include "../Collision/Shapes/b2EdgeShape.h"
> 
37c32
< b2World::b2World(const b2Vec2& gravity)
---
> b2World::b2World(const b2AABB& worldAABB, const b2Vec2& gravity, bool doSleep)
39a35,37
> 	m_boundaryListener = NULL;
> 	m_contactFilter = &b2_defaultFilter;
> 	m_contactListener = NULL;
42a41
> 	m_contactList = NULL;
43a43
> 	m_controllerList = NULL;
45a46
> 	m_contactCount = 0;
46a48
> 	m_controllerCount = 0;
50,52d51
< 	m_subStepping = false;
< 
< 	m_stepComplete = true;
54c53
< 	m_allowSleep = true;
---
> 	m_allowSleep = doSleep;
57c56
< 	m_flags = e_clearForces;
---
> 	m_lock = false;
61c60,62
< 	m_contactManager.m_allocator = &m_blockAllocator;
---
> 	m_contactManager.m_world = this;
> 	void* mem = b2Alloc(sizeof(b2BroadPhase));
> 	m_broadPhase = new (mem) b2BroadPhase(worldAABB, &m_contactManager);
63c64,65
< 	memset(&m_profile, 0, sizeof(b2Profile));
---
> 	b2BodyDef bd;
> 	m_groundBody = CreateBody(&bd);
68,84c70,72
< 	// Some shapes allocate using b2Alloc.
< 	b2Body* b = m_bodyList;
< 	while (b)
< 	{
< 		b2Body* bNext = b->m_next;
< 
< 		b2Fixture* f = b->m_fixtureList;
< 		while (f)
< 		{
< 			b2Fixture* fNext = f->m_next;
< 			f->m_proxyCount = 0;
< 			f->Destroy(&m_blockAllocator);
< 			f = fNext;
< 		}
< 
< 		b = bNext;
< 	}
---
> 	DestroyBody(m_groundBody);
> 	m_broadPhase->~b2BroadPhase();
> 	b2Free(m_broadPhase);
91a80,84
> void b2World::SetBoundaryListener(b2BoundaryListener* listener)
> {
> 	m_boundaryListener = listener;
> }
> 
94c87
< 	m_contactManager.m_contactFilter = filter;
---
> 	m_contactFilter = filter;
99c92
< 	m_contactManager.m_contactListener = listener;
---
> 	m_contactListener = listener;
102c95
< void b2World::SetDebugDraw(b2Draw* debugDraw)
---
> void b2World::SetDebugDraw(b2DebugDraw* debugDraw)
109,110c102,103
< 	b2Assert(IsLocked() == false);
< 	if (IsLocked())
---
> 	b2Assert(m_lock == false);
> 	if (m_lock == true)
134,135c127,128
< 	b2Assert(IsLocked() == false);
< 	if (IsLocked())
---
> 	b2Assert(m_lock == false);
> 	if (m_lock == true)
141,142c134,135
< 	b2JointEdge* je = b->m_jointList;
< 	while (je)
---
> 	b2JointEdge* jn = b->m_jointList;
> 	while (jn)
144,145c137,138
< 		b2JointEdge* je0 = je;
< 		je = je->next;
---
> 		b2JointEdge* jn0 = jn;
> 		jn = jn->next;
149c142
< 			m_destructionListener->SayGoodbye(je0->joint);
---
> 			m_destructionListener->SayGoodbye(jn0->joint);
152,154c145
< 		DestroyJoint(je0->joint);
< 
< 		b->m_jointList = je;
---
> 		DestroyJoint(jn0->joint);
156d146
< 	b->m_jointList = NULL;
158,160c148,150
< 	// Delete the attached contacts.
< 	b2ContactEdge* ce = b->m_contactList;
< 	while (ce)
---
> 	//Detach controllers attached to this body
> 	b2ControllerEdge* ce = b->m_controllerList;
> 	while(ce)
162,164c152,155
< 		b2ContactEdge* ce0 = ce;
< 		ce = ce->next;
< 		m_contactManager.Destroy(ce0->contact);
---
> 		b2ControllerEdge* ce0 = ce;
> 		ce = ce->nextController;
> 
> 		ce0->controller->RemoveBody(b);
166d156
< 	b->m_contactList = NULL;
168,170c158,161
< 	// Delete the attached fixtures. This destroys broad-phase proxies.
< 	b2Fixture* f = b->m_fixtureList;
< 	while (f)
---
> 	// Delete the attached shapes. This destroys broad-phase
> 	// proxies and pairs, leading to the destruction of contacts.
> 	b2Shape* s = b->m_shapeList;
> 	while (s)
172,173c163,164
< 		b2Fixture* f0 = f;
< 		f = f->m_next;
---
> 		b2Shape* s0 = s;
> 		s = s->m_next;
177c168
< 			m_destructionListener->SayGoodbye(f0);
---
> 			m_destructionListener->SayGoodbye(s0);
180,186c171,172
< 		f0->DestroyProxies(&m_contactManager.m_broadPhase);
< 		f0->Destroy(&m_blockAllocator);
< 		f0->~b2Fixture();
< 		m_blockAllocator.Free(f0, sizeof(b2Fixture));
< 
< 		b->m_fixtureList = f;
< 		b->m_fixtureCount -= 1;
---
> 		s0->DestroyProxy(m_broadPhase);
> 		b2Shape::Destroy(s0, &m_blockAllocator);
188,189d173
< 	b->m_fixtureList = NULL;
< 	b->m_fixtureCount = 0;
214,218c198
< 	b2Assert(IsLocked() == false);
< 	if (IsLocked())
< 	{
< 		return NULL;
< 	}
---
> 	b2Assert(m_lock == false);
233,248c213,225
< 	j->m_edgeA.joint = j;
< 	j->m_edgeA.other = j->m_bodyB;
< 	j->m_edgeA.prev = NULL;
< 	j->m_edgeA.next = j->m_bodyA->m_jointList;
< 	if (j->m_bodyA->m_jointList) j->m_bodyA->m_jointList->prev = &j->m_edgeA;
< 	j->m_bodyA->m_jointList = &j->m_edgeA;
< 
< 	j->m_edgeB.joint = j;
< 	j->m_edgeB.other = j->m_bodyA;
< 	j->m_edgeB.prev = NULL;
< 	j->m_edgeB.next = j->m_bodyB->m_jointList;
< 	if (j->m_bodyB->m_jointList) j->m_bodyB->m_jointList->prev = &j->m_edgeB;
< 	j->m_bodyB->m_jointList = &j->m_edgeB;
< 
< 	b2Body* bodyA = def->bodyA;
< 	b2Body* bodyB = def->bodyB;
---
> 	j->m_node1.joint = j;
> 	j->m_node1.other = j->m_body2;
> 	j->m_node1.prev = NULL;
> 	j->m_node1.next = j->m_body1->m_jointList;
> 	if (j->m_body1->m_jointList) j->m_body1->m_jointList->prev = &j->m_node1;
> 	j->m_body1->m_jointList = &j->m_node1;
> 
> 	j->m_node2.joint = j;
> 	j->m_node2.other = j->m_body1;
> 	j->m_node2.prev = NULL;
> 	j->m_node2.next = j->m_body2->m_jointList;
> 	if (j->m_body2->m_jointList) j->m_body2->m_jointList->prev = &j->m_node2;
> 	j->m_body2->m_jointList = &j->m_node2;
250c227
< 	// If the joint prevents collisions, then flag any contacts for filtering.
---
> 	// If the joint prevents collisions, then reset collision filtering.
253,254c230,232
< 		b2ContactEdge* edge = bodyB->GetContactList();
< 		while (edge)
---
> 		// Reset the proxies on the body with the minimum number of shapes.
> 		b2Body* b = def->body1->m_shapeCount < def->body2->m_shapeCount ? def->body1 : def->body2;
> 		for (b2Shape* s = b->m_shapeList; s; s = s->m_next)
256,263c234
< 			if (edge->other == bodyA)
< 			{
< 				// Flag the contact for filtering at the next time step (where either
< 				// body is awake).
< 				edge->contact->FlagForFiltering();
< 			}
< 
< 			edge = edge->next;
---
> 			s->RefilterProxy(m_broadPhase, b->GetXForm());
267,268d237
< 	// Note: creating a joint doesn't wake the bodies.
< 
274,278c243
< 	b2Assert(IsLocked() == false);
< 	if (IsLocked())
< 	{
< 		return;
< 	}
---
> 	b2Assert(m_lock == false);
299,300c264,265
< 	b2Body* bodyA = j->m_bodyA;
< 	b2Body* bodyB = j->m_bodyB;
---
> 	b2Body* body1 = j->m_body1;
> 	b2Body* body2 = j->m_body2;
303,304c268,269
< 	bodyA->SetAwake(true);
< 	bodyB->SetAwake(true);
---
> 	body1->WakeUp();
> 	body2->WakeUp();
307c272
< 	if (j->m_edgeA.prev)
---
> 	if (j->m_node1.prev)
309c274
< 		j->m_edgeA.prev->next = j->m_edgeA.next;
---
> 		j->m_node1.prev->next = j->m_node1.next;
312c277
< 	if (j->m_edgeA.next)
---
> 	if (j->m_node1.next)
314c279
< 		j->m_edgeA.next->prev = j->m_edgeA.prev;
---
> 		j->m_node1.next->prev = j->m_node1.prev;
317c282
< 	if (&j->m_edgeA == bodyA->m_jointList)
---
> 	if (&j->m_node1 == body1->m_jointList)
319c284
< 		bodyA->m_jointList = j->m_edgeA.next;
---
> 		body1->m_jointList = j->m_node1.next;
322,323c287,288
< 	j->m_edgeA.prev = NULL;
< 	j->m_edgeA.next = NULL;
---
> 	j->m_node1.prev = NULL;
> 	j->m_node1.next = NULL;
326c291
< 	if (j->m_edgeB.prev)
---
> 	if (j->m_node2.prev)
328c293
< 		j->m_edgeB.prev->next = j->m_edgeB.next;
---
> 		j->m_node2.prev->next = j->m_node2.next;
331c296
< 	if (j->m_edgeB.next)
---
> 	if (j->m_node2.next)
333c298
< 		j->m_edgeB.next->prev = j->m_edgeB.prev;
---
> 		j->m_node2.next->prev = j->m_node2.prev;
336c301
< 	if (&j->m_edgeB == bodyB->m_jointList)
---
> 	if (&j->m_node2 == body2->m_jointList)
338c303
< 		bodyB->m_jointList = j->m_edgeB.next;
---
> 		body2->m_jointList = j->m_node2.next;
341,342c306,307
< 	j->m_edgeB.prev = NULL;
< 	j->m_edgeB.next = NULL;
---
> 	j->m_node2.prev = NULL;
> 	j->m_node2.next = NULL;
349c314
< 	// If the joint prevents collisions, then flag any contacts for filtering.
---
> 	// If the joint prevents collisions, then reset collision filtering.
352,362c317,321
< 		b2ContactEdge* edge = bodyB->GetContactList();
< 		while (edge)
< 		{
< 			if (edge->other == bodyA)
< 			{
< 				// Flag the contact for filtering at the next time step (where either
< 				// body is awake).
< 				edge->contact->FlagForFiltering();
< 			}
< 
< 			edge = edge->next;
---
> 		// Reset the proxies on the body with the minimum number of shapes.
> 		b2Body* b = body1->m_shapeCount < body2->m_shapeCount ? body1 : body2;
> 		for (b2Shape* s = b->m_shapeList; s; s = s->m_next)
> 		{
> 			s->RefilterProxy(m_broadPhase, b->GetXForm());
365a325,351
> 
> b2Controller* b2World::CreateController(b2ControllerDef* def)
> {
> 	b2Controller* controller = def->Create(&m_blockAllocator);
> 
> 	controller->m_next = m_controllerList;
> 	controller->m_prev = NULL;
> 	if(m_controllerList)
> 		m_controllerList->m_prev = controller;
> 	m_controllerList = controller;
> 	++m_controllerCount;
> 
> 	controller->m_world = this;
> 
> 	return controller;
> }
> 
> void b2World::DestroyController(b2Controller* controller)
> {
> 	b2Assert(m_controllerCount>0);
> 	if(controller->m_next)
> 		controller->m_next->m_prev = controller->m_prev;
> 	if(controller->m_prev)
> 		controller->m_prev->m_next = controller->m_next;
> 	if(controller == m_controllerList)
> 		m_controllerList = controller->m_next;
> 	--m_controllerCount;
367,368c353,356
< //
< void b2World::SetAllowSleeping(bool flag)
---
> 	b2Controller::Destroy(controller, &m_blockAllocator);
> }
> 
> void b2World::Refilter(b2Shape* shape)
370,373c358
< 	if (flag == m_allowSleep)
< 	{
< 		return;
< 	}
---
> 	b2Assert(m_lock == false);
375,382c360
< 	m_allowSleep = flag;
< 	if (m_allowSleep == false)
< 	{
< 		for (b2Body* b = m_bodyList; b; b = b->m_next)
< 		{
< 			b->SetAwake(true);
< 		}
< 	}
---
> 	shape->RefilterProxy(m_broadPhase, shape->GetBody()->GetXForm());
388,390c366,370
< 	m_profile.solveInit = 0.0f;
< 	m_profile.solveVelocity = 0.0f;
< 	m_profile.solvePosition = 0.0f;
---
> 	// Step all controlls
> 	for(b2Controller* controller = m_controllerList;controller;controller=controller->m_next)
> 	{
> 		controller->Step(step);
> 	}
393,397c373
< 	b2Island island(m_bodyCount,
< 					m_contactManager.m_contactCount,
< 					m_jointCount,
< 					&m_stackAllocator,
< 					m_contactManager.m_contactListener);
---
> 	b2Island island(m_bodyCount, m_contactCount, m_jointCount, &m_stackAllocator, m_contactListener);
404c380
< 	for (b2Contact* c = m_contactManager.m_contactList; c; c = c->m_next)
---
> 	for (b2Contact* c = m_contactList; c; c = c->m_next)
418,423c394
< 		if (seed->m_flags & b2Body::e_islandFlag)
< 		{
< 			continue;
< 		}
< 
< 		if (seed->IsAwake() == false || seed->IsActive() == false)
---
> 		if (seed->m_flags & (b2Body::e_islandFlag | b2Body::e_sleepFlag | b2Body::e_frozenFlag))
428,429c399
< 		// The seed can be dynamic or kinematic.
< 		if (seed->GetType() == b2_staticBody)
---
> 		if (seed->IsStatic())
445d414
< 			b2Assert(b->IsActive() == true);
449c418
< 			b->SetAwake(true);
---
> 			b->m_flags &= ~b2Body::e_sleepFlag;
453c422
< 			if (b->GetType() == b2_staticBody)
---
> 			if (b->IsStatic())
459c428
< 			for (b2ContactEdge* ce = b->m_contactList; ce; ce = ce->next)
---
> 			for (b2ContactEdge* cn = b->m_contactList; cn; cn = cn->next)
461,462d429
< 				b2Contact* contact = ce->contact;
< 
464,471c431
< 				if (contact->m_flags & b2Contact::e_islandFlag)
< 				{
< 					continue;
< 				}
< 
< 				// Is this contact solid and touching?
< 				if (contact->IsEnabled() == false ||
< 					contact->IsTouching() == false)
---
> 				if (cn->contact->m_flags & (b2Contact::e_islandFlag | b2Contact::e_nonSolidFlag))
476,479c436,437
< 				// Skip sensors.
< 				bool sensorA = contact->m_fixtureA->m_isSensor;
< 				bool sensorB = contact->m_fixtureB->m_isSensor;
< 				if (sensorA || sensorB)
---
> 				// Is this contact touching?
> 				if (cn->contact->GetManifoldCount() == 0)
484,485c442,443
< 				island.Add(contact);
< 				contact->m_flags |= b2Contact::e_islandFlag;
---
> 				island.Add(cn->contact);
> 				cn->contact->m_flags |= b2Contact::e_islandFlag;
487c445
< 				b2Body* other = ce->other;
---
> 				b2Body* other = cn->other;
501c459
< 			for (b2JointEdge* je = b->m_jointList; je; je = je->next)
---
> 			for (b2JointEdge* jn = b->m_jointList; jn; jn = jn->next)
503c461
< 				if (je->joint->m_islandFlag == true)
---
> 				if (jn->joint->m_islandFlag == true)
508,517c466,467
< 				b2Body* other = je->other;
< 
< 				// Don't simulate joints connected to inactive bodies.
< 				if (other->IsActive() == false)
< 				{
< 					continue;
< 				}
< 
< 				island.Add(je->joint);
< 				je->joint->m_islandFlag = true;
---
> 				island.Add(jn->joint);
> 				jn->joint->m_islandFlag = true;
518a469
> 				b2Body* other = jn->other;
530,534c481
< 		b2Profile profile;
< 		island.Solve(&profile, step, m_gravity, m_allowSleep);
< 		m_profile.solveInit += profile.solveInit;
< 		m_profile.solveVelocity += profile.solveVelocity;
< 		m_profile.solvePosition += profile.solvePosition;
---
> 		island.Solve(step, m_gravity, m_allowSleep);
541c488
< 			if (b->GetType() == b2_staticBody)
---
> 			if (b->IsStatic())
549a497,498
> 	// Synchronize shapes, check for out of range bodies.
> 	for (b2Body* b = m_bodyList; b; b = b->GetNext())
551,553c500
< 		b2Timer timer;
< 		// Synchronize fixtures, check for out of range bodies.
< 		for (b2Body* b = m_bodyList; b; b = b->GetNext())
---
> 		if (b->m_flags & (b2Body::e_sleepFlag | b2Body::e_frozenFlag))
555,564c502,503
< 			// If a body was not in an island then it did not move.
< 			if ((b->m_flags & b2Body::e_islandFlag) == 0)
< 			{
< 				continue;
< 			}
< 
< 			if (b->GetType() == b2_staticBody)
< 			{
< 				continue;
< 			}
---
> 			continue;
> 		}
566,567c505,507
< 			// Update fixtures (for broad-phase).
< 			b->SynchronizeFixtures();
---
> 		if (b->IsStatic())
> 		{
> 			continue;
568a509,513
> 		
> 		// Update shapes (for broad-phase). If the shapes go out of
> 		// the world AABB then shapes and contacts may be destroyed,
> 		// including contacts that are
> 		bool inRange = b->SynchronizeShapes();
570,572c515,519
< 		// Look for new contacts.
< 		m_contactManager.FindNewContacts();
< 		m_profile.broadphase = timer.GetMilliseconds();
---
> 		// Did the body's shapes leave the world?
> 		if (inRange == false && m_boundaryListener != NULL)
> 		{
> 			m_boundaryListener->Violation(b);
> 		}
573a521,524
> 
> 	// Commit shape proxy movements to the broad-phase so that new contacts are created.
> 	// Also, some contacts can be destroyed.
> 	m_broadPhase->Commit();
579c530,542
< 	b2Island island(2 * b2_maxTOIContacts, b2_maxTOIContacts, 0, &m_stackAllocator, m_contactManager.m_contactListener);
---
> 	// Reserve an island and a queue for TOI island solution.
> 	b2Island island(m_bodyCount, b2_maxTOIContactsPerIsland, b2_maxTOIJointsPerIsland, &m_stackAllocator, m_contactListener);
> 	
> 	//Simple one pass queue
> 	//Relies on the fact that we're only making one pass
> 	//through and each body can only be pushed/popped once.
> 	//To push: 
> 	//  queue[queueStart+queueSize++] = newElement;
> 	//To pop: 
> 	//	poppedElement = queue[queueStart++];
> 	//  --queueSize;
> 	int32 queueCapacity = m_bodyCount;
> 	b2Body** queue = (b2Body**)m_stackAllocator.Allocate(queueCapacity* sizeof(b2Body*));
581c544
< 	if (m_stepComplete)
---
> 	for (b2Body* b = m_bodyList; b; b = b->m_next)
583,587c546,548
< 		for (b2Body* b = m_bodyList; b; b = b->m_next)
< 		{
< 			b->m_flags &= ~b2Body::e_islandFlag;
< 			b->m_sweep.alpha0 = 0.0f;
< 		}
---
> 		b->m_flags &= ~b2Body::e_islandFlag;
> 		b->m_sweep.t0 = 0.0f;
> 	}
589,595c550,558
< 		for (b2Contact* c = m_contactManager.m_contactList; c; c = c->m_next)
< 		{
< 			// Invalidate TOI
< 			c->m_flags &= ~(b2Contact::e_toiFlag | b2Contact::e_islandFlag);
< 			c->m_toiCount = 0;
< 			c->m_toi = 1.0f;
< 		}
---
> 	for (b2Contact* c = m_contactList; c; c = c->m_next)
> 	{
> 		// Invalidate TOI
> 		c->m_flags &= ~(b2Contact::e_toiFlag | b2Contact::e_islandFlag);
> 	}
> 
> 	for (b2Joint* j = m_jointList; j; j = j->m_next)
> 	{
>             j->m_islandFlag = false;
603c566
< 		float32 minAlpha = 1.0f;
---
> 		float32 minTOI = 1.0f;
605c568
< 		for (b2Contact* c = m_contactManager.m_contactList; c; c = c->m_next)
---
> 		for (b2Contact* c = m_contactList; c; c = c->m_next)
607,608c570
< 			// Is this contact disabled?
< 			if (c->IsEnabled() == false)
---
> 			if (c->m_flags & (b2Contact::e_slowFlag | b2Contact::e_nonSolidFlag))
613,617c575
< 			// Prevent excessive sub-stepping.
< 			if (c->m_toiCount > b2_maxSubSteps)
< 			{
< 				continue;
< 			}
---
> 			// TODO_ERIN keep a counter on the contact, only respond to M TOIs per contact.
619c577
< 			float32 alpha = 1.0f;
---
> 			float32 toi = 1.0f;
623c581
< 				alpha = c->m_toi;
---
> 				toi = c->m_toi;
627,653c585,589
< 				b2Fixture* fA = c->GetFixtureA();
< 				b2Fixture* fB = c->GetFixtureB();
< 
< 				// Is there a sensor?
< 				if (fA->IsSensor() || fB->IsSensor())
< 				{
< 					continue;
< 				}
< 
< 				b2Body* bA = fA->GetBody();
< 				b2Body* bB = fB->GetBody();
< 
< 				b2BodyType typeA = bA->m_type;
< 				b2BodyType typeB = bB->m_type;
< 				b2Assert(typeA == b2_dynamicBody || typeB == b2_dynamicBody);
< 
< 				bool activeA = bA->IsAwake() && typeA != b2_staticBody;
< 				bool activeB = bB->IsAwake() && typeB != b2_staticBody;
< 
< 				// Is at least one body active (awake and dynamic or kinematic)?
< 				if (activeA == false && activeB == false)
< 				{
< 					continue;
< 				}
< 
< 				bool collideA = bA->IsBullet() || typeA != b2_dynamicBody;
< 				bool collideB = bB->IsBullet() || typeB != b2_dynamicBody;
---
> 				// Compute the TOI for this contact.
> 				b2Shape* s1 = c->GetShape1();
> 				b2Shape* s2 = c->GetShape2();
> 				b2Body* b1 = s1->GetBody();
> 				b2Body* b2 = s2->GetBody();
655,656c591
< 				// Are these two non-bullet dynamic bodies?
< 				if (collideA == false && collideB == false)
---
> 				if ((b1->IsStatic() || b1->IsSleeping()) && (b2->IsStatic() || b2->IsSleeping()))
661d595
< 				// Compute the TOI for this contact.
663,665c597,599
< 				float32 alpha0 = bA->m_sweep.alpha0;
< 
< 				if (bA->m_sweep.alpha0 < bB->m_sweep.alpha0)
---
> 				float32 t0 = b1->m_sweep.t0;
> 				
> 				if (b1->m_sweep.t0 < b2->m_sweep.t0)
667,668c601,602
< 					alpha0 = bB->m_sweep.alpha0;
< 					bA->m_sweep.Advance(alpha0);
---
> 					t0 = b2->m_sweep.t0;
> 					b1->m_sweep.Advance(t0);
670c604
< 				else if (bB->m_sweep.alpha0 < bA->m_sweep.alpha0)
---
> 				else if (b2->m_sweep.t0 < b1->m_sweep.t0)
672,673c606,607
< 					alpha0 = bA->m_sweep.alpha0;
< 					bB->m_sweep.Advance(alpha0);
---
> 					t0 = b1->m_sweep.t0;
> 					b2->m_sweep.Advance(t0);
676,679c610
< 				b2Assert(alpha0 < 1.0f);
< 
< 				int32 indexA = c->GetChildIndexA();
< 				int32 indexB = c->GetChildIndexB();
---
> 				b2Assert(t0 < 1.0f);
681,687c612,613
< 				// Compute the time of impact in interval [0, minTOI]
< 				b2TOIInput input;
< 				input.proxyA.Set(fA->GetShape(), indexA);
< 				input.proxyB.Set(fB->GetShape(), indexB);
< 				input.sweepA = bA->m_sweep;
< 				input.sweepB = bB->m_sweep;
< 				input.tMax = 1.0f;
---
> 				// Compute the time of impact.
> 				toi = b2TimeOfImpact(c->m_shape1, b1->m_sweep, c->m_shape2, b2->m_sweep);
689,690c615
< 				b2TOIOutput output;
< 				b2TimeOfImpact(&output, &input);
---
> 				b2Assert(0.0f <= toi && toi <= 1.0f);
692,694c617,618
< 				// Beta is the fraction of the remaining portion of the .
< 				float32 beta = output.t;
< 				if (output.state == b2TOIOutput::e_touching)
---
> 				// If the TOI is in range ...
> 				if (0.0f < toi && toi < 1.0f)
696,700c620,621
< 					alpha = b2Min(alpha0 + (1.0f - alpha0) * beta, 1.0f);
< 				}
< 				else
< 				{
< 					alpha = 1.0f;
---
> 					// Interpolate on the actual range.
> 					toi = b2Min((1.0f - toi) * t0 + toi, 1.0f);
703c624,625
< 				c->m_toi = alpha;
---
> 
> 				c->m_toi = toi;
707c629
< 			if (alpha < minAlpha)
---
> 			if (B2_FLT_EPSILON < toi && toi < minTOI)
711c633
< 				minAlpha = alpha;
---
> 				minTOI = toi;
715c637
< 		if (minContact == NULL || 1.0f - 10.0f * b2_epsilon < minAlpha)
---
> 		if (minContact == NULL || 1.0f - 100.0f * B2_FLT_EPSILON < minTOI)
718d639
< 			m_stepComplete = true;
723,732c644,649
< 		b2Fixture* fA = minContact->GetFixtureA();
< 		b2Fixture* fB = minContact->GetFixtureB();
< 		b2Body* bA = fA->GetBody();
< 		b2Body* bB = fB->GetBody();
< 
< 		b2Sweep backup1 = bA->m_sweep;
< 		b2Sweep backup2 = bB->m_sweep;
< 
< 		bA->Advance(minAlpha);
< 		bB->Advance(minAlpha);
---
> 		b2Shape* s1 = minContact->GetShape1();
> 		b2Shape* s2 = minContact->GetShape2();
> 		b2Body* b1 = s1->GetBody();
> 		b2Body* b2 = s2->GetBody();
> 		b1->Advance(minTOI);
> 		b2->Advance(minTOI);
735c652
< 		minContact->Update(m_contactManager.m_contactListener);
---
> 		minContact->Update(m_contactListener);
737d653
< 		++minContact->m_toiCount;
739,740c655
< 		// Is the contact solid?
< 		if (minContact->IsEnabled() == false || minContact->IsTouching() == false)
---
> 		if (minContact->GetManifoldCount() == 0)
742,747c657,658
< 			// Restore the sweeps.
< 			minContact->SetEnabled(false);
< 			bA->m_sweep = backup1;
< 			bB->m_sweep = backup2;
< 			bA->SynchronizeTransform();
< 			bB->SynchronizeTransform();
---
> 			// This shouldn't happen. Numerical error?
> 			//b2Assert(false);
751,752c662,667
< 		bA->SetAwake(true);
< 		bB->SetAwake(true);
---
> 		// Build the TOI island. We need a dynamic seed.
> 		b2Body* seed = b1;
> 		if (seed->IsStatic())
> 		{
> 			seed = b2;
> 		}
754c669
< 		// Build the island
---
> 		// Reset island and queue.
756,849c671,709
< 		island.Add(bA);
< 		island.Add(bB);
< 		island.Add(minContact);
< 
< 		bA->m_flags |= b2Body::e_islandFlag;
< 		bB->m_flags |= b2Body::e_islandFlag;
< 		minContact->m_flags |= b2Contact::e_islandFlag;
< 
< 		// Get contacts on bodyA and bodyB.
< 		b2Body* bodies[2] = {bA, bB};
< 		for (int32 i = 0; i < 2; ++i)
< 		{
< 			b2Body* body = bodies[i];
< 			if (body->m_type == b2_dynamicBody)
< 			{
< 				for (b2ContactEdge* ce = body->m_contactList; ce; ce = ce->next)
< 				{
< 					if (island.m_bodyCount == island.m_bodyCapacity)
< 					{
< 						break;
< 					}
< 
< 					if (island.m_contactCount == island.m_contactCapacity)
< 					{
< 						break;
< 					}
< 
< 					b2Contact* contact = ce->contact;
< 
< 					// Has this contact already been added to the island?
< 					if (contact->m_flags & b2Contact::e_islandFlag)
< 					{
< 						continue;
< 					}
< 
< 					// Only add static, kinematic, or bullet bodies.
< 					b2Body* other = ce->other;
< 					if (other->m_type == b2_dynamicBody &&
< 						body->IsBullet() == false && other->IsBullet() == false)
< 					{
< 						continue;
< 					}
< 
< 					// Skip sensors.
< 					bool sensorA = contact->m_fixtureA->m_isSensor;
< 					bool sensorB = contact->m_fixtureB->m_isSensor;
< 					if (sensorA || sensorB)
< 					{
< 						continue;
< 					}
< 
< 					// Tentatively advance the body to the TOI.
< 					b2Sweep backup = other->m_sweep;
< 					if ((other->m_flags & b2Body::e_islandFlag) == 0)
< 					{
< 						other->Advance(minAlpha);
< 					}
< 
< 					// Update the contact points
< 					contact->Update(m_contactManager.m_contactListener);
< 
< 					// Was the contact disabled by the user?
< 					if (contact->IsEnabled() == false)
< 					{
< 						other->m_sweep = backup;
< 						other->SynchronizeTransform();
< 						continue;
< 					}
< 
< 					// Are there contact points?
< 					if (contact->IsTouching() == false)
< 					{
< 						other->m_sweep = backup;
< 						other->SynchronizeTransform();
< 						continue;
< 					}
< 
< 					// Add the contact to the island
< 					contact->m_flags |= b2Contact::e_islandFlag;
< 					island.Add(contact);
< 
< 					// Has the other body already been added to the island?
< 					if (other->m_flags & b2Body::e_islandFlag)
< 					{
< 						continue;
< 					}
< 					
< 					// Add the other body to the island.
< 					other->m_flags |= b2Body::e_islandFlag;
< 
< 					if (other->m_type != b2_staticBody)
< 					{
< 						other->SetAwake(true);
< 					}
---
> 		
> 		int32 queueStart = 0; // starting index for queue
> 		int32 queueSize = 0;  // elements in queue
> 		queue[queueStart + queueSize++] = seed;
> 		seed->m_flags |= b2Body::e_islandFlag;
> 
> 		// Perform a breadth first search (BFS) on the contact/joint graph.
> 		while (queueSize > 0)
> 		{
> 			// Grab the next body off the stack and add it to the island.
> 			b2Body* b = queue[queueStart++];
> 			--queueSize;
> 			
> 			island.Add(b);
> 
> 			// Make sure the body is awake.
> 			b->m_flags &= ~b2Body::e_sleepFlag;
> 
> 			// To keep islands as small as possible, we don't
> 			// propagate islands across static bodies.
> 			if (b->IsStatic())
> 			{
> 				continue;
> 			}
> 
> 			// Search all contacts connected to this body.
> 			for (b2ContactEdge* cEdge = b->m_contactList; cEdge; cEdge = cEdge->next)
> 			{
> 				// Does the TOI island still have space for contacts?
> 				if (island.m_contactCount == island.m_contactCapacity)
> 				{
> 					continue;
> 				}
> 
> 				// Has this contact already been added to an island? Skip slow or non-solid contacts.
> 				if (cEdge->contact->m_flags & (b2Contact::e_islandFlag | b2Contact::e_slowFlag | b2Contact::e_nonSolidFlag))
> 				{
> 					continue;
> 				}
851c711,714
< 					island.Add(other);
---
> 				// Is this contact touching? For performance we are not updating this contact.
> 				if (cEdge->contact->GetManifoldCount() == 0)
> 				{
> 					continue;
852a716,774
> 
> 				island.Add(cEdge->contact);
> 				cEdge->contact->m_flags |= b2Contact::e_islandFlag;
> 
> 				// Update other body.
> 				b2Body* other = cEdge->other;
> 
> 				// Was the other body already added to this island?
> 				if (other->m_flags & b2Body::e_islandFlag)
> 				{
> 					continue;
> 				}
> 
> 				// March forward, this can do no harm since this is the min TOI.
> 				if (other->IsStatic() == false)
> 				{
> 					other->Advance(minTOI);
> 					other->WakeUp();
> 				}
> 
> 				b2Assert(queueStart + queueSize < queueCapacity);
> 				queue[queueStart + queueSize] = other;
> 				++queueSize;
> 				other->m_flags |= b2Body::e_islandFlag;
> 			}
> 			
> 			for (b2JointEdge* jEdge = b->m_jointList; jEdge; jEdge = jEdge->next)
> 			{
> 				if (island.m_jointCount == island.m_jointCapacity)
> 				{
> 					continue;
> 				}
> 				
> 				if (jEdge->joint->m_islandFlag == true)
> 				{
> 					continue;
> 				}
> 				
> 				island.Add(jEdge->joint);
> 				
> 				jEdge->joint->m_islandFlag = true;
> 				
> 				b2Body* other = jEdge->other;
> 				
> 				if (other->m_flags & b2Body::e_islandFlag)
> 				{
> 					continue;
> 				}
> 				
> 				if (!other->IsStatic())
> 				{
> 					other->Advance(minTOI);
> 					other->WakeUp();
> 				}
> 				
> 				b2Assert(queueStart + queueSize < queueCapacity);
> 				queue[queueStart + queueSize] = other;
> 				++queueSize;
> 				other->m_flags |= b2Body::e_islandFlag;
857c779,780
< 		subStep.dt = (1.0f - minAlpha) * step.dt;
---
> 		subStep.warmStarting = false;
> 		subStep.dt = (1.0f - minTOI) * step.dt;
859,860c782
< 		subStep.dtRatio = 1.0f;
< 		subStep.positionIterations = 20;
---
> 		subStep.dtRatio = 0.0f;
862,863c784
< 		subStep.warmStarting = false;
< 		island.SolveTOI(subStep, bA->m_islandIndex, bB->m_islandIndex);
---
> 		subStep.positionIterations = step.positionIterations;
865c786,788
< 		// Reset island flags and synchronize broad-phase proxies.
---
> 		island.SolveTOI(subStep);
> 
> 		// Post solve cleanup.
868,869c791,798
< 			b2Body* body = island.m_bodies[i];
< 			body->m_flags &= ~b2Body::e_islandFlag;
---
> 			// Allow bodies to participate in future TOI islands.
> 			b2Body* b = island.m_bodies[i];
> 			b->m_flags &= ~b2Body::e_islandFlag;
> 
> 			if (b->m_flags & (b2Body::e_sleepFlag | b2Body::e_frozenFlag))
> 			{
> 				continue;
> 			}
871c800
< 			if (body->m_type != b2_dynamicBody)
---
> 			if (b->IsStatic())
876c805,808
< 			body->SynchronizeFixtures();
---
> 			// Update shapes (for broad-phase). If the shapes go out of
> 			// the world AABB then shapes and contacts may be destroyed,
> 			// including contacts that are
> 			bool inRange = b->SynchronizeShapes();
878,879c810,811
< 			// Invalidate all contact TOIs on this displaced body.
< 			for (b2ContactEdge* ce = body->m_contactList; ce; ce = ce->next)
---
> 			// Did the body's shapes leave the world?
> 			if (inRange == false && m_boundaryListener != NULL)
881c813,820
< 				ce->contact->m_flags &= ~(b2Contact::e_toiFlag | b2Contact::e_islandFlag);
---
> 				m_boundaryListener->Violation(b);
> 			}
> 
> 			// Invalidate all contact TOIs associated with this body. Some of these
> 			// may not be in the island because they were not touching.
> 			for (b2ContactEdge* cn = b->m_contactList; cn; cn = cn->next)
> 			{
> 				cn->contact->m_flags &= ~b2Contact::e_toiFlag;
885,887c824,829
< 		// Commit fixture proxy movements to the broad-phase so that new contacts are created.
< 		// Also, some contacts can be destroyed.
< 		m_contactManager.FindNewContacts();
---
> 		for (int32 i = 0; i < island.m_contactCount; ++i)
> 		{
> 			// Allow contacts to participate in future TOI islands.
> 			b2Contact* c = island.m_contacts[i];
> 			c->m_flags &= ~(b2Contact::e_toiFlag | b2Contact::e_islandFlag);
> 		}
889c831
< 		if (m_subStepping)
---
> 		for (int32 i = 0; i < island.m_jointCount; ++i)
891,892c833,835
< 			m_stepComplete = false;
< 			break;
---
> 			// Allow joints to participate in future TOI islands.
> 			b2Joint* j = island.m_joints[i];
> 			j->m_islandFlag = false;
893a837,840
> 		
> 		// Commit shape proxy movements to the broad-phase so that new contacts are created.
> 		// Also, some contacts can be destroyed.
> 		m_broadPhase->Commit();
894a842,843
> 
> 	m_stackAllocator.Free(queue);
899,908c848
< 	b2Timer stepTimer;
< 
< 	// If new fixtures were added, we need to find the new contacts.
< 	if (m_flags & e_newFixture)
< 	{
< 		m_contactManager.FindNewContacts();
< 		m_flags &= ~e_newFixture;
< 	}
< 
< 	m_flags |= e_locked;
---
> 	m_lock = true;
927,932c867,868
< 	// Update contacts. This is where some contacts are destroyed.
< 	{
< 		b2Timer timer;
< 		m_contactManager.Collide();
< 		m_profile.collide = timer.GetMilliseconds();
< 	}
---
> 	// Update contacts.
> 	m_contactManager.Collide();
935c871
< 	if (m_stepComplete && step.dt > 0.0f)
---
> 	if (step.dt > 0.0f)
937d872
< 		b2Timer timer;
939d873
< 		m_profile.solve = timer.GetMilliseconds();
945d878
< 		b2Timer timer;
947,952d879
< 		m_profile.solveTOI = timer.GetMilliseconds();
< 	}
< 
< 	if (step.dt > 0.0f)
< 	{
< 		m_inv_dt0 = step.inv_dt;
955,960c882,883
< 	if (m_flags & e_clearForces)
< 	{
< 		ClearForces();
< 	}
< 
< 	m_flags &= ~e_locked;
---
> 	// Draw debug information.
> 	DrawDebugData();
962c885,886
< 	m_profile.step = stepTimer.GetMilliseconds();
---
> 	m_inv_dt0 = step.inv_dt;
> 	m_lock = false;
965c889
< void b2World::ClearForces()
---
> int32 b2World::Query(const b2AABB& aabb, b2Shape** shapes, int32 maxCount)
967c891,895
< 	for (b2Body* body = m_bodyList; body; body = body->GetNext())
---
> 	void** results = (void**)m_stackAllocator.Allocate(maxCount * sizeof(void*));
> 
> 	int32 count = m_broadPhase->Query(aabb, results, maxCount);
> 
> 	for (int32 i = 0; i < count; ++i)
969,970c897
< 		body->m_force.SetZero();
< 		body->m_torque = 0.0f;
---
> 		shapes[i] = (b2Shape*)results[i];
971a899,901
> 
> 	m_stackAllocator.Free(results);
> 	return count;
974c904
< struct b2WorldQueryWrapper
---
> int32 b2World::Raycast(const b2Segment& segment, b2Shape** shapes, int32 maxCount, bool solidShapes, void* userData)
976c906,914
< 	bool QueryCallback(int32 proxyId)
---
> 	m_raycastSegment = &segment;
> 	m_raycastUserData = userData;
> 	m_raycastSolidShape = solidShapes;
> 
> 	void** results = (void**)m_stackAllocator.Allocate(maxCount * sizeof(void*));
> 
> 	int32 count = m_broadPhase->QuerySegment(segment,results,maxCount, &RaycastSortKey);
> 
> 	for (int32 i = 0; i < count; ++i)
978,979c916
< 		b2FixtureProxy* proxy = (b2FixtureProxy*)broadPhase->GetUserData(proxyId);
< 		return callback->ReportFixture(proxy->fixture);
---
> 		shapes[i] = (b2Shape*)results[i];
982,991c919,920
< 	const b2BroadPhase* broadPhase;
< 	b2QueryCallback* callback;
< };
< 
< void b2World::QueryAABB(b2QueryCallback* callback, const b2AABB& aabb) const
< {
< 	b2WorldQueryWrapper wrapper;
< 	wrapper.broadPhase = &m_contactManager.m_broadPhase;
< 	wrapper.callback = callback;
< 	m_contactManager.m_broadPhase.Query(&wrapper, aabb);
---
> 	m_stackAllocator.Free(results);
> 	return count;
994c923
< struct b2WorldRayCastWrapper
---
> b2Shape* b2World::RaycastOne(const b2Segment& segment, float32* lambda, b2Vec2* normal, bool solidShapes, void* userData)
996,1003c925,926
< 	float32 RayCastCallback(const b2RayCastInput& input, int32 proxyId)
< 	{
< 		void* userData = broadPhase->GetUserData(proxyId);
< 		b2FixtureProxy* proxy = (b2FixtureProxy*)userData;
< 		b2Fixture* fixture = proxy->fixture;
< 		int32 index = proxy->childIndex;
< 		b2RayCastOutput output;
< 		bool hit = fixture->RayCast(&output, input, index);
---
> 	int32 maxCount = 1;
> 	b2Shape* shape;
1005,1010c928
< 		if (hit)
< 		{
< 			float32 fraction = output.fraction;
< 			b2Vec2 point = (1.0f - fraction) * input.p1 + fraction * input.p2;
< 			return callback->ReportFixture(fixture, point, output.normal, fraction);
< 		}
---
> 	int32 count = Raycast(segment, &shape, maxCount, solidShapes, userData);
1012,1013c930,931
< 		return input.maxFraction;
< 	}
---
> 	if(count==0)
> 		return NULL;
1015,1017c933
< 	const b2BroadPhase* broadPhase;
< 	b2RayCastCallback* callback;
< };
---
> 	b2Assert(count==1);
1019,1028c935,940
< void b2World::RayCast(b2RayCastCallback* callback, const b2Vec2& point1, const b2Vec2& point2) const
< {
< 	b2WorldRayCastWrapper wrapper;
< 	wrapper.broadPhase = &m_contactManager.m_broadPhase;
< 	wrapper.callback = callback;
< 	b2RayCastInput input;
< 	input.maxFraction = 1.0f;
< 	input.p1 = point1;
< 	input.p2 = point2;
< 	m_contactManager.m_broadPhase.RayCast(&wrapper, input);
---
> 	//Redundantly do TestSegment a second time, as the previous one's results are inaccessible
> 
> 	const b2XForm xf = shape->GetBody()->GetXForm();
> 	shape->TestSegment(xf, lambda, normal,segment,1);
> 	//We already know it returns true
> 	return shape;
1031c943
< void b2World::DrawShape(b2Fixture* fixture, const b2Transform& xf, const b2Color& color)
---
> void b2World::DrawShape(b2Shape* shape, const b2XForm& xf, const b2Color& color, bool core)
1033c945,947
< 	switch (fixture->GetType())
---
> 	b2Color coreColor(0.9f, 0.6f, 0.6f);
> 
> 	switch (shape->GetType())
1035c949
< 	case b2Shape::e_circle:
---
> 	case e_circleShape:
1037c951
< 			b2CircleShape* circle = (b2CircleShape*)fixture->GetShape();
---
> 			b2CircleShape* circle = (b2CircleShape*)shape;
1039,1041c953,955
< 			b2Vec2 center = b2Mul(xf, circle->m_p);
< 			float32 radius = circle->m_radius;
< 			b2Vec2 axis = b2Mul(xf.q, b2Vec2(1.0f, 0.0f));
---
> 			b2Vec2 center = b2Mul(xf, circle->GetLocalPosition());
> 			float32 radius = circle->GetRadius();
> 			b2Vec2 axis = xf.R.col1;
1044,1054d957
< 		}
< 		break;
< 
< 	case b2Shape::e_edge:
< 		{
< 			b2EdgeShape* edge = (b2EdgeShape*)fixture->GetShape();
< 			b2Vec2 v1 = b2Mul(xf, edge->m_vertex1);
< 			b2Vec2 v2 = b2Mul(xf, edge->m_vertex2);
< 			m_debugDraw->DrawSegment(v1, v2, color);
< 		}
< 		break;
1056,1068c959,961
< 	case b2Shape::e_chain:
< 		{
< 			b2ChainShape* chain = (b2ChainShape*)fixture->GetShape();
< 			int32 count = chain->m_count;
< 			const b2Vec2* vertices = chain->m_vertices;
< 
< 			b2Vec2 v1 = b2Mul(xf, vertices[0]);
< 			for (int32 i = 1; i < count; ++i)
< 			{
< 				b2Vec2 v2 = b2Mul(xf, vertices[i]);
< 				m_debugDraw->DrawSegment(v1, v2, color);
< 				m_debugDraw->DrawCircle(v1, 0.05f, color);
< 				v1 = v2;
---
> 			if (core)
> 			{
> 				m_debugDraw->DrawCircle(center, radius - b2_toiSlop, coreColor);
1073c966
< 	case b2Shape::e_polygon:
---
> 	case e_polygonShape:
1075,1076c968,971
< 			b2PolygonShape* poly = (b2PolygonShape*)fixture->GetShape();
< 			int32 vertexCount = poly->m_count;
---
> 			b2PolygonShape* poly = (b2PolygonShape*)shape;
> 			int32 vertexCount = poly->GetVertexCount();
> 			const b2Vec2* localVertices = poly->GetVertices();
> 
1082c977
< 				vertices[i] = b2Mul(xf, poly->m_vertices[i]);
---
> 				vertices[i] = b2Mul(xf, localVertices[i]);
1085a981,1003
> 
> 			if (core)
> 			{
> 				const b2Vec2* localCoreVertices = poly->GetCoreVertices();
> 				for (int32 i = 0; i < vertexCount; ++i)
> 				{
> 					vertices[i] = b2Mul(xf, localCoreVertices[i]);
> 				}
> 				m_debugDraw->DrawPolygon(vertices, vertexCount, coreColor);
> 			}
> 		}
> 		break;
> 		
> 	case e_edgeShape:
> 		{
> 			b2EdgeShape* edge = (b2EdgeShape*)shape;
> 			
> 			m_debugDraw->DrawSegment(b2Mul(xf, edge->GetVertex1()), b2Mul(xf, edge->GetVertex2()), color);
> 			
> 			if (core)
> 			{
> 				m_debugDraw->DrawSegment(b2Mul(xf, edge->GetCoreVertex1()), b2Mul(xf, edge->GetCoreVertex2()), coreColor);
> 			}
1088,1090d1005
<             
<     default:
<         break;
1096,1103c1011,1018
< 	b2Body* bodyA = joint->GetBodyA();
< 	b2Body* bodyB = joint->GetBodyB();
< 	const b2Transform& xf1 = bodyA->GetTransform();
< 	const b2Transform& xf2 = bodyB->GetTransform();
< 	b2Vec2 x1 = xf1.p;
< 	b2Vec2 x2 = xf2.p;
< 	b2Vec2 p1 = joint->GetAnchorA();
< 	b2Vec2 p2 = joint->GetAnchorB();
---
> 	b2Body* b1 = joint->GetBody1();
> 	b2Body* b2 = joint->GetBody2();
> 	const b2XForm& xf1 = b1->GetXForm();
> 	const b2XForm& xf2 = b2->GetXForm();
> 	b2Vec2 x1 = xf1.position;
> 	b2Vec2 x2 = xf2.position;
> 	b2Vec2 p1 = joint->GetAnchor1();
> 	b2Vec2 p2 = joint->GetAnchor2();
1116,1117c1031,1032
< 			b2Vec2 s1 = pulley->GetGroundAnchorA();
< 			b2Vec2 s2 = pulley->GetGroundAnchorB();
---
> 			b2Vec2 s1 = pulley->GetGroundAnchor1();
> 			b2Vec2 s2 = pulley->GetGroundAnchor2();
1144c1059
< 	if (flags & b2Draw::e_shapeBit)
---
> 	if (flags & b2DebugDraw::e_shapeBit)
1145a1061,1062
> 		bool core = (flags & b2DebugDraw::e_coreShapeBit) == b2DebugDraw::e_coreShapeBit;
> 
1148,1149c1065,1066
< 			const b2Transform& xf = b->GetTransform();
< 			for (b2Fixture* f = b->GetFixtureList(); f; f = f->GetNext())
---
> 			const b2XForm& xf = b->GetXForm();
> 			for (b2Shape* s = b->GetShapeList(); s; s = s->GetNext())
1151c1068
< 				if (b->IsActive() == false)
---
> 				if (b->IsStatic())
1153c1070
< 					DrawShape(f, xf, b2Color(0.5f, 0.5f, 0.3f));
---
> 					DrawShape(s, xf, b2Color(0.5f, 0.9f, 0.5f), core);
1155c1072
< 				else if (b->GetType() == b2_staticBody)
---
> 				else if (b->IsSleeping())
1157,1165c1074
< 					DrawShape(f, xf, b2Color(0.5f, 0.9f, 0.5f));
< 				}
< 				else if (b->GetType() == b2_kinematicBody)
< 				{
< 					DrawShape(f, xf, b2Color(0.5f, 0.5f, 0.9f));
< 				}
< 				else if (b->IsAwake() == false)
< 				{
< 					DrawShape(f, xf, b2Color(0.6f, 0.6f, 0.6f));
---
> 					DrawShape(s, xf, b2Color(0.5f, 0.5f, 0.9f), core);
1169c1078
< 					DrawShape(f, xf, b2Color(0.9f, 0.7f, 0.7f));
---
> 					DrawShape(s, xf, b2Color(0.9f, 0.9f, 0.9f), core);
1175c1084
< 	if (flags & b2Draw::e_jointBit)
---
> 	if (flags & b2DebugDraw::e_jointBit)
1179c1088,1099
< 			DrawJoint(j);
---
> 			if (j->GetType() != e_mouseJoint)
> 			{
> 				DrawJoint(j);
> 			}
> 		}
> 	}
> 
> 	if (flags & b2DebugDraw::e_controllerBit)
> 	{
> 		for (b2Controller* c = m_controllerList; c; c= c->GetNext())
> 		{
> 			c->Draw(m_debugDraw);
1183c1103
< 	if (flags & b2Draw::e_pairBit)
---
> 	if (flags & b2DebugDraw::e_pairBit)
1185,1186c1105,1110
< 		b2Color color(0.3f, 0.9f, 0.9f);
< 		for (b2Contact* c = m_contactManager.m_contactList; c; c = c->GetNext())
---
> 		b2BroadPhase* bp = m_broadPhase;
> 		b2Vec2 invQ;
> 		invQ.Set(1.0f / bp->m_quantizationFactor.x, 1.0f / bp->m_quantizationFactor.y);
> 		b2Color color(0.9f, 0.9f, 0.3f);
> 
> 		for (int32 i = 0; i < b2_tableCapacity; ++i)
1188,1189c1112,1130
< 			//b2Fixture* fixtureA = c->GetFixtureA();
< 			//b2Fixture* fixtureB = c->GetFixtureB();
---
> 			uint16 index = bp->m_pairManager.m_hashTable[i];
> 			while (index != b2_nullPair)
> 			{
> 				b2Pair* pair = bp->m_pairManager.m_pairs + index;
> 				b2Proxy* p1 = bp->m_proxyPool + pair->proxyId1;
> 				b2Proxy* p2 = bp->m_proxyPool + pair->proxyId2;
> 
> 				b2AABB b1, b2;
> 				b1.lowerBound.x = bp->m_worldAABB.lowerBound.x + invQ.x * bp->m_bounds[0][p1->lowerBounds[0]].value;
> 				b1.lowerBound.y = bp->m_worldAABB.lowerBound.y + invQ.y * bp->m_bounds[1][p1->lowerBounds[1]].value;
> 				b1.upperBound.x = bp->m_worldAABB.lowerBound.x + invQ.x * bp->m_bounds[0][p1->upperBounds[0]].value;
> 				b1.upperBound.y = bp->m_worldAABB.lowerBound.y + invQ.y * bp->m_bounds[1][p1->upperBounds[1]].value;
> 				b2.lowerBound.x = bp->m_worldAABB.lowerBound.x + invQ.x * bp->m_bounds[0][p2->lowerBounds[0]].value;
> 				b2.lowerBound.y = bp->m_worldAABB.lowerBound.y + invQ.y * bp->m_bounds[1][p2->lowerBounds[1]].value;
> 				b2.upperBound.x = bp->m_worldAABB.lowerBound.x + invQ.x * bp->m_bounds[0][p2->upperBounds[0]].value;
> 				b2.upperBound.y = bp->m_worldAABB.lowerBound.y + invQ.y * bp->m_bounds[1][p2->upperBounds[1]].value;
> 
> 				b2Vec2 x1 = 0.5f * (b1.lowerBound + b1.upperBound);
> 				b2Vec2 x2 = 0.5f * (b2.lowerBound + b2.upperBound);
1191,1192c1132
< 			//b2Vec2 cA = fixtureA->GetAABB().GetCenter();
< 			//b2Vec2 cB = fixtureB->GetAABB().GetCenter();
---
> 				m_debugDraw->DrawSegment(x1, x2, color);
1194c1134,1135
< 			//m_debugDraw->DrawSegment(cA, cB, color);
---
> 				index = pair->next;
> 			}
1198c1139
< 	if (flags & b2Draw::e_aabbBit)
---
> 	if (flags & b2DebugDraw::e_aabbBit)
1200,1201c1141,1143
< 		b2Color color(0.9f, 0.3f, 0.9f);
< 		b2BroadPhase* bp = &m_contactManager.m_broadPhase;
---
> 		b2BroadPhase* bp = m_broadPhase;
> 		b2Vec2 worldLower = bp->m_worldAABB.lowerBound;
> 		b2Vec2 worldUpper = bp->m_worldAABB.upperBound;
1203c1145,1148
< 		for (b2Body* b = m_bodyList; b; b = b->GetNext())
---
> 		b2Vec2 invQ;
> 		invQ.Set(1.0f / bp->m_quantizationFactor.x, 1.0f / bp->m_quantizationFactor.y);
> 		b2Color color(0.9f, 0.3f, 0.9f);
> 		for (int32 i = 0; i < b2_maxProxies; ++i)
1205c1150,1151
< 			if (b->IsActive() == false)
---
> 			b2Proxy* p = bp->m_proxyPool + i;
> 			if (p->IsValid() == false)
1210c1156,1186
< 			for (b2Fixture* f = b->GetFixtureList(); f; f = f->GetNext())
---
> 			b2AABB b;
> 			b.lowerBound.x = worldLower.x + invQ.x * bp->m_bounds[0][p->lowerBounds[0]].value;
> 			b.lowerBound.y = worldLower.y + invQ.y * bp->m_bounds[1][p->lowerBounds[1]].value;
> 			b.upperBound.x = worldLower.x + invQ.x * bp->m_bounds[0][p->upperBounds[0]].value;
> 			b.upperBound.y = worldLower.y + invQ.y * bp->m_bounds[1][p->upperBounds[1]].value;
> 
> 			b2Vec2 vs[4];
> 			vs[0].Set(b.lowerBound.x, b.lowerBound.y);
> 			vs[1].Set(b.upperBound.x, b.lowerBound.y);
> 			vs[2].Set(b.upperBound.x, b.upperBound.y);
> 			vs[3].Set(b.lowerBound.x, b.upperBound.y);
> 
> 			m_debugDraw->DrawPolygon(vs, 4, color);
> 		}
> 
> 		b2Vec2 vs[4];
> 		vs[0].Set(worldLower.x, worldLower.y);
> 		vs[1].Set(worldUpper.x, worldLower.y);
> 		vs[2].Set(worldUpper.x, worldUpper.y);
> 		vs[3].Set(worldLower.x, worldUpper.y);
> 		m_debugDraw->DrawPolygon(vs, 4, b2Color(0.3f, 0.9f, 0.9f));
> 	}
> 
> 	if (flags & b2DebugDraw::e_obbBit)
> 	{
> 		b2Color color(0.5f, 0.3f, 0.5f);
> 
> 		for (b2Body* b = m_bodyList; b; b = b->GetNext())
> 		{
> 			const b2XForm& xf = b->GetXForm();
> 			for (b2Shape* s = b->GetShapeList(); s; s = s->GetNext())
1212c1188
< 				for (int32 i = 0; i < f->m_proxyCount; ++i)
---
> 				if (s->GetType() != e_polygonShape)
1214,1220c1190,1200
< 					b2FixtureProxy* proxy = f->m_proxies + i;
< 					b2AABB aabb = bp->GetFatAABB(proxy->proxyId);
< 					b2Vec2 vs[4];
< 					vs[0].Set(aabb.lowerBound.x, aabb.lowerBound.y);
< 					vs[1].Set(aabb.upperBound.x, aabb.lowerBound.y);
< 					vs[2].Set(aabb.upperBound.x, aabb.upperBound.y);
< 					vs[3].Set(aabb.lowerBound.x, aabb.upperBound.y);
---
> 					continue;
> 				}
> 
> 				b2PolygonShape* poly = (b2PolygonShape*)s;
> 				const b2OBB& obb = poly->GetOBB();
> 				b2Vec2 h = obb.extents;
> 				b2Vec2 vs[4];
> 				vs[0].Set(-h.x, -h.y);
> 				vs[1].Set( h.x, -h.y);
> 				vs[2].Set( h.x,  h.y);
> 				vs[3].Set(-h.x,  h.y);
1222c1202,1205
< 					m_debugDraw->DrawPolygon(vs, 4, color);
---
> 				for (int32 i = 0; i < 4; ++i)
> 				{
> 					vs[i] = obb.center + b2Mul(obb.R, vs[i]);
> 					vs[i] = b2Mul(xf, vs[i]);
1223a1207,1208
> 
> 				m_debugDraw->DrawPolygon(vs, 4, color);
1228c1213
< 	if (flags & b2Draw::e_centerOfMassBit)
---
> 	if (flags & b2DebugDraw::e_centerOfMassBit)
1232,1234c1217,1219
< 			b2Transform xf = b->GetTransform();
< 			xf.p = b->GetWorldCenter();
< 			m_debugDraw->DrawTransform(xf);
---
> 			b2XForm xf = b->GetXForm();
> 			xf.position = b->GetWorldCenter();
> 			m_debugDraw->DrawXForm(xf);
1239c1224
< int32 b2World::GetProxyCount() const
---
> void b2World::Validate()
1241c1226
< 	return m_contactManager.m_broadPhase.GetProxyCount();
---
> 	m_broadPhase->Validate();
1244c1229
< int32 b2World::GetTreeHeight() const
---
> int32 b2World::GetProxyCount() const
1246c1231
< 	return m_contactManager.m_broadPhase.GetTreeHeight();
---
> 	return m_broadPhase->m_proxyCount;
1249c1234
< int32 b2World::GetTreeBalance() const
---
> int32 b2World::GetPairCount() const
1251c1236
< 	return m_contactManager.m_broadPhase.GetTreeBalance();
---
> 	return m_broadPhase->m_pairManager.m_pairCount;
1254c1239
< float32 b2World::GetTreeQuality() const
---
> bool b2World::InRange(const b2AABB& aabb) const
1256c1241
< 	return m_contactManager.m_broadPhase.GetTreeQuality();
---
> 	return m_broadPhase->InRange(aabb);
1259c1244
< void b2World::ShiftOrigin(const b2Vec2& newOrigin)
---
> float32 b2World::RaycastSortKey(void* data)
1261,1265c1246,1249
< 	b2Assert((m_flags & e_locked) == 0);
< 	if ((m_flags & e_locked) == e_locked)
< 	{
< 		return;
< 	}
---
> 	b2Shape* shape = (b2Shape*)data;
> 	b2Body* body = shape->GetBody();
> 	b2World* world = body->GetWorld();
> 	const b2XForm xf = body->GetXForm();
1267,1300c1251,1252
< 	for (b2Body* b = m_bodyList; b; b = b->m_next)
< 	{
< 		b->m_xf.p -= newOrigin;
< 		b->m_sweep.c0 -= newOrigin;
< 		b->m_sweep.c -= newOrigin;
< 	}
< 
< 	for (b2Joint* j = m_jointList; j; j = j->m_next)
< 	{
< 		j->ShiftOrigin(newOrigin);
< 	}
< 
< 	m_contactManager.m_broadPhase.ShiftOrigin(newOrigin);
< }
< 
< void b2World::Dump()
< {
< 	if ((m_flags & e_locked) == e_locked)
< 	{
< 		return;
< 	}
< 
< 	b2Log("b2Vec2 g(%.15lef, %.15lef);\n", m_gravity.x, m_gravity.y);
< 	b2Log("m_world->SetGravity(g);\n");
< 
< 	b2Log("b2Body** bodies = (b2Body**)b2Alloc(%d * sizeof(b2Body*));\n", m_bodyCount);
< 	b2Log("b2Joint** joints = (b2Joint**)b2Alloc(%d * sizeof(b2Joint*));\n", m_jointCount);
< 	int32 i = 0;
< 	for (b2Body* b = m_bodyList; b; b = b->m_next)
< 	{
< 		b->m_islandIndex = i;
< 		b->Dump();
< 		++i;
< 	}
---
> 	if(world->m_contactFilter && !world->m_contactFilter->RayCollide(world->m_raycastUserData,shape))
> 		return -1;
1302,1315c1254,1255
< 	i = 0;
< 	for (b2Joint* j = m_jointList; j; j = j->m_next)
< 	{
< 		j->m_index = i;
< 		++i;
< 	}
< 
< 	// First pass on joints, skip gear joints.
< 	for (b2Joint* j = m_jointList; j; j = j->m_next)
< 	{
< 		if (j->m_type == e_gearJoint)
< 		{
< 			continue;
< 		}
---
> 	float32 lambda;
> 	b2SegmentCollide collide = shape->TestSegment(xf, &lambda, &world->m_raycastNormal, *world->m_raycastSegment,1);
1317,1320c1257,1260
< 		b2Log("{\n");
< 		j->Dump();
< 		b2Log("}\n");
< 	}
---
> 	if(world->m_raycastSolidShape && collide==e_missCollide)
> 		return -1;
> 	if(!world->m_raycastSolidShape && collide!=e_hitCollide)
> 		return -1;
1322,1338c1262
< 	// Second pass on joints, only gear joints.
< 	for (b2Joint* j = m_jointList; j; j = j->m_next)
< 	{
< 		if (j->m_type != e_gearJoint)
< 		{
< 			continue;
< 		}
< 
< 		b2Log("{\n");
< 		j->Dump();
< 		b2Log("}\n");
< 	}
< 
< 	b2Log("b2Free(joints);\n");
< 	b2Log("b2Free(bodies);\n");
< 	b2Log("joints = NULL;\n");
< 	b2Log("bodies = NULL;\n");
---
> 	return lambda;
1339a1264
> 
diff -r -x './svn/*' native/Box2D/Dynamics/.svn/text-base/b2World.h.svn-base ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/.svn/text-base/b2World.h.svn-base
2c2
< * Copyright (c) 2006-2011 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
22,27c22,26
< #include <Box2D/Common/b2Math.h>
< #include <Box2D/Common/b2BlockAllocator.h>
< #include <Box2D/Common/b2StackAllocator.h>
< #include <Box2D/Dynamics/b2ContactManager.h>
< #include <Box2D/Dynamics/b2WorldCallbacks.h>
< #include <Box2D/Dynamics/b2TimeStep.h>
---
> #include "../Common/b2Math.h"
> #include "../Common/b2BlockAllocator.h"
> #include "../Common/b2StackAllocator.h"
> #include "b2ContactManager.h"
> #include "b2WorldCallbacks.h"
29a29
> struct b2ShapeDef;
31d30
< struct b2Color;
34,35d32
< class b2Draw;
< class b2Fixture;
36a34,48
> class b2Shape;
> class b2Contact;
> class b2BroadPhase;
> class b2Controller;
> class b2ControllerDef;
> 
> struct b2TimeStep
> {
> 	float32 dt;			// time step
> 	float32 inv_dt;		// inverse time step (0 if dt == 0).
> 	float32 dtRatio;	// dt * inv_dt0
> 	int32 velocityIterations;
> 	int32 positionIterations;
> 	bool warmStarting;
> };
44a57
> 	/// @param worldAABB a bounding box that completely encompasses all your shapes.
46c59,60
< 	b2World(const b2Vec2& gravity);
---
> 	/// @param doSleep improve performance by not simulating inactive bodies.
> 	b2World(const b2AABB& worldAABB, const b2Vec2& gravity, bool doSleep);
51,52c65
< 	/// Register a destruction listener. The listener is owned by you and must
< 	/// remain in scope.
---
> 	/// Register a destruction listener.
54a68,70
> 	/// Register a broad-phase boundary listener.
> 	void SetBoundaryListener(b2BoundaryListener* listener);
> 
56,57c72
< 	/// Otherwise the default filter is used (b2_defaultFilter). The listener is
< 	/// owned by you and must remain in scope. 
---
> 	/// Otherwise the default filter is used (b2_defaultFilter).
60,61c75
< 	/// Register a contact event listener. The listener is owned by you and must
< 	/// remain in scope.
---
> 	/// Register a contact event listener
65,67c79,81
< 	/// inside with b2World::DrawDebugData method. The debug draw object is owned
< 	/// by you and must remain in scope.
< 	void SetDebugDraw(b2Draw* debugDraw);
---
> 	/// inside the b2World::Step method, so make sure your renderer is ready to
> 	/// consume draw commands when you call Step().
> 	void SetDebugDraw(b2DebugDraw* debugDraw);
88a103,112
> 	/// Add a controller to the world.
> 	b2Controller* CreateController(b2ControllerDef* def);
> 
> 	/// Removes a controller from the world.
> 	void DestroyController(b2Controller* controller);
> 
> 	/// The world provides a single static ground body with no collision shapes.
> 	/// You can use this to simplify the creation of joints and static shapes.
> 	b2Body* GetGroundBody();
> 
94,108c118
< 	void Step(	float32 timeStep,
< 				int32 velocityIterations,
< 				int32 positionIterations);
< 
< 	/// Manually clear the force buffer on all bodies. By default, forces are cleared automatically
< 	/// after each call to Step. The default behavior is modified by calling SetAutoClearForces.
< 	/// The purpose of this function is to support sub-stepping. Sub-stepping is often used to maintain
< 	/// a fixed sized time step under a variable frame-rate.
< 	/// When you perform sub-stepping you will disable auto clearing of forces and instead call
< 	/// ClearForces after all sub-steps are complete in one pass of your game loop.
< 	/// @see SetAutoClearForces
< 	void ClearForces();
< 
< 	/// Call this to draw shapes and other debug draw data.
< 	void DrawDebugData();
---
> 	void Step(float32 timeStep, int32 velocityIterations, int32 positionIterations);
110,112c120,122
< 	/// Query the world for all fixtures that potentially overlap the
< 	/// provided AABB.
< 	/// @param callback a user implemented callback class.
---
> 	/// Query the world for all shapes that potentially overlap the
> 	/// provided AABB. You provide a shape pointer buffer of specified
> 	/// size. The number of shapes found is returned.
114c124,150
< 	void QueryAABB(b2QueryCallback* callback, const b2AABB& aabb) const;
---
> 	/// @param shapes a user allocated shape pointer array of size maxCount (or greater).
> 	/// @param maxCount the capacity of the shapes array.
> 	/// @return the number of shapes found in aabb.
> 	int32 Query(const b2AABB& aabb, b2Shape** shapes, int32 maxCount);
> 
> 	/// Query the world for all shapes that intersect a given segment. You provide a shap
> 	/// pointer buffer of specified size. The number of shapes found is returned, and the buffer
> 	/// is filled in order of intersection
> 	/// @param segment defines the begin and end point of the ray cast, from p1 to p2.
> 	/// Use b2Segment.Extend to create (semi-)infinite rays
> 	/// @param shapes a user allocated shape pointer array of size maxCount (or greater).
> 	/// @param maxCount the capacity of the shapes array
> 	/// @param solidShapes determines if shapes that the ray starts in are counted as hits.
> 	/// @param userData passed through the worlds contact filter, with method RayCollide. This can be used to filter valid shapes
> 	/// @returns the number of shapes found
> 	int32 Raycast(const b2Segment& segment, b2Shape** shapes, int32 maxCount, bool solidShapes, void* userData);
> 
> 	/// Performs a raycast as with Raycast, finding the first intersecting shape.
> 	/// @param segment defines the begin and end point of the ray cast, from p1 to p2.
> 	/// Use b2Segment.Extend to create (semi-)infinite rays	
> 	/// @param lambda returns the hit fraction. You can use this to compute the contact point
> 	/// p = (1 - lambda) * segment.p1 + lambda * segment.p2.
> 	/// @param normal returns the normal at the contact point. If there is no intersection, the normal
> 	/// is not set.
> 	/// @param solidShapes determines if shapes that the ray starts in are counted as hits.
> 	/// @returns the colliding shape shape, or null if not found
> 	b2Shape* RaycastOne(const b2Segment& segment, float32* lambda, b2Vec2* normal, bool solidShapes, void* userData);
116,122c152,153
< 	/// Ray-cast the world for all fixtures in the path of the ray. Your callback
< 	/// controls whether you get the closest point, any point, or n-points.
< 	/// The ray-cast ignores shapes that contain the starting point.
< 	/// @param callback a user implemented callback class.
< 	/// @param point1 the ray starting point
< 	/// @param point2 the ray ending point
< 	void RayCast(b2RayCastCallback* callback, const b2Vec2& point1, const b2Vec2& point2) const;
---
> 	/// Check if the AABB is within the broadphase limits.
> 	bool InRange(const b2AABB& aabb) const;
128d158
< 	const b2Body* GetBodyList() const;
134d163
< 	const b2Joint* GetJointList() const;
136,146c165,171
< 	/// Get the world contact list. With the returned contact, use b2Contact::GetNext to get
< 	/// the next contact in the world list. A NULL contact indicates the end of the list.
< 	/// @return the head of the world contact list.
< 	/// @warning contacts are created and destroyed in the middle of a time step.
< 	/// Use b2ContactListener to avoid missing contacts.
< 	b2Contact* GetContactList();
< 	const b2Contact* GetContactList() const;
< 
< 	/// Enable/disable sleep.
< 	void SetAllowSleeping(bool flag);
< 	bool GetAllowSleeping() const { return m_allowSleep; }
---
> 	/// Get the world controller list. With the returned controller, use b2Controller::GetNext to get
> 	/// the next controller in the world list. A NULL controller indicates the end of the list.
> 	/// @return the head of the world controller list.
> 	b2Controller* GetControllerList();
> 
> 	/// Re-filter a shape. This re-runs contact filtering on a shape.
> 	void Refilter(b2Shape* shape);
150d174
< 	bool GetWarmStarting() const { return m_warmStarting; }
154d177
< 	bool GetContinuousPhysics() const { return m_continuousPhysics; }
156,158c179,180
< 	/// Enable/disable single stepped continuous physics. For testing.
< 	void SetSubStepping(bool flag) { m_subStepping = flag; }
< 	bool GetSubStepping() const { return m_subStepping; }
---
> 	/// Perform validation of internal data structures.
> 	void Validate();
162a185,187
> 	/// Get the number of broad-phase pairs.
> 	int32 GetPairCount() const;
> 
172,180c197,198
< 	/// Get the height of the dynamic tree.
< 	int32 GetTreeHeight() const;
< 
< 	/// Get the balance of the dynamic tree.
< 	int32 GetTreeBalance() const;
< 
< 	/// Get the quality metric of the dynamic tree. The smaller the better.
< 	/// The minimum is 1.
< 	float32 GetTreeQuality() const;
---
> 	/// Get the number of controllers.
> 	int32 GetControllerCount() const;
188,211d205
< 	/// Is the world locked (in the middle of a time step).
< 	bool IsLocked() const;
< 
< 	/// Set flag to control automatic clearing of forces after each time step.
< 	void SetAutoClearForces(bool flag);
< 
< 	/// Get the flag that controls automatic clearing of forces after each time step.
< 	bool GetAutoClearForces() const;
< 
< 	/// Shift the world origin. Useful for large worlds.
< 	/// The body shift formula is: position -= newOrigin
< 	/// @param newOrigin the new origin with respect to the old origin
< 	void ShiftOrigin(const b2Vec2& newOrigin);
< 
< 	/// Get the contact manager for testing.
< 	const b2ContactManager& GetContactManager() const;
< 
< 	/// Get the current profile.
< 	const b2Profile& GetProfile() const;
< 
< 	/// Dump the world into the log file.
< 	/// @warning this should be called outside of a time step.
< 	void Dump();
< 
214,221d207
< 	// m_flags
< 	enum
< 	{
< 		e_newFixture	= 0x0001,
< 		e_locked		= 0x0002,
< 		e_clearForces	= 0x0004
< 	};
< 
223d208
< 	friend class b2Fixture;
231c216,220
< 	void DrawShape(b2Fixture* shape, const b2Transform& xf, const b2Color& color);
---
> 	void DrawShape(b2Shape* shape, const b2XForm& xf, const b2Color& color, bool core);
> 	void DrawDebugData();
> 
> 	//Is it safe to pass private static function pointers?
> 	static float32 RaycastSortKey(void* shape);
236c225
< 	int32 m_flags;
---
> 	bool m_lock;
237a227
> 	b2BroadPhase* m_broadPhase;
241a232,241
> 	b2Controller* m_controllerList;
> 
> 	b2Vec2 m_raycastNormal;
> 	void* m_raycastUserData;
> 	const b2Segment* m_raycastSegment;
> 	bool m_raycastSolidShape;
> 
> 
> 	// Do not access
> 	b2Contact* m_contactList;
243a244
> 	int32 m_contactCount;
244a246
> 	int32 m_controllerCount;
248a251,252
> 	b2Body* m_groundBody;
> 
250c254,257
< 	b2Draw* m_debugDraw;
---
> 	b2BoundaryListener* m_boundaryListener;
> 	b2ContactFilter* m_contactFilter;
> 	b2ContactListener* m_contactListener;
> 	b2DebugDraw* m_debugDraw;
256c263
< 	// These are for debugging the solver.
---
> 	// This is for debugging the solver.
258,261d264
< 	bool m_continuousPhysics;
< 	bool m_subStepping;
< 
< 	bool m_stepComplete;
263c266,267
< 	b2Profile m_profile;
---
> 	// This is for debugging the solver.
> 	bool m_continuousPhysics;
266c270
< inline b2Body* b2World::GetBodyList()
---
> inline b2Body* b2World::GetGroundBody()
268c272
< 	return m_bodyList;
---
> 	return m_groundBody;
271c275
< inline const b2Body* b2World::GetBodyList() const
---
> inline b2Body* b2World::GetBodyList()
281,286c285
< inline const b2Joint* b2World::GetJointList() const
< {
< 	return m_jointList;
< }
< 
< inline b2Contact* b2World::GetContactList()
---
> inline b2Controller* b2World::GetControllerList()
288,293c287
< 	return m_contactManager.m_contactList;
< }
< 
< inline const b2Contact* b2World::GetContactList() const
< {
< 	return m_contactManager.m_contactList;
---
> 	return m_controllerList;
308c302,307
< 	return m_contactManager.m_contactCount;
---
> 	return m_contactCount;
> }
> 
> inline int32 b2World::GetControllerCount() const
> {
> 	return m_controllerCount;
321,353d319
< inline bool b2World::IsLocked() const
< {
< 	return (m_flags & e_locked) == e_locked;
< }
< 
< inline void b2World::SetAutoClearForces(bool flag)
< {
< 	if (flag)
< 	{
< 		m_flags |= e_clearForces;
< 	}
< 	else
< 	{
< 		m_flags &= ~e_clearForces;
< 	}
< }
< 
< /// Get the flag that controls automatic clearing of forces after each time step.
< inline bool b2World::GetAutoClearForces() const
< {
< 	return (m_flags & e_clearForces) == e_clearForces;
< }
< 
< inline const b2ContactManager& b2World::GetContactManager() const
< {
< 	return m_contactManager;
< }
< 
< inline const b2Profile& b2World::GetProfile() const
< {
< 	return m_profile;
< }
< 
diff -r -x './svn/*' native/Box2D/Dynamics/.svn/text-base/b2WorldCallbacks.cpp.svn-base ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/.svn/text-base/b2WorldCallbacks.cpp.svn-base
2c2
< * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
19,20c19,22
< #include <Box2D/Dynamics/b2WorldCallbacks.h>
< #include <Box2D/Dynamics/b2Fixture.h>
---
> #include "b2WorldCallbacks.h"
> #include "../Collision/Shapes/b2Shape.h"
> 
> b2ContactFilter b2_defaultFilter;
24c26
< bool b2ContactFilter::ShouldCollide(b2Fixture* fixtureA, b2Fixture* fixtureB)
---
> bool b2ContactFilter::ShouldCollide(b2Shape* shape1, b2Shape* shape2)
26,27c28,29
< 	const b2Filter& filterA = fixtureA->GetFilterData();
< 	const b2Filter& filterB = fixtureB->GetFilterData();
---
> 	const b2FilterData& filter1 = shape1->GetFilterData();
> 	const b2FilterData& filter2 = shape2->GetFilterData();
29c31
< 	if (filterA.groupIndex == filterB.groupIndex && filterA.groupIndex != 0)
---
> 	if (filter1.groupIndex == filter2.groupIndex && filter1.groupIndex != 0)
31c33
< 		return filterA.groupIndex > 0;
---
> 		return filter1.groupIndex > 0;
34c36
< 	bool collide = (filterA.maskBits & filterB.categoryBits) != 0 && (filterA.categoryBits & filterB.maskBits) != 0;
---
> 	bool collide = (filter1.maskBits & filter2.categoryBits) != 0 && (filter1.categoryBits & filter2.maskBits) != 0;
36a39,71
> 
> bool b2ContactFilter::RayCollide(void* userData, b2Shape* shape)
> {
> 	//By default, cast userData as a shape, and then collide if the shapes would collide
> 	if(!userData)
> 		return true;
> 	return ShouldCollide((b2Shape*)userData,shape);
> }
> 
> b2DebugDraw::b2DebugDraw()
> {
> 	m_drawFlags = 0;
> }
> 
> void b2DebugDraw::SetFlags(uint32 flags)
> {
> 	m_drawFlags = flags;
> }
> 
> uint32 b2DebugDraw::GetFlags() const
> {
> 	return m_drawFlags;
> }
> 
> void b2DebugDraw::AppendFlags(uint32 flags)
> {
> 	m_drawFlags |= flags;
> }
> 
> void b2DebugDraw::ClearFlags(uint32 flags)
> {
> 	m_drawFlags &= ~flags;
> }
diff -r -x './svn/*' native/Box2D/Dynamics/.svn/text-base/b2WorldCallbacks.h.svn-base ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/.svn/text-base/b2WorldCallbacks.h.svn-base
2c2
< * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
22c22
< #include <Box2D/Common/b2Settings.h>
---
> #include "../Common/b2Settings.h"
25,26c25,26
< struct b2Transform;
< class b2Fixture;
---
> struct b2XForm;
> class b2Shape;
29a30
> struct b2ContactPoint;
31d31
< struct b2Manifold;
33c33
< /// Joints and fixtures are destroyed when their associated
---
> /// Joints and shapes are destroyed when their associated
45c45
< 	/// Called when any fixture is about to be destroyed due
---
> 	/// Called when any shape is about to be destroyed due
47c47
< 	virtual void SayGoodbye(b2Fixture* fixture) = 0;
---
> 	virtual void SayGoodbye(b2Shape* shape) = 0;
49a50,62
> 
> /// This is called when a body's shape passes outside of the world boundary.
> class b2BoundaryListener
> {
> public:
> 	virtual ~b2BoundaryListener() {}
> 
> 	/// This is called for each body that leaves the world boundary.
> 	/// @warning you can't modify the world inside this callback.
> 	virtual void Violation(b2Body* body) = 0;
> };
> 
> 
59,60c72
< 	virtual bool ShouldCollide(b2Fixture* fixtureA, b2Fixture* fixtureB);
< };
---
> 	virtual bool ShouldCollide(b2Shape* shape1, b2Shape* shape2);
62,69c74,75
< /// Contact impulses for reporting. Impulses are used instead of forces because
< /// sub-step forces may approach infinity for rigid body collisions. These
< /// match up one-to-one with the contact points in b2Manifold.
< struct b2ContactImpulse
< {
< 	float32 normalImpulses[b2_maxManifoldPoints];
< 	float32 tangentImpulses[b2_maxManifoldPoints];
< 	int32 count;
---
> 	/// Return true if the given shape should be considered for ray intersection
> 	virtual bool RayCollide(void* userData, b2Shape* b2Shape);
72c78,81
< /// Implement this class to get contact information. You can use these results for
---
> /// The default contact filter.
> extern b2ContactFilter b2_defaultFilter;
> 
> /// Implement this class to get collision results. You can use these results for
79a89
> /// @warning The contact separation is the last computed value.
86,87c96,98
< 	/// Called when two fixtures begin to touch.
< 	virtual void BeginContact(b2Contact* contact) { B2_NOT_USED(contact); }
---
> 	/// Called when a contact point is added. This includes the geometry
> 	/// and the forces.
> 	virtual void Add(const b2ContactPoint* point) { B2_NOT_USED(point); }
89,90c100,102
< 	/// Called when two fixtures cease to touch.
< 	virtual void EndContact(b2Contact* contact) { B2_NOT_USED(contact); }
---
> 	/// Called when a contact point persists. This includes the geometry
> 	/// and the forces.
> 	virtual void Persist(const b2ContactPoint* point) { B2_NOT_USED(point); }
92,118c104,109
< 	/// This is called after a contact is updated. This allows you to inspect a
< 	/// contact before it goes to the solver. If you are careful, you can modify the
< 	/// contact manifold (e.g. disable contact).
< 	/// A copy of the old manifold is provided so that you can detect changes.
< 	/// Note: this is called only for awake bodies.
< 	/// Note: this is called even when the number of contact points is zero.
< 	/// Note: this is not called for sensors.
< 	/// Note: if you set the number of contact points to zero, you will not
< 	/// get an EndContact callback. However, you may get a BeginContact callback
< 	/// the next step.
< 	virtual void PreSolve(b2Contact* contact, const b2Manifold* oldManifold)
< 	{
< 		B2_NOT_USED(contact);
< 		B2_NOT_USED(oldManifold);
< 	}
< 
< 	/// This lets you inspect a contact after the solver is finished. This is useful
< 	/// for inspecting impulses.
< 	/// Note: the contact manifold does not include time of impact impulses, which can be
< 	/// arbitrarily large if the sub-step is small. Hence the impulse is provided explicitly
< 	/// in a separate data structure.
< 	/// Note: this is only called for contacts that are touching, solid, and awake.
< 	virtual void PostSolve(b2Contact* contact, const b2ContactImpulse* impulse)
< 	{
< 		B2_NOT_USED(contact);
< 		B2_NOT_USED(impulse);
< 	}
---
> 	/// Called when a contact point is removed. This includes the last
> 	/// computed geometry and forces.
> 	virtual void Remove(const b2ContactPoint* point) { B2_NOT_USED(point); }
> 
> 	/// Called after a contact point is solved.
> 	virtual void Result(const b2ContactResult* point) { B2_NOT_USED(point); }
121,123c112,113
< /// Callback class for AABB queries.
< /// See b2World::Query
< class b2QueryCallback
---
> /// Color for debug drawing. Each value has the range [0,1].
> struct b2Color
125,130c115,117
< public:
< 	virtual ~b2QueryCallback() {}
< 
< 	/// Called for each fixture found in the query AABB.
< 	/// @return false to terminate the query.
< 	virtual bool ReportFixture(b2Fixture* fixture) = 0;
---
> 	b2Color() {}
> 	b2Color(float32 r, float32 g, float32 b) : r(r), g(g), b(b) {}
> 	float32 r, g, b;
133,135c120,122
< /// Callback class for ray casts.
< /// See b2World::RayCast
< class b2RayCastCallback
---
> /// Implement and register this class with a b2World to provide debug drawing of physics
> /// entities in your game.
> class b2DebugDraw
138c125,170
< 	virtual ~b2RayCastCallback() {}
---
> 	b2DebugDraw();
> 
> 	virtual ~b2DebugDraw() {}
> 
> 	enum
> 	{
> 		e_shapeBit				= 0x0001, ///< draw shapes
> 		e_jointBit				= 0x0002, ///< draw joint connections
> 		e_coreShapeBit			= 0x0004, ///< draw core (TOI) shapes
> 		e_aabbBit				= 0x0008, ///< draw axis aligned bounding boxes
> 		e_obbBit				= 0x0010, ///< draw oriented bounding boxes
> 		e_pairBit				= 0x0020, ///< draw broad-phase pairs
> 		e_centerOfMassBit		= 0x0040, ///< draw center of mass frame
> 		e_controllerBit			= 0x0080, ///< draw controllers
> 	};
> 
> 	/// Set the drawing flags.
> 	void SetFlags(uint32 flags);
> 
> 	/// Get the drawing flags.
> 	uint32 GetFlags() const;
> 	
> 	/// Append flags to the current flags.
> 	void AppendFlags(uint32 flags);
> 
> 	/// Clear flags from the current flags.
> 	void ClearFlags(uint32 flags);
> 
> 	/// Draw a closed polygon provided in CCW order.
> 	virtual void DrawPolygon(const b2Vec2* vertices, int32 vertexCount, const b2Color& color) = 0;
> 
> 	/// Draw a solid closed polygon provided in CCW order.
> 	virtual void DrawSolidPolygon(const b2Vec2* vertices, int32 vertexCount, const b2Color& color) = 0;
> 
> 	/// Draw a circle.
> 	virtual void DrawCircle(const b2Vec2& center, float32 radius, const b2Color& color) = 0;
> 	
> 	/// Draw a solid circle.
> 	virtual void DrawSolidCircle(const b2Vec2& center, float32 radius, const b2Vec2& axis, const b2Color& color) = 0;
> 	
> 	/// Draw a line segment.
> 	virtual void DrawSegment(const b2Vec2& p1, const b2Vec2& p2, const b2Color& color) = 0;
> 
> 	/// Draw a transform. Choose your own length scale.
> 	/// @param xf a transform.
> 	virtual void DrawXForm(const b2XForm& xf) = 0;
140,152c172,173
< 	/// Called for each fixture found in the query. You control how the ray cast
< 	/// proceeds by returning a float:
< 	/// return -1: ignore this fixture and continue
< 	/// return 0: terminate the ray cast
< 	/// return fraction: clip the ray to this point
< 	/// return 1: don't clip the ray and continue
< 	/// @param fixture the fixture hit by the ray
< 	/// @param point the point of initial intersection
< 	/// @param normal the normal vector at the point of intersection
< 	/// @return -1 to filter, 0 to terminate, fraction to clip the ray for
< 	/// closest hit, 1 to continue
< 	virtual float32 ReportFixture(	b2Fixture* fixture, const b2Vec2& point,
< 									const b2Vec2& normal, float32 fraction) = 0;
---
> protected:
> 	uint32 m_drawFlags;
diff -r -x './svn/*' native/Box2D/Dynamics/Contacts/.svn/all-wcprops ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Contacts/.svn/all-wcprops
3,4c3,4
< V 53
< /svn/!svn/ver/248/trunk/Box2D/Box2D/Dynamics/Contacts
---
> V 57
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Dynamics/Contacts
6c6
< b2EdgeAndPolygonContact.cpp
---
> b2PolyAndEdgeContact.h
9,10c9,10
< V 81
< /svn/!svn/ver/158/trunk/Box2D/Box2D/Dynamics/Contacts/b2EdgeAndPolygonContact.cpp
---
> V 80
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Dynamics/Contacts/b2PolyAndEdgeContact.h
15,28c15,16
< V 73
< /svn/!svn/ver/158/trunk/Box2D/Box2D/Dynamics/Contacts/b2CircleContact.cpp
< END
< b2PolygonAndCircleContact.h
< K 25
< svn:wc:ra_dav:version-url
< V 81
< /svn/!svn/ver/158/trunk/Box2D/Box2D/Dynamics/Contacts/b2PolygonAndCircleContact.h
< END
< b2EdgeAndPolygonContact.h
< K 25
< svn:wc:ra_dav:version-url
< V 79
< /svn/!svn/ver/158/trunk/Box2D/Box2D/Dynamics/Contacts/b2EdgeAndPolygonContact.h
---
> V 77
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Dynamics/Contacts/b2CircleContact.cpp
33,34c21,22
< V 71
< /svn/!svn/ver/158/trunk/Box2D/Box2D/Dynamics/Contacts/b2CircleContact.h
---
> V 75
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Dynamics/Contacts/b2CircleContact.h
39,40c27,28
< V 80
< /svn/!svn/ver/158/trunk/Box2D/Box2D/Dynamics/Contacts/b2EdgeAndCircleContact.cpp
---
> V 84
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Dynamics/Contacts/b2EdgeAndCircleContact.cpp
45,46c33,34
< V 73
< /svn/!svn/ver/245/trunk/Box2D/Box2D/Dynamics/Contacts/b2ContactSolver.cpp
---
> V 77
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Dynamics/Contacts/b2ContactSolver.cpp
48c36
< b2ChainAndPolygonContact.cpp
---
> b2EdgeAndCircleContact.h
52c40
< /svn/!svn/ver/198/trunk/Box2D/Box2D/Dynamics/Contacts/b2ChainAndPolygonContact.cpp
---
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Dynamics/Contacts/b2EdgeAndCircleContact.h
54c42
< b2EdgeAndCircleContact.h
---
> b2ContactSolver.h
57,58c45,46
< V 78
< /svn/!svn/ver/158/trunk/Box2D/Box2D/Dynamics/Contacts/b2EdgeAndCircleContact.h
---
> V 75
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Dynamics/Contacts/b2ContactSolver.h
63,68d50
< V 67
< /svn/!svn/ver/248/trunk/Box2D/Box2D/Dynamics/Contacts/b2Contact.cpp
< END
< b2ContactSolver.h
< K 25
< svn:wc:ra_dav:version-url
70c52
< /svn/!svn/ver/238/trunk/Box2D/Box2D/Dynamics/Contacts/b2ContactSolver.h
---
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Dynamics/Contacts/b2Contact.cpp
72c54
< b2ChainAndPolygonContact.h
---
> b2NullContact.h
75,76c57,58
< V 80
< /svn/!svn/ver/198/trunk/Box2D/Box2D/Dynamics/Contacts/b2ChainAndPolygonContact.h
---
> V 73
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Dynamics/Contacts/b2NullContact.h
78c60
< b2Contact.h
---
> b2PolyContact.cpp
81,82c63,64
< V 65
< /svn/!svn/ver/238/trunk/Box2D/Box2D/Dynamics/Contacts/b2Contact.h
---
> V 75
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Dynamics/Contacts/b2PolyContact.cpp
84c66
< b2PolygonContact.cpp
---
> b2Contact.h
87,88c69,70
< V 74
< /svn/!svn/ver/158/trunk/Box2D/Box2D/Dynamics/Contacts/b2PolygonContact.cpp
---
> V 69
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Dynamics/Contacts/b2Contact.h
90c72
< b2ChainAndCircleContact.cpp
---
> b2PolyAndCircleContact.cpp
93,94c75,76
< V 81
< /svn/!svn/ver/198/trunk/Box2D/Box2D/Dynamics/Contacts/b2ChainAndCircleContact.cpp
---
> V 84
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Dynamics/Contacts/b2PolyAndCircleContact.cpp
96c78
< b2PolygonAndCircleContact.cpp
---
> b2PolyContact.h
99,100c81,82
< V 83
< /svn/!svn/ver/158/trunk/Box2D/Box2D/Dynamics/Contacts/b2PolygonAndCircleContact.cpp
---
> V 73
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Dynamics/Contacts/b2PolyContact.h
102c84
< b2PolygonContact.h
---
> b2PolyAndEdgeContact.cpp
105,106c87,88
< V 72
< /svn/!svn/ver/158/trunk/Box2D/Box2D/Dynamics/Contacts/b2PolygonContact.h
---
> V 82
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Dynamics/Contacts/b2PolyAndEdgeContact.cpp
108c90
< b2ChainAndCircleContact.h
---
> b2PolyAndCircleContact.h
111,112c93,94
< V 79
< /svn/!svn/ver/198/trunk/Box2D/Box2D/Dynamics/Contacts/b2ChainAndCircleContact.h
---
> V 82
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Dynamics/Contacts/b2PolyAndCircleContact.h
diff -r -x './svn/*' native/Box2D/Dynamics/Contacts/.svn/entries ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Contacts/.svn/entries
4,6c4,6
< 254
< http://box2d.googlecode.com/svn/trunk/Box2D/Box2D/Dynamics/Contacts
< http://box2d.googlecode.com/svn
---
> 7
> http://android-opengl-box2d-basics.googlecode.com/svn/trunk/rt-jnibox2d/box2d/Dynamics/Contacts
> http://android-opengl-box2d-basics.googlecode.com/svn
10,12c10,12
< 2012-04-04T06:42:01.588851Z
< 248
< erincatto@gmail.com
---
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
27c27
< cafe418c-1137-0410-84cc-357ec87a5d9b
---
> 5131c71c-dced-4c25-419c-0ca2576ce0a2
29c29
< b2EdgeAndPolygonContact.cpp
---
> b2PolyAndEdgeContact.h
35,39c35,39
< 2013-06-18T12:51:07.000000Z
< 9106ff45e5bf8df9b0e0bb78565cb5bb
< 2011-03-24T17:36:44.542193Z
< 158
< erincatto
---
> 2013-07-02T14:40:40.000000Z
> b3fb0a14935b575b829a9bcfb1afe36b
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
61c61
< 2107
---
> 1684
69,73c69,73
< 2013-06-18T12:51:07.000000Z
< 5d9d1cfb5b02a98532d787599c16d2a4
< 2011-03-24T17:36:44.542193Z
< 158
< erincatto
---
> 2013-07-02T14:40:40.000000Z
> 52bd8f4d1b4dd2e5443b2037de5bfe46
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
95,163c95
< 2135
< 
< b2PolygonAndCircleContact.h
< file
< 
< 
< 
< 
< 2013-06-18T12:51:07.000000Z
< 1a2dcc118ee2551ba7b92631311ae842
< 2011-03-24T17:36:44.542193Z
< 158
< erincatto
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 1550
< 
< b2EdgeAndPolygonContact.h
< file
< 
< 
< 
< 
< 2013-06-18T12:51:07.000000Z
< 89fcb07fea6274d4963d4d16f04991f4
< 2011-03-24T17:36:44.542193Z
< 158
< erincatto
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 1550
---
> 3967
171,175c103,107
< 2013-06-18T12:51:07.000000Z
< 11e5cc85505e1a778dd2217b9d4dfeea
< 2011-03-24T17:36:44.542193Z
< 158
< erincatto
---
> 2013-07-02T14:40:40.000000Z
> 2e52cc6d5725afe960f8717d8e727b63
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
197c129
< 1506
---
> 1547
205,209c137,141
< 2013-06-18T12:51:07.000000Z
< f2b82ebd9b9fb385ff1219c33f308de8
< 2011-03-24T17:36:44.542193Z
< 158
< erincatto
---
> 2013-07-02T14:40:40.000000Z
> 4aa2083de9a5ed2e290fb09aa17d0945
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
231c163
< 2093
---
> 5774
239,243c171,175
< 2013-06-18T12:51:07.000000Z
< 28460e791f1370f9041f471f875fc74c
< 2012-03-17T06:32:44.892106Z
< 245
< erincatto@gmail.com
---
> 2013-07-02T14:40:40.000000Z
> fbe05b90b04989dc14ac7b0f21100038
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
265c197
< 23601
---
> 21592
267c199
< b2ChainAndPolygonContact.cpp
---
> b2EdgeAndCircleContact.h
273,277c205,209
< 2013-06-18T12:51:07.000000Z
< d9b775e1eee2cb1abcaf1eca9b163bd0
< 2011-08-08T07:03:57.627343Z
< 198
< erincatto@gmail.com
---
> 2013-07-02T14:40:40.000000Z
> 1f687384f0efbb448880b91f5d7f0718
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
299c231
< 2369
---
> 1878
301c233
< b2EdgeAndCircleContact.h
---
> b2ContactSolver.h
307,311c239,243
< 2013-06-18T12:51:07.000000Z
< 7e74f145f93a347e5a549e270502d156
< 2011-03-24T17:36:44.542193Z
< 158
< erincatto
---
> 2013-07-02T14:40:40.000000Z
> e487d9ebdf6670d8c7da0a2a89081a99
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
333c265
< 1545
---
> 2190
341,345c273,277
< 2013-06-18T12:51:07.000000Z
< e1b8934da6fb8d58e8ca47a1e12e15d2
< 2012-04-04T06:42:01.588851Z
< 248
< erincatto@gmail.com
---
> 2013-07-02T14:40:40.000000Z
> 0cfabc35600a35b0c830c72c3a0f60b0
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
367c299
< 7639
---
> 5082
369c301
< b2ContactSolver.h
---
> b2NullContact.h
375,379c307,311
< 2013-06-18T12:51:07.000000Z
< bbdb0a92ed69a162a069c806e086ae90
< 2011-11-14T05:45:39.018408Z
< 238
< erincatto@gmail.com
---
> 2013-07-02T14:40:40.000000Z
> b802b9e43f3d602c84e1b2028dcf03b3
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
401c333
< 2513
---
> 1207
403c335
< b2ChainAndPolygonContact.h
---
> b2PolyContact.cpp
409,413c341,345
< 2013-06-18T12:51:07.000000Z
< 052fdc0c40e6941575c04f4d859de42f
< 2011-08-08T07:03:57.627343Z
< 198
< erincatto@gmail.com
---
> 2013-07-02T14:40:40.000000Z
> 786a56ff1e6e97d5253910a7b95435ab
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
435c367
< 1583
---
> 4663
443,481c375,379
< 2013-06-18T12:51:07.000000Z
< ad7d70e5269e0a0dcffc8e94e83bbed5
< 2011-11-14T05:45:39.018408Z
< 238
< erincatto@gmail.com
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 9662
< 
< b2PolygonContact.cpp
< file
< 
< 
< 
< 
< 2013-06-18T12:51:07.000000Z
< b6498355293e081ffec2a49815de9c2f
< 2011-03-24T17:36:44.542193Z
< 158
< erincatto
---
> 2013-07-02T14:40:40.000000Z
> 2be1861296340cd1312e37f78f574fae
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
503c401
< 2154
---
> 5704
505c403
< b2ChainAndCircleContact.cpp
---
> b2PolyAndCircleContact.cpp
511,515c409,413
< 2013-06-18T12:51:07.000000Z
< 063ee581d7b7899c4cd0edd980184869
< 2011-08-08T07:03:57.627343Z
< 198
< erincatto@gmail.com
---
> 2013-07-02T14:40:40.000000Z
> 3913ac995ebdd77e94e15e197c5d1400
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
537c435
< 2354
---
> 4739
539c437
< b2PolygonAndCircleContact.cpp
---
> b2PolyContact.h
545,549c443,447
< 2013-06-18T12:51:07.000000Z
< 12d722b7c06275cd2afeab5ddfacb231
< 2011-03-24T17:36:44.542193Z
< 158
< erincatto
---
> 2013-07-02T14:40:40.000000Z
> 6835d03fd7214afc69a97bda605af5b5
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
571c469
< 2135
---
> 1468
573c471
< b2PolygonContact.h
---
> b2PolyAndEdgeContact.cpp
579,583c477,481
< 2013-06-18T12:51:07.000000Z
< 0da675fab9a4a8ca6faa1b3c548c1ea4
< 2011-03-24T17:36:44.542193Z
< 158
< erincatto
---
> 2013-07-02T14:40:40.000000Z
> 66367f107eebdab59d7050ff7b833bdd
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
605c503
< 1511
---
> 13008
607c505
< b2ChainAndCircleContact.h
---
> b2PolyAndCircleContact.h
613,617c511,515
< 2013-06-18T12:51:07.000000Z
< 548c874dacc7659fcb8afd978f4dda50
< 2011-08-08T07:03:57.627343Z
< 198
< erincatto@gmail.com
---
> 2013-07-02T14:40:40.000000Z
> 3f487ed8c0a83e8c0cb0e6fd81c1cde5
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
639c537
< 1578
---
> 1530
Only in native/Box2D/Dynamics/Contacts/.svn/text-base: b2ChainAndCircleContact.cpp.svn-base
Only in native/Box2D/Dynamics/Contacts/.svn/text-base: b2ChainAndCircleContact.h.svn-base
Only in native/Box2D/Dynamics/Contacts/.svn/text-base: b2ChainAndPolygonContact.cpp.svn-base
Only in native/Box2D/Dynamics/Contacts/.svn/text-base: b2ChainAndPolygonContact.h.svn-base
diff -r -x './svn/*' native/Box2D/Dynamics/Contacts/.svn/text-base/b2CircleContact.cpp.svn-base ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Contacts/.svn/text-base/b2CircleContact.cpp.svn-base
2c2
< * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
19,24c19,22
< #include <Box2D/Dynamics/Contacts/b2CircleContact.h>
< #include <Box2D/Dynamics/b2Body.h>
< #include <Box2D/Dynamics/b2Fixture.h>
< #include <Box2D/Dynamics/b2WorldCallbacks.h>
< #include <Box2D/Common/b2BlockAllocator.h>
< #include <Box2D/Collision/b2TimeOfImpact.h>
---
> #include "b2CircleContact.h"
> #include "../b2Body.h"
> #include "../b2WorldCallbacks.h"
> #include "../../Common/b2BlockAllocator.h"
26,27c24,25
< #include <new>
< using namespace std;
---
> #include <new>
> #include <string.h>
29c27
< b2Contact* b2CircleContact::Create(b2Fixture* fixtureA, int32, b2Fixture* fixtureB, int32, b2BlockAllocator* allocator)
---
> b2Contact* b2CircleContact::Create(b2Shape* shape1, b2Shape* shape2, b2BlockAllocator* allocator)
32c30
< 	return new (mem) b2CircleContact(fixtureA, fixtureB);
---
> 	return new (mem) b2CircleContact(shape1, shape2);
41,42c39,40
< b2CircleContact::b2CircleContact(b2Fixture* fixtureA, b2Fixture* fixtureB)
< 	: b2Contact(fixtureA, 0, fixtureB, 0)
---
> b2CircleContact::b2CircleContact(b2Shape* s1, b2Shape* s2)
> : b2Contact(s1, s2)
44,45c42,46
< 	b2Assert(m_fixtureA->GetType() == b2Shape::e_circle);
< 	b2Assert(m_fixtureB->GetType() == b2Shape::e_circle);
---
> 	b2Assert(m_shape1->GetType() == e_circleShape);
> 	b2Assert(m_shape2->GetType() == e_circleShape);
> 	m_manifold.pointCount = 0;
> 	m_manifold.points[0].normalImpulse = 0.0f;
> 	m_manifold.points[0].tangentImpulse = 0.0f;
48c49
< void b2CircleContact::Evaluate(b2Manifold* manifold, const b2Transform& xfA, const b2Transform& xfB)
---
> void b2CircleContact::Evaluate(b2ContactListener* listener)
50,52c51,121
< 	b2CollideCircles(manifold,
< 					(b2CircleShape*)m_fixtureA->GetShape(), xfA,
< 					(b2CircleShape*)m_fixtureB->GetShape(), xfB);
---
> 	b2Body* b1 = m_shape1->GetBody();
> 	b2Body* b2 = m_shape2->GetBody();
> 
> 	b2Manifold m0;
> 	memcpy(&m0, &m_manifold, sizeof(b2Manifold));
> 
> 	b2CollideCircles(&m_manifold, (b2CircleShape*)m_shape1, b1->GetXForm(), (b2CircleShape*)m_shape2, b2->GetXForm());
> 
> 	b2ContactPoint cp;
> 	cp.shape1 = m_shape1;
> 	cp.shape2 = m_shape2;
> 	cp.friction = b2MixFriction(m_shape1->GetFriction(), m_shape2->GetFriction());
> 	cp.restitution = b2MixRestitution(m_shape1->GetRestitution(), m_shape2->GetRestitution());
> 
> 	if (m_manifold.pointCount > 0)
> 	{
> 		m_manifoldCount = 1;
> 		b2ManifoldPoint* mp = m_manifold.points + 0;
> 
> 		if (m0.pointCount == 0)
> 		{
> 			mp->normalImpulse = 0.0f;
> 			mp->tangentImpulse = 0.0f;
> 
> 			if (listener)
> 			{
> 				cp.position = b1->GetWorldPoint(mp->localPoint1);
> 				b2Vec2 v1 = b1->GetLinearVelocityFromLocalPoint(mp->localPoint1);
> 				b2Vec2 v2 = b2->GetLinearVelocityFromLocalPoint(mp->localPoint2);
> 				cp.velocity = v2 - v1;
> 				cp.normal = m_manifold.normal;
> 				cp.separation = mp->separation;
> 				cp.id = mp->id;
> 				listener->Add(&cp);
> 			}
> 		}
> 		else
> 		{
> 			b2ManifoldPoint* mp0 = m0.points + 0;
> 			mp->normalImpulse = mp0->normalImpulse;
> 			mp->tangentImpulse = mp0->tangentImpulse;
> 
> 			if (listener)
> 			{
> 				cp.position = b1->GetWorldPoint(mp->localPoint1);
> 				b2Vec2 v1 = b1->GetLinearVelocityFromLocalPoint(mp->localPoint1);
> 				b2Vec2 v2 = b2->GetLinearVelocityFromLocalPoint(mp->localPoint2);
> 				cp.velocity = v2 - v1;
> 				cp.normal = m_manifold.normal;
> 				cp.separation = mp->separation;
> 				cp.id = mp->id;
> 				listener->Persist(&cp);
> 			}
> 		}
> 	}
> 	else
> 	{
> 		m_manifoldCount = 0;
> 		if (m0.pointCount > 0 && listener)
> 		{
> 			b2ManifoldPoint* mp0 = m0.points + 0;
> 			cp.position = b1->GetWorldPoint(mp0->localPoint1);
> 			b2Vec2 v1 = b1->GetLinearVelocityFromLocalPoint(mp0->localPoint1);
> 			b2Vec2 v2 = b2->GetLinearVelocityFromLocalPoint(mp0->localPoint2);
> 			cp.velocity = v2 - v1;
> 			cp.normal = m0.normal;
> 			cp.separation = mp0->separation;
> 			cp.id = mp0->id;
> 			listener->Remove(&cp);
> 		}
> 	}
diff -r -x './svn/*' native/Box2D/Dynamics/Contacts/.svn/text-base/b2CircleContact.h.svn-base ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Contacts/.svn/text-base/b2CircleContact.h.svn-base
2c2
< * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
19,20c19,20
< #ifndef B2_CIRCLE_CONTACT_H
< #define B2_CIRCLE_CONTACT_H
---
> #ifndef CIRCLE_CONTACT_H
> #define CIRCLE_CONTACT_H
22c22,24
< #include <Box2D/Dynamics/Contacts/b2Contact.h>
---
> #include "../../Common/b2Math.h"
> #include "../../Collision/b2Collision.h"
> #include "b2Contact.h"
29,30c31
< 	static b2Contact* Create(	b2Fixture* fixtureA, int32 indexA,
< 								b2Fixture* fixtureB, int32 indexB, b2BlockAllocator* allocator);
---
> 	static b2Contact* Create(b2Shape* shape1, b2Shape* shape2, b2BlockAllocator* allocator);
33c34
< 	b2CircleContact(b2Fixture* fixtureA, b2Fixture* fixtureB);
---
> 	b2CircleContact(b2Shape* shape1, b2Shape* shape2);
36c37,43
< 	void Evaluate(b2Manifold* manifold, const b2Transform& xfA, const b2Transform& xfB);
---
> 	void Evaluate(b2ContactListener* listener);
> 	b2Manifold* GetManifolds()
> 	{
> 		return &m_manifold;
> 	}
> 
> 	b2Manifold m_manifold;
diff -r -x './svn/*' native/Box2D/Dynamics/Contacts/.svn/text-base/b2Contact.cpp.svn-base ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Contacts/.svn/text-base/b2Contact.cpp.svn-base
2c2
< * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
19,35c19,30
< #include <Box2D/Dynamics/Contacts/b2Contact.h>
< #include <Box2D/Dynamics/Contacts/b2CircleContact.h>
< #include <Box2D/Dynamics/Contacts/b2PolygonAndCircleContact.h>
< #include <Box2D/Dynamics/Contacts/b2PolygonContact.h>
< #include <Box2D/Dynamics/Contacts/b2EdgeAndCircleContact.h>
< #include <Box2D/Dynamics/Contacts/b2EdgeAndPolygonContact.h>
< #include <Box2D/Dynamics/Contacts/b2ChainAndCircleContact.h>
< #include <Box2D/Dynamics/Contacts/b2ChainAndPolygonContact.h>
< #include <Box2D/Dynamics/Contacts/b2ContactSolver.h>
< 
< #include <Box2D/Collision/b2Collision.h>
< #include <Box2D/Collision/b2TimeOfImpact.h>
< #include <Box2D/Collision/Shapes/b2Shape.h>
< #include <Box2D/Common/b2BlockAllocator.h>
< #include <Box2D/Dynamics/b2Body.h>
< #include <Box2D/Dynamics/b2Fixture.h>
< #include <Box2D/Dynamics/b2World.h>
---
> #include "b2Contact.h"
> #include "b2CircleContact.h"
> #include "b2PolyAndCircleContact.h"
> #include "b2PolyContact.h"
> #include "b2EdgeAndCircleContact.h"
> #include "b2PolyAndEdgeContact.h"
> #include "b2ContactSolver.h"
> #include "../../Collision/b2Collision.h"
> #include "../../Collision/Shapes/b2Shape.h"
> #include "../../Common/b2BlockAllocator.h"
> #include "../../Dynamics/b2World.h"
> #include "../../Dynamics/b2Body.h"
37c32
< b2ContactRegister b2Contact::s_registers[b2Shape::e_typeCount][b2Shape::e_typeCount];
---
> b2ContactRegister b2Contact::s_registers[e_shapeTypeCount][e_shapeTypeCount];
42,48c37,42
< 	AddType(b2CircleContact::Create, b2CircleContact::Destroy, b2Shape::e_circle, b2Shape::e_circle);
< 	AddType(b2PolygonAndCircleContact::Create, b2PolygonAndCircleContact::Destroy, b2Shape::e_polygon, b2Shape::e_circle);
< 	AddType(b2PolygonContact::Create, b2PolygonContact::Destroy, b2Shape::e_polygon, b2Shape::e_polygon);
< 	AddType(b2EdgeAndCircleContact::Create, b2EdgeAndCircleContact::Destroy, b2Shape::e_edge, b2Shape::e_circle);
< 	AddType(b2EdgeAndPolygonContact::Create, b2EdgeAndPolygonContact::Destroy, b2Shape::e_edge, b2Shape::e_polygon);
< 	AddType(b2ChainAndCircleContact::Create, b2ChainAndCircleContact::Destroy, b2Shape::e_chain, b2Shape::e_circle);
< 	AddType(b2ChainAndPolygonContact::Create, b2ChainAndPolygonContact::Destroy, b2Shape::e_chain, b2Shape::e_polygon);
---
> 	AddType(b2CircleContact::Create, b2CircleContact::Destroy, e_circleShape, e_circleShape);
> 	AddType(b2PolyAndCircleContact::Create, b2PolyAndCircleContact::Destroy, e_polygonShape, e_circleShape);
> 	AddType(b2PolygonContact::Create, b2PolygonContact::Destroy, e_polygonShape, e_polygonShape);
> 	
> 	AddType(b2EdgeAndCircleContact::Create, b2EdgeAndCircleContact::Destroy, e_edgeShape, e_circleShape);
> 	AddType(b2PolyAndEdgeContact::Create, b2PolyAndEdgeContact::Destroy, e_polygonShape, e_edgeShape);
52c46
< 						b2Shape::Type type1, b2Shape::Type type2)
---
> 					  b2ShapeType type1, b2ShapeType type2)
54,55c48,49
< 	b2Assert(0 <= type1 && type1 < b2Shape::e_typeCount);
< 	b2Assert(0 <= type2 && type2 < b2Shape::e_typeCount);
---
> 	b2Assert(e_unknownShape < type1 && type1 < e_shapeTypeCount);
> 	b2Assert(e_unknownShape < type2 && type2 < e_shapeTypeCount);
69c63
< b2Contact* b2Contact::Create(b2Fixture* fixtureA, int32 indexA, b2Fixture* fixtureB, int32 indexB, b2BlockAllocator* allocator)
---
> b2Contact* b2Contact::Create(b2Shape* shape1, b2Shape* shape2, b2BlockAllocator* allocator)
77,78c71,72
< 	b2Shape::Type type1 = fixtureA->GetType();
< 	b2Shape::Type type2 = fixtureB->GetType();
---
> 	b2ShapeType type1 = shape1->GetType();
> 	b2ShapeType type2 = shape2->GetType();
80,81c74,75
< 	b2Assert(0 <= type1 && type1 < b2Shape::e_typeCount);
< 	b2Assert(0 <= type2 && type2 < b2Shape::e_typeCount);
---
> 	b2Assert(e_unknownShape < type1 && type1 < e_shapeTypeCount);
> 	b2Assert(e_unknownShape < type2 && type2 < e_shapeTypeCount);
88c82
< 			return createFcn(fixtureA, indexA, fixtureB, indexB, allocator);
---
> 			return createFcn(shape1, shape2, allocator);
92c86,92
< 			return createFcn(fixtureB, indexB, fixtureA, indexA, allocator);
---
> 			b2Contact* c = createFcn(shape2, shape1, allocator);
> 			for (int32 i = 0; i < c->GetManifoldCount(); ++i)
> 			{
> 				b2Manifold* m = c->GetManifolds() + i;
> 				m->normal = -m->normal;
> 			}
> 			return c;
105,110c105
< 	b2Fixture* fixtureA = contact->m_fixtureA;
< 	b2Fixture* fixtureB = contact->m_fixtureB;
< 
< 	if (contact->m_manifold.pointCount > 0 &&
< 		fixtureA->IsSensor() == false &&
< 		fixtureB->IsSensor() == false)
---
> 	if (contact->GetManifoldCount() > 0)
112,113c107,108
< 		fixtureA->GetBody()->SetAwake(true);
< 		fixtureB->GetBody()->SetAwake(true);
---
> 		contact->GetShape1()->GetBody()->WakeUp();
> 		contact->GetShape2()->GetBody()->WakeUp();
116,117c111,112
< 	b2Shape::Type typeA = fixtureA->GetType();
< 	b2Shape::Type typeB = fixtureB->GetType();
---
> 	b2ShapeType type1 = contact->GetShape1()->GetType();
> 	b2ShapeType type2 = contact->GetShape2()->GetType();
119,120c114,115
< 	b2Assert(0 <= typeA && typeB < b2Shape::e_typeCount);
< 	b2Assert(0 <= typeA && typeB < b2Shape::e_typeCount);
---
> 	b2Assert(e_unknownShape < type1 && type1 < e_shapeTypeCount);
> 	b2Assert(e_unknownShape < type2 && type2 < e_shapeTypeCount);
122c117
< 	b2ContactDestroyFcn* destroyFcn = s_registers[typeA][typeB].destroyFcn;
---
> 	b2ContactDestroyFcn* destroyFcn = s_registers[type1][type2].destroyFcn;
126c121
< b2Contact::b2Contact(b2Fixture* fA, int32 indexA, b2Fixture* fB, int32 indexB)
---
> b2Contact::b2Contact(b2Shape* s1, b2Shape* s2)
128c123
< 	m_flags = e_enabledFlag;
---
> 	m_flags = 0;
130,131c125,128
< 	m_fixtureA = fA;
< 	m_fixtureB = fB;
---
> 	if (s1->IsSensor() || s2->IsSensor())
> 	{
> 		m_flags |= e_nonSolidFlag;
> 	}
133,134c130,131
< 	m_indexA = indexA;
< 	m_indexB = indexB;
---
> 	m_shape1 = s1;
> 	m_shape2 = s2;
136c133
< 	m_manifold.pointCount = 0;
---
> 	m_manifoldCount = 0;
141,156c138,146
< 	m_nodeA.contact = NULL;
< 	m_nodeA.prev = NULL;
< 	m_nodeA.next = NULL;
< 	m_nodeA.other = NULL;
< 
< 	m_nodeB.contact = NULL;
< 	m_nodeB.prev = NULL;
< 	m_nodeB.next = NULL;
< 	m_nodeB.other = NULL;
< 
< 	m_toiCount = 0;
< 
< 	m_friction = b2MixFriction(m_fixtureA->m_friction, m_fixtureB->m_friction);
< 	m_restitution = b2MixRestitution(m_fixtureA->m_restitution, m_fixtureB->m_restitution);
< 
< 	m_tangentSpeed = 0.0f;
---
> 	m_node1.contact = NULL;
> 	m_node1.prev = NULL;
> 	m_node1.next = NULL;
> 	m_node1.other = NULL;
> 
> 	m_node2.contact = NULL;
> 	m_node2.prev = NULL;
> 	m_node2.next = NULL;
> 	m_node2.other = NULL;
159,160d148
< // Update the contact manifold and touching status.
< // Note: do not assume the fixture AABBs are overlapping or are valid.
163,166c151
< 	b2Manifold oldManifold = m_manifold;
< 
< 	// Re-enable this contact.
< 	m_flags |= e_enabledFlag;
---
> 	int32 oldCount = GetManifoldCount();
168,169c153
< 	bool touching = false;
< 	bool wasTouching = (m_flags & e_touchingFlag) == e_touchingFlag;
---
> 	Evaluate(listener);
171,173c155
< 	bool sensorA = m_fixtureA->IsSensor();
< 	bool sensorB = m_fixtureB->IsSensor();
< 	bool sensor = sensorA || sensorB;
---
> 	int32 newCount = GetManifoldCount();
175,185c157,158
< 	b2Body* bodyA = m_fixtureA->GetBody();
< 	b2Body* bodyB = m_fixtureB->GetBody();
< 	const b2Transform& xfA = bodyA->GetTransform();
< 	const b2Transform& xfB = bodyB->GetTransform();
< 
< 	// Is this contact a sensor?
< 	if (sensor)
< 	{
< 		const b2Shape* shapeA = m_fixtureA->GetShape();
< 		const b2Shape* shapeB = m_fixtureB->GetShape();
< 		touching = b2TestOverlap(shapeA, m_indexA, shapeB, m_indexB, xfA, xfB);
---
> 	b2Body* body1 = m_shape1->GetBody();
> 	b2Body* body2 = m_shape2->GetBody();
187,190c160
< 		// Sensors don't generate manifolds.
< 		m_manifold.pointCount = 0;
< 	}
< 	else
---
> 	if (newCount == 0 && oldCount > 0)
192,221c162,163
< 		Evaluate(&m_manifold, xfA, xfB);
< 		touching = m_manifold.pointCount > 0;
< 
< 		// Match old contact ids to new contact ids and copy the
< 		// stored impulses to warm start the solver.
< 		for (int32 i = 0; i < m_manifold.pointCount; ++i)
< 		{
< 			b2ManifoldPoint* mp2 = m_manifold.points + i;
< 			mp2->normalImpulse = 0.0f;
< 			mp2->tangentImpulse = 0.0f;
< 			b2ContactID id2 = mp2->id;
< 
< 			for (int32 j = 0; j < oldManifold.pointCount; ++j)
< 			{
< 				b2ManifoldPoint* mp1 = oldManifold.points + j;
< 
< 				if (mp1->id.key == id2.key)
< 				{
< 					mp2->normalImpulse = mp1->normalImpulse;
< 					mp2->tangentImpulse = mp1->tangentImpulse;
< 					break;
< 				}
< 			}
< 		}
< 
< 		if (touching != wasTouching)
< 		{
< 			bodyA->SetAwake(true);
< 			bodyB->SetAwake(true);
< 		}
---
> 		body1->WakeUp();
> 		body2->WakeUp();
224c166,167
< 	if (touching)
---
> 	// Slow contacts don't generate TOI events.
> 	if (body1->IsStatic() || body1->IsBullet() || body2->IsStatic() || body2->IsBullet())
226c169
< 		m_flags |= e_touchingFlag;
---
> 		m_flags &= ~e_slowFlag;
230,245c173
< 		m_flags &= ~e_touchingFlag;
< 	}
< 
< 	if (wasTouching == false && touching == true && listener)
< 	{
< 		listener->BeginContact(this);
< 	}
< 
< 	if (wasTouching == true && touching == false && listener)
< 	{
< 		listener->EndContact(this);
< 	}
< 
< 	if (sensor == false && touching && listener)
< 	{
< 		listener->PreSolve(this, &oldManifold);
---
> 		m_flags |= e_slowFlag;
diff -r -x './svn/*' native/Box2D/Dynamics/Contacts/.svn/text-base/b2Contact.h.svn-base ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Contacts/.svn/text-base/b2Contact.h.svn-base
2c2
< * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
19,20c19,20
< #ifndef B2_CONTACT_H
< #define B2_CONTACT_H
---
> #ifndef CONTACT_H
> #define CONTACT_H
22,25c22,24
< #include <Box2D/Common/b2Math.h>
< #include <Box2D/Collision/b2Collision.h>
< #include <Box2D/Collision/Shapes/b2Shape.h>
< #include <Box2D/Dynamics/b2Fixture.h>
---
> #include "../../Common/b2Math.h"
> #include "../../Collision/b2Collision.h"
> #include "../../Collision/Shapes/b2Shape.h"
29d27
< class b2Fixture;
35,51c33
< /// Friction mixing law. The idea is to allow either fixture to drive the restitution to zero.
< /// For example, anything slides on ice.
< inline float32 b2MixFriction(float32 friction1, float32 friction2)
< {
< 	return std::sqrt(friction1 * friction2);
< }
< 
< /// Restitution mixing law. The idea is allow for anything to bounce off an inelastic surface.
< /// For example, a superball bounces on anything.
< inline float32 b2MixRestitution(float32 restitution1, float32 restitution2)
< {
< 	return restitution1 > restitution2 ? restitution1 : restitution2;
< }
< 
< typedef b2Contact* b2ContactCreateFcn(	b2Fixture* fixtureA, int32 indexA,
< 										b2Fixture* fixtureB, int32 indexB,
< 										b2BlockAllocator* allocator);
---
> typedef b2Contact* b2ContactCreateFcn(b2Shape* shape1, b2Shape* shape2, b2BlockAllocator* allocator);
73a56,81
> /// This structure is used to report contact points.
> struct b2ContactPoint
> {
> 	b2Shape* shape1;		///< the first shape
> 	b2Shape* shape2;		///< the second shape
> 	b2Vec2 position;		///< position in world coordinates
> 	b2Vec2 velocity;		///< velocity of point on body2 relative to point on body1 (pre-solver)
> 	b2Vec2 normal;			///< points from shape1 to shape2
> 	float32 separation;		///< the separation is negative when shapes are touching
> 	float32 friction;		///< the combined friction coefficient
> 	float32 restitution;	///< the combined restitution coefficient
> 	b2ContactID id;			///< the contact id identifies the features in contact
> };
> 
> /// This structure is used to report contact point results.
> struct b2ContactResult
> {
> 	b2Shape* shape1;		///< the first shape
> 	b2Shape* shape2;		///< the second shape
> 	b2Vec2 position;		///< position in world coordinates
> 	b2Vec2 normal;			///< points from shape1 to shape2
> 	float32 normalImpulse;	///< the normal impulse applied to body2
> 	float32 tangentImpulse;	///< the tangent impulse applied to body2
> 	b2ContactID id;			///< the contact id identifies the features in contact
> };
> 
81,95c89,90
< 	/// Get the contact manifold. Do not modify the manifold unless you understand the
< 	/// internals of Box2D.
< 	b2Manifold* GetManifold();
< 	const b2Manifold* GetManifold() const;
< 
< 	/// Get the world manifold.
< 	void GetWorldManifold(b2WorldManifold* worldManifold) const;
< 
< 	/// Is this contact touching?
< 	bool IsTouching() const;
< 
< 	/// Enable/disable this contact. This can be used inside the pre-solve
< 	/// contact listener. The contact is only disabled for the current
< 	/// time step (or sub-step in continuous collisions).
< 	void SetEnabled(bool flag);
---
> 	/// Get the manifold array.
> 	virtual b2Manifold* GetManifolds() = 0;
97,98c92,99
< 	/// Has this contact been disabled?
< 	bool IsEnabled() const;
---
> 	/// Get the number of manifolds. This is 0 or 1 between convex shapes.
> 	/// This may be greater than 1 for convex-vs-concave shapes. Each
> 	/// manifold holds up to two contact points with a shared contact normal.
> 	int32 GetManifoldCount() const;
> 
> 	/// Is this contact solid?
> 	/// @return true if this contact should generate a response.
> 	bool IsSolid() const;
102d102
< 	const b2Contact* GetNext() const;
104,106c104,105
< 	/// Get fixture A in this contact.
< 	b2Fixture* GetFixtureA();
< 	const b2Fixture* GetFixtureA() const;
---
> 	/// Get the first shape in this contact.
> 	b2Shape* GetShape1();
108,109c107,108
< 	/// Get the child primitive index for fixture A.
< 	int32 GetChildIndexA() const;
---
> 	/// Get the second shape in this contact.
> 	b2Shape* GetShape2();
111,152c110,111
< 	/// Get fixture B in this contact.
< 	b2Fixture* GetFixtureB();
< 	const b2Fixture* GetFixtureB() const;
< 
< 	/// Get the child primitive index for fixture B.
< 	int32 GetChildIndexB() const;
< 
< 	/// Override the default friction mixture. You can call this in b2ContactListener::PreSolve.
< 	/// This value persists until set or reset.
< 	void SetFriction(float32 friction);
< 
< 	/// Get the friction.
< 	float32 GetFriction() const;
< 
< 	/// Reset the friction mixture to the default value.
< 	void ResetFriction();
< 
< 	/// Override the default restitution mixture. You can call this in b2ContactListener::PreSolve.
< 	/// The value persists until you set or reset.
< 	void SetRestitution(float32 restitution);
< 
< 	/// Get the restitution.
< 	float32 GetRestitution() const;
< 
< 	/// Reset the restitution to the default value.
< 	void ResetRestitution();
< 
< 	/// Set the desired tangent speed for a conveyor belt behavior. In meters per second.
< 	void SetTangentSpeed(float32 speed);
< 
< 	/// Get the desired tangent speed. In meters per second.
< 	float32 GetTangentSpeed() const;
< 
< 	/// Evaluate this contact with your own manifold and transforms.
< 	virtual void Evaluate(b2Manifold* manifold, const b2Transform& xfA, const b2Transform& xfB) = 0;
< 
< protected:
< 	friend class b2ContactManager;
< 	friend class b2World;
< 	friend class b2ContactSolver;
< 	friend class b2Body;
< 	friend class b2Fixture;
---
> 	//--------------- Internals Below -------------------
> public:
154c113
< 	// Flags stored in m_flags
---
> 	// m_flags
157,173c116,119
< 		// Used when crawling contact graph when forming islands.
< 		e_islandFlag		= 0x0001,
< 
<         // Set when the shapes are touching.
< 		e_touchingFlag		= 0x0002,
< 
< 		// This contact can be disabled (by user)
< 		e_enabledFlag		= 0x0004,
< 
< 		// This contact needs filtering because a fixture filter was changed.
< 		e_filterFlag		= 0x0008,
< 
< 		// This bullet contact had a TOI event
< 		e_bulletHitFlag		= 0x0010,
< 
< 		// This contact has a valid TOI in m_toi
< 		e_toiFlag			= 0x0020
---
> 		e_nonSolidFlag	= 0x0001,
> 		e_slowFlag		= 0x0002,
> 		e_islandFlag	= 0x0004,
> 		e_toiFlag		= 0x0008,
176,178d121
< 	/// Flag this contact for filtering. Filtering will occur the next time step.
< 	void FlagForFiltering();
< 
180c123
< 						b2Shape::Type typeA, b2Shape::Type typeB);
---
> 						b2ShapeType type1, b2ShapeType type2);
182,183c125
< 	static b2Contact* Create(b2Fixture* fixtureA, int32 indexA, b2Fixture* fixtureB, int32 indexB, b2BlockAllocator* allocator);
< 	static void Destroy(b2Contact* contact, b2Shape::Type typeA, b2Shape::Type typeB, b2BlockAllocator* allocator);
---
> 	static b2Contact* Create(b2Shape* shape1, b2Shape* shape2, b2BlockAllocator* allocator);
186,187c128,129
< 	b2Contact() : m_fixtureA(NULL), m_fixtureB(NULL) {}
< 	b2Contact(b2Fixture* fixtureA, int32 indexA, b2Fixture* fixtureB, int32 indexB);
---
> 	b2Contact() : m_shape1(NULL), m_shape2(NULL) {}
> 	b2Contact(b2Shape* shape1, b2Shape* shape2);
191,192c133,134
< 
< 	static b2ContactRegister s_registers[b2Shape::e_typeCount][b2Shape::e_typeCount];
---
> 	virtual void Evaluate(b2ContactListener* listener) = 0;
> 	static b2ContactRegister s_registers[e_shapeTypeCount][e_shapeTypeCount];
195a138
> 	int32 m_manifoldCount;
202,209c145,146
< 	b2ContactEdge m_nodeA;
< 	b2ContactEdge m_nodeB;
< 
< 	b2Fixture* m_fixtureA;
< 	b2Fixture* m_fixtureB;
< 
< 	int32 m_indexA;
< 	int32 m_indexB;
---
> 	b2ContactEdge m_node1;
> 	b2ContactEdge m_node2;
211c148,149
< 	b2Manifold m_manifold;
---
> 	b2Shape* m_shape1;
> 	b2Shape* m_shape2;
213d150
< 	int32 m_toiCount;
215,219d151
< 
< 	float32 m_friction;
< 	float32 m_restitution;
< 
< 	float32 m_tangentSpeed;
222c154
< inline b2Manifold* b2Contact::GetManifold()
---
> inline int32 b2Contact::GetManifoldCount() const
224,251c156
< 	return &m_manifold;
< }
< 
< inline const b2Manifold* b2Contact::GetManifold() const
< {
< 	return &m_manifold;
< }
< 
< inline void b2Contact::GetWorldManifold(b2WorldManifold* worldManifold) const
< {
< 	const b2Body* bodyA = m_fixtureA->GetBody();
< 	const b2Body* bodyB = m_fixtureB->GetBody();
< 	const b2Shape* shapeA = m_fixtureA->GetShape();
< 	const b2Shape* shapeB = m_fixtureB->GetShape();
< 
< 	worldManifold->Initialize(&m_manifold, bodyA->GetTransform(), shapeA->m_radius, bodyB->GetTransform(), shapeB->m_radius);
< }
< 
< inline void b2Contact::SetEnabled(bool flag)
< {
< 	if (flag)
< 	{
< 		m_flags |= e_enabledFlag;
< 	}
< 	else
< 	{
< 		m_flags &= ~e_enabledFlag;
< 	}
---
> 	return m_manifoldCount;
254c159
< inline bool b2Contact::IsEnabled() const
---
> inline bool b2Contact::IsSolid() const
256,261c161
< 	return (m_flags & e_enabledFlag) == e_enabledFlag;
< }
< 
< inline bool b2Contact::IsTouching() const
< {
< 	return (m_flags & e_touchingFlag) == e_touchingFlag;
---
> 	return (m_flags & e_nonSolidFlag) == 0;
269,339c169
< inline const b2Contact* b2Contact::GetNext() const
< {
< 	return m_next;
< }
< 
< inline b2Fixture* b2Contact::GetFixtureA()
< {
< 	return m_fixtureA;
< }
< 
< inline const b2Fixture* b2Contact::GetFixtureA() const
< {
< 	return m_fixtureA;
< }
< 
< inline b2Fixture* b2Contact::GetFixtureB()
< {
< 	return m_fixtureB;
< }
< 
< inline int32 b2Contact::GetChildIndexA() const
< {
< 	return m_indexA;
< }
< 
< inline const b2Fixture* b2Contact::GetFixtureB() const
< {
< 	return m_fixtureB;
< }
< 
< inline int32 b2Contact::GetChildIndexB() const
< {
< 	return m_indexB;
< }
< 
< inline void b2Contact::FlagForFiltering()
< {
< 	m_flags |= e_filterFlag;
< }
< 
< inline void b2Contact::SetFriction(float32 friction)
< {
< 	m_friction = friction;
< }
< 
< inline float32 b2Contact::GetFriction() const
< {
< 	return m_friction;
< }
< 
< inline void b2Contact::ResetFriction()
< {
< 	m_friction = b2MixFriction(m_fixtureA->m_friction, m_fixtureB->m_friction);
< }
< 
< inline void b2Contact::SetRestitution(float32 restitution)
< {
< 	m_restitution = restitution;
< }
< 
< inline float32 b2Contact::GetRestitution() const
< {
< 	return m_restitution;
< }
< 
< inline void b2Contact::ResetRestitution()
< {
< 	m_restitution = b2MixRestitution(m_fixtureA->m_restitution, m_fixtureB->m_restitution);
< }
< 
< inline void b2Contact::SetTangentSpeed(float32 speed)
---
> inline b2Shape* b2Contact::GetShape1()
341c171
< 	m_tangentSpeed = speed;
---
> 	return m_shape1;
344c174
< inline float32 b2Contact::GetTangentSpeed() const
---
> inline b2Shape* b2Contact::GetShape2()
346c176
< 	return m_tangentSpeed;
---
> 	return m_shape2;
diff -r -x './svn/*' native/Box2D/Dynamics/Contacts/.svn/text-base/b2ContactSolver.cpp.svn-base ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Contacts/.svn/text-base/b2ContactSolver.cpp.svn-base
2c2
< * Copyright (c) 2006-2011 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
19,25c19,23
< #include <Box2D/Dynamics/Contacts/b2ContactSolver.h>
< 
< #include <Box2D/Dynamics/Contacts/b2Contact.h>
< #include <Box2D/Dynamics/b2Body.h>
< #include <Box2D/Dynamics/b2Fixture.h>
< #include <Box2D/Dynamics/b2World.h>
< #include <Box2D/Common/b2StackAllocator.h>
---
> #include "b2ContactSolver.h"
> #include "b2Contact.h"
> #include "../b2Body.h"
> #include "../b2World.h"
> #include "../../Common/b2StackAllocator.h"
29,44c27
< struct b2ContactPositionConstraint
< {
< 	b2Vec2 localPoints[b2_maxManifoldPoints];
< 	b2Vec2 localNormal;
< 	b2Vec2 localPoint;
< 	int32 indexA;
< 	int32 indexB;
< 	float32 invMassA, invMassB;
< 	b2Vec2 localCenterA, localCenterB;
< 	float32 invIA, invIB;
< 	b2Manifold::Type type;
< 	float32 radiusA, radiusB;
< 	int32 pointCount;
< };
< 
< b2ContactSolver::b2ContactSolver(b2ContactSolverDef* def)
---
> b2ContactSolver::b2ContactSolver(const b2TimeStep& step, b2Contact** contacts, int32 contactCount, b2StackAllocator* allocator)
46,53c29,30
< 	m_step = def->step;
< 	m_allocator = def->allocator;
< 	m_count = def->count;
< 	m_positionConstraints = (b2ContactPositionConstraint*)m_allocator->Allocate(m_count * sizeof(b2ContactPositionConstraint));
< 	m_velocityConstraints = (b2ContactVelocityConstraint*)m_allocator->Allocate(m_count * sizeof(b2ContactVelocityConstraint));
< 	m_positions = def->positions;
< 	m_velocities = def->velocities;
< 	m_contacts = def->contacts;
---
> 	m_step = step;
> 	m_allocator = allocator;
55,56c32,33
< 	// Initialize position independent portions of the constraints.
< 	for (int32 i = 0; i < m_count; ++i)
---
> 	m_constraintCount = 0;
> 	for (int32 i = 0; i < contactCount; ++i)
58,127c35,36
< 		b2Contact* contact = m_contacts[i];
< 
< 		b2Fixture* fixtureA = contact->m_fixtureA;
< 		b2Fixture* fixtureB = contact->m_fixtureB;
< 		b2Shape* shapeA = fixtureA->GetShape();
< 		b2Shape* shapeB = fixtureB->GetShape();
< 		float32 radiusA = shapeA->m_radius;
< 		float32 radiusB = shapeB->m_radius;
< 		b2Body* bodyA = fixtureA->GetBody();
< 		b2Body* bodyB = fixtureB->GetBody();
< 		b2Manifold* manifold = contact->GetManifold();
< 
< 		int32 pointCount = manifold->pointCount;
< 		b2Assert(pointCount > 0);
< 
< 		b2ContactVelocityConstraint* vc = m_velocityConstraints + i;
< 		vc->friction = contact->m_friction;
< 		vc->restitution = contact->m_restitution;
< 		vc->tangentSpeed = contact->m_tangentSpeed;
< 		vc->indexA = bodyA->m_islandIndex;
< 		vc->indexB = bodyB->m_islandIndex;
< 		vc->invMassA = bodyA->m_invMass;
< 		vc->invMassB = bodyB->m_invMass;
< 		vc->invIA = bodyA->m_invI;
< 		vc->invIB = bodyB->m_invI;
< 		vc->contactIndex = i;
< 		vc->pointCount = pointCount;
< 		vc->K.SetZero();
< 		vc->normalMass.SetZero();
< 
< 		b2ContactPositionConstraint* pc = m_positionConstraints + i;
< 		pc->indexA = bodyA->m_islandIndex;
< 		pc->indexB = bodyB->m_islandIndex;
< 		pc->invMassA = bodyA->m_invMass;
< 		pc->invMassB = bodyB->m_invMass;
< 		pc->localCenterA = bodyA->m_sweep.localCenter;
< 		pc->localCenterB = bodyB->m_sweep.localCenter;
< 		pc->invIA = bodyA->m_invI;
< 		pc->invIB = bodyB->m_invI;
< 		pc->localNormal = manifold->localNormal;
< 		pc->localPoint = manifold->localPoint;
< 		pc->pointCount = pointCount;
< 		pc->radiusA = radiusA;
< 		pc->radiusB = radiusB;
< 		pc->type = manifold->type;
< 
< 		for (int32 j = 0; j < pointCount; ++j)
< 		{
< 			b2ManifoldPoint* cp = manifold->points + j;
< 			b2VelocityConstraintPoint* vcp = vc->points + j;
< 	
< 			if (m_step.warmStarting)
< 			{
< 				vcp->normalImpulse = m_step.dtRatio * cp->normalImpulse;
< 				vcp->tangentImpulse = m_step.dtRatio * cp->tangentImpulse;
< 			}
< 			else
< 			{
< 				vcp->normalImpulse = 0.0f;
< 				vcp->tangentImpulse = 0.0f;
< 			}
< 
< 			vcp->rA.SetZero();
< 			vcp->rB.SetZero();
< 			vcp->normalMass = 0.0f;
< 			vcp->tangentMass = 0.0f;
< 			vcp->velocityBias = 0.0f;
< 
< 			pc->localPoints[j] = cp->localPoint;
< 		}
---
> 		b2Assert(contacts[i]->IsSolid());
> 		m_constraintCount += contacts[i]->GetManifoldCount();
129d37
< }
131,135c39
< b2ContactSolver::~b2ContactSolver()
< {
< 	m_allocator->Free(m_velocityConstraints);
< 	m_allocator->Free(m_positionConstraints);
< }
---
> 	m_constraints = (b2ContactConstraint*)m_allocator->Allocate(m_constraintCount * sizeof(b2ContactConstraint));
137,140c41,42
< // Initialize position dependent portions of the velocity constraints.
< void b2ContactSolver::InitializeVelocityConstraints()
< {
< 	for (int32 i = 0; i < m_count; ++i)
---
> 	int32 count = 0;
> 	for (int32 i = 0; i < contactCount; ++i)
142,175c44
< 		b2ContactVelocityConstraint* vc = m_velocityConstraints + i;
< 		b2ContactPositionConstraint* pc = m_positionConstraints + i;
< 
< 		float32 radiusA = pc->radiusA;
< 		float32 radiusB = pc->radiusB;
< 		b2Manifold* manifold = m_contacts[vc->contactIndex]->GetManifold();
< 
< 		int32 indexA = vc->indexA;
< 		int32 indexB = vc->indexB;
< 
< 		float32 mA = vc->invMassA;
< 		float32 mB = vc->invMassB;
< 		float32 iA = vc->invIA;
< 		float32 iB = vc->invIB;
< 		b2Vec2 localCenterA = pc->localCenterA;
< 		b2Vec2 localCenterB = pc->localCenterB;
< 
< 		b2Vec2 cA = m_positions[indexA].c;
< 		float32 aA = m_positions[indexA].a;
< 		b2Vec2 vA = m_velocities[indexA].v;
< 		float32 wA = m_velocities[indexA].w;
< 
< 		b2Vec2 cB = m_positions[indexB].c;
< 		float32 aB = m_positions[indexB].a;
< 		b2Vec2 vB = m_velocities[indexB].v;
< 		float32 wB = m_velocities[indexB].w;
< 
< 		b2Assert(manifold->pointCount > 0);
< 
< 		b2Transform xfA, xfB;
< 		xfA.q.Set(aA);
< 		xfB.q.Set(aB);
< 		xfA.p = cA - b2Mul(xfA.q, localCenterA);
< 		xfB.p = cB - b2Mul(xfB.q, localCenterB);
---
> 		b2Contact* contact = contacts[i];
177,178c46,77
< 		b2WorldManifold worldManifold;
< 		worldManifold.Initialize(manifold, xfA, radiusA, xfB, radiusB);
---
> 		b2Shape* shape1 = contact->m_shape1;
> 		b2Shape* shape2 = contact->m_shape2;
> 		b2Body* b1 = shape1->GetBody();
> 		b2Body* b2 = shape2->GetBody();
> 		int32 manifoldCount = contact->GetManifoldCount();
> 		b2Manifold* manifolds = contact->GetManifolds();
> 
> 		float32 friction = b2MixFriction(shape1->GetFriction(), shape2->GetFriction());
> 		float32 restitution = b2MixRestitution(shape1->GetRestitution(), shape2->GetRestitution());
> 
> 		b2Vec2 v1 = b1->m_linearVelocity;
> 		b2Vec2 v2 = b2->m_linearVelocity;
> 		float32 w1 = b1->m_angularVelocity;
> 		float32 w2 = b2->m_angularVelocity;
> 
> 		for (int32 j = 0; j < manifoldCount; ++j)
> 		{
> 			b2Manifold* manifold = manifolds + j;
> 
> 			b2Assert(manifold->pointCount > 0);
> 
> 			const b2Vec2 normal = manifold->normal;
> 
> 			b2Assert(count < m_constraintCount);
> 			b2ContactConstraint* cc = m_constraints + count;
> 			cc->body1 = b1;
> 			cc->body2 = b2;
> 			cc->manifold = manifold;
> 			cc->normal = normal;
> 			cc->pointCount = manifold->pointCount;
> 			cc->friction = friction;
> 			cc->restitution = restitution;
180,185c79,82
< 		vc->normal = worldManifold.normal;
< 
< 		int32 pointCount = vc->pointCount;
< 		for (int32 j = 0; j < pointCount; ++j)
< 		{
< 			b2VelocityConstraintPoint* vcp = vc->points + j;
---
> 			for (int32 k = 0; k < cc->pointCount; ++k)
> 			{
> 				b2ManifoldPoint* cp = manifold->points + k;
> 				b2ContactConstraintPoint* ccp = cc->points + k;
187,188c84,86
< 			vcp->rA = worldManifold.points[j] - cA;
< 			vcp->rB = worldManifold.points[j] - cB;
---
> 				ccp->normalImpulse = cp->normalImpulse;
> 				ccp->tangentImpulse = cp->tangentImpulse;
> 				ccp->separation = cp->separation;
190,191c88,91
< 			float32 rnA = b2Cross(vcp->rA, vc->normal);
< 			float32 rnB = b2Cross(vcp->rB, vc->normal);
---
> 				ccp->localAnchor1 = cp->localPoint1;
> 				ccp->localAnchor2 = cp->localPoint2;
> 				ccp->r1 = b2Mul(b1->GetXForm().R, cp->localPoint1 - b1->GetLocalCenter());
> 				ccp->r2 = b2Mul(b2->GetXForm().R, cp->localPoint2 - b2->GetLocalCenter());
193c93,96
< 			float32 kNormal = mA + mB + iA * rnA * rnA + iB * rnB * rnB;
---
> 				float32 rn1 = b2Cross(ccp->r1, normal);
> 				float32 rn2 = b2Cross(ccp->r2, normal);
> 				rn1 *= rn1;
> 				rn2 *= rn2;
195c98
< 			vcp->normalMass = kNormal > 0.0f ? 1.0f / kNormal : 0.0f;
---
> 				float32 kNormal = b1->m_invMass + b2->m_invMass + b1->m_invI * rn1 + b2->m_invI * rn2;
197c100,101
< 			b2Vec2 tangent = b2Cross(vc->normal, 1.0f);
---
> 				b2Assert(kNormal > B2_FLT_EPSILON);
> 				ccp->normalMass = 1.0f / kNormal;
199,200c103,104
< 			float32 rtA = b2Cross(vcp->rA, tangent);
< 			float32 rtB = b2Cross(vcp->rB, tangent);
---
> 				float32 kEqualized = b1->m_mass * b1->m_invMass + b2->m_mass * b2->m_invMass;
> 				kEqualized += b1->m_mass * b1->m_invI * rn1 + b2->m_mass * b2->m_invI * rn2;
202c106,107
< 			float32 kTangent = mA + mB + iA * rtA * rtA + iB * rtB * rtB;
---
> 				b2Assert(kEqualized > B2_FLT_EPSILON);
> 				ccp->equalizedMass = 1.0f / kEqualized;
204c109
< 			vcp->tangentMass = kTangent > 0.0f ? 1.0f /  kTangent : 0.0f;
---
> 				b2Vec2 tangent = b2Cross(normal, 1.0f);
206,213c111,114
< 			// Setup a velocity bias for restitution.
< 			vcp->velocityBias = 0.0f;
< 			float32 vRel = b2Dot(vc->normal, vB + b2Cross(wB, vcp->rB) - vA - b2Cross(wA, vcp->rA));
< 			if (vRel < -b2_velocityThreshold)
< 			{
< 				vcp->velocityBias = -vc->restitution * vRel;
< 			}
< 		}
---
> 				float32 rt1 = b2Cross(ccp->r1, tangent);
> 				float32 rt2 = b2Cross(ccp->r2, tangent);
> 				rt1 *= rt1;
> 				rt2 *= rt2;
215,219c116
< 		// If we have two points, then prepare the block solver.
< 		if (vc->pointCount == 2)
< 		{
< 			b2VelocityConstraintPoint* vcp1 = vc->points + 0;
< 			b2VelocityConstraintPoint* vcp2 = vc->points + 1;
---
> 				float32 kTangent = b1->m_invMass + b2->m_invMass + b1->m_invI * rt1 + b2->m_invI * rt2;
221,228c118,119
< 			float32 rn1A = b2Cross(vcp1->rA, vc->normal);
< 			float32 rn1B = b2Cross(vcp1->rB, vc->normal);
< 			float32 rn2A = b2Cross(vcp2->rA, vc->normal);
< 			float32 rn2B = b2Cross(vcp2->rB, vc->normal);
< 
< 			float32 k11 = mA + mB + iA * rn1A * rn1A + iB * rn1B * rn1B;
< 			float32 k22 = mA + mB + iA * rn2A * rn2A + iB * rn2B * rn2B;
< 			float32 k12 = mA + mB + iA * rn1A * rn2A + iB * rn1B * rn2B;
---
> 				b2Assert(kTangent > B2_FLT_EPSILON);
> 				ccp->tangentMass = 1.0f /  kTangent;
230,237c121,134
< 			// Ensure a reasonable condition number.
< 			const float32 k_maxConditionNumber = 1000.0f;
< 			if (k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12))
< 			{
< 				// K is safe to invert.
< 				vc->K.ex.Set(k11, k12);
< 				vc->K.ey.Set(k12, k22);
< 				vc->normalMass = vc->K.GetInverse();
---
> 				// Setup a velocity bias for restitution.
> 				ccp->velocityBias = 0.0f;
> 				if (ccp->separation > 0.0f)
> 				{
> 					ccp->velocityBias = -step.inv_dt * ccp->separation; // TODO_ERIN b2TimeStep
> 				}
> 				else
> 				{
> 					float32 vRel = b2Dot(cc->normal, v2 + b2Cross(w2, ccp->r2) - v1 - b2Cross(w1, ccp->r1));
> 					if (vRel < -b2_velocityThreshold)
> 					{
> 						ccp->velocityBias = -cc->restitution * vRel;
> 					}
> 				}
239c136,138
< 			else
---
> 
> 			// If we have two points, then prepare the block solver.
> 			if (cc->pointCount == 2)
241,243c140,171
< 				// The constraints are redundant, just use one.
< 				// TODO_ERIN use deepest?
< 				vc->pointCount = 1;
---
> 				b2ContactConstraintPoint* ccp1 = cc->points + 0;
> 				b2ContactConstraintPoint* ccp2 = cc->points + 1;
> 				
> 				float32 invMass1 = b1->m_invMass;
> 				float32 invI1 = b1->m_invI;
> 				float32 invMass2 = b2->m_invMass;
> 				float32 invI2 = b2->m_invI;
> 
> 				float32 rn11 = b2Cross(ccp1->r1, normal);
> 				float32 rn12 = b2Cross(ccp1->r2, normal);
> 				float32 rn21 = b2Cross(ccp2->r1, normal);
> 				float32 rn22 = b2Cross(ccp2->r2, normal);
> 
> 				float32 k11 = invMass1 + invMass2 + invI1 * rn11 * rn11 + invI2 * rn12 * rn12;
> 				float32 k22 = invMass1 + invMass2 + invI1 * rn21 * rn21 + invI2 * rn22 * rn22;
> 				float32 k12 = invMass1 + invMass2 + invI1 * rn11 * rn21 + invI2 * rn12 * rn22;
> 
> 				// Ensure a reasonable condition number.
> 				const float32 k_maxConditionNumber = 100.0f;
> 				if (k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12))
> 				{
> 					// K is safe to invert.
> 					cc->K.col1.Set(k11, k12);
> 					cc->K.col2.Set(k12, k22);
> 					cc->normalMass = cc->K.GetInverse();
> 				}
> 				else
> 				{
> 					// The constraints are redundant, just use one.
> 					// TODO_ERIN use deepest?
> 					cc->pointCount = 1;
> 				}
244a173,174
> 
> 			++count;
246a177,183
> 
> 	b2Assert(count == m_constraintCount);
> }
> 
> b2ContactSolver::~b2ContactSolver()
> {
> 	m_allocator->Free(m_constraints);
249c186
< void b2ContactSolver::WarmStart()
---
> void b2ContactSolver::InitVelocityConstraints(const b2TimeStep& step)
252c189
< 	for (int32 i = 0; i < m_count; ++i)
---
> 	for (int32 i = 0; i < m_constraintCount; ++i)
254,267c191
< 		b2ContactVelocityConstraint* vc = m_velocityConstraints + i;
< 
< 		int32 indexA = vc->indexA;
< 		int32 indexB = vc->indexB;
< 		float32 mA = vc->invMassA;
< 		float32 iA = vc->invIA;
< 		float32 mB = vc->invMassB;
< 		float32 iB = vc->invIB;
< 		int32 pointCount = vc->pointCount;
< 
< 		b2Vec2 vA = m_velocities[indexA].v;
< 		float32 wA = m_velocities[indexA].w;
< 		b2Vec2 vB = m_velocities[indexB].v;
< 		float32 wB = m_velocities[indexB].w;
---
> 		b2ContactConstraint* c = m_constraints + i;
269c193,199
< 		b2Vec2 normal = vc->normal;
---
> 		b2Body* b1 = c->body1;
> 		b2Body* b2 = c->body2;
> 		float32 invMass1 = b1->m_invMass;
> 		float32 invI1 = b1->m_invI;
> 		float32 invMass2 = b2->m_invMass;
> 		float32 invI2 = b2->m_invI;
> 		b2Vec2 normal = c->normal;
272c202,216
< 		for (int32 j = 0; j < pointCount; ++j)
---
> 		if (step.warmStarting)
> 		{
> 			for (int32 j = 0; j < c->pointCount; ++j)
> 			{
> 				b2ContactConstraintPoint* ccp = c->points + j;
> 				ccp->normalImpulse *= step.dtRatio;
> 				ccp->tangentImpulse *= step.dtRatio;
> 				b2Vec2 P = ccp->normalImpulse * normal + ccp->tangentImpulse * tangent;
> 				b1->m_angularVelocity -= invI1 * b2Cross(ccp->r1, P);
> 				b1->m_linearVelocity -= invMass1 * P;
> 				b2->m_angularVelocity += invI2 * b2Cross(ccp->r2, P);
> 				b2->m_linearVelocity += invMass2 * P;
> 			}
> 		}
> 		else
274,279c218,223
< 			b2VelocityConstraintPoint* vcp = vc->points + j;
< 			b2Vec2 P = vcp->normalImpulse * normal + vcp->tangentImpulse * tangent;
< 			wA -= iA * b2Cross(vcp->rA, P);
< 			vA -= mA * P;
< 			wB += iB * b2Cross(vcp->rB, P);
< 			vB += mB * P;
---
> 			for (int32 j = 0; j < c->pointCount; ++j)
> 			{
> 				b2ContactConstraintPoint* ccp = c->points + j;
> 				ccp->normalImpulse = 0.0f;
> 				ccp->tangentImpulse = 0.0f;
> 			}
281,285d224
< 
< 		m_velocities[indexA].v = vA;
< 		m_velocities[indexA].w = wA;
< 		m_velocities[indexB].v = vB;
< 		m_velocities[indexB].w = wB;
291c230
< 	for (int32 i = 0; i < m_count; ++i)
---
> 	for (int32 i = 0; i < m_constraintCount; ++i)
293,308c232,243
< 		b2ContactVelocityConstraint* vc = m_velocityConstraints + i;
< 
< 		int32 indexA = vc->indexA;
< 		int32 indexB = vc->indexB;
< 		float32 mA = vc->invMassA;
< 		float32 iA = vc->invIA;
< 		float32 mB = vc->invMassB;
< 		float32 iB = vc->invIB;
< 		int32 pointCount = vc->pointCount;
< 
< 		b2Vec2 vA = m_velocities[indexA].v;
< 		float32 wA = m_velocities[indexA].w;
< 		b2Vec2 vB = m_velocities[indexB].v;
< 		float32 wB = m_velocities[indexB].w;
< 
< 		b2Vec2 normal = vc->normal;
---
> 		b2ContactConstraint* c = m_constraints + i;
> 		b2Body* b1 = c->body1;
> 		b2Body* b2 = c->body2;
> 		float32 w1 = b1->m_angularVelocity;
> 		float32 w2 = b2->m_angularVelocity;
> 		b2Vec2 v1 = b1->m_linearVelocity;
> 		b2Vec2 v2 = b2->m_linearVelocity;
> 		float32 invMass1 = b1->m_invMass;
> 		float32 invI1 = b1->m_invI;
> 		float32 invMass2 = b2->m_invMass;
> 		float32 invI2 = b2->m_invI;
> 		b2Vec2 normal = c->normal;
310c245
< 		float32 friction = vc->friction;
---
> 		float32 friction = c->friction;
312,341c247
< 		b2Assert(pointCount == 1 || pointCount == 2);
< 
< 		// Solve tangent constraints first because non-penetration is more important
< 		// than friction.
< 		for (int32 j = 0; j < pointCount; ++j)
< 		{
< 			b2VelocityConstraintPoint* vcp = vc->points + j;
< 
< 			// Relative velocity at contact
< 			b2Vec2 dv = vB + b2Cross(wB, vcp->rB) - vA - b2Cross(wA, vcp->rA);
< 
< 			// Compute tangent force
< 			float32 vt = b2Dot(dv, tangent) - vc->tangentSpeed;
< 			float32 lambda = vcp->tangentMass * (-vt);
< 
< 			// b2Clamp the accumulated force
< 			float32 maxFriction = friction * vcp->normalImpulse;
< 			float32 newImpulse = b2Clamp(vcp->tangentImpulse + lambda, -maxFriction, maxFriction);
< 			lambda = newImpulse - vcp->tangentImpulse;
< 			vcp->tangentImpulse = newImpulse;
< 
< 			// Apply contact impulse
< 			b2Vec2 P = lambda * tangent;
< 
< 			vA -= mA * P;
< 			wA -= iA * b2Cross(vcp->rA, P);
< 
< 			vB += mB * P;
< 			wB += iB * b2Cross(vcp->rB, P);
< 		}
---
> 		b2Assert(c->pointCount == 1 || c->pointCount == 2);
344c250
< 		if (vc->pointCount == 1)
---
> 		if (c->pointCount == 1)
346c252
< 			b2VelocityConstraintPoint* vcp = vc->points + 0;
---
> 			b2ContactConstraintPoint* ccp = c->points + 0;
349c255
< 			b2Vec2 dv = vB + b2Cross(wB, vcp->rB) - vA - b2Cross(wA, vcp->rA);
---
> 			b2Vec2 dv = v2 + b2Cross(w2, ccp->r2) - v1 - b2Cross(w1, ccp->r1);
353c259
< 			float32 lambda = -vcp->normalMass * (vn - vcp->velocityBias);
---
> 			float32 lambda = -ccp->normalMass * (vn - ccp->velocityBias);
356,358c262,263
< 			float32 newImpulse = b2Max(vcp->normalImpulse + lambda, 0.0f);
< 			lambda = newImpulse - vcp->normalImpulse;
< 			vcp->normalImpulse = newImpulse;
---
> 			float32 newImpulse = b2Max(ccp->normalImpulse + lambda, 0.0f);
> 			lambda = newImpulse - ccp->normalImpulse;
362,363c267,268
< 			vA -= mA * P;
< 			wA -= iA * b2Cross(vcp->rA, P);
---
> 			v1 -= invMass1 * P;
> 			w1 -= invI1 * b2Cross(ccp->r1, P);
365,366c270,272
< 			vB += mB * P;
< 			wB += iB * b2Cross(vcp->rB, P);
---
> 			v2 += invMass2 * P;
> 			w2 += invI2 * b2Cross(ccp->r2, P);
> 			ccp->normalImpulse = newImpulse;
376c282
< 			// b = vn0 - velocityBias
---
> 			// b = vn_0 - velocityBias
388c294
< 			// x = a + d
---
> 			// x = x' - a
390,395c296
< 			// a := old total impulse
< 			// x := new total impulse
< 			// d := incremental impulse 
< 			//
< 			// For the current iteration we extend the formula for the incremental impulse
< 			// to compute the new total impulse:
---
> 			// Plug into above equation:
397,400c298,301
< 			// vn = A * d + b
< 			//    = A * (x - a) + b
< 			//    = A * x + b - A * a
< 			//    = A * x + b'
---
> 			// vn = A * x + b
> 			//    = A * (x' - a) + b
> 			//    = A * x' + b - A * a
> 			//    = A * x' + b'
403,404c304,305
< 			b2VelocityConstraintPoint* cp1 = vc->points + 0;
< 			b2VelocityConstraintPoint* cp2 = vc->points + 1;
---
> 			b2ContactConstraintPoint* cp1 = c->points + 0;
> 			b2ContactConstraintPoint* cp2 = c->points + 1;
410,411c311,312
< 			b2Vec2 dv1 = vB + b2Cross(wB, cp1->rB) - vA - b2Cross(wA, cp1->rA);
< 			b2Vec2 dv2 = vB + b2Cross(wB, cp2->rB) - vA - b2Cross(wA, cp2->rA);
---
> 			b2Vec2 dv1 = v2 + b2Cross(w2, cp1->r2) - v1 - b2Cross(w1, cp1->r1);
> 			b2Vec2 dv2 = v2 + b2Cross(w2, cp2->r2) - v1 - b2Cross(w1, cp2->r1);
420,422c321
< 
< 			// Compute b'
< 			b -= b2Mul(vc->K, a);
---
> 			b -= b2Mul(c->K, a);
432c331
< 				// 0 = A * x + b'
---
> 				// 0 = A * x' + b'
434c333
< 				// Solve for x:
---
> 				// Solve for x':
436c335
< 				// x = - inv(A) * b'
---
> 				// x' = - inv(A) * b'
438c337
< 				b2Vec2 x = - b2Mul(vc->normalMass, b);
---
> 				b2Vec2 x = - b2Mul(c->normalMass, b);
442c341
< 					// Get the incremental impulse
---
> 					// Resubstitute for the incremental impulse
448,449c347,348
< 					vA -= mA * (P1 + P2);
< 					wA -= iA * (b2Cross(cp1->rA, P1) + b2Cross(cp2->rA, P2));
---
> 					v1 -= invMass1 * (P1 + P2);
> 					w1 -= invI1 * (b2Cross(cp1->r1, P1) + b2Cross(cp2->r1, P2));
451,452c350,351
< 					vB += mB * (P1 + P2);
< 					wB += iB * (b2Cross(cp1->rB, P1) + b2Cross(cp2->rB, P2));
---
> 					v2 += invMass2 * (P1 + P2);
> 					w2 += invI2 * (b2Cross(cp1->r2, P1) + b2Cross(cp2->r2, P2));
460,461c359,360
< 					dv1 = vB + b2Cross(wB, cp1->rB) - vA - b2Cross(wA, cp1->rA);
< 					dv2 = vB + b2Cross(wB, cp2->rB) - vA - b2Cross(wA, cp2->rA);
---
> 					dv1 = v2 + b2Cross(w2, cp1->r2) - v1 - b2Cross(w1, cp1->r1);
> 					dv2 = v2 + b2Cross(w2, cp2->r2) - v1 - b2Cross(w1, cp2->r1);
476,477c375,376
< 				//   0 = a11 * x1 + a12 * 0 + b1' 
< 				// vn2 = a21 * x1 + a22 * 0 + b2'
---
> 				//   0 = a11 * x1' + a12 * 0 + b1' 
> 				// vn2 = a21 * x1' + a22 * 0 + b2'
482c381
< 				vn2 = vc->K.ex.y * x.x + b.y;
---
> 				vn2 = c->K.col1.y * x.x + b.y;
486c385
< 					// Get the incremental impulse
---
> 					// Resubstitute for the incremental impulse
492,493c391,392
< 					vA -= mA * (P1 + P2);
< 					wA -= iA * (b2Cross(cp1->rA, P1) + b2Cross(cp2->rA, P2));
---
> 					v1 -= invMass1 * (P1 + P2);
> 					w1 -= invI1 * (b2Cross(cp1->r1, P1) + b2Cross(cp2->r1, P2));
495,496c394,395
< 					vB += mB * (P1 + P2);
< 					wB += iB * (b2Cross(cp1->rB, P1) + b2Cross(cp2->rB, P2));
---
> 					v2 += invMass2 * (P1 + P2);
> 					w2 += invI2 * (b2Cross(cp1->r2, P1) + b2Cross(cp2->r2, P2));
504c403
< 					dv1 = vB + b2Cross(wB, cp1->rB) - vA - b2Cross(wA, cp1->rA);
---
> 					dv1 = v2 + b2Cross(w2, cp1->r2) - v1 - b2Cross(w1, cp1->r1);
516c415
< 				// Case 3: vn2 = 0 and x1 = 0
---
> 				// Case 3: w2 = 0 and x1 = 0
518,519c417,418
< 				// vn1 = a11 * 0 + a12 * x2 + b1' 
< 				//   0 = a21 * 0 + a22 * x2 + b2'
---
> 				// vn1 = a11 * 0 + a12 * x2' + b1' 
> 				//   0 = a21 * 0 + a22 * x2' + b2'
523c422
< 				vn1 = vc->K.ey.x * x.y + b.x;
---
> 				vn1 = c->K.col2.x * x.y + b.x;
534,535c433,434
< 					vA -= mA * (P1 + P2);
< 					wA -= iA * (b2Cross(cp1->rA, P1) + b2Cross(cp2->rA, P2));
---
> 					v1 -= invMass1 * (P1 + P2);
> 					w1 -= invI1 * (b2Cross(cp1->r1, P1) + b2Cross(cp2->r1, P2));
537,538c436,437
< 					vB += mB * (P1 + P2);
< 					wB += iB * (b2Cross(cp1->rB, P1) + b2Cross(cp2->rB, P2));
---
> 					v2 += invMass2 * (P1 + P2);
> 					w2 += invI2 * (b2Cross(cp1->r2, P1) + b2Cross(cp2->r2, P2));
546c445
< 					dv2 = vB + b2Cross(wB, cp2->rB) - vA - b2Cross(wA, cp2->rA);
---
> 					dv2 = v2 + b2Cross(w2, cp2->r2) - v1 - b2Cross(w1, cp2->r1);
574,575c473,474
< 					vA -= mA * (P1 + P2);
< 					wA -= iA * (b2Cross(cp1->rA, P1) + b2Cross(cp2->rA, P2));
---
> 					v1 -= invMass1 * (P1 + P2);
> 					w1 -= invI1 * (b2Cross(cp1->r1, P1) + b2Cross(cp2->r1, P2));
577,578c476,477
< 					vB += mB * (P1 + P2);
< 					wB += iB * (b2Cross(cp1->rB, P1) + b2Cross(cp2->rB, P2));
---
> 					v2 += invMass2 * (P1 + P2);
> 					w2 += invI2 * (b2Cross(cp1->r2, P1) + b2Cross(cp2->r2, P2));
592,597c491,494
< 		m_velocities[indexA].v = vA;
< 		m_velocities[indexA].w = wA;
< 		m_velocities[indexB].v = vB;
< 		m_velocities[indexB].w = wB;
< 	}
< }
---
> 		// Solve tangent constraints
> 		for (int32 j = 0; j < c->pointCount; ++j)
> 		{
> 			b2ContactConstraintPoint* ccp = c->points + j;
599,604c496,497
< void b2ContactSolver::StoreImpulses()
< {
< 	for (int32 i = 0; i < m_count; ++i)
< 	{
< 		b2ContactVelocityConstraint* vc = m_velocityConstraints + i;
< 		b2Manifold* manifold = m_contacts[vc->contactIndex]->GetManifold();
---
> 			// Relative velocity at contact
> 			b2Vec2 dv = v2 + b2Cross(w2, ccp->r2) - v1 - b2Cross(w1, ccp->r1);
606,609c499,517
< 		for (int32 j = 0; j < vc->pointCount; ++j)
< 		{
< 			manifold->points[j].normalImpulse = vc->points[j].normalImpulse;
< 			manifold->points[j].tangentImpulse = vc->points[j].tangentImpulse;
---
> 			// Compute tangent force
> 			float32 vt = b2Dot(dv, tangent);
> 			float32 lambda = ccp->tangentMass * (-vt);
> 
> 			// b2Clamp the accumulated force
> 			float32 maxFriction = friction * ccp->normalImpulse;
> 			float32 newImpulse = b2Clamp(ccp->tangentImpulse + lambda, -maxFriction, maxFriction);
> 			lambda = newImpulse - ccp->tangentImpulse;
> 
> 			// Apply contact impulse
> 			b2Vec2 P = lambda * tangent;
> 
> 			v1 -= invMass1 * P;
> 			w1 -= invI1 * b2Cross(ccp->r1, P);
> 
> 			v2 += invMass2 * P;
> 			w2 += invI2 * b2Cross(ccp->r2, P);
> 
> 			ccp->tangentImpulse = newImpulse;
610a519,523
> 
> 		b1->m_linearVelocity = v1;
> 		b1->m_angularVelocity = w1;
> 		b2->m_linearVelocity = v2;
> 		b2->m_angularVelocity = w2;
614c527
< struct b2PositionSolverManifold
---
> void b2ContactSolver::FinalizeVelocityConstraints()
616c529
< 	void Initialize(b2ContactPositionConstraint* pc, const b2Transform& xfA, const b2Transform& xfB, int32 index)
---
> 	for (int32 i = 0; i < m_constraintCount; ++i)
618c531,532
< 		b2Assert(pc->pointCount > 0);
---
> 		b2ContactConstraint* c = m_constraints + i;
> 		b2Manifold* m = c->manifold;
620c534
< 		switch (pc->type)
---
> 		for (int32 j = 0; j < c->pointCount; ++j)
622,656c536,537
< 		case b2Manifold::e_circles:
< 			{
< 				b2Vec2 pointA = b2Mul(xfA, pc->localPoint);
< 				b2Vec2 pointB = b2Mul(xfB, pc->localPoints[0]);
< 				normal = pointB - pointA;
< 				normal.Normalize();
< 				point = 0.5f * (pointA + pointB);
< 				separation = b2Dot(pointB - pointA, normal) - pc->radiusA - pc->radiusB;
< 			}
< 			break;
< 
< 		case b2Manifold::e_faceA:
< 			{
< 				normal = b2Mul(xfA.q, pc->localNormal);
< 				b2Vec2 planePoint = b2Mul(xfA, pc->localPoint);
< 
< 				b2Vec2 clipPoint = b2Mul(xfB, pc->localPoints[index]);
< 				separation = b2Dot(clipPoint - planePoint, normal) - pc->radiusA - pc->radiusB;
< 				point = clipPoint;
< 			}
< 			break;
< 
< 		case b2Manifold::e_faceB:
< 			{
< 				normal = b2Mul(xfB.q, pc->localNormal);
< 				b2Vec2 planePoint = b2Mul(xfB, pc->localPoint);
< 
< 				b2Vec2 clipPoint = b2Mul(xfA, pc->localPoints[index]);
< 				separation = b2Dot(clipPoint - planePoint, normal) - pc->radiusA - pc->radiusB;
< 				point = clipPoint;
< 
< 				// Ensure normal points from A to B
< 				normal = -normal;
< 			}
< 			break;
---
> 			m->points[j].normalImpulse = c->points[j].normalImpulse;
> 			m->points[j].tangentImpulse = c->points[j].tangentImpulse;
658a540
> }
660,664c542
< 	b2Vec2 normal;
< 	b2Vec2 point;
< 	float32 separation;
< };
< 
---
> #if 1
666c544
< bool b2ContactSolver::SolvePositionConstraints()
---
> bool b2ContactSolver::SolvePositionConstraints(float32 baumgarte)
670c548
< 	for (int32 i = 0; i < m_count; ++i)
---
> 	for (int32 i = 0; i < m_constraintCount; ++i)
672,682c550,570
< 		b2ContactPositionConstraint* pc = m_positionConstraints + i;
< 
< 		int32 indexA = pc->indexA;
< 		int32 indexB = pc->indexB;
< 		b2Vec2 localCenterA = pc->localCenterA;
< 		float32 mA = pc->invMassA;
< 		float32 iA = pc->invIA;
< 		b2Vec2 localCenterB = pc->localCenterB;
< 		float32 mB = pc->invMassB;
< 		float32 iB = pc->invIB;
< 		int32 pointCount = pc->pointCount;
---
> 		b2ContactConstraint* c = m_constraints + i;
> 		b2Body* b1 = c->body1;
> 		b2Body* b2 = c->body2;
> 		float32 invMass1 = b1->m_mass * b1->m_invMass;
> 		float32 invI1 = b1->m_mass * b1->m_invI;
> 		float32 invMass2 = b2->m_mass * b2->m_invMass;
> 		float32 invI2 = b2->m_mass * b2->m_invI;
> 
> 		b2Vec2 normal = c->normal;
> 
> 		// Solver normal constraints
> 		for (int32 j = 0; j < c->pointCount; ++j)
> 		{
> 			b2ContactConstraintPoint* ccp = c->points + j;
> 
> 			b2Vec2 r1 = b2Mul(b1->GetXForm().R, ccp->localAnchor1 - b1->GetLocalCenter());
> 			b2Vec2 r2 = b2Mul(b2->GetXForm().R, ccp->localAnchor2 - b2->GetLocalCenter());
> 
> 			b2Vec2 p1 = b1->m_sweep.c + r1;
> 			b2Vec2 p2 = b2->m_sweep.c + r2;
> 			b2Vec2 dp = p2 - p1;
684,707c572,573
< 		b2Vec2 cA = m_positions[indexA].c;
< 		float32 aA = m_positions[indexA].a;
< 
< 		b2Vec2 cB = m_positions[indexB].c;
< 		float32 aB = m_positions[indexB].a;
< 
< 		// Solve normal constraints
< 		for (int32 j = 0; j < pointCount; ++j)
< 		{
< 			b2Transform xfA, xfB;
< 			xfA.q.Set(aA);
< 			xfB.q.Set(aB);
< 			xfA.p = cA - b2Mul(xfA.q, localCenterA);
< 			xfB.p = cB - b2Mul(xfB.q, localCenterB);
< 
< 			b2PositionSolverManifold psm;
< 			psm.Initialize(pc, xfA, xfB, j);
< 			b2Vec2 normal = psm.normal;
< 
< 			b2Vec2 point = psm.point;
< 			float32 separation = psm.separation;
< 
< 			b2Vec2 rA = point - cA;
< 			b2Vec2 rB = point - cB;
---
> 			// Approximate the current separation.
> 			float32 separation = b2Dot(dp, normal) + ccp->separation;
713,718c579
< 			float32 C = b2Clamp(b2_baumgarte * (separation + b2_linearSlop), -b2_maxLinearCorrection, 0.0f);
< 
< 			// Compute the effective mass.
< 			float32 rnA = b2Cross(rA, normal);
< 			float32 rnB = b2Cross(rB, normal);
< 			float32 K = mA + mB + iA * rnA * rnA + iB * rnB * rnB;
---
> 			float32 C = baumgarte * b2Clamp(separation + b2_linearSlop, -b2_maxLinearCorrection, 0.0f);
721c582
< 			float32 impulse = K > 0.0f ? - C / K : 0.0f;
---
> 			float32 impulse = -ccp->equalizedMass * C;
725,729c586,592
< 			cA -= mA * P;
< 			aA -= iA * b2Cross(rA, P);
< 
< 			cB += mB * P;
< 			aB += iB * b2Cross(rB, P);
---
> 			b1->m_sweep.c -= invMass1 * P;
> 			b1->m_sweep.a -= invI1 * b2Cross(r1, P);
> 			b1->SynchronizeTransform();
> 
> 			b2->m_sweep.c += invMass2 * P;
> 			b2->m_sweep.a += invI2 * b2Cross(r2, P);
> 			b2->SynchronizeTransform();
731,736d593
< 
< 		m_positions[indexA].c = cA;
< 		m_positions[indexA].a = aA;
< 
< 		m_positions[indexB].c = cB;
< 		m_positions[indexB].a = aB;
741c598
< 	return minSeparation >= -3.0f * b2_linearSlop;
---
> 	return minSeparation >= -1.5f * b2_linearSlop;
744,747c601
< // Sequential position solver for position constraints.
< bool b2ContactSolver::SolveTOIPositionConstraints(int32 toiIndexA, int32 toiIndexB)
< {
< 	float32 minSeparation = 0.0f;
---
> #else
749c603,606
< 	for (int32 i = 0; i < m_count; ++i)
---
> // Block solver. Doesn't seem that great.
> void b2ContactSolver::SolvePositionConstraints(float32 baumgarte)
> {
> 	for (int32 i = 0; i < m_constraintCount; ++i)
751c608,645
< 		b2ContactPositionConstraint* pc = m_positionConstraints + i;
---
> 		b2ContactConstraint* c = m_constraints + i;
> 		b2Body* b1 = c->body1;
> 		b2Body* b2 = c->body2;
> 		float32 invMass1 = b1->m_mass * b1->m_invMass;
> 		float32 invI1 = b1->m_mass * b1->m_invI;
> 		float32 invMass2 = b2->m_mass * b2->m_invMass;
> 		float32 invI2 = b2->m_mass * b2->m_invI;
> 
> 		b2Vec2 normal = c->normal;
> 		bool singlePoint = c->pointCount == 1;
> 
> 		if (c->pointCount == 2)
> 		{
> 			b2ContactConstraintPoint* ccp1 = c->points + 0;
> 			b2ContactConstraintPoint* ccp2 = c->points + 1;
> 
> 			b2Vec2 r11 = b2Mul(b1->GetXForm().R, ccp1->localAnchor1 - b1->GetLocalCenter());
> 			b2Vec2 r12 = b2Mul(b2->GetXForm().R, ccp1->localAnchor2 - b2->GetLocalCenter());
> 
> 			b2Vec2 r21 = b2Mul(b1->GetXForm().R, ccp2->localAnchor1 - b1->GetLocalCenter());
> 			b2Vec2 r22 = b2Mul(b2->GetXForm().R, ccp2->localAnchor2 - b2->GetLocalCenter());
> 
> 			b2Vec2 p11 = b1->m_sweep.c + r11;
> 			b2Vec2 p12 = b2->m_sweep.c + r12;
> 			b2Vec2 dp1 = p12 - p11;
> 
> 			b2Vec2 p21 = b1->m_sweep.c + r21;
> 			b2Vec2 p22 = b2->m_sweep.c + r22;
> 			b2Vec2 dp2 = p22 - p21;
> 
> 			float32 rn11 = b2Cross(r11, normal);
> 			float32 rn12 = b2Cross(r12, normal);
> 			float32 rn21 = b2Cross(r21, normal);
> 			float32 rn22 = b2Cross(r22, normal);
> 
> 			float32 k11 = invMass1 + invMass2 + invI1 * rn11 * rn11 + invI2 * rn12 * rn12;
> 			float32 k22 = invMass1 + invMass2 + invI1 * rn21 * rn21 + invI2 * rn22 * rn22;
> 			float32 k12 = invMass1 + invMass2 + invI1 * rn11 * rn21 + invI2 * rn12 * rn22;
753,765c647,653
< 		int32 indexA = pc->indexA;
< 		int32 indexB = pc->indexB;
< 		b2Vec2 localCenterA = pc->localCenterA;
< 		b2Vec2 localCenterB = pc->localCenterB;
< 		int32 pointCount = pc->pointCount;
< 
< 		float32 mA = 0.0f;
< 		float32 iA = 0.0f;
< 		if (indexA == toiIndexA || indexA == toiIndexB)
< 		{
< 			mA = pc->invMassA;
< 			iA = pc->invIA;
< 		}
---
> 			// Ensure a reasonable condition number.
> 			const float32 k_maxConditionNumber = 100.0f;
> 			if (k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12))
> 			{
> 				b2Mat22 K;
> 				K.col1.Set(k11, k12);
> 				K.col2.Set(k12, k22);
767,773c655,656
< 		float32 mB = 0.0f;
< 		float32 iB = 0.;
< 		if (indexB == toiIndexA || indexB == toiIndexB)
< 		{
< 			mB = pc->invMassB;
< 			iB = pc->invIB;
< 		}
---
> 				float32 separation1 = b2Dot(dp1, normal) + ccp1->separation;
> 				float32 separation2 = b2Dot(dp2, normal) + ccp2->separation;
775,776c658,660
< 		b2Vec2 cA = m_positions[indexA].c;
< 		float32 aA = m_positions[indexA].a;
---
> 				b2Vec2 C;
> 				C.x = baumgarte * (separation1 + b2_linearSlop);
> 				C.y = baumgarte * (separation2 + b2_linearSlop);
778,779c662
< 		b2Vec2 cB = m_positions[indexB].c;
< 		float32 aB = m_positions[indexB].a;
---
> 				b2Vec2 f = K.Solve(-C);
781,782c664,698
< 		// Solve normal constraints
< 		for (int32 j = 0; j < pointCount; ++j)
---
> 				if (f.x < 0.0f && f.y < 0.0f)
> 				{
> 					f.SetZero();
> 				}
> 				else if (f.x < 0.0f)
> 				{
> 					f.x = 0.0f;
> 					f.y = -C.y / k22;
> 				}
> 				else if (f.y < 0.0f)
> 				{
> 					f.x = -C.x / k11;
> 					f.y = 0.0f;
> 				}
> 
> 				b2Vec2 P1 = f.x * normal;
> 				b2Vec2 P2 = f.y * normal;
> 
> 				b1->m_sweep.c -= invMass1 * (P1 + P2);
> 				b1->m_sweep.a -= invI1 * (b2Cross(r11, P1) + b2Cross(r21, P2));
> 				b1->SynchronizeTransform();
> 
> 				b2->m_sweep.c += invMass2 * (P1 + P2);
> 				b2->m_sweep.a += invI2 * (b2Cross(r12, P1) + b2Cross(r22, P2));
> 				b2->SynchronizeTransform();
> 			}
> 			else
> 			{
> 				// The constraints are linearly dependent, so just use the first one.
> 				// This my cause a problem if the deepest one is ignored.
> 				singlePoint = true;
> 			}
> 		}
> 
> 		if (singlePoint)
784,792c700
< 			b2Transform xfA, xfB;
< 			xfA.q.Set(aA);
< 			xfB.q.Set(aB);
< 			xfA.p = cA - b2Mul(xfA.q, localCenterA);
< 			xfB.p = cB - b2Mul(xfB.q, localCenterB);
< 
< 			b2PositionSolverManifold psm;
< 			psm.Initialize(pc, xfA, xfB, j);
< 			b2Vec2 normal = psm.normal;
---
> 			b2ContactConstraintPoint* ccp = c->points + 0;
794,795c702,703
< 			b2Vec2 point = psm.point;
< 			float32 separation = psm.separation;
---
> 			b2Vec2 r1 = b2Mul(b1->GetXForm().R, ccp->localAnchor1 - b1->GetLocalCenter());
> 			b2Vec2 r2 = b2Mul(b2->GetXForm().R, ccp->localAnchor2 - b2->GetLocalCenter());
797,798c705,707
< 			b2Vec2 rA = point - cA;
< 			b2Vec2 rB = point - cB;
---
> 			b2Vec2 p1 = b1->m_sweep.c + r1;
> 			b2Vec2 p2 = b2->m_sweep.c + r2;
> 			b2Vec2 dp = p2 - p1;
800,801c709,710
< 			// Track max constraint error.
< 			minSeparation = b2Min(minSeparation, separation);
---
> 			// Approximate the current separation.
> 			float32 separation = b2Dot(dp, normal) + ccp->separation;
804,809c713
< 			float32 C = b2Clamp(b2_toiBaugarte * (separation + b2_linearSlop), -b2_maxLinearCorrection, 0.0f);
< 
< 			// Compute the effective mass.
< 			float32 rnA = b2Cross(rA, normal);
< 			float32 rnB = b2Cross(rB, normal);
< 			float32 K = mA + mB + iA * rnA * rnA + iB * rnB * rnB;
---
> 			float32 C = baumgarte * b2Clamp(separation + b2_linearSlop, -b2_maxLinearCorrection, 0.0f);
812c716
< 			float32 impulse = K > 0.0f ? - C / K : 0.0f;
---
> 			float32 impulse = -ccp->equalizedMass * C;
816,820c720,726
< 			cA -= mA * P;
< 			aA -= iA * b2Cross(rA, P);
< 
< 			cB += mB * P;
< 			aB += iB * b2Cross(rB, P);
---
> 			b1->m_sweep.c -= invMass1 * P;
> 			b1->m_sweep.a -= invI1 * b2Cross(r1, P);
> 			b1->SynchronizeTransform();
> 
> 			b2->m_sweep.c += invMass2 * P;
> 			b2->m_sweep.a += invI2 * b2Cross(r2, P);
> 			b2->SynchronizeTransform();
822,827d727
< 
< 		m_positions[indexA].c = cA;
< 		m_positions[indexA].a = aA;
< 
< 		m_positions[indexB].c = cB;
< 		m_positions[indexB].a = aB;
829,832d728
< 
< 	// We can't expect minSpeparation >= -b2_linearSlop because we don't
< 	// push the separation above -b2_linearSlop.
< 	return minSeparation >= -1.5f * b2_linearSlop;
833a730,732
> 
> #endif
> 
diff -r -x './svn/*' native/Box2D/Dynamics/Contacts/.svn/text-base/b2ContactSolver.h.svn-base ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Contacts/.svn/text-base/b2ContactSolver.h.svn-base
2c2
< * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
19,20c19,20
< #ifndef B2_CONTACT_SOLVER_H
< #define B2_CONTACT_SOLVER_H
---
> #ifndef CONTACT_SOLVER_H
> #define CONTACT_SOLVER_H
22,24c22,24
< #include <Box2D/Common/b2Math.h>
< #include <Box2D/Collision/b2Collision.h>
< #include <Box2D/Dynamics/b2TimeStep.h>
---
> #include "../../Common/b2Math.h"
> #include "../../Collision/b2Collision.h"
> #include "../b2World.h"
27a28
> class b2Island;
29d29
< struct b2ContactPositionConstraint;
31c31
< struct b2VelocityConstraintPoint
---
> struct b2ContactConstraintPoint
33,34c33,36
< 	b2Vec2 rA;
< 	b2Vec2 rB;
---
> 	b2Vec2 localAnchor1;
> 	b2Vec2 localAnchor2;
> 	b2Vec2 r1;
> 	b2Vec2 r2;
38a41,42
> 	float32 equalizedMass;
> 	float32 separation;
42c46
< struct b2ContactVelocityConstraint
---
> struct b2ContactConstraint
44c48
< 	b2VelocityConstraintPoint points[b2_maxManifoldPoints];
---
> 	b2ContactConstraintPoint points[b2_maxManifoldPoints];
48,51c52,54
< 	int32 indexA;
< 	int32 indexB;
< 	float32 invMassA, invMassB;
< 	float32 invIA, invIB;
---
> 	b2Manifold* manifold;
> 	b2Body* body1;
> 	b2Body* body2;
54d56
< 	float32 tangentSpeed;
56,66d57
< 	int32 contactIndex;
< };
< 
< struct b2ContactSolverDef
< {
< 	b2TimeStep step;
< 	b2Contact** contacts;
< 	int32 count;
< 	b2Position* positions;
< 	b2Velocity* velocities;
< 	b2StackAllocator* allocator;
72c63
< 	b2ContactSolver(b2ContactSolverDef* def);
---
> 	b2ContactSolver(const b2TimeStep& step, b2Contact** contacts, int32 contactCount, b2StackAllocator* allocator);
75,77c66
< 	void InitializeVelocityConstraints();
< 
< 	void WarmStart();
---
> 	void InitVelocityConstraints(const b2TimeStep& step);
79c68
< 	void StoreImpulses();
---
> 	void FinalizeVelocityConstraints();
81,82c70
< 	bool SolvePositionConstraints();
< 	bool SolveTOIPositionConstraints(int32 toiIndexA, int32 toiIndexB);
---
> 	bool SolvePositionConstraints(float32 baumgarte);
85,86d72
< 	b2Position* m_positions;
< 	b2Velocity* m_velocities;
88,91c74,75
< 	b2ContactPositionConstraint* m_positionConstraints;
< 	b2ContactVelocityConstraint* m_velocityConstraints;
< 	b2Contact** m_contacts;
< 	int m_count;
---
> 	b2ContactConstraint* m_constraints;
> 	int m_constraintCount;
95d78
< 
diff -r -x './svn/*' native/Box2D/Dynamics/Contacts/.svn/text-base/b2EdgeAndCircleContact.cpp.svn-base ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Contacts/.svn/text-base/b2EdgeAndCircleContact.cpp.svn-base
1,50c1,192
< /*
< * Copyright (c) 2006-2010 Erin Catto http://www.box2d.org
< *
< * This software is provided 'as-is', without any express or implied
< * warranty.  In no event will the authors be held liable for any damages
< * arising from the use of this software.
< * Permission is granted to anyone to use this software for any purpose,
< * including commercial applications, and to alter it and redistribute it
< * freely, subject to the following restrictions:
< * 1. The origin of this software must not be misrepresented; you must not
< * claim that you wrote the original software. If you use this software
< * in a product, an acknowledgment in the product documentation would be
< * appreciated but is not required.
< * 2. Altered source versions must be plainly marked as such, and must not be
< * misrepresented as being the original software.
< * 3. This notice may not be removed or altered from any source distribution.
< */
< 
< #include <Box2D/Dynamics/Contacts/b2EdgeAndCircleContact.h>
< #include <Box2D/Common/b2BlockAllocator.h>
< #include <Box2D/Dynamics/b2Fixture.h>
< 
< #include <new>
< using namespace std;
< 
< b2Contact* b2EdgeAndCircleContact::Create(b2Fixture* fixtureA, int32, b2Fixture* fixtureB, int32, b2BlockAllocator* allocator)
< {
< 	void* mem = allocator->Allocate(sizeof(b2EdgeAndCircleContact));
< 	return new (mem) b2EdgeAndCircleContact(fixtureA, fixtureB);
< }
< 
< void b2EdgeAndCircleContact::Destroy(b2Contact* contact, b2BlockAllocator* allocator)
< {
< 	((b2EdgeAndCircleContact*)contact)->~b2EdgeAndCircleContact();
< 	allocator->Free(contact, sizeof(b2EdgeAndCircleContact));
< }
< 
< b2EdgeAndCircleContact::b2EdgeAndCircleContact(b2Fixture* fixtureA, b2Fixture* fixtureB)
< : b2Contact(fixtureA, 0, fixtureB, 0)
< {
< 	b2Assert(m_fixtureA->GetType() == b2Shape::e_edge);
< 	b2Assert(m_fixtureB->GetType() == b2Shape::e_circle);
< }
< 
< void b2EdgeAndCircleContact::Evaluate(b2Manifold* manifold, const b2Transform& xfA, const b2Transform& xfB)
< {
< 	b2CollideEdgeAndCircle(	manifold,
< 								(b2EdgeShape*)m_fixtureA->GetShape(), xfA,
< 								(b2CircleShape*)m_fixtureB->GetShape(), xfB);
< }
---
> /*
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
> *
> * This software is provided 'as-is', without any express or implied
> * warranty.  In no event will the authors be held liable for any damages
> * arising from the use of this software.
> * Permission is granted to anyone to use this software for any purpose,
> * including commercial applications, and to alter it and redistribute it
> * freely, subject to the following restrictions:
> * 1. The origin of this software must not be misrepresented; you must not
> * claim that you wrote the original software. If you use this software
> * in a product, an acknowledgment in the product documentation would be
> * appreciated but is not required.
> * 2. Altered source versions must be plainly marked as such, and must not be
> * misrepresented as being the original software.
> * 3. This notice may not be removed or altered from any source distribution.
> */
> 
> #include "b2EdgeAndCircleContact.h"
> #include "../b2Body.h"
> #include "../b2WorldCallbacks.h"
> #include "../../Common/b2BlockAllocator.h"
> #include "../../Collision/Shapes/b2EdgeShape.h"
> 
> #include <new>
> 
> b2Contact* b2EdgeAndCircleContact::Create(b2Shape* shape1, b2Shape* shape2, b2BlockAllocator* allocator)
> {
> 	void* mem = allocator->Allocate(sizeof(b2EdgeAndCircleContact));
> 	return new (mem) b2EdgeAndCircleContact(shape1, shape2);
> }
> 
> void b2EdgeAndCircleContact::Destroy(b2Contact* contact, b2BlockAllocator* allocator)
> {
> 	((b2EdgeAndCircleContact*)contact)->~b2EdgeAndCircleContact();
> 	allocator->Free(contact, sizeof(b2EdgeAndCircleContact));
> }
> 
> b2EdgeAndCircleContact::b2EdgeAndCircleContact(b2Shape* s1, b2Shape* s2)
> : b2Contact(s1, s2)
> {
> 	b2Assert(m_shape1->GetType() == e_edgeShape);
> 	b2Assert(m_shape2->GetType() == e_circleShape);
> 	m_manifold.pointCount = 0;
> 	m_manifold.points[0].normalImpulse = 0.0f;
> 	m_manifold.points[0].tangentImpulse = 0.0f;
> }
> 
> void b2EdgeAndCircleContact::Evaluate(b2ContactListener* listener)
> {
> 	b2Body* b1 = m_shape1->GetBody();
> 	b2Body* b2 = m_shape2->GetBody();
> 
> 	b2Manifold m0;
> 	memcpy(&m0, &m_manifold, sizeof(b2Manifold));
> 
> 	b2CollideEdgeAndCircle(&m_manifold, (b2EdgeShape*)m_shape1, b1->GetXForm(), (b2CircleShape*)m_shape2, b2->GetXForm());
> 
> 	b2ContactPoint cp;
> 	cp.shape1 = m_shape1;
> 	cp.shape2 = m_shape2;
> 	cp.friction = b2MixFriction(m_shape1->GetFriction(), m_shape2->GetFriction());
> 	cp.restitution = b2MixRestitution(m_shape1->GetRestitution(), m_shape2->GetRestitution());
> 
> 	if (m_manifold.pointCount > 0)
> 	{
> 		m_manifoldCount = 1;
> 		b2ManifoldPoint* mp = m_manifold.points + 0;
> 
> 		if (m0.pointCount == 0)
> 		{
> 			mp->normalImpulse = 0.0f;
> 			mp->tangentImpulse = 0.0f;
> 
> 			if (listener)
> 			{
> 				cp.position = b1->GetWorldPoint(mp->localPoint1);
> 				b2Vec2 v1 = b1->GetLinearVelocityFromLocalPoint(mp->localPoint1);
> 				b2Vec2 v2 = b2->GetLinearVelocityFromLocalPoint(mp->localPoint2);
> 				cp.velocity = v2 - v1;
> 				cp.normal = m_manifold.normal;
> 				cp.separation = mp->separation;
> 				cp.id = mp->id;
> 				listener->Add(&cp);
> 			}
> 		}
> 		else
> 		{
> 			b2ManifoldPoint* mp0 = m0.points + 0;
> 			mp->normalImpulse = mp0->normalImpulse;
> 			mp->tangentImpulse = mp0->tangentImpulse;
> 
> 			if (listener)
> 			{
> 				cp.position = b1->GetWorldPoint(mp->localPoint1);
> 				b2Vec2 v1 = b1->GetLinearVelocityFromLocalPoint(mp->localPoint1);
> 				b2Vec2 v2 = b2->GetLinearVelocityFromLocalPoint(mp->localPoint2);
> 				cp.velocity = v2 - v1;
> 				cp.normal = m_manifold.normal;
> 				cp.separation = mp->separation;
> 				cp.id = mp->id;
> 				listener->Persist(&cp);
> 			}
> 		}
> 	}
> 	else
> 	{
> 		m_manifoldCount = 0;
> 		if (m0.pointCount > 0 && listener)
> 		{
> 			b2ManifoldPoint* mp0 = m0.points + 0;
> 			cp.position = b1->GetWorldPoint(mp0->localPoint1);
> 			b2Vec2 v1 = b1->GetLinearVelocityFromLocalPoint(mp0->localPoint1);
> 			b2Vec2 v2 = b2->GetLinearVelocityFromLocalPoint(mp0->localPoint2);
> 			cp.velocity = v2 - v1;
> 			cp.normal = m0.normal;
> 			cp.separation = mp0->separation;
> 			cp.id = mp0->id;
> 			listener->Remove(&cp);
> 		}
> 	}
> }
> 
> void b2EdgeAndCircleContact::b2CollideEdgeAndCircle(b2Manifold* manifold,
> 																const b2EdgeShape* edge, 
> 																const b2XForm& xf1,
> 																const b2CircleShape* circle, 
> 																const b2XForm& xf2)
> {
> 	manifold->pointCount = 0;
> 	b2Vec2 d;
> 	b2Vec2 c = b2Mul(xf2, circle->GetLocalPosition());
> 	b2Vec2 cLocal = b2MulT(xf1, c);
> 	b2Vec2 n = edge->GetNormalVector();
> 	b2Vec2 v1 = edge->GetVertex1();
> 	b2Vec2 v2 = edge->GetVertex2();
> 	float32 radius = circle->GetRadius();
> 	float32 separation;
> 	
> 	float32 dirDist = b2Dot((cLocal - v1), edge->GetDirectionVector());
> 	if (dirDist <= 0) {
> 		d = cLocal - v1;
> 		if (b2Dot(d, edge->GetCorner1Vector()) < 0) {
> 			return;
> 		}
> 		d = c - b2Mul(xf1, v1);
> 	} else if (dirDist >= edge->GetLength()) {
> 		d = cLocal - v2;
> 		if (b2Dot(d, edge->GetCorner2Vector()) > 0) {
> 			return;
> 		}
> 		d = c - b2Mul(xf1, v2);
> 	} else {
> 		separation = b2Dot(cLocal - v1, n);
> 		if (separation > radius || separation < -radius) {
> 			return;
> 		}
> 		separation -= radius;
> 		manifold->normal = b2Mul(xf1.R, n);
> 		manifold->pointCount = 1;
> 		manifold->points[0].id.key = 0;
> 		manifold->points[0].separation = separation;
> 		c = c - radius * manifold->normal;
> 		manifold->points[0].localPoint1 = b2MulT(xf1, c);
> 		manifold->points[0].localPoint2 = b2MulT(xf2, c);
> 		return;
> 	}
> 	
> 	float32 distSqr = b2Dot(d,d);
> 	if (distSqr > radius * radius)
> 	{
> 		return;
> 	}
> 	
> 	if (distSqr < B2_FLT_EPSILON)
> 	{
> 		separation = -radius;
> 		manifold->normal = b2Mul(xf1.R, n);
> 	}
> 	else
> 	{
> 		separation = d.Normalize() - radius;
> 		manifold->normal = d;
> 	}
> 	
> 	manifold->pointCount = 1;
> 	manifold->points[0].id.key = 0;
> 	manifold->points[0].separation = separation;
> 	c = c - radius * manifold->normal;
> 	manifold->points[0].localPoint1 = b2MulT(xf1, c);
> 	manifold->points[0].localPoint2 = b2MulT(xf2, c);
> }
diff -r -x './svn/*' native/Box2D/Dynamics/Contacts/.svn/text-base/b2EdgeAndCircleContact.h.svn-base ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Contacts/.svn/text-base/b2EdgeAndCircleContact.h.svn-base
2c2
< * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
19,20c19,20
< #ifndef B2_EDGE_AND_CIRCLE_CONTACT_H
< #define B2_EDGE_AND_CIRCLE_CONTACT_H
---
> #ifndef EDGE_AND_CIRCLE_CONTACT_H
> #define EDGE_AND_CIRCLE_CONTACT_H
22c22,28
< #include <Box2D/Dynamics/Contacts/b2Contact.h>
---
> #include "../../Common/b2Math.h"
> #include "../../Collision/b2Collision.h"
> #include "../../Collision/Shapes/b2EdgeShape.h"
> #include "../../Collision/Shapes/b2CircleShape.h"
> #include "b2Contact.h"
> 
> #include <memory.h>
29,30c35
< 	static b2Contact* Create(	b2Fixture* fixtureA, int32 indexA,
< 								b2Fixture* fixtureB, int32 indexB, b2BlockAllocator* allocator);
---
> 	static b2Contact* Create(b2Shape* shape1, b2Shape* shape2, b2BlockAllocator* allocator);
33c38
< 	b2EdgeAndCircleContact(b2Fixture* fixtureA, b2Fixture* fixtureB);
---
> 	b2EdgeAndCircleContact(b2Shape* shape1, b2Shape* shape2);
36c41,50
< 	void Evaluate(b2Manifold* manifold, const b2Transform& xfA, const b2Transform& xfB);
---
> 	void Evaluate(b2ContactListener* listener);
> 	void b2CollideEdgeAndCircle(b2Manifold* manifold,
> 									  const b2EdgeShape* edge, const b2XForm& xf1,
> 									  const b2CircleShape* circle, const b2XForm& xf2);
> 	b2Manifold* GetManifolds()
> 	{
> 		return &m_manifold;
> 	}
> 
> 	b2Manifold m_manifold;
Only in native/Box2D/Dynamics/Contacts/.svn/text-base: b2EdgeAndPolygonContact.cpp.svn-base
Only in native/Box2D/Dynamics/Contacts/.svn/text-base: b2EdgeAndPolygonContact.h.svn-base
Only in ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Contacts/.svn/text-base: b2NullContact.h.svn-base
Only in ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Contacts/.svn/text-base: b2PolyAndCircleContact.cpp.svn-base
Only in ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Contacts/.svn/text-base: b2PolyAndCircleContact.h.svn-base
Only in ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Contacts/.svn/text-base: b2PolyAndEdgeContact.cpp.svn-base
Only in ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Contacts/.svn/text-base: b2PolyAndEdgeContact.h.svn-base
Only in ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Contacts/.svn/text-base: b2PolyContact.cpp.svn-base
Only in ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Contacts/.svn/text-base: b2PolyContact.h.svn-base
Only in native/Box2D/Dynamics/Contacts/.svn/text-base: b2PolygonAndCircleContact.cpp.svn-base
Only in native/Box2D/Dynamics/Contacts/.svn/text-base: b2PolygonAndCircleContact.h.svn-base
Only in native/Box2D/Dynamics/Contacts/.svn/text-base: b2PolygonContact.cpp.svn-base
Only in native/Box2D/Dynamics/Contacts/.svn/text-base: b2PolygonContact.h.svn-base
Only in native/Box2D/Dynamics/Contacts: b2ChainAndCircleContact.cpp
Only in native/Box2D/Dynamics/Contacts: b2ChainAndCircleContact.h
Only in native/Box2D/Dynamics/Contacts: b2ChainAndPolygonContact.cpp
Only in native/Box2D/Dynamics/Contacts: b2ChainAndPolygonContact.h
diff -r -x './svn/*' native/Box2D/Dynamics/Contacts/b2CircleContact.cpp ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Contacts/b2CircleContact.cpp
2c2
< * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
19,24c19,22
< #include <Box2D/Dynamics/Contacts/b2CircleContact.h>
< #include <Box2D/Dynamics/b2Body.h>
< #include <Box2D/Dynamics/b2Fixture.h>
< #include <Box2D/Dynamics/b2WorldCallbacks.h>
< #include <Box2D/Common/b2BlockAllocator.h>
< #include <Box2D/Collision/b2TimeOfImpact.h>
---
> #include "b2CircleContact.h"
> #include "../b2Body.h"
> #include "../b2WorldCallbacks.h"
> #include "../../Common/b2BlockAllocator.h"
26,27c24,25
< #include <new>
< using namespace std;
---
> #include <new>
> #include <string.h>
29c27
< b2Contact* b2CircleContact::Create(b2Fixture* fixtureA, int32, b2Fixture* fixtureB, int32, b2BlockAllocator* allocator)
---
> b2Contact* b2CircleContact::Create(b2Shape* shape1, b2Shape* shape2, b2BlockAllocator* allocator)
32c30
< 	return new (mem) b2CircleContact(fixtureA, fixtureB);
---
> 	return new (mem) b2CircleContact(shape1, shape2);
41,42c39,40
< b2CircleContact::b2CircleContact(b2Fixture* fixtureA, b2Fixture* fixtureB)
< 	: b2Contact(fixtureA, 0, fixtureB, 0)
---
> b2CircleContact::b2CircleContact(b2Shape* s1, b2Shape* s2)
> : b2Contact(s1, s2)
44,45c42,46
< 	b2Assert(m_fixtureA->GetType() == b2Shape::e_circle);
< 	b2Assert(m_fixtureB->GetType() == b2Shape::e_circle);
---
> 	b2Assert(m_shape1->GetType() == e_circleShape);
> 	b2Assert(m_shape2->GetType() == e_circleShape);
> 	m_manifold.pointCount = 0;
> 	m_manifold.points[0].normalImpulse = 0.0f;
> 	m_manifold.points[0].tangentImpulse = 0.0f;
48c49
< void b2CircleContact::Evaluate(b2Manifold* manifold, const b2Transform& xfA, const b2Transform& xfB)
---
> void b2CircleContact::Evaluate(b2ContactListener* listener)
50,52c51,121
< 	b2CollideCircles(manifold,
< 					(b2CircleShape*)m_fixtureA->GetShape(), xfA,
< 					(b2CircleShape*)m_fixtureB->GetShape(), xfB);
---
> 	b2Body* b1 = m_shape1->GetBody();
> 	b2Body* b2 = m_shape2->GetBody();
> 
> 	b2Manifold m0;
> 	memcpy(&m0, &m_manifold, sizeof(b2Manifold));
> 
> 	b2CollideCircles(&m_manifold, (b2CircleShape*)m_shape1, b1->GetXForm(), (b2CircleShape*)m_shape2, b2->GetXForm());
> 
> 	b2ContactPoint cp;
> 	cp.shape1 = m_shape1;
> 	cp.shape2 = m_shape2;
> 	cp.friction = b2MixFriction(m_shape1->GetFriction(), m_shape2->GetFriction());
> 	cp.restitution = b2MixRestitution(m_shape1->GetRestitution(), m_shape2->GetRestitution());
> 
> 	if (m_manifold.pointCount > 0)
> 	{
> 		m_manifoldCount = 1;
> 		b2ManifoldPoint* mp = m_manifold.points + 0;
> 
> 		if (m0.pointCount == 0)
> 		{
> 			mp->normalImpulse = 0.0f;
> 			mp->tangentImpulse = 0.0f;
> 
> 			if (listener)
> 			{
> 				cp.position = b1->GetWorldPoint(mp->localPoint1);
> 				b2Vec2 v1 = b1->GetLinearVelocityFromLocalPoint(mp->localPoint1);
> 				b2Vec2 v2 = b2->GetLinearVelocityFromLocalPoint(mp->localPoint2);
> 				cp.velocity = v2 - v1;
> 				cp.normal = m_manifold.normal;
> 				cp.separation = mp->separation;
> 				cp.id = mp->id;
> 				listener->Add(&cp);
> 			}
> 		}
> 		else
> 		{
> 			b2ManifoldPoint* mp0 = m0.points + 0;
> 			mp->normalImpulse = mp0->normalImpulse;
> 			mp->tangentImpulse = mp0->tangentImpulse;
> 
> 			if (listener)
> 			{
> 				cp.position = b1->GetWorldPoint(mp->localPoint1);
> 				b2Vec2 v1 = b1->GetLinearVelocityFromLocalPoint(mp->localPoint1);
> 				b2Vec2 v2 = b2->GetLinearVelocityFromLocalPoint(mp->localPoint2);
> 				cp.velocity = v2 - v1;
> 				cp.normal = m_manifold.normal;
> 				cp.separation = mp->separation;
> 				cp.id = mp->id;
> 				listener->Persist(&cp);
> 			}
> 		}
> 	}
> 	else
> 	{
> 		m_manifoldCount = 0;
> 		if (m0.pointCount > 0 && listener)
> 		{
> 			b2ManifoldPoint* mp0 = m0.points + 0;
> 			cp.position = b1->GetWorldPoint(mp0->localPoint1);
> 			b2Vec2 v1 = b1->GetLinearVelocityFromLocalPoint(mp0->localPoint1);
> 			b2Vec2 v2 = b2->GetLinearVelocityFromLocalPoint(mp0->localPoint2);
> 			cp.velocity = v2 - v1;
> 			cp.normal = m0.normal;
> 			cp.separation = mp0->separation;
> 			cp.id = mp0->id;
> 			listener->Remove(&cp);
> 		}
> 	}
diff -r -x './svn/*' native/Box2D/Dynamics/Contacts/b2CircleContact.h ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Contacts/b2CircleContact.h
2c2
< * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
19,20c19,20
< #ifndef B2_CIRCLE_CONTACT_H
< #define B2_CIRCLE_CONTACT_H
---
> #ifndef CIRCLE_CONTACT_H
> #define CIRCLE_CONTACT_H
22c22,24
< #include <Box2D/Dynamics/Contacts/b2Contact.h>
---
> #include "../../Common/b2Math.h"
> #include "../../Collision/b2Collision.h"
> #include "b2Contact.h"
29,30c31
< 	static b2Contact* Create(	b2Fixture* fixtureA, int32 indexA,
< 								b2Fixture* fixtureB, int32 indexB, b2BlockAllocator* allocator);
---
> 	static b2Contact* Create(b2Shape* shape1, b2Shape* shape2, b2BlockAllocator* allocator);
33c34
< 	b2CircleContact(b2Fixture* fixtureA, b2Fixture* fixtureB);
---
> 	b2CircleContact(b2Shape* shape1, b2Shape* shape2);
36c37,43
< 	void Evaluate(b2Manifold* manifold, const b2Transform& xfA, const b2Transform& xfB);
---
> 	void Evaluate(b2ContactListener* listener);
> 	b2Manifold* GetManifolds()
> 	{
> 		return &m_manifold;
> 	}
> 
> 	b2Manifold m_manifold;
diff -r -x './svn/*' native/Box2D/Dynamics/Contacts/b2Contact.cpp ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Contacts/b2Contact.cpp
2c2
< * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
19,35c19,30
< #include <Box2D/Dynamics/Contacts/b2Contact.h>
< #include <Box2D/Dynamics/Contacts/b2CircleContact.h>
< #include <Box2D/Dynamics/Contacts/b2PolygonAndCircleContact.h>
< #include <Box2D/Dynamics/Contacts/b2PolygonContact.h>
< #include <Box2D/Dynamics/Contacts/b2EdgeAndCircleContact.h>
< #include <Box2D/Dynamics/Contacts/b2EdgeAndPolygonContact.h>
< #include <Box2D/Dynamics/Contacts/b2ChainAndCircleContact.h>
< #include <Box2D/Dynamics/Contacts/b2ChainAndPolygonContact.h>
< #include <Box2D/Dynamics/Contacts/b2ContactSolver.h>
< 
< #include <Box2D/Collision/b2Collision.h>
< #include <Box2D/Collision/b2TimeOfImpact.h>
< #include <Box2D/Collision/Shapes/b2Shape.h>
< #include <Box2D/Common/b2BlockAllocator.h>
< #include <Box2D/Dynamics/b2Body.h>
< #include <Box2D/Dynamics/b2Fixture.h>
< #include <Box2D/Dynamics/b2World.h>
---
> #include "b2Contact.h"
> #include "b2CircleContact.h"
> #include "b2PolyAndCircleContact.h"
> #include "b2PolyContact.h"
> #include "b2EdgeAndCircleContact.h"
> #include "b2PolyAndEdgeContact.h"
> #include "b2ContactSolver.h"
> #include "../../Collision/b2Collision.h"
> #include "../../Collision/Shapes/b2Shape.h"
> #include "../../Common/b2BlockAllocator.h"
> #include "../../Dynamics/b2World.h"
> #include "../../Dynamics/b2Body.h"
37c32
< b2ContactRegister b2Contact::s_registers[b2Shape::e_typeCount][b2Shape::e_typeCount];
---
> b2ContactRegister b2Contact::s_registers[e_shapeTypeCount][e_shapeTypeCount];
42,48c37,42
< 	AddType(b2CircleContact::Create, b2CircleContact::Destroy, b2Shape::e_circle, b2Shape::e_circle);
< 	AddType(b2PolygonAndCircleContact::Create, b2PolygonAndCircleContact::Destroy, b2Shape::e_polygon, b2Shape::e_circle);
< 	AddType(b2PolygonContact::Create, b2PolygonContact::Destroy, b2Shape::e_polygon, b2Shape::e_polygon);
< 	AddType(b2EdgeAndCircleContact::Create, b2EdgeAndCircleContact::Destroy, b2Shape::e_edge, b2Shape::e_circle);
< 	AddType(b2EdgeAndPolygonContact::Create, b2EdgeAndPolygonContact::Destroy, b2Shape::e_edge, b2Shape::e_polygon);
< 	AddType(b2ChainAndCircleContact::Create, b2ChainAndCircleContact::Destroy, b2Shape::e_chain, b2Shape::e_circle);
< 	AddType(b2ChainAndPolygonContact::Create, b2ChainAndPolygonContact::Destroy, b2Shape::e_chain, b2Shape::e_polygon);
---
> 	AddType(b2CircleContact::Create, b2CircleContact::Destroy, e_circleShape, e_circleShape);
> 	AddType(b2PolyAndCircleContact::Create, b2PolyAndCircleContact::Destroy, e_polygonShape, e_circleShape);
> 	AddType(b2PolygonContact::Create, b2PolygonContact::Destroy, e_polygonShape, e_polygonShape);
> 	
> 	AddType(b2EdgeAndCircleContact::Create, b2EdgeAndCircleContact::Destroy, e_edgeShape, e_circleShape);
> 	AddType(b2PolyAndEdgeContact::Create, b2PolyAndEdgeContact::Destroy, e_polygonShape, e_edgeShape);
52c46
< 						b2Shape::Type type1, b2Shape::Type type2)
---
> 					  b2ShapeType type1, b2ShapeType type2)
54,55c48,49
< 	b2Assert(0 <= type1 && type1 < b2Shape::e_typeCount);
< 	b2Assert(0 <= type2 && type2 < b2Shape::e_typeCount);
---
> 	b2Assert(e_unknownShape < type1 && type1 < e_shapeTypeCount);
> 	b2Assert(e_unknownShape < type2 && type2 < e_shapeTypeCount);
69c63
< b2Contact* b2Contact::Create(b2Fixture* fixtureA, int32 indexA, b2Fixture* fixtureB, int32 indexB, b2BlockAllocator* allocator)
---
> b2Contact* b2Contact::Create(b2Shape* shape1, b2Shape* shape2, b2BlockAllocator* allocator)
77,78c71,72
< 	b2Shape::Type type1 = fixtureA->GetType();
< 	b2Shape::Type type2 = fixtureB->GetType();
---
> 	b2ShapeType type1 = shape1->GetType();
> 	b2ShapeType type2 = shape2->GetType();
80,81c74,75
< 	b2Assert(0 <= type1 && type1 < b2Shape::e_typeCount);
< 	b2Assert(0 <= type2 && type2 < b2Shape::e_typeCount);
---
> 	b2Assert(e_unknownShape < type1 && type1 < e_shapeTypeCount);
> 	b2Assert(e_unknownShape < type2 && type2 < e_shapeTypeCount);
88c82
< 			return createFcn(fixtureA, indexA, fixtureB, indexB, allocator);
---
> 			return createFcn(shape1, shape2, allocator);
92c86,92
< 			return createFcn(fixtureB, indexB, fixtureA, indexA, allocator);
---
> 			b2Contact* c = createFcn(shape2, shape1, allocator);
> 			for (int32 i = 0; i < c->GetManifoldCount(); ++i)
> 			{
> 				b2Manifold* m = c->GetManifolds() + i;
> 				m->normal = -m->normal;
> 			}
> 			return c;
105,110c105
< 	b2Fixture* fixtureA = contact->m_fixtureA;
< 	b2Fixture* fixtureB = contact->m_fixtureB;
< 
< 	if (contact->m_manifold.pointCount > 0 &&
< 		fixtureA->IsSensor() == false &&
< 		fixtureB->IsSensor() == false)
---
> 	if (contact->GetManifoldCount() > 0)
112,113c107,108
< 		fixtureA->GetBody()->SetAwake(true);
< 		fixtureB->GetBody()->SetAwake(true);
---
> 		contact->GetShape1()->GetBody()->WakeUp();
> 		contact->GetShape2()->GetBody()->WakeUp();
116,117c111,112
< 	b2Shape::Type typeA = fixtureA->GetType();
< 	b2Shape::Type typeB = fixtureB->GetType();
---
> 	b2ShapeType type1 = contact->GetShape1()->GetType();
> 	b2ShapeType type2 = contact->GetShape2()->GetType();
119,120c114,115
< 	b2Assert(0 <= typeA && typeB < b2Shape::e_typeCount);
< 	b2Assert(0 <= typeA && typeB < b2Shape::e_typeCount);
---
> 	b2Assert(e_unknownShape < type1 && type1 < e_shapeTypeCount);
> 	b2Assert(e_unknownShape < type2 && type2 < e_shapeTypeCount);
122c117
< 	b2ContactDestroyFcn* destroyFcn = s_registers[typeA][typeB].destroyFcn;
---
> 	b2ContactDestroyFcn* destroyFcn = s_registers[type1][type2].destroyFcn;
126c121
< b2Contact::b2Contact(b2Fixture* fA, int32 indexA, b2Fixture* fB, int32 indexB)
---
> b2Contact::b2Contact(b2Shape* s1, b2Shape* s2)
128c123
< 	m_flags = e_enabledFlag;
---
> 	m_flags = 0;
130,131c125,128
< 	m_fixtureA = fA;
< 	m_fixtureB = fB;
---
> 	if (s1->IsSensor() || s2->IsSensor())
> 	{
> 		m_flags |= e_nonSolidFlag;
> 	}
133,134c130,131
< 	m_indexA = indexA;
< 	m_indexB = indexB;
---
> 	m_shape1 = s1;
> 	m_shape2 = s2;
136c133
< 	m_manifold.pointCount = 0;
---
> 	m_manifoldCount = 0;
141,156c138,146
< 	m_nodeA.contact = NULL;
< 	m_nodeA.prev = NULL;
< 	m_nodeA.next = NULL;
< 	m_nodeA.other = NULL;
< 
< 	m_nodeB.contact = NULL;
< 	m_nodeB.prev = NULL;
< 	m_nodeB.next = NULL;
< 	m_nodeB.other = NULL;
< 
< 	m_toiCount = 0;
< 
< 	m_friction = b2MixFriction(m_fixtureA->m_friction, m_fixtureB->m_friction);
< 	m_restitution = b2MixRestitution(m_fixtureA->m_restitution, m_fixtureB->m_restitution);
< 
< 	m_tangentSpeed = 0.0f;
---
> 	m_node1.contact = NULL;
> 	m_node1.prev = NULL;
> 	m_node1.next = NULL;
> 	m_node1.other = NULL;
> 
> 	m_node2.contact = NULL;
> 	m_node2.prev = NULL;
> 	m_node2.next = NULL;
> 	m_node2.other = NULL;
159,160d148
< // Update the contact manifold and touching status.
< // Note: do not assume the fixture AABBs are overlapping or are valid.
163,166c151
< 	b2Manifold oldManifold = m_manifold;
< 
< 	// Re-enable this contact.
< 	m_flags |= e_enabledFlag;
---
> 	int32 oldCount = GetManifoldCount();
168,169c153
< 	bool touching = false;
< 	bool wasTouching = (m_flags & e_touchingFlag) == e_touchingFlag;
---
> 	Evaluate(listener);
171,173c155
< 	bool sensorA = m_fixtureA->IsSensor();
< 	bool sensorB = m_fixtureB->IsSensor();
< 	bool sensor = sensorA || sensorB;
---
> 	int32 newCount = GetManifoldCount();
175,185c157,158
< 	b2Body* bodyA = m_fixtureA->GetBody();
< 	b2Body* bodyB = m_fixtureB->GetBody();
< 	const b2Transform& xfA = bodyA->GetTransform();
< 	const b2Transform& xfB = bodyB->GetTransform();
< 
< 	// Is this contact a sensor?
< 	if (sensor)
< 	{
< 		const b2Shape* shapeA = m_fixtureA->GetShape();
< 		const b2Shape* shapeB = m_fixtureB->GetShape();
< 		touching = b2TestOverlap(shapeA, m_indexA, shapeB, m_indexB, xfA, xfB);
---
> 	b2Body* body1 = m_shape1->GetBody();
> 	b2Body* body2 = m_shape2->GetBody();
187,190c160
< 		// Sensors don't generate manifolds.
< 		m_manifold.pointCount = 0;
< 	}
< 	else
---
> 	if (newCount == 0 && oldCount > 0)
192,221c162,163
< 		Evaluate(&m_manifold, xfA, xfB);
< 		touching = m_manifold.pointCount > 0;
< 
< 		// Match old contact ids to new contact ids and copy the
< 		// stored impulses to warm start the solver.
< 		for (int32 i = 0; i < m_manifold.pointCount; ++i)
< 		{
< 			b2ManifoldPoint* mp2 = m_manifold.points + i;
< 			mp2->normalImpulse = 0.0f;
< 			mp2->tangentImpulse = 0.0f;
< 			b2ContactID id2 = mp2->id;
< 
< 			for (int32 j = 0; j < oldManifold.pointCount; ++j)
< 			{
< 				b2ManifoldPoint* mp1 = oldManifold.points + j;
< 
< 				if (mp1->id.key == id2.key)
< 				{
< 					mp2->normalImpulse = mp1->normalImpulse;
< 					mp2->tangentImpulse = mp1->tangentImpulse;
< 					break;
< 				}
< 			}
< 		}
< 
< 		if (touching != wasTouching)
< 		{
< 			bodyA->SetAwake(true);
< 			bodyB->SetAwake(true);
< 		}
---
> 		body1->WakeUp();
> 		body2->WakeUp();
224c166,167
< 	if (touching)
---
> 	// Slow contacts don't generate TOI events.
> 	if (body1->IsStatic() || body1->IsBullet() || body2->IsStatic() || body2->IsBullet())
226c169
< 		m_flags |= e_touchingFlag;
---
> 		m_flags &= ~e_slowFlag;
230,245c173
< 		m_flags &= ~e_touchingFlag;
< 	}
< 
< 	if (wasTouching == false && touching == true && listener)
< 	{
< 		listener->BeginContact(this);
< 	}
< 
< 	if (wasTouching == true && touching == false && listener)
< 	{
< 		listener->EndContact(this);
< 	}
< 
< 	if (sensor == false && touching && listener)
< 	{
< 		listener->PreSolve(this, &oldManifold);
---
> 		m_flags |= e_slowFlag;
diff -r -x './svn/*' native/Box2D/Dynamics/Contacts/b2Contact.h ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Contacts/b2Contact.h
2c2
< * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
19,20c19,20
< #ifndef B2_CONTACT_H
< #define B2_CONTACT_H
---
> #ifndef CONTACT_H
> #define CONTACT_H
22,25c22,24
< #include <Box2D/Common/b2Math.h>
< #include <Box2D/Collision/b2Collision.h>
< #include <Box2D/Collision/Shapes/b2Shape.h>
< #include <Box2D/Dynamics/b2Fixture.h>
---
> #include "../../Common/b2Math.h"
> #include "../../Collision/b2Collision.h"
> #include "../../Collision/Shapes/b2Shape.h"
29d27
< class b2Fixture;
35,51c33
< /// Friction mixing law. The idea is to allow either fixture to drive the restitution to zero.
< /// For example, anything slides on ice.
< inline float32 b2MixFriction(float32 friction1, float32 friction2)
< {
< 	return std::sqrt(friction1 * friction2);
< }
< 
< /// Restitution mixing law. The idea is allow for anything to bounce off an inelastic surface.
< /// For example, a superball bounces on anything.
< inline float32 b2MixRestitution(float32 restitution1, float32 restitution2)
< {
< 	return restitution1 > restitution2 ? restitution1 : restitution2;
< }
< 
< typedef b2Contact* b2ContactCreateFcn(	b2Fixture* fixtureA, int32 indexA,
< 										b2Fixture* fixtureB, int32 indexB,
< 										b2BlockAllocator* allocator);
---
> typedef b2Contact* b2ContactCreateFcn(b2Shape* shape1, b2Shape* shape2, b2BlockAllocator* allocator);
73a56,81
> /// This structure is used to report contact points.
> struct b2ContactPoint
> {
> 	b2Shape* shape1;		///< the first shape
> 	b2Shape* shape2;		///< the second shape
> 	b2Vec2 position;		///< position in world coordinates
> 	b2Vec2 velocity;		///< velocity of point on body2 relative to point on body1 (pre-solver)
> 	b2Vec2 normal;			///< points from shape1 to shape2
> 	float32 separation;		///< the separation is negative when shapes are touching
> 	float32 friction;		///< the combined friction coefficient
> 	float32 restitution;	///< the combined restitution coefficient
> 	b2ContactID id;			///< the contact id identifies the features in contact
> };
> 
> /// This structure is used to report contact point results.
> struct b2ContactResult
> {
> 	b2Shape* shape1;		///< the first shape
> 	b2Shape* shape2;		///< the second shape
> 	b2Vec2 position;		///< position in world coordinates
> 	b2Vec2 normal;			///< points from shape1 to shape2
> 	float32 normalImpulse;	///< the normal impulse applied to body2
> 	float32 tangentImpulse;	///< the tangent impulse applied to body2
> 	b2ContactID id;			///< the contact id identifies the features in contact
> };
> 
81,95c89,90
< 	/// Get the contact manifold. Do not modify the manifold unless you understand the
< 	/// internals of Box2D.
< 	b2Manifold* GetManifold();
< 	const b2Manifold* GetManifold() const;
< 
< 	/// Get the world manifold.
< 	void GetWorldManifold(b2WorldManifold* worldManifold) const;
< 
< 	/// Is this contact touching?
< 	bool IsTouching() const;
< 
< 	/// Enable/disable this contact. This can be used inside the pre-solve
< 	/// contact listener. The contact is only disabled for the current
< 	/// time step (or sub-step in continuous collisions).
< 	void SetEnabled(bool flag);
---
> 	/// Get the manifold array.
> 	virtual b2Manifold* GetManifolds() = 0;
97,98c92,99
< 	/// Has this contact been disabled?
< 	bool IsEnabled() const;
---
> 	/// Get the number of manifolds. This is 0 or 1 between convex shapes.
> 	/// This may be greater than 1 for convex-vs-concave shapes. Each
> 	/// manifold holds up to two contact points with a shared contact normal.
> 	int32 GetManifoldCount() const;
> 
> 	/// Is this contact solid?
> 	/// @return true if this contact should generate a response.
> 	bool IsSolid() const;
102d102
< 	const b2Contact* GetNext() const;
104,106c104,105
< 	/// Get fixture A in this contact.
< 	b2Fixture* GetFixtureA();
< 	const b2Fixture* GetFixtureA() const;
---
> 	/// Get the first shape in this contact.
> 	b2Shape* GetShape1();
108,109c107,108
< 	/// Get the child primitive index for fixture A.
< 	int32 GetChildIndexA() const;
---
> 	/// Get the second shape in this contact.
> 	b2Shape* GetShape2();
111,152c110,111
< 	/// Get fixture B in this contact.
< 	b2Fixture* GetFixtureB();
< 	const b2Fixture* GetFixtureB() const;
< 
< 	/// Get the child primitive index for fixture B.
< 	int32 GetChildIndexB() const;
< 
< 	/// Override the default friction mixture. You can call this in b2ContactListener::PreSolve.
< 	/// This value persists until set or reset.
< 	void SetFriction(float32 friction);
< 
< 	/// Get the friction.
< 	float32 GetFriction() const;
< 
< 	/// Reset the friction mixture to the default value.
< 	void ResetFriction();
< 
< 	/// Override the default restitution mixture. You can call this in b2ContactListener::PreSolve.
< 	/// The value persists until you set or reset.
< 	void SetRestitution(float32 restitution);
< 
< 	/// Get the restitution.
< 	float32 GetRestitution() const;
< 
< 	/// Reset the restitution to the default value.
< 	void ResetRestitution();
< 
< 	/// Set the desired tangent speed for a conveyor belt behavior. In meters per second.
< 	void SetTangentSpeed(float32 speed);
< 
< 	/// Get the desired tangent speed. In meters per second.
< 	float32 GetTangentSpeed() const;
< 
< 	/// Evaluate this contact with your own manifold and transforms.
< 	virtual void Evaluate(b2Manifold* manifold, const b2Transform& xfA, const b2Transform& xfB) = 0;
< 
< protected:
< 	friend class b2ContactManager;
< 	friend class b2World;
< 	friend class b2ContactSolver;
< 	friend class b2Body;
< 	friend class b2Fixture;
---
> 	//--------------- Internals Below -------------------
> public:
154c113
< 	// Flags stored in m_flags
---
> 	// m_flags
157,173c116,119
< 		// Used when crawling contact graph when forming islands.
< 		e_islandFlag		= 0x0001,
< 
<         // Set when the shapes are touching.
< 		e_touchingFlag		= 0x0002,
< 
< 		// This contact can be disabled (by user)
< 		e_enabledFlag		= 0x0004,
< 
< 		// This contact needs filtering because a fixture filter was changed.
< 		e_filterFlag		= 0x0008,
< 
< 		// This bullet contact had a TOI event
< 		e_bulletHitFlag		= 0x0010,
< 
< 		// This contact has a valid TOI in m_toi
< 		e_toiFlag			= 0x0020
---
> 		e_nonSolidFlag	= 0x0001,
> 		e_slowFlag		= 0x0002,
> 		e_islandFlag	= 0x0004,
> 		e_toiFlag		= 0x0008,
176,178d121
< 	/// Flag this contact for filtering. Filtering will occur the next time step.
< 	void FlagForFiltering();
< 
180c123
< 						b2Shape::Type typeA, b2Shape::Type typeB);
---
> 						b2ShapeType type1, b2ShapeType type2);
182,183c125
< 	static b2Contact* Create(b2Fixture* fixtureA, int32 indexA, b2Fixture* fixtureB, int32 indexB, b2BlockAllocator* allocator);
< 	static void Destroy(b2Contact* contact, b2Shape::Type typeA, b2Shape::Type typeB, b2BlockAllocator* allocator);
---
> 	static b2Contact* Create(b2Shape* shape1, b2Shape* shape2, b2BlockAllocator* allocator);
186,187c128,129
< 	b2Contact() : m_fixtureA(NULL), m_fixtureB(NULL) {}
< 	b2Contact(b2Fixture* fixtureA, int32 indexA, b2Fixture* fixtureB, int32 indexB);
---
> 	b2Contact() : m_shape1(NULL), m_shape2(NULL) {}
> 	b2Contact(b2Shape* shape1, b2Shape* shape2);
191,192c133,134
< 
< 	static b2ContactRegister s_registers[b2Shape::e_typeCount][b2Shape::e_typeCount];
---
> 	virtual void Evaluate(b2ContactListener* listener) = 0;
> 	static b2ContactRegister s_registers[e_shapeTypeCount][e_shapeTypeCount];
195a138
> 	int32 m_manifoldCount;
202,209c145,146
< 	b2ContactEdge m_nodeA;
< 	b2ContactEdge m_nodeB;
< 
< 	b2Fixture* m_fixtureA;
< 	b2Fixture* m_fixtureB;
< 
< 	int32 m_indexA;
< 	int32 m_indexB;
---
> 	b2ContactEdge m_node1;
> 	b2ContactEdge m_node2;
211c148,149
< 	b2Manifold m_manifold;
---
> 	b2Shape* m_shape1;
> 	b2Shape* m_shape2;
213d150
< 	int32 m_toiCount;
215,219d151
< 
< 	float32 m_friction;
< 	float32 m_restitution;
< 
< 	float32 m_tangentSpeed;
222c154
< inline b2Manifold* b2Contact::GetManifold()
---
> inline int32 b2Contact::GetManifoldCount() const
224,251c156
< 	return &m_manifold;
< }
< 
< inline const b2Manifold* b2Contact::GetManifold() const
< {
< 	return &m_manifold;
< }
< 
< inline void b2Contact::GetWorldManifold(b2WorldManifold* worldManifold) const
< {
< 	const b2Body* bodyA = m_fixtureA->GetBody();
< 	const b2Body* bodyB = m_fixtureB->GetBody();
< 	const b2Shape* shapeA = m_fixtureA->GetShape();
< 	const b2Shape* shapeB = m_fixtureB->GetShape();
< 
< 	worldManifold->Initialize(&m_manifold, bodyA->GetTransform(), shapeA->m_radius, bodyB->GetTransform(), shapeB->m_radius);
< }
< 
< inline void b2Contact::SetEnabled(bool flag)
< {
< 	if (flag)
< 	{
< 		m_flags |= e_enabledFlag;
< 	}
< 	else
< 	{
< 		m_flags &= ~e_enabledFlag;
< 	}
---
> 	return m_manifoldCount;
254c159
< inline bool b2Contact::IsEnabled() const
---
> inline bool b2Contact::IsSolid() const
256,261c161
< 	return (m_flags & e_enabledFlag) == e_enabledFlag;
< }
< 
< inline bool b2Contact::IsTouching() const
< {
< 	return (m_flags & e_touchingFlag) == e_touchingFlag;
---
> 	return (m_flags & e_nonSolidFlag) == 0;
269,339c169
< inline const b2Contact* b2Contact::GetNext() const
< {
< 	return m_next;
< }
< 
< inline b2Fixture* b2Contact::GetFixtureA()
< {
< 	return m_fixtureA;
< }
< 
< inline const b2Fixture* b2Contact::GetFixtureA() const
< {
< 	return m_fixtureA;
< }
< 
< inline b2Fixture* b2Contact::GetFixtureB()
< {
< 	return m_fixtureB;
< }
< 
< inline int32 b2Contact::GetChildIndexA() const
< {
< 	return m_indexA;
< }
< 
< inline const b2Fixture* b2Contact::GetFixtureB() const
< {
< 	return m_fixtureB;
< }
< 
< inline int32 b2Contact::GetChildIndexB() const
< {
< 	return m_indexB;
< }
< 
< inline void b2Contact::FlagForFiltering()
< {
< 	m_flags |= e_filterFlag;
< }
< 
< inline void b2Contact::SetFriction(float32 friction)
< {
< 	m_friction = friction;
< }
< 
< inline float32 b2Contact::GetFriction() const
< {
< 	return m_friction;
< }
< 
< inline void b2Contact::ResetFriction()
< {
< 	m_friction = b2MixFriction(m_fixtureA->m_friction, m_fixtureB->m_friction);
< }
< 
< inline void b2Contact::SetRestitution(float32 restitution)
< {
< 	m_restitution = restitution;
< }
< 
< inline float32 b2Contact::GetRestitution() const
< {
< 	return m_restitution;
< }
< 
< inline void b2Contact::ResetRestitution()
< {
< 	m_restitution = b2MixRestitution(m_fixtureA->m_restitution, m_fixtureB->m_restitution);
< }
< 
< inline void b2Contact::SetTangentSpeed(float32 speed)
---
> inline b2Shape* b2Contact::GetShape1()
341c171
< 	m_tangentSpeed = speed;
---
> 	return m_shape1;
344c174
< inline float32 b2Contact::GetTangentSpeed() const
---
> inline b2Shape* b2Contact::GetShape2()
346c176
< 	return m_tangentSpeed;
---
> 	return m_shape2;
diff -r -x './svn/*' native/Box2D/Dynamics/Contacts/b2ContactSolver.cpp ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Contacts/b2ContactSolver.cpp
2c2
< * Copyright (c) 2006-2011 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
19,25c19,23
< #include <Box2D/Dynamics/Contacts/b2ContactSolver.h>
< 
< #include <Box2D/Dynamics/Contacts/b2Contact.h>
< #include <Box2D/Dynamics/b2Body.h>
< #include <Box2D/Dynamics/b2Fixture.h>
< #include <Box2D/Dynamics/b2World.h>
< #include <Box2D/Common/b2StackAllocator.h>
---
> #include "b2ContactSolver.h"
> #include "b2Contact.h"
> #include "../b2Body.h"
> #include "../b2World.h"
> #include "../../Common/b2StackAllocator.h"
29,44c27
< struct b2ContactPositionConstraint
< {
< 	b2Vec2 localPoints[b2_maxManifoldPoints];
< 	b2Vec2 localNormal;
< 	b2Vec2 localPoint;
< 	int32 indexA;
< 	int32 indexB;
< 	float32 invMassA, invMassB;
< 	b2Vec2 localCenterA, localCenterB;
< 	float32 invIA, invIB;
< 	b2Manifold::Type type;
< 	float32 radiusA, radiusB;
< 	int32 pointCount;
< };
< 
< b2ContactSolver::b2ContactSolver(b2ContactSolverDef* def)
---
> b2ContactSolver::b2ContactSolver(const b2TimeStep& step, b2Contact** contacts, int32 contactCount, b2StackAllocator* allocator)
46,53c29,30
< 	m_step = def->step;
< 	m_allocator = def->allocator;
< 	m_count = def->count;
< 	m_positionConstraints = (b2ContactPositionConstraint*)m_allocator->Allocate(m_count * sizeof(b2ContactPositionConstraint));
< 	m_velocityConstraints = (b2ContactVelocityConstraint*)m_allocator->Allocate(m_count * sizeof(b2ContactVelocityConstraint));
< 	m_positions = def->positions;
< 	m_velocities = def->velocities;
< 	m_contacts = def->contacts;
---
> 	m_step = step;
> 	m_allocator = allocator;
55,56c32,33
< 	// Initialize position independent portions of the constraints.
< 	for (int32 i = 0; i < m_count; ++i)
---
> 	m_constraintCount = 0;
> 	for (int32 i = 0; i < contactCount; ++i)
58,127c35,36
< 		b2Contact* contact = m_contacts[i];
< 
< 		b2Fixture* fixtureA = contact->m_fixtureA;
< 		b2Fixture* fixtureB = contact->m_fixtureB;
< 		b2Shape* shapeA = fixtureA->GetShape();
< 		b2Shape* shapeB = fixtureB->GetShape();
< 		float32 radiusA = shapeA->m_radius;
< 		float32 radiusB = shapeB->m_radius;
< 		b2Body* bodyA = fixtureA->GetBody();
< 		b2Body* bodyB = fixtureB->GetBody();
< 		b2Manifold* manifold = contact->GetManifold();
< 
< 		int32 pointCount = manifold->pointCount;
< 		b2Assert(pointCount > 0);
< 
< 		b2ContactVelocityConstraint* vc = m_velocityConstraints + i;
< 		vc->friction = contact->m_friction;
< 		vc->restitution = contact->m_restitution;
< 		vc->tangentSpeed = contact->m_tangentSpeed;
< 		vc->indexA = bodyA->m_islandIndex;
< 		vc->indexB = bodyB->m_islandIndex;
< 		vc->invMassA = bodyA->m_invMass;
< 		vc->invMassB = bodyB->m_invMass;
< 		vc->invIA = bodyA->m_invI;
< 		vc->invIB = bodyB->m_invI;
< 		vc->contactIndex = i;
< 		vc->pointCount = pointCount;
< 		vc->K.SetZero();
< 		vc->normalMass.SetZero();
< 
< 		b2ContactPositionConstraint* pc = m_positionConstraints + i;
< 		pc->indexA = bodyA->m_islandIndex;
< 		pc->indexB = bodyB->m_islandIndex;
< 		pc->invMassA = bodyA->m_invMass;
< 		pc->invMassB = bodyB->m_invMass;
< 		pc->localCenterA = bodyA->m_sweep.localCenter;
< 		pc->localCenterB = bodyB->m_sweep.localCenter;
< 		pc->invIA = bodyA->m_invI;
< 		pc->invIB = bodyB->m_invI;
< 		pc->localNormal = manifold->localNormal;
< 		pc->localPoint = manifold->localPoint;
< 		pc->pointCount = pointCount;
< 		pc->radiusA = radiusA;
< 		pc->radiusB = radiusB;
< 		pc->type = manifold->type;
< 
< 		for (int32 j = 0; j < pointCount; ++j)
< 		{
< 			b2ManifoldPoint* cp = manifold->points + j;
< 			b2VelocityConstraintPoint* vcp = vc->points + j;
< 	
< 			if (m_step.warmStarting)
< 			{
< 				vcp->normalImpulse = m_step.dtRatio * cp->normalImpulse;
< 				vcp->tangentImpulse = m_step.dtRatio * cp->tangentImpulse;
< 			}
< 			else
< 			{
< 				vcp->normalImpulse = 0.0f;
< 				vcp->tangentImpulse = 0.0f;
< 			}
< 
< 			vcp->rA.SetZero();
< 			vcp->rB.SetZero();
< 			vcp->normalMass = 0.0f;
< 			vcp->tangentMass = 0.0f;
< 			vcp->velocityBias = 0.0f;
< 
< 			pc->localPoints[j] = cp->localPoint;
< 		}
---
> 		b2Assert(contacts[i]->IsSolid());
> 		m_constraintCount += contacts[i]->GetManifoldCount();
129d37
< }
131,135c39
< b2ContactSolver::~b2ContactSolver()
< {
< 	m_allocator->Free(m_velocityConstraints);
< 	m_allocator->Free(m_positionConstraints);
< }
---
> 	m_constraints = (b2ContactConstraint*)m_allocator->Allocate(m_constraintCount * sizeof(b2ContactConstraint));
137,140c41,42
< // Initialize position dependent portions of the velocity constraints.
< void b2ContactSolver::InitializeVelocityConstraints()
< {
< 	for (int32 i = 0; i < m_count; ++i)
---
> 	int32 count = 0;
> 	for (int32 i = 0; i < contactCount; ++i)
142,175c44
< 		b2ContactVelocityConstraint* vc = m_velocityConstraints + i;
< 		b2ContactPositionConstraint* pc = m_positionConstraints + i;
< 
< 		float32 radiusA = pc->radiusA;
< 		float32 radiusB = pc->radiusB;
< 		b2Manifold* manifold = m_contacts[vc->contactIndex]->GetManifold();
< 
< 		int32 indexA = vc->indexA;
< 		int32 indexB = vc->indexB;
< 
< 		float32 mA = vc->invMassA;
< 		float32 mB = vc->invMassB;
< 		float32 iA = vc->invIA;
< 		float32 iB = vc->invIB;
< 		b2Vec2 localCenterA = pc->localCenterA;
< 		b2Vec2 localCenterB = pc->localCenterB;
< 
< 		b2Vec2 cA = m_positions[indexA].c;
< 		float32 aA = m_positions[indexA].a;
< 		b2Vec2 vA = m_velocities[indexA].v;
< 		float32 wA = m_velocities[indexA].w;
< 
< 		b2Vec2 cB = m_positions[indexB].c;
< 		float32 aB = m_positions[indexB].a;
< 		b2Vec2 vB = m_velocities[indexB].v;
< 		float32 wB = m_velocities[indexB].w;
< 
< 		b2Assert(manifold->pointCount > 0);
< 
< 		b2Transform xfA, xfB;
< 		xfA.q.Set(aA);
< 		xfB.q.Set(aB);
< 		xfA.p = cA - b2Mul(xfA.q, localCenterA);
< 		xfB.p = cB - b2Mul(xfB.q, localCenterB);
---
> 		b2Contact* contact = contacts[i];
177,178c46,77
< 		b2WorldManifold worldManifold;
< 		worldManifold.Initialize(manifold, xfA, radiusA, xfB, radiusB);
---
> 		b2Shape* shape1 = contact->m_shape1;
> 		b2Shape* shape2 = contact->m_shape2;
> 		b2Body* b1 = shape1->GetBody();
> 		b2Body* b2 = shape2->GetBody();
> 		int32 manifoldCount = contact->GetManifoldCount();
> 		b2Manifold* manifolds = contact->GetManifolds();
> 
> 		float32 friction = b2MixFriction(shape1->GetFriction(), shape2->GetFriction());
> 		float32 restitution = b2MixRestitution(shape1->GetRestitution(), shape2->GetRestitution());
> 
> 		b2Vec2 v1 = b1->m_linearVelocity;
> 		b2Vec2 v2 = b2->m_linearVelocity;
> 		float32 w1 = b1->m_angularVelocity;
> 		float32 w2 = b2->m_angularVelocity;
> 
> 		for (int32 j = 0; j < manifoldCount; ++j)
> 		{
> 			b2Manifold* manifold = manifolds + j;
> 
> 			b2Assert(manifold->pointCount > 0);
> 
> 			const b2Vec2 normal = manifold->normal;
> 
> 			b2Assert(count < m_constraintCount);
> 			b2ContactConstraint* cc = m_constraints + count;
> 			cc->body1 = b1;
> 			cc->body2 = b2;
> 			cc->manifold = manifold;
> 			cc->normal = normal;
> 			cc->pointCount = manifold->pointCount;
> 			cc->friction = friction;
> 			cc->restitution = restitution;
180,185c79,82
< 		vc->normal = worldManifold.normal;
< 
< 		int32 pointCount = vc->pointCount;
< 		for (int32 j = 0; j < pointCount; ++j)
< 		{
< 			b2VelocityConstraintPoint* vcp = vc->points + j;
---
> 			for (int32 k = 0; k < cc->pointCount; ++k)
> 			{
> 				b2ManifoldPoint* cp = manifold->points + k;
> 				b2ContactConstraintPoint* ccp = cc->points + k;
187,188c84,86
< 			vcp->rA = worldManifold.points[j] - cA;
< 			vcp->rB = worldManifold.points[j] - cB;
---
> 				ccp->normalImpulse = cp->normalImpulse;
> 				ccp->tangentImpulse = cp->tangentImpulse;
> 				ccp->separation = cp->separation;
190,191c88,91
< 			float32 rnA = b2Cross(vcp->rA, vc->normal);
< 			float32 rnB = b2Cross(vcp->rB, vc->normal);
---
> 				ccp->localAnchor1 = cp->localPoint1;
> 				ccp->localAnchor2 = cp->localPoint2;
> 				ccp->r1 = b2Mul(b1->GetXForm().R, cp->localPoint1 - b1->GetLocalCenter());
> 				ccp->r2 = b2Mul(b2->GetXForm().R, cp->localPoint2 - b2->GetLocalCenter());
193c93,96
< 			float32 kNormal = mA + mB + iA * rnA * rnA + iB * rnB * rnB;
---
> 				float32 rn1 = b2Cross(ccp->r1, normal);
> 				float32 rn2 = b2Cross(ccp->r2, normal);
> 				rn1 *= rn1;
> 				rn2 *= rn2;
195c98
< 			vcp->normalMass = kNormal > 0.0f ? 1.0f / kNormal : 0.0f;
---
> 				float32 kNormal = b1->m_invMass + b2->m_invMass + b1->m_invI * rn1 + b2->m_invI * rn2;
197c100,101
< 			b2Vec2 tangent = b2Cross(vc->normal, 1.0f);
---
> 				b2Assert(kNormal > B2_FLT_EPSILON);
> 				ccp->normalMass = 1.0f / kNormal;
199,200c103,104
< 			float32 rtA = b2Cross(vcp->rA, tangent);
< 			float32 rtB = b2Cross(vcp->rB, tangent);
---
> 				float32 kEqualized = b1->m_mass * b1->m_invMass + b2->m_mass * b2->m_invMass;
> 				kEqualized += b1->m_mass * b1->m_invI * rn1 + b2->m_mass * b2->m_invI * rn2;
202c106,107
< 			float32 kTangent = mA + mB + iA * rtA * rtA + iB * rtB * rtB;
---
> 				b2Assert(kEqualized > B2_FLT_EPSILON);
> 				ccp->equalizedMass = 1.0f / kEqualized;
204c109
< 			vcp->tangentMass = kTangent > 0.0f ? 1.0f /  kTangent : 0.0f;
---
> 				b2Vec2 tangent = b2Cross(normal, 1.0f);
206,213c111,114
< 			// Setup a velocity bias for restitution.
< 			vcp->velocityBias = 0.0f;
< 			float32 vRel = b2Dot(vc->normal, vB + b2Cross(wB, vcp->rB) - vA - b2Cross(wA, vcp->rA));
< 			if (vRel < -b2_velocityThreshold)
< 			{
< 				vcp->velocityBias = -vc->restitution * vRel;
< 			}
< 		}
---
> 				float32 rt1 = b2Cross(ccp->r1, tangent);
> 				float32 rt2 = b2Cross(ccp->r2, tangent);
> 				rt1 *= rt1;
> 				rt2 *= rt2;
215,219c116
< 		// If we have two points, then prepare the block solver.
< 		if (vc->pointCount == 2)
< 		{
< 			b2VelocityConstraintPoint* vcp1 = vc->points + 0;
< 			b2VelocityConstraintPoint* vcp2 = vc->points + 1;
---
> 				float32 kTangent = b1->m_invMass + b2->m_invMass + b1->m_invI * rt1 + b2->m_invI * rt2;
221,228c118,119
< 			float32 rn1A = b2Cross(vcp1->rA, vc->normal);
< 			float32 rn1B = b2Cross(vcp1->rB, vc->normal);
< 			float32 rn2A = b2Cross(vcp2->rA, vc->normal);
< 			float32 rn2B = b2Cross(vcp2->rB, vc->normal);
< 
< 			float32 k11 = mA + mB + iA * rn1A * rn1A + iB * rn1B * rn1B;
< 			float32 k22 = mA + mB + iA * rn2A * rn2A + iB * rn2B * rn2B;
< 			float32 k12 = mA + mB + iA * rn1A * rn2A + iB * rn1B * rn2B;
---
> 				b2Assert(kTangent > B2_FLT_EPSILON);
> 				ccp->tangentMass = 1.0f /  kTangent;
230,237c121,134
< 			// Ensure a reasonable condition number.
< 			const float32 k_maxConditionNumber = 1000.0f;
< 			if (k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12))
< 			{
< 				// K is safe to invert.
< 				vc->K.ex.Set(k11, k12);
< 				vc->K.ey.Set(k12, k22);
< 				vc->normalMass = vc->K.GetInverse();
---
> 				// Setup a velocity bias for restitution.
> 				ccp->velocityBias = 0.0f;
> 				if (ccp->separation > 0.0f)
> 				{
> 					ccp->velocityBias = -step.inv_dt * ccp->separation; // TODO_ERIN b2TimeStep
> 				}
> 				else
> 				{
> 					float32 vRel = b2Dot(cc->normal, v2 + b2Cross(w2, ccp->r2) - v1 - b2Cross(w1, ccp->r1));
> 					if (vRel < -b2_velocityThreshold)
> 					{
> 						ccp->velocityBias = -cc->restitution * vRel;
> 					}
> 				}
239c136,138
< 			else
---
> 
> 			// If we have two points, then prepare the block solver.
> 			if (cc->pointCount == 2)
241,243c140,171
< 				// The constraints are redundant, just use one.
< 				// TODO_ERIN use deepest?
< 				vc->pointCount = 1;
---
> 				b2ContactConstraintPoint* ccp1 = cc->points + 0;
> 				b2ContactConstraintPoint* ccp2 = cc->points + 1;
> 				
> 				float32 invMass1 = b1->m_invMass;
> 				float32 invI1 = b1->m_invI;
> 				float32 invMass2 = b2->m_invMass;
> 				float32 invI2 = b2->m_invI;
> 
> 				float32 rn11 = b2Cross(ccp1->r1, normal);
> 				float32 rn12 = b2Cross(ccp1->r2, normal);
> 				float32 rn21 = b2Cross(ccp2->r1, normal);
> 				float32 rn22 = b2Cross(ccp2->r2, normal);
> 
> 				float32 k11 = invMass1 + invMass2 + invI1 * rn11 * rn11 + invI2 * rn12 * rn12;
> 				float32 k22 = invMass1 + invMass2 + invI1 * rn21 * rn21 + invI2 * rn22 * rn22;
> 				float32 k12 = invMass1 + invMass2 + invI1 * rn11 * rn21 + invI2 * rn12 * rn22;
> 
> 				// Ensure a reasonable condition number.
> 				const float32 k_maxConditionNumber = 100.0f;
> 				if (k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12))
> 				{
> 					// K is safe to invert.
> 					cc->K.col1.Set(k11, k12);
> 					cc->K.col2.Set(k12, k22);
> 					cc->normalMass = cc->K.GetInverse();
> 				}
> 				else
> 				{
> 					// The constraints are redundant, just use one.
> 					// TODO_ERIN use deepest?
> 					cc->pointCount = 1;
> 				}
244a173,174
> 
> 			++count;
246a177,183
> 
> 	b2Assert(count == m_constraintCount);
> }
> 
> b2ContactSolver::~b2ContactSolver()
> {
> 	m_allocator->Free(m_constraints);
249c186
< void b2ContactSolver::WarmStart()
---
> void b2ContactSolver::InitVelocityConstraints(const b2TimeStep& step)
252c189
< 	for (int32 i = 0; i < m_count; ++i)
---
> 	for (int32 i = 0; i < m_constraintCount; ++i)
254,267c191
< 		b2ContactVelocityConstraint* vc = m_velocityConstraints + i;
< 
< 		int32 indexA = vc->indexA;
< 		int32 indexB = vc->indexB;
< 		float32 mA = vc->invMassA;
< 		float32 iA = vc->invIA;
< 		float32 mB = vc->invMassB;
< 		float32 iB = vc->invIB;
< 		int32 pointCount = vc->pointCount;
< 
< 		b2Vec2 vA = m_velocities[indexA].v;
< 		float32 wA = m_velocities[indexA].w;
< 		b2Vec2 vB = m_velocities[indexB].v;
< 		float32 wB = m_velocities[indexB].w;
---
> 		b2ContactConstraint* c = m_constraints + i;
269c193,199
< 		b2Vec2 normal = vc->normal;
---
> 		b2Body* b1 = c->body1;
> 		b2Body* b2 = c->body2;
> 		float32 invMass1 = b1->m_invMass;
> 		float32 invI1 = b1->m_invI;
> 		float32 invMass2 = b2->m_invMass;
> 		float32 invI2 = b2->m_invI;
> 		b2Vec2 normal = c->normal;
272c202,216
< 		for (int32 j = 0; j < pointCount; ++j)
---
> 		if (step.warmStarting)
> 		{
> 			for (int32 j = 0; j < c->pointCount; ++j)
> 			{
> 				b2ContactConstraintPoint* ccp = c->points + j;
> 				ccp->normalImpulse *= step.dtRatio;
> 				ccp->tangentImpulse *= step.dtRatio;
> 				b2Vec2 P = ccp->normalImpulse * normal + ccp->tangentImpulse * tangent;
> 				b1->m_angularVelocity -= invI1 * b2Cross(ccp->r1, P);
> 				b1->m_linearVelocity -= invMass1 * P;
> 				b2->m_angularVelocity += invI2 * b2Cross(ccp->r2, P);
> 				b2->m_linearVelocity += invMass2 * P;
> 			}
> 		}
> 		else
274,279c218,223
< 			b2VelocityConstraintPoint* vcp = vc->points + j;
< 			b2Vec2 P = vcp->normalImpulse * normal + vcp->tangentImpulse * tangent;
< 			wA -= iA * b2Cross(vcp->rA, P);
< 			vA -= mA * P;
< 			wB += iB * b2Cross(vcp->rB, P);
< 			vB += mB * P;
---
> 			for (int32 j = 0; j < c->pointCount; ++j)
> 			{
> 				b2ContactConstraintPoint* ccp = c->points + j;
> 				ccp->normalImpulse = 0.0f;
> 				ccp->tangentImpulse = 0.0f;
> 			}
281,285d224
< 
< 		m_velocities[indexA].v = vA;
< 		m_velocities[indexA].w = wA;
< 		m_velocities[indexB].v = vB;
< 		m_velocities[indexB].w = wB;
291c230
< 	for (int32 i = 0; i < m_count; ++i)
---
> 	for (int32 i = 0; i < m_constraintCount; ++i)
293,308c232,243
< 		b2ContactVelocityConstraint* vc = m_velocityConstraints + i;
< 
< 		int32 indexA = vc->indexA;
< 		int32 indexB = vc->indexB;
< 		float32 mA = vc->invMassA;
< 		float32 iA = vc->invIA;
< 		float32 mB = vc->invMassB;
< 		float32 iB = vc->invIB;
< 		int32 pointCount = vc->pointCount;
< 
< 		b2Vec2 vA = m_velocities[indexA].v;
< 		float32 wA = m_velocities[indexA].w;
< 		b2Vec2 vB = m_velocities[indexB].v;
< 		float32 wB = m_velocities[indexB].w;
< 
< 		b2Vec2 normal = vc->normal;
---
> 		b2ContactConstraint* c = m_constraints + i;
> 		b2Body* b1 = c->body1;
> 		b2Body* b2 = c->body2;
> 		float32 w1 = b1->m_angularVelocity;
> 		float32 w2 = b2->m_angularVelocity;
> 		b2Vec2 v1 = b1->m_linearVelocity;
> 		b2Vec2 v2 = b2->m_linearVelocity;
> 		float32 invMass1 = b1->m_invMass;
> 		float32 invI1 = b1->m_invI;
> 		float32 invMass2 = b2->m_invMass;
> 		float32 invI2 = b2->m_invI;
> 		b2Vec2 normal = c->normal;
310c245
< 		float32 friction = vc->friction;
---
> 		float32 friction = c->friction;
312,341c247
< 		b2Assert(pointCount == 1 || pointCount == 2);
< 
< 		// Solve tangent constraints first because non-penetration is more important
< 		// than friction.
< 		for (int32 j = 0; j < pointCount; ++j)
< 		{
< 			b2VelocityConstraintPoint* vcp = vc->points + j;
< 
< 			// Relative velocity at contact
< 			b2Vec2 dv = vB + b2Cross(wB, vcp->rB) - vA - b2Cross(wA, vcp->rA);
< 
< 			// Compute tangent force
< 			float32 vt = b2Dot(dv, tangent) - vc->tangentSpeed;
< 			float32 lambda = vcp->tangentMass * (-vt);
< 
< 			// b2Clamp the accumulated force
< 			float32 maxFriction = friction * vcp->normalImpulse;
< 			float32 newImpulse = b2Clamp(vcp->tangentImpulse + lambda, -maxFriction, maxFriction);
< 			lambda = newImpulse - vcp->tangentImpulse;
< 			vcp->tangentImpulse = newImpulse;
< 
< 			// Apply contact impulse
< 			b2Vec2 P = lambda * tangent;
< 
< 			vA -= mA * P;
< 			wA -= iA * b2Cross(vcp->rA, P);
< 
< 			vB += mB * P;
< 			wB += iB * b2Cross(vcp->rB, P);
< 		}
---
> 		b2Assert(c->pointCount == 1 || c->pointCount == 2);
344c250
< 		if (vc->pointCount == 1)
---
> 		if (c->pointCount == 1)
346c252
< 			b2VelocityConstraintPoint* vcp = vc->points + 0;
---
> 			b2ContactConstraintPoint* ccp = c->points + 0;
349c255
< 			b2Vec2 dv = vB + b2Cross(wB, vcp->rB) - vA - b2Cross(wA, vcp->rA);
---
> 			b2Vec2 dv = v2 + b2Cross(w2, ccp->r2) - v1 - b2Cross(w1, ccp->r1);
353c259
< 			float32 lambda = -vcp->normalMass * (vn - vcp->velocityBias);
---
> 			float32 lambda = -ccp->normalMass * (vn - ccp->velocityBias);
356,358c262,263
< 			float32 newImpulse = b2Max(vcp->normalImpulse + lambda, 0.0f);
< 			lambda = newImpulse - vcp->normalImpulse;
< 			vcp->normalImpulse = newImpulse;
---
> 			float32 newImpulse = b2Max(ccp->normalImpulse + lambda, 0.0f);
> 			lambda = newImpulse - ccp->normalImpulse;
362,363c267,268
< 			vA -= mA * P;
< 			wA -= iA * b2Cross(vcp->rA, P);
---
> 			v1 -= invMass1 * P;
> 			w1 -= invI1 * b2Cross(ccp->r1, P);
365,366c270,272
< 			vB += mB * P;
< 			wB += iB * b2Cross(vcp->rB, P);
---
> 			v2 += invMass2 * P;
> 			w2 += invI2 * b2Cross(ccp->r2, P);
> 			ccp->normalImpulse = newImpulse;
376c282
< 			// b = vn0 - velocityBias
---
> 			// b = vn_0 - velocityBias
388c294
< 			// x = a + d
---
> 			// x = x' - a
390,395c296
< 			// a := old total impulse
< 			// x := new total impulse
< 			// d := incremental impulse 
< 			//
< 			// For the current iteration we extend the formula for the incremental impulse
< 			// to compute the new total impulse:
---
> 			// Plug into above equation:
397,400c298,301
< 			// vn = A * d + b
< 			//    = A * (x - a) + b
< 			//    = A * x + b - A * a
< 			//    = A * x + b'
---
> 			// vn = A * x + b
> 			//    = A * (x' - a) + b
> 			//    = A * x' + b - A * a
> 			//    = A * x' + b'
403,404c304,305
< 			b2VelocityConstraintPoint* cp1 = vc->points + 0;
< 			b2VelocityConstraintPoint* cp2 = vc->points + 1;
---
> 			b2ContactConstraintPoint* cp1 = c->points + 0;
> 			b2ContactConstraintPoint* cp2 = c->points + 1;
410,411c311,312
< 			b2Vec2 dv1 = vB + b2Cross(wB, cp1->rB) - vA - b2Cross(wA, cp1->rA);
< 			b2Vec2 dv2 = vB + b2Cross(wB, cp2->rB) - vA - b2Cross(wA, cp2->rA);
---
> 			b2Vec2 dv1 = v2 + b2Cross(w2, cp1->r2) - v1 - b2Cross(w1, cp1->r1);
> 			b2Vec2 dv2 = v2 + b2Cross(w2, cp2->r2) - v1 - b2Cross(w1, cp2->r1);
420,422c321
< 
< 			// Compute b'
< 			b -= b2Mul(vc->K, a);
---
> 			b -= b2Mul(c->K, a);
432c331
< 				// 0 = A * x + b'
---
> 				// 0 = A * x' + b'
434c333
< 				// Solve for x:
---
> 				// Solve for x':
436c335
< 				// x = - inv(A) * b'
---
> 				// x' = - inv(A) * b'
438c337
< 				b2Vec2 x = - b2Mul(vc->normalMass, b);
---
> 				b2Vec2 x = - b2Mul(c->normalMass, b);
442c341
< 					// Get the incremental impulse
---
> 					// Resubstitute for the incremental impulse
448,449c347,348
< 					vA -= mA * (P1 + P2);
< 					wA -= iA * (b2Cross(cp1->rA, P1) + b2Cross(cp2->rA, P2));
---
> 					v1 -= invMass1 * (P1 + P2);
> 					w1 -= invI1 * (b2Cross(cp1->r1, P1) + b2Cross(cp2->r1, P2));
451,452c350,351
< 					vB += mB * (P1 + P2);
< 					wB += iB * (b2Cross(cp1->rB, P1) + b2Cross(cp2->rB, P2));
---
> 					v2 += invMass2 * (P1 + P2);
> 					w2 += invI2 * (b2Cross(cp1->r2, P1) + b2Cross(cp2->r2, P2));
460,461c359,360
< 					dv1 = vB + b2Cross(wB, cp1->rB) - vA - b2Cross(wA, cp1->rA);
< 					dv2 = vB + b2Cross(wB, cp2->rB) - vA - b2Cross(wA, cp2->rA);
---
> 					dv1 = v2 + b2Cross(w2, cp1->r2) - v1 - b2Cross(w1, cp1->r1);
> 					dv2 = v2 + b2Cross(w2, cp2->r2) - v1 - b2Cross(w1, cp2->r1);
476,477c375,376
< 				//   0 = a11 * x1 + a12 * 0 + b1' 
< 				// vn2 = a21 * x1 + a22 * 0 + b2'
---
> 				//   0 = a11 * x1' + a12 * 0 + b1' 
> 				// vn2 = a21 * x1' + a22 * 0 + b2'
482c381
< 				vn2 = vc->K.ex.y * x.x + b.y;
---
> 				vn2 = c->K.col1.y * x.x + b.y;
486c385
< 					// Get the incremental impulse
---
> 					// Resubstitute for the incremental impulse
492,493c391,392
< 					vA -= mA * (P1 + P2);
< 					wA -= iA * (b2Cross(cp1->rA, P1) + b2Cross(cp2->rA, P2));
---
> 					v1 -= invMass1 * (P1 + P2);
> 					w1 -= invI1 * (b2Cross(cp1->r1, P1) + b2Cross(cp2->r1, P2));
495,496c394,395
< 					vB += mB * (P1 + P2);
< 					wB += iB * (b2Cross(cp1->rB, P1) + b2Cross(cp2->rB, P2));
---
> 					v2 += invMass2 * (P1 + P2);
> 					w2 += invI2 * (b2Cross(cp1->r2, P1) + b2Cross(cp2->r2, P2));
504c403
< 					dv1 = vB + b2Cross(wB, cp1->rB) - vA - b2Cross(wA, cp1->rA);
---
> 					dv1 = v2 + b2Cross(w2, cp1->r2) - v1 - b2Cross(w1, cp1->r1);
516c415
< 				// Case 3: vn2 = 0 and x1 = 0
---
> 				// Case 3: w2 = 0 and x1 = 0
518,519c417,418
< 				// vn1 = a11 * 0 + a12 * x2 + b1' 
< 				//   0 = a21 * 0 + a22 * x2 + b2'
---
> 				// vn1 = a11 * 0 + a12 * x2' + b1' 
> 				//   0 = a21 * 0 + a22 * x2' + b2'
523c422
< 				vn1 = vc->K.ey.x * x.y + b.x;
---
> 				vn1 = c->K.col2.x * x.y + b.x;
534,535c433,434
< 					vA -= mA * (P1 + P2);
< 					wA -= iA * (b2Cross(cp1->rA, P1) + b2Cross(cp2->rA, P2));
---
> 					v1 -= invMass1 * (P1 + P2);
> 					w1 -= invI1 * (b2Cross(cp1->r1, P1) + b2Cross(cp2->r1, P2));
537,538c436,437
< 					vB += mB * (P1 + P2);
< 					wB += iB * (b2Cross(cp1->rB, P1) + b2Cross(cp2->rB, P2));
---
> 					v2 += invMass2 * (P1 + P2);
> 					w2 += invI2 * (b2Cross(cp1->r2, P1) + b2Cross(cp2->r2, P2));
546c445
< 					dv2 = vB + b2Cross(wB, cp2->rB) - vA - b2Cross(wA, cp2->rA);
---
> 					dv2 = v2 + b2Cross(w2, cp2->r2) - v1 - b2Cross(w1, cp2->r1);
574,575c473,474
< 					vA -= mA * (P1 + P2);
< 					wA -= iA * (b2Cross(cp1->rA, P1) + b2Cross(cp2->rA, P2));
---
> 					v1 -= invMass1 * (P1 + P2);
> 					w1 -= invI1 * (b2Cross(cp1->r1, P1) + b2Cross(cp2->r1, P2));
577,578c476,477
< 					vB += mB * (P1 + P2);
< 					wB += iB * (b2Cross(cp1->rB, P1) + b2Cross(cp2->rB, P2));
---
> 					v2 += invMass2 * (P1 + P2);
> 					w2 += invI2 * (b2Cross(cp1->r2, P1) + b2Cross(cp2->r2, P2));
592,597c491,494
< 		m_velocities[indexA].v = vA;
< 		m_velocities[indexA].w = wA;
< 		m_velocities[indexB].v = vB;
< 		m_velocities[indexB].w = wB;
< 	}
< }
---
> 		// Solve tangent constraints
> 		for (int32 j = 0; j < c->pointCount; ++j)
> 		{
> 			b2ContactConstraintPoint* ccp = c->points + j;
599,604c496,497
< void b2ContactSolver::StoreImpulses()
< {
< 	for (int32 i = 0; i < m_count; ++i)
< 	{
< 		b2ContactVelocityConstraint* vc = m_velocityConstraints + i;
< 		b2Manifold* manifold = m_contacts[vc->contactIndex]->GetManifold();
---
> 			// Relative velocity at contact
> 			b2Vec2 dv = v2 + b2Cross(w2, ccp->r2) - v1 - b2Cross(w1, ccp->r1);
606,609c499,517
< 		for (int32 j = 0; j < vc->pointCount; ++j)
< 		{
< 			manifold->points[j].normalImpulse = vc->points[j].normalImpulse;
< 			manifold->points[j].tangentImpulse = vc->points[j].tangentImpulse;
---
> 			// Compute tangent force
> 			float32 vt = b2Dot(dv, tangent);
> 			float32 lambda = ccp->tangentMass * (-vt);
> 
> 			// b2Clamp the accumulated force
> 			float32 maxFriction = friction * ccp->normalImpulse;
> 			float32 newImpulse = b2Clamp(ccp->tangentImpulse + lambda, -maxFriction, maxFriction);
> 			lambda = newImpulse - ccp->tangentImpulse;
> 
> 			// Apply contact impulse
> 			b2Vec2 P = lambda * tangent;
> 
> 			v1 -= invMass1 * P;
> 			w1 -= invI1 * b2Cross(ccp->r1, P);
> 
> 			v2 += invMass2 * P;
> 			w2 += invI2 * b2Cross(ccp->r2, P);
> 
> 			ccp->tangentImpulse = newImpulse;
610a519,523
> 
> 		b1->m_linearVelocity = v1;
> 		b1->m_angularVelocity = w1;
> 		b2->m_linearVelocity = v2;
> 		b2->m_angularVelocity = w2;
614c527
< struct b2PositionSolverManifold
---
> void b2ContactSolver::FinalizeVelocityConstraints()
616c529
< 	void Initialize(b2ContactPositionConstraint* pc, const b2Transform& xfA, const b2Transform& xfB, int32 index)
---
> 	for (int32 i = 0; i < m_constraintCount; ++i)
618c531,532
< 		b2Assert(pc->pointCount > 0);
---
> 		b2ContactConstraint* c = m_constraints + i;
> 		b2Manifold* m = c->manifold;
620c534
< 		switch (pc->type)
---
> 		for (int32 j = 0; j < c->pointCount; ++j)
622,656c536,537
< 		case b2Manifold::e_circles:
< 			{
< 				b2Vec2 pointA = b2Mul(xfA, pc->localPoint);
< 				b2Vec2 pointB = b2Mul(xfB, pc->localPoints[0]);
< 				normal = pointB - pointA;
< 				normal.Normalize();
< 				point = 0.5f * (pointA + pointB);
< 				separation = b2Dot(pointB - pointA, normal) - pc->radiusA - pc->radiusB;
< 			}
< 			break;
< 
< 		case b2Manifold::e_faceA:
< 			{
< 				normal = b2Mul(xfA.q, pc->localNormal);
< 				b2Vec2 planePoint = b2Mul(xfA, pc->localPoint);
< 
< 				b2Vec2 clipPoint = b2Mul(xfB, pc->localPoints[index]);
< 				separation = b2Dot(clipPoint - planePoint, normal) - pc->radiusA - pc->radiusB;
< 				point = clipPoint;
< 			}
< 			break;
< 
< 		case b2Manifold::e_faceB:
< 			{
< 				normal = b2Mul(xfB.q, pc->localNormal);
< 				b2Vec2 planePoint = b2Mul(xfB, pc->localPoint);
< 
< 				b2Vec2 clipPoint = b2Mul(xfA, pc->localPoints[index]);
< 				separation = b2Dot(clipPoint - planePoint, normal) - pc->radiusA - pc->radiusB;
< 				point = clipPoint;
< 
< 				// Ensure normal points from A to B
< 				normal = -normal;
< 			}
< 			break;
---
> 			m->points[j].normalImpulse = c->points[j].normalImpulse;
> 			m->points[j].tangentImpulse = c->points[j].tangentImpulse;
658a540
> }
660,664c542
< 	b2Vec2 normal;
< 	b2Vec2 point;
< 	float32 separation;
< };
< 
---
> #if 1
666c544
< bool b2ContactSolver::SolvePositionConstraints()
---
> bool b2ContactSolver::SolvePositionConstraints(float32 baumgarte)
670c548
< 	for (int32 i = 0; i < m_count; ++i)
---
> 	for (int32 i = 0; i < m_constraintCount; ++i)
672,682c550,570
< 		b2ContactPositionConstraint* pc = m_positionConstraints + i;
< 
< 		int32 indexA = pc->indexA;
< 		int32 indexB = pc->indexB;
< 		b2Vec2 localCenterA = pc->localCenterA;
< 		float32 mA = pc->invMassA;
< 		float32 iA = pc->invIA;
< 		b2Vec2 localCenterB = pc->localCenterB;
< 		float32 mB = pc->invMassB;
< 		float32 iB = pc->invIB;
< 		int32 pointCount = pc->pointCount;
---
> 		b2ContactConstraint* c = m_constraints + i;
> 		b2Body* b1 = c->body1;
> 		b2Body* b2 = c->body2;
> 		float32 invMass1 = b1->m_mass * b1->m_invMass;
> 		float32 invI1 = b1->m_mass * b1->m_invI;
> 		float32 invMass2 = b2->m_mass * b2->m_invMass;
> 		float32 invI2 = b2->m_mass * b2->m_invI;
> 
> 		b2Vec2 normal = c->normal;
> 
> 		// Solver normal constraints
> 		for (int32 j = 0; j < c->pointCount; ++j)
> 		{
> 			b2ContactConstraintPoint* ccp = c->points + j;
> 
> 			b2Vec2 r1 = b2Mul(b1->GetXForm().R, ccp->localAnchor1 - b1->GetLocalCenter());
> 			b2Vec2 r2 = b2Mul(b2->GetXForm().R, ccp->localAnchor2 - b2->GetLocalCenter());
> 
> 			b2Vec2 p1 = b1->m_sweep.c + r1;
> 			b2Vec2 p2 = b2->m_sweep.c + r2;
> 			b2Vec2 dp = p2 - p1;
684,707c572,573
< 		b2Vec2 cA = m_positions[indexA].c;
< 		float32 aA = m_positions[indexA].a;
< 
< 		b2Vec2 cB = m_positions[indexB].c;
< 		float32 aB = m_positions[indexB].a;
< 
< 		// Solve normal constraints
< 		for (int32 j = 0; j < pointCount; ++j)
< 		{
< 			b2Transform xfA, xfB;
< 			xfA.q.Set(aA);
< 			xfB.q.Set(aB);
< 			xfA.p = cA - b2Mul(xfA.q, localCenterA);
< 			xfB.p = cB - b2Mul(xfB.q, localCenterB);
< 
< 			b2PositionSolverManifold psm;
< 			psm.Initialize(pc, xfA, xfB, j);
< 			b2Vec2 normal = psm.normal;
< 
< 			b2Vec2 point = psm.point;
< 			float32 separation = psm.separation;
< 
< 			b2Vec2 rA = point - cA;
< 			b2Vec2 rB = point - cB;
---
> 			// Approximate the current separation.
> 			float32 separation = b2Dot(dp, normal) + ccp->separation;
713,718c579
< 			float32 C = b2Clamp(b2_baumgarte * (separation + b2_linearSlop), -b2_maxLinearCorrection, 0.0f);
< 
< 			// Compute the effective mass.
< 			float32 rnA = b2Cross(rA, normal);
< 			float32 rnB = b2Cross(rB, normal);
< 			float32 K = mA + mB + iA * rnA * rnA + iB * rnB * rnB;
---
> 			float32 C = baumgarte * b2Clamp(separation + b2_linearSlop, -b2_maxLinearCorrection, 0.0f);
721c582
< 			float32 impulse = K > 0.0f ? - C / K : 0.0f;
---
> 			float32 impulse = -ccp->equalizedMass * C;
725,729c586,592
< 			cA -= mA * P;
< 			aA -= iA * b2Cross(rA, P);
< 
< 			cB += mB * P;
< 			aB += iB * b2Cross(rB, P);
---
> 			b1->m_sweep.c -= invMass1 * P;
> 			b1->m_sweep.a -= invI1 * b2Cross(r1, P);
> 			b1->SynchronizeTransform();
> 
> 			b2->m_sweep.c += invMass2 * P;
> 			b2->m_sweep.a += invI2 * b2Cross(r2, P);
> 			b2->SynchronizeTransform();
731,736d593
< 
< 		m_positions[indexA].c = cA;
< 		m_positions[indexA].a = aA;
< 
< 		m_positions[indexB].c = cB;
< 		m_positions[indexB].a = aB;
741c598
< 	return minSeparation >= -3.0f * b2_linearSlop;
---
> 	return minSeparation >= -1.5f * b2_linearSlop;
744,747c601
< // Sequential position solver for position constraints.
< bool b2ContactSolver::SolveTOIPositionConstraints(int32 toiIndexA, int32 toiIndexB)
< {
< 	float32 minSeparation = 0.0f;
---
> #else
749c603,606
< 	for (int32 i = 0; i < m_count; ++i)
---
> // Block solver. Doesn't seem that great.
> void b2ContactSolver::SolvePositionConstraints(float32 baumgarte)
> {
> 	for (int32 i = 0; i < m_constraintCount; ++i)
751c608,645
< 		b2ContactPositionConstraint* pc = m_positionConstraints + i;
---
> 		b2ContactConstraint* c = m_constraints + i;
> 		b2Body* b1 = c->body1;
> 		b2Body* b2 = c->body2;
> 		float32 invMass1 = b1->m_mass * b1->m_invMass;
> 		float32 invI1 = b1->m_mass * b1->m_invI;
> 		float32 invMass2 = b2->m_mass * b2->m_invMass;
> 		float32 invI2 = b2->m_mass * b2->m_invI;
> 
> 		b2Vec2 normal = c->normal;
> 		bool singlePoint = c->pointCount == 1;
> 
> 		if (c->pointCount == 2)
> 		{
> 			b2ContactConstraintPoint* ccp1 = c->points + 0;
> 			b2ContactConstraintPoint* ccp2 = c->points + 1;
> 
> 			b2Vec2 r11 = b2Mul(b1->GetXForm().R, ccp1->localAnchor1 - b1->GetLocalCenter());
> 			b2Vec2 r12 = b2Mul(b2->GetXForm().R, ccp1->localAnchor2 - b2->GetLocalCenter());
> 
> 			b2Vec2 r21 = b2Mul(b1->GetXForm().R, ccp2->localAnchor1 - b1->GetLocalCenter());
> 			b2Vec2 r22 = b2Mul(b2->GetXForm().R, ccp2->localAnchor2 - b2->GetLocalCenter());
> 
> 			b2Vec2 p11 = b1->m_sweep.c + r11;
> 			b2Vec2 p12 = b2->m_sweep.c + r12;
> 			b2Vec2 dp1 = p12 - p11;
> 
> 			b2Vec2 p21 = b1->m_sweep.c + r21;
> 			b2Vec2 p22 = b2->m_sweep.c + r22;
> 			b2Vec2 dp2 = p22 - p21;
> 
> 			float32 rn11 = b2Cross(r11, normal);
> 			float32 rn12 = b2Cross(r12, normal);
> 			float32 rn21 = b2Cross(r21, normal);
> 			float32 rn22 = b2Cross(r22, normal);
> 
> 			float32 k11 = invMass1 + invMass2 + invI1 * rn11 * rn11 + invI2 * rn12 * rn12;
> 			float32 k22 = invMass1 + invMass2 + invI1 * rn21 * rn21 + invI2 * rn22 * rn22;
> 			float32 k12 = invMass1 + invMass2 + invI1 * rn11 * rn21 + invI2 * rn12 * rn22;
753,765c647,653
< 		int32 indexA = pc->indexA;
< 		int32 indexB = pc->indexB;
< 		b2Vec2 localCenterA = pc->localCenterA;
< 		b2Vec2 localCenterB = pc->localCenterB;
< 		int32 pointCount = pc->pointCount;
< 
< 		float32 mA = 0.0f;
< 		float32 iA = 0.0f;
< 		if (indexA == toiIndexA || indexA == toiIndexB)
< 		{
< 			mA = pc->invMassA;
< 			iA = pc->invIA;
< 		}
---
> 			// Ensure a reasonable condition number.
> 			const float32 k_maxConditionNumber = 100.0f;
> 			if (k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12))
> 			{
> 				b2Mat22 K;
> 				K.col1.Set(k11, k12);
> 				K.col2.Set(k12, k22);
767,773c655,656
< 		float32 mB = 0.0f;
< 		float32 iB = 0.;
< 		if (indexB == toiIndexA || indexB == toiIndexB)
< 		{
< 			mB = pc->invMassB;
< 			iB = pc->invIB;
< 		}
---
> 				float32 separation1 = b2Dot(dp1, normal) + ccp1->separation;
> 				float32 separation2 = b2Dot(dp2, normal) + ccp2->separation;
775,776c658,660
< 		b2Vec2 cA = m_positions[indexA].c;
< 		float32 aA = m_positions[indexA].a;
---
> 				b2Vec2 C;
> 				C.x = baumgarte * (separation1 + b2_linearSlop);
> 				C.y = baumgarte * (separation2 + b2_linearSlop);
778,779c662
< 		b2Vec2 cB = m_positions[indexB].c;
< 		float32 aB = m_positions[indexB].a;
---
> 				b2Vec2 f = K.Solve(-C);
781,782c664,698
< 		// Solve normal constraints
< 		for (int32 j = 0; j < pointCount; ++j)
---
> 				if (f.x < 0.0f && f.y < 0.0f)
> 				{
> 					f.SetZero();
> 				}
> 				else if (f.x < 0.0f)
> 				{
> 					f.x = 0.0f;
> 					f.y = -C.y / k22;
> 				}
> 				else if (f.y < 0.0f)
> 				{
> 					f.x = -C.x / k11;
> 					f.y = 0.0f;
> 				}
> 
> 				b2Vec2 P1 = f.x * normal;
> 				b2Vec2 P2 = f.y * normal;
> 
> 				b1->m_sweep.c -= invMass1 * (P1 + P2);
> 				b1->m_sweep.a -= invI1 * (b2Cross(r11, P1) + b2Cross(r21, P2));
> 				b1->SynchronizeTransform();
> 
> 				b2->m_sweep.c += invMass2 * (P1 + P2);
> 				b2->m_sweep.a += invI2 * (b2Cross(r12, P1) + b2Cross(r22, P2));
> 				b2->SynchronizeTransform();
> 			}
> 			else
> 			{
> 				// The constraints are linearly dependent, so just use the first one.
> 				// This my cause a problem if the deepest one is ignored.
> 				singlePoint = true;
> 			}
> 		}
> 
> 		if (singlePoint)
784,792c700
< 			b2Transform xfA, xfB;
< 			xfA.q.Set(aA);
< 			xfB.q.Set(aB);
< 			xfA.p = cA - b2Mul(xfA.q, localCenterA);
< 			xfB.p = cB - b2Mul(xfB.q, localCenterB);
< 
< 			b2PositionSolverManifold psm;
< 			psm.Initialize(pc, xfA, xfB, j);
< 			b2Vec2 normal = psm.normal;
---
> 			b2ContactConstraintPoint* ccp = c->points + 0;
794,795c702,703
< 			b2Vec2 point = psm.point;
< 			float32 separation = psm.separation;
---
> 			b2Vec2 r1 = b2Mul(b1->GetXForm().R, ccp->localAnchor1 - b1->GetLocalCenter());
> 			b2Vec2 r2 = b2Mul(b2->GetXForm().R, ccp->localAnchor2 - b2->GetLocalCenter());
797,798c705,707
< 			b2Vec2 rA = point - cA;
< 			b2Vec2 rB = point - cB;
---
> 			b2Vec2 p1 = b1->m_sweep.c + r1;
> 			b2Vec2 p2 = b2->m_sweep.c + r2;
> 			b2Vec2 dp = p2 - p1;
800,801c709,710
< 			// Track max constraint error.
< 			minSeparation = b2Min(minSeparation, separation);
---
> 			// Approximate the current separation.
> 			float32 separation = b2Dot(dp, normal) + ccp->separation;
804,809c713
< 			float32 C = b2Clamp(b2_toiBaugarte * (separation + b2_linearSlop), -b2_maxLinearCorrection, 0.0f);
< 
< 			// Compute the effective mass.
< 			float32 rnA = b2Cross(rA, normal);
< 			float32 rnB = b2Cross(rB, normal);
< 			float32 K = mA + mB + iA * rnA * rnA + iB * rnB * rnB;
---
> 			float32 C = baumgarte * b2Clamp(separation + b2_linearSlop, -b2_maxLinearCorrection, 0.0f);
812c716
< 			float32 impulse = K > 0.0f ? - C / K : 0.0f;
---
> 			float32 impulse = -ccp->equalizedMass * C;
816,820c720,726
< 			cA -= mA * P;
< 			aA -= iA * b2Cross(rA, P);
< 
< 			cB += mB * P;
< 			aB += iB * b2Cross(rB, P);
---
> 			b1->m_sweep.c -= invMass1 * P;
> 			b1->m_sweep.a -= invI1 * b2Cross(r1, P);
> 			b1->SynchronizeTransform();
> 
> 			b2->m_sweep.c += invMass2 * P;
> 			b2->m_sweep.a += invI2 * b2Cross(r2, P);
> 			b2->SynchronizeTransform();
822,827d727
< 
< 		m_positions[indexA].c = cA;
< 		m_positions[indexA].a = aA;
< 
< 		m_positions[indexB].c = cB;
< 		m_positions[indexB].a = aB;
829,832d728
< 
< 	// We can't expect minSpeparation >= -b2_linearSlop because we don't
< 	// push the separation above -b2_linearSlop.
< 	return minSeparation >= -1.5f * b2_linearSlop;
833a730,732
> 
> #endif
> 
diff -r -x './svn/*' native/Box2D/Dynamics/Contacts/b2ContactSolver.h ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Contacts/b2ContactSolver.h
2c2
< * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
19,20c19,20
< #ifndef B2_CONTACT_SOLVER_H
< #define B2_CONTACT_SOLVER_H
---
> #ifndef CONTACT_SOLVER_H
> #define CONTACT_SOLVER_H
22,24c22,24
< #include <Box2D/Common/b2Math.h>
< #include <Box2D/Collision/b2Collision.h>
< #include <Box2D/Dynamics/b2TimeStep.h>
---
> #include "../../Common/b2Math.h"
> #include "../../Collision/b2Collision.h"
> #include "../b2World.h"
27a28
> class b2Island;
29d29
< struct b2ContactPositionConstraint;
31c31
< struct b2VelocityConstraintPoint
---
> struct b2ContactConstraintPoint
33,34c33,36
< 	b2Vec2 rA;
< 	b2Vec2 rB;
---
> 	b2Vec2 localAnchor1;
> 	b2Vec2 localAnchor2;
> 	b2Vec2 r1;
> 	b2Vec2 r2;
38a41,42
> 	float32 equalizedMass;
> 	float32 separation;
42c46
< struct b2ContactVelocityConstraint
---
> struct b2ContactConstraint
44c48
< 	b2VelocityConstraintPoint points[b2_maxManifoldPoints];
---
> 	b2ContactConstraintPoint points[b2_maxManifoldPoints];
48,51c52,54
< 	int32 indexA;
< 	int32 indexB;
< 	float32 invMassA, invMassB;
< 	float32 invIA, invIB;
---
> 	b2Manifold* manifold;
> 	b2Body* body1;
> 	b2Body* body2;
54d56
< 	float32 tangentSpeed;
56,66d57
< 	int32 contactIndex;
< };
< 
< struct b2ContactSolverDef
< {
< 	b2TimeStep step;
< 	b2Contact** contacts;
< 	int32 count;
< 	b2Position* positions;
< 	b2Velocity* velocities;
< 	b2StackAllocator* allocator;
72c63
< 	b2ContactSolver(b2ContactSolverDef* def);
---
> 	b2ContactSolver(const b2TimeStep& step, b2Contact** contacts, int32 contactCount, b2StackAllocator* allocator);
75,77c66
< 	void InitializeVelocityConstraints();
< 
< 	void WarmStart();
---
> 	void InitVelocityConstraints(const b2TimeStep& step);
79c68
< 	void StoreImpulses();
---
> 	void FinalizeVelocityConstraints();
81,82c70
< 	bool SolvePositionConstraints();
< 	bool SolveTOIPositionConstraints(int32 toiIndexA, int32 toiIndexB);
---
> 	bool SolvePositionConstraints(float32 baumgarte);
85,86d72
< 	b2Position* m_positions;
< 	b2Velocity* m_velocities;
88,91c74,75
< 	b2ContactPositionConstraint* m_positionConstraints;
< 	b2ContactVelocityConstraint* m_velocityConstraints;
< 	b2Contact** m_contacts;
< 	int m_count;
---
> 	b2ContactConstraint* m_constraints;
> 	int m_constraintCount;
95d78
< 
diff -r -x './svn/*' native/Box2D/Dynamics/Contacts/b2EdgeAndCircleContact.cpp ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Contacts/b2EdgeAndCircleContact.cpp
1,50c1,192
< /*
< * Copyright (c) 2006-2010 Erin Catto http://www.box2d.org
< *
< * This software is provided 'as-is', without any express or implied
< * warranty.  In no event will the authors be held liable for any damages
< * arising from the use of this software.
< * Permission is granted to anyone to use this software for any purpose,
< * including commercial applications, and to alter it and redistribute it
< * freely, subject to the following restrictions:
< * 1. The origin of this software must not be misrepresented; you must not
< * claim that you wrote the original software. If you use this software
< * in a product, an acknowledgment in the product documentation would be
< * appreciated but is not required.
< * 2. Altered source versions must be plainly marked as such, and must not be
< * misrepresented as being the original software.
< * 3. This notice may not be removed or altered from any source distribution.
< */
< 
< #include <Box2D/Dynamics/Contacts/b2EdgeAndCircleContact.h>
< #include <Box2D/Common/b2BlockAllocator.h>
< #include <Box2D/Dynamics/b2Fixture.h>
< 
< #include <new>
< using namespace std;
< 
< b2Contact* b2EdgeAndCircleContact::Create(b2Fixture* fixtureA, int32, b2Fixture* fixtureB, int32, b2BlockAllocator* allocator)
< {
< 	void* mem = allocator->Allocate(sizeof(b2EdgeAndCircleContact));
< 	return new (mem) b2EdgeAndCircleContact(fixtureA, fixtureB);
< }
< 
< void b2EdgeAndCircleContact::Destroy(b2Contact* contact, b2BlockAllocator* allocator)
< {
< 	((b2EdgeAndCircleContact*)contact)->~b2EdgeAndCircleContact();
< 	allocator->Free(contact, sizeof(b2EdgeAndCircleContact));
< }
< 
< b2EdgeAndCircleContact::b2EdgeAndCircleContact(b2Fixture* fixtureA, b2Fixture* fixtureB)
< : b2Contact(fixtureA, 0, fixtureB, 0)
< {
< 	b2Assert(m_fixtureA->GetType() == b2Shape::e_edge);
< 	b2Assert(m_fixtureB->GetType() == b2Shape::e_circle);
< }
< 
< void b2EdgeAndCircleContact::Evaluate(b2Manifold* manifold, const b2Transform& xfA, const b2Transform& xfB)
< {
< 	b2CollideEdgeAndCircle(	manifold,
< 								(b2EdgeShape*)m_fixtureA->GetShape(), xfA,
< 								(b2CircleShape*)m_fixtureB->GetShape(), xfB);
< }
---
> /*
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
> *
> * This software is provided 'as-is', without any express or implied
> * warranty.  In no event will the authors be held liable for any damages
> * arising from the use of this software.
> * Permission is granted to anyone to use this software for any purpose,
> * including commercial applications, and to alter it and redistribute it
> * freely, subject to the following restrictions:
> * 1. The origin of this software must not be misrepresented; you must not
> * claim that you wrote the original software. If you use this software
> * in a product, an acknowledgment in the product documentation would be
> * appreciated but is not required.
> * 2. Altered source versions must be plainly marked as such, and must not be
> * misrepresented as being the original software.
> * 3. This notice may not be removed or altered from any source distribution.
> */
> 
> #include "b2EdgeAndCircleContact.h"
> #include "../b2Body.h"
> #include "../b2WorldCallbacks.h"
> #include "../../Common/b2BlockAllocator.h"
> #include "../../Collision/Shapes/b2EdgeShape.h"
> 
> #include <new>
> 
> b2Contact* b2EdgeAndCircleContact::Create(b2Shape* shape1, b2Shape* shape2, b2BlockAllocator* allocator)
> {
> 	void* mem = allocator->Allocate(sizeof(b2EdgeAndCircleContact));
> 	return new (mem) b2EdgeAndCircleContact(shape1, shape2);
> }
> 
> void b2EdgeAndCircleContact::Destroy(b2Contact* contact, b2BlockAllocator* allocator)
> {
> 	((b2EdgeAndCircleContact*)contact)->~b2EdgeAndCircleContact();
> 	allocator->Free(contact, sizeof(b2EdgeAndCircleContact));
> }
> 
> b2EdgeAndCircleContact::b2EdgeAndCircleContact(b2Shape* s1, b2Shape* s2)
> : b2Contact(s1, s2)
> {
> 	b2Assert(m_shape1->GetType() == e_edgeShape);
> 	b2Assert(m_shape2->GetType() == e_circleShape);
> 	m_manifold.pointCount = 0;
> 	m_manifold.points[0].normalImpulse = 0.0f;
> 	m_manifold.points[0].tangentImpulse = 0.0f;
> }
> 
> void b2EdgeAndCircleContact::Evaluate(b2ContactListener* listener)
> {
> 	b2Body* b1 = m_shape1->GetBody();
> 	b2Body* b2 = m_shape2->GetBody();
> 
> 	b2Manifold m0;
> 	memcpy(&m0, &m_manifold, sizeof(b2Manifold));
> 
> 	b2CollideEdgeAndCircle(&m_manifold, (b2EdgeShape*)m_shape1, b1->GetXForm(), (b2CircleShape*)m_shape2, b2->GetXForm());
> 
> 	b2ContactPoint cp;
> 	cp.shape1 = m_shape1;
> 	cp.shape2 = m_shape2;
> 	cp.friction = b2MixFriction(m_shape1->GetFriction(), m_shape2->GetFriction());
> 	cp.restitution = b2MixRestitution(m_shape1->GetRestitution(), m_shape2->GetRestitution());
> 
> 	if (m_manifold.pointCount > 0)
> 	{
> 		m_manifoldCount = 1;
> 		b2ManifoldPoint* mp = m_manifold.points + 0;
> 
> 		if (m0.pointCount == 0)
> 		{
> 			mp->normalImpulse = 0.0f;
> 			mp->tangentImpulse = 0.0f;
> 
> 			if (listener)
> 			{
> 				cp.position = b1->GetWorldPoint(mp->localPoint1);
> 				b2Vec2 v1 = b1->GetLinearVelocityFromLocalPoint(mp->localPoint1);
> 				b2Vec2 v2 = b2->GetLinearVelocityFromLocalPoint(mp->localPoint2);
> 				cp.velocity = v2 - v1;
> 				cp.normal = m_manifold.normal;
> 				cp.separation = mp->separation;
> 				cp.id = mp->id;
> 				listener->Add(&cp);
> 			}
> 		}
> 		else
> 		{
> 			b2ManifoldPoint* mp0 = m0.points + 0;
> 			mp->normalImpulse = mp0->normalImpulse;
> 			mp->tangentImpulse = mp0->tangentImpulse;
> 
> 			if (listener)
> 			{
> 				cp.position = b1->GetWorldPoint(mp->localPoint1);
> 				b2Vec2 v1 = b1->GetLinearVelocityFromLocalPoint(mp->localPoint1);
> 				b2Vec2 v2 = b2->GetLinearVelocityFromLocalPoint(mp->localPoint2);
> 				cp.velocity = v2 - v1;
> 				cp.normal = m_manifold.normal;
> 				cp.separation = mp->separation;
> 				cp.id = mp->id;
> 				listener->Persist(&cp);
> 			}
> 		}
> 	}
> 	else
> 	{
> 		m_manifoldCount = 0;
> 		if (m0.pointCount > 0 && listener)
> 		{
> 			b2ManifoldPoint* mp0 = m0.points + 0;
> 			cp.position = b1->GetWorldPoint(mp0->localPoint1);
> 			b2Vec2 v1 = b1->GetLinearVelocityFromLocalPoint(mp0->localPoint1);
> 			b2Vec2 v2 = b2->GetLinearVelocityFromLocalPoint(mp0->localPoint2);
> 			cp.velocity = v2 - v1;
> 			cp.normal = m0.normal;
> 			cp.separation = mp0->separation;
> 			cp.id = mp0->id;
> 			listener->Remove(&cp);
> 		}
> 	}
> }
> 
> void b2EdgeAndCircleContact::b2CollideEdgeAndCircle(b2Manifold* manifold,
> 																const b2EdgeShape* edge, 
> 																const b2XForm& xf1,
> 																const b2CircleShape* circle, 
> 																const b2XForm& xf2)
> {
> 	manifold->pointCount = 0;
> 	b2Vec2 d;
> 	b2Vec2 c = b2Mul(xf2, circle->GetLocalPosition());
> 	b2Vec2 cLocal = b2MulT(xf1, c);
> 	b2Vec2 n = edge->GetNormalVector();
> 	b2Vec2 v1 = edge->GetVertex1();
> 	b2Vec2 v2 = edge->GetVertex2();
> 	float32 radius = circle->GetRadius();
> 	float32 separation;
> 	
> 	float32 dirDist = b2Dot((cLocal - v1), edge->GetDirectionVector());
> 	if (dirDist <= 0) {
> 		d = cLocal - v1;
> 		if (b2Dot(d, edge->GetCorner1Vector()) < 0) {
> 			return;
> 		}
> 		d = c - b2Mul(xf1, v1);
> 	} else if (dirDist >= edge->GetLength()) {
> 		d = cLocal - v2;
> 		if (b2Dot(d, edge->GetCorner2Vector()) > 0) {
> 			return;
> 		}
> 		d = c - b2Mul(xf1, v2);
> 	} else {
> 		separation = b2Dot(cLocal - v1, n);
> 		if (separation > radius || separation < -radius) {
> 			return;
> 		}
> 		separation -= radius;
> 		manifold->normal = b2Mul(xf1.R, n);
> 		manifold->pointCount = 1;
> 		manifold->points[0].id.key = 0;
> 		manifold->points[0].separation = separation;
> 		c = c - radius * manifold->normal;
> 		manifold->points[0].localPoint1 = b2MulT(xf1, c);
> 		manifold->points[0].localPoint2 = b2MulT(xf2, c);
> 		return;
> 	}
> 	
> 	float32 distSqr = b2Dot(d,d);
> 	if (distSqr > radius * radius)
> 	{
> 		return;
> 	}
> 	
> 	if (distSqr < B2_FLT_EPSILON)
> 	{
> 		separation = -radius;
> 		manifold->normal = b2Mul(xf1.R, n);
> 	}
> 	else
> 	{
> 		separation = d.Normalize() - radius;
> 		manifold->normal = d;
> 	}
> 	
> 	manifold->pointCount = 1;
> 	manifold->points[0].id.key = 0;
> 	manifold->points[0].separation = separation;
> 	c = c - radius * manifold->normal;
> 	manifold->points[0].localPoint1 = b2MulT(xf1, c);
> 	manifold->points[0].localPoint2 = b2MulT(xf2, c);
> }
diff -r -x './svn/*' native/Box2D/Dynamics/Contacts/b2EdgeAndCircleContact.h ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Contacts/b2EdgeAndCircleContact.h
2c2
< * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
19,20c19,20
< #ifndef B2_EDGE_AND_CIRCLE_CONTACT_H
< #define B2_EDGE_AND_CIRCLE_CONTACT_H
---
> #ifndef EDGE_AND_CIRCLE_CONTACT_H
> #define EDGE_AND_CIRCLE_CONTACT_H
22c22,28
< #include <Box2D/Dynamics/Contacts/b2Contact.h>
---
> #include "../../Common/b2Math.h"
> #include "../../Collision/b2Collision.h"
> #include "../../Collision/Shapes/b2EdgeShape.h"
> #include "../../Collision/Shapes/b2CircleShape.h"
> #include "b2Contact.h"
> 
> #include <memory.h>
29,30c35
< 	static b2Contact* Create(	b2Fixture* fixtureA, int32 indexA,
< 								b2Fixture* fixtureB, int32 indexB, b2BlockAllocator* allocator);
---
> 	static b2Contact* Create(b2Shape* shape1, b2Shape* shape2, b2BlockAllocator* allocator);
33c38
< 	b2EdgeAndCircleContact(b2Fixture* fixtureA, b2Fixture* fixtureB);
---
> 	b2EdgeAndCircleContact(b2Shape* shape1, b2Shape* shape2);
36c41,50
< 	void Evaluate(b2Manifold* manifold, const b2Transform& xfA, const b2Transform& xfB);
---
> 	void Evaluate(b2ContactListener* listener);
> 	void b2CollideEdgeAndCircle(b2Manifold* manifold,
> 									  const b2EdgeShape* edge, const b2XForm& xf1,
> 									  const b2CircleShape* circle, const b2XForm& xf2);
> 	b2Manifold* GetManifolds()
> 	{
> 		return &m_manifold;
> 	}
> 
> 	b2Manifold m_manifold;
Only in native/Box2D/Dynamics/Contacts: b2EdgeAndPolygonContact.cpp
Only in native/Box2D/Dynamics/Contacts: b2EdgeAndPolygonContact.h
Only in ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Contacts: b2NullContact.h
Only in ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Contacts: b2PolyAndCircleContact.cpp
Only in ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Contacts: b2PolyAndCircleContact.h
Only in ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Contacts: b2PolyAndEdgeContact.cpp
Only in ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Contacts: b2PolyAndEdgeContact.h
Only in ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Contacts: b2PolyContact.cpp
Only in ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Contacts: b2PolyContact.h
Only in native/Box2D/Dynamics/Contacts: b2PolygonAndCircleContact.cpp
Only in native/Box2D/Dynamics/Contacts: b2PolygonAndCircleContact.h
Only in native/Box2D/Dynamics/Contacts: b2PolygonContact.cpp
Only in native/Box2D/Dynamics/Contacts: b2PolygonContact.h
Only in ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics: Controllers
diff -r -x './svn/*' native/Box2D/Dynamics/Joints/.svn/all-wcprops ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Joints/.svn/all-wcprops
3,10c3,4
< V 51
< /svn/!svn/ver/250/trunk/Box2D/Box2D/Dynamics/Joints
< END
< b2WheelJoint.h
< K 25
< svn:wc:ra_dav:version-url
< V 66
< /svn/!svn/ver/219/trunk/Box2D/Box2D/Dynamics/Joints/b2WheelJoint.h
---
> V 55
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Dynamics/Joints
15,16c9,10
< V 69
< /svn/!svn/ver/217/trunk/Box2D/Box2D/Dynamics/Joints/b2RevoluteJoint.h
---
> V 73
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Dynamics/Joints/b2RevoluteJoint.h
21,22c15,16
< V 69
< /svn/!svn/ver/246/trunk/Box2D/Box2D/Dynamics/Joints/b2PulleyJoint.cpp
---
> V 73
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Dynamics/Joints/b2PulleyJoint.cpp
24,30c18
< b2RopeJoint.h
< K 25
< svn:wc:ra_dav:version-url
< V 65
< /svn/!svn/ver/220/trunk/Box2D/Box2D/Dynamics/Joints/b2RopeJoint.h
< END
< b2FrictionJoint.cpp
---
> b2GearJoint.cpp
34c22
< /svn/!svn/ver/219/trunk/Box2D/Box2D/Dynamics/Joints/b2FrictionJoint.cpp
---
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Dynamics/Joints/b2GearJoint.cpp
36c24
< b2GearJoint.cpp
---
> b2PulleyJoint.h
39,40c27,28
< V 67
< /svn/!svn/ver/250/trunk/Box2D/Box2D/Dynamics/Joints/b2GearJoint.cpp
---
> V 71
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Dynamics/Joints/b2PulleyJoint.h
45,50d32
< V 63
< /svn/!svn/ver/247/trunk/Box2D/Box2D/Dynamics/Joints/b2Joint.cpp
< END
< b2PulleyJoint.h
< K 25
< svn:wc:ra_dav:version-url
52c34
< /svn/!svn/ver/246/trunk/Box2D/Box2D/Dynamics/Joints/b2PulleyJoint.h
---
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Dynamics/Joints/b2Joint.cpp
54c36
< b2FrictionJoint.h
---
> b2GearJoint.h
58c40
< /svn/!svn/ver/219/trunk/Box2D/Box2D/Dynamics/Joints/b2FrictionJoint.h
---
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Dynamics/Joints/b2GearJoint.h
60c42
< b2GearJoint.h
---
> b2Joint.h
64c46
< /svn/!svn/ver/219/trunk/Box2D/Box2D/Dynamics/Joints/b2GearJoint.h
---
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Dynamics/Joints/b2Joint.h
66c48
< b2Joint.h
---
> b2LineJoint.cpp
69,70c51,52
< V 61
< /svn/!svn/ver/247/trunk/Box2D/Box2D/Dynamics/Joints/b2Joint.h
---
> V 71
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Dynamics/Joints/b2LineJoint.cpp
75,76c57,58
< V 68
< /svn/!svn/ver/246/trunk/Box2D/Box2D/Dynamics/Joints/b2MouseJoint.cpp
---
> V 72
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Dynamics/Joints/b2MouseJoint.cpp
81,82c63,64
< V 71
< /svn/!svn/ver/219/trunk/Box2D/Box2D/Dynamics/Joints/b2DistanceJoint.cpp
---
> V 75
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Dynamics/Joints/b2DistanceJoint.cpp
87,88c69,70
< V 72
< /svn/!svn/ver/250/trunk/Box2D/Box2D/Dynamics/Joints/b2PrismaticJoint.cpp
---
> V 76
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Dynamics/Joints/b2PrismaticJoint.cpp
90c72
< b2WeldJoint.cpp
---
> b2LineJoint.h
93,94c75,76
< V 67
< /svn/!svn/ver/250/trunk/Box2D/Box2D/Dynamics/Joints/b2WeldJoint.cpp
---
> V 69
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Dynamics/Joints/b2LineJoint.h
99,100c81,82
< V 66
< /svn/!svn/ver/246/trunk/Box2D/Box2D/Dynamics/Joints/b2MouseJoint.h
---
> V 70
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Dynamics/Joints/b2MouseJoint.h
105,112c87,88
< V 69
< /svn/!svn/ver/217/trunk/Box2D/Box2D/Dynamics/Joints/b2DistanceJoint.h
< END
< b2MotorJoint.cpp
< K 25
< svn:wc:ra_dav:version-url
< V 68
< /svn/!svn/ver/247/trunk/Box2D/Box2D/Dynamics/Joints/b2MotorJoint.cpp
---
> V 73
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Dynamics/Joints/b2DistanceJoint.h
117,130c93,94
< V 70
< /svn/!svn/ver/220/trunk/Box2D/Box2D/Dynamics/Joints/b2PrismaticJoint.h
< END
< b2WeldJoint.h
< K 25
< svn:wc:ra_dav:version-url
< V 65
< /svn/!svn/ver/217/trunk/Box2D/Box2D/Dynamics/Joints/b2WeldJoint.h
< END
< b2WheelJoint.cpp
< K 25
< svn:wc:ra_dav:version-url
< V 68
< /svn/!svn/ver/245/trunk/Box2D/Box2D/Dynamics/Joints/b2WheelJoint.cpp
---
> V 74
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Dynamics/Joints/b2PrismaticJoint.h
135,148c99,100
< V 71
< /svn/!svn/ver/250/trunk/Box2D/Box2D/Dynamics/Joints/b2RevoluteJoint.cpp
< END
< b2MotorJoint.h
< K 25
< svn:wc:ra_dav:version-url
< V 66
< /svn/!svn/ver/247/trunk/Box2D/Box2D/Dynamics/Joints/b2MotorJoint.h
< END
< b2RopeJoint.cpp
< K 25
< svn:wc:ra_dav:version-url
< V 67
< /svn/!svn/ver/219/trunk/Box2D/Box2D/Dynamics/Joints/b2RopeJoint.cpp
---
> V 75
> /svn/!svn/ver/7/trunk/rt-jnibox2d/box2d/Dynamics/Joints/b2RevoluteJoint.cpp
diff -r -x './svn/*' native/Box2D/Dynamics/Joints/.svn/entries ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Joints/.svn/entries
4,6c4,6
< 254
< http://box2d.googlecode.com/svn/trunk/Box2D/Box2D/Dynamics/Joints
< http://box2d.googlecode.com/svn
---
> 7
> http://android-opengl-box2d-basics.googlecode.com/svn/trunk/rt-jnibox2d/box2d/Dynamics/Joints
> http://android-opengl-box2d-basics.googlecode.com/svn
10,12c10,12
< 2012-06-24T02:55:58.404098Z
< 250
< erincatto@gmail.com
---
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
27,61c27
< cafe418c-1137-0410-84cc-357ec87a5d9b
< 
< b2WheelJoint.h
< file
< 
< 
< 
< 
< 2013-06-18T12:51:07.000000Z
< 313b5ca8cfe7be8629153d867af7caa9
< 2011-09-04T22:42:14.068192Z
< 219
< erincatto@gmail.com
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 6174
---
> 5131c71c-dced-4c25-419c-0ca2576ce0a2
69,73c35,39
< 2013-06-18T12:51:07.000000Z
< 1106a50c17cbd7dc7dc8253bb365c4f9
< 2011-09-04T21:47:57.715492Z
< 217
< erincatto@gmail.com
---
> 2013-07-02T14:40:40.000000Z
> 67da875b584662b492b4982d5142b2ad
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
95c61
< 6390
---
> 5446
103,175c69,73
< 2013-06-18T12:51:07.000000Z
< 83c89b639b475b7a8994f19c6509fd0a
< 2012-03-18T07:00:37.028153Z
< 246
< erincatto@gmail.com
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 9155
< 
< b2RopeJoint.h
< file
< 
< 
< 
< 
< 2013-06-18T12:51:07.000000Z
< bba3a54fda9bf3a0668ba443e40f9dad
< 2011-09-07T03:36:21.951452Z
< 220
< erincatto@gmail.com
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 3537
< 
< b2FrictionJoint.cpp
< file
< 
< 
< 
< 
< 2013-06-18T12:51:07.000000Z
< e85d8b97c9b20661a9ae0c6ebf5de380
< 2011-09-04T22:42:14.068192Z
< 219
< erincatto@gmail.com
---
> 2013-07-02T14:40:40.000000Z
> 432770bc25942e32bd3ccd071c01a453
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
197c95
< 7144
---
> 11462
205,209c103,107
< 2013-06-18T12:51:07.000000Z
< bc4cf93b9cad246778c6bff869c468de
< 2012-06-24T02:55:58.404098Z
< 250
< erincatto@gmail.com
---
> 2013-07-02T14:40:40.000000Z
> ad70e81d48f29c348cc8b09805ccf1e9
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
231c129
< 12019
---
> 7043
233c131
< b2Joint.cpp
---
> b2PulleyJoint.h
239,243c137,141
< 2013-06-18T12:51:07.000000Z
< 278270e749380e450c85a4578b290175
< 2012-03-19T06:31:22.740365Z
< 247
< erincatto@gmail.com
---
> 2013-07-02T14:40:40.000000Z
> 4b0b43cd0e83ca2f239192a9109326ab
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
265c163
< 5361
---
> 4442
267c165
< b2PulleyJoint.h
---
> b2Joint.cpp
273,277c171,175
< 2013-06-18T12:51:07.000000Z
< 32fc9ef767150f710aede64bdef514ca
< 2012-03-18T07:00:37.028153Z
< 246
< erincatto@gmail.com
---
> 2013-07-02T14:40:40.000000Z
> bd44e3410cb2d664a6c8161d391e15c1
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
299c197
< 4592
---
> 3673
301c199
< b2FrictionJoint.h
---
> b2GearJoint.h
307,311c205,209
< 2013-06-18T12:51:07.000000Z
< bfe79638e702efeac3e6e3ae8c256bcd
< 2011-09-04T22:42:14.068192Z
< 219
< erincatto@gmail.com
---
> 2013-07-02T14:40:40.000000Z
> 1d7ecf1935a762dcdbb65a4e8247b863
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
333c231
< 3408
---
> 3262
335c233
< b2GearJoint.h
---
> b2Joint.h
341,345c239,243
< 2013-06-18T12:51:07.000000Z
< 86d31ea3eab4e1efae667223b3a43df8
< 2011-09-04T22:42:14.068192Z
< 219
< erincatto@gmail.com
---
> 2013-07-02T14:40:40.000000Z
> 686a07250279058a0533e9c56cf44cb2
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
367c265
< 3588
---
> 5972
369c267
< b2Joint.h
---
> b2LineJoint.cpp
375,379c273,277
< 2013-06-18T12:51:07.000000Z
< 166b4b9db2d7758d92d01f76e50a5b25
< 2012-03-19T06:31:22.740365Z
< 247
< erincatto@gmail.com
---
> 2013-07-02T14:40:40.000000Z
> 5228b270e73fd8f1ec841f3f20a35bc7
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
401c299
< 5733
---
> 14613
409,413c307,311
< 2013-06-18T12:51:07.000000Z
< ec8001e294daf90b607b8e87d243580a
< 2012-03-18T07:00:37.028153Z
< 246
< erincatto@gmail.com
---
> 2013-07-02T14:40:40.000000Z
> af157c4540ee5a5c41b613f32f971502
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
435c333
< 5690
---
> 4368
443,447c341,345
< 2013-06-18T12:51:07.000000Z
< 655db91c82ae50f590e068f86f6c8030
< 2011-09-04T22:42:14.068192Z
< 219
< erincatto@gmail.com
---
> 2013-07-02T14:40:40.000000Z
> d53e0d1b0e11d2d8ed2f55a3afcb652e
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
469c367
< 7555
---
> 6000
477,481c375,379
< 2013-06-18T12:51:07.000000Z
< 186f22e6b3fdf8b9d398ba46eb16dba3
< 2012-06-24T02:55:58.404098Z
< 250
< erincatto@gmail.com
---
> 2013-07-02T14:40:40.000000Z
> 4d82c68eac4f4d745e195a7274f3820c
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
503c401
< 17475
---
> 15930
505c403
< b2WeldJoint.cpp
---
> b2LineJoint.h
511,515c409,413
< 2013-06-18T12:51:07.000000Z
< 75923f15d3f37a8a8e33adfea62043cc
< 2012-06-24T02:55:58.404098Z
< 250
< erincatto@gmail.com
---
> 2013-07-02T14:40:40.000000Z
> 0f7cb86a51ae8baa7235ccd31b0f7606
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
537c435
< 9005
---
> 5068
545,549c443,447
< 2013-06-18T12:51:07.000000Z
< d1b382af1371fb8bffc8173590ccd60f
< 2012-03-18T07:00:37.028153Z
< 246
< erincatto@gmail.com
---
> 2013-07-02T14:40:40.000000Z
> 314035cf188f06f0c526dfadb9cf3fcf
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
571c469
< 3817
---
> 2996
579,617c477,481
< 2013-06-18T12:51:07.000000Z
< cee1cd9ae9c46ef46b209ab149e96d86
< 2011-09-04T21:47:57.715492Z
< 217
< erincatto@gmail.com
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 4756
< 
< b2MotorJoint.cpp
< file
< 
< 
< 
< 
< 2013-06-18T12:51:07.000000Z
< e312f30fa13748379e0fc8920365011a
< 2012-03-19T06:31:22.740365Z
< 247
< erincatto@gmail.com
---
> 2013-07-02T14:40:40.000000Z
> 8008a8a22c96be20352e4c170083d4ee
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
639c503
< 8141
---
> 3084
647,719c511,515
< 2013-06-18T12:51:07.000000Z
< b4f7d1596acc21c558d8ed8a1bbe36a6
< 2011-09-07T03:36:21.951452Z
< 220
< erincatto@gmail.com
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 6097
< 
< b2WeldJoint.h
< file
< 
< 
< 
< 
< 2013-06-18T12:51:07.000000Z
< 13e90b710d3eca59d296ddd12895d47b
< 2011-09-04T21:47:57.715492Z
< 217
< erincatto@gmail.com
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 3889
< 
< b2WheelJoint.cpp
< file
< 
< 
< 
< 
< 2013-06-18T12:51:07.000000Z
< 45b486f7dff7b43ac4ce215c9d675b07
< 2012-03-17T06:32:44.892106Z
< 245
< erincatto@gmail.com
---
> 2013-07-02T14:40:40.000000Z
> fca1d7ceb148d30c1bf3ebe0d127aee6
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
741c537
< 10990
---
> 5307
749,821c545,549
< 2013-06-18T12:51:07.000000Z
< fc22e50f4f9133d3fa03e40f91a27ca6
< 2012-06-24T02:55:58.404098Z
< 250
< erincatto@gmail.com
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 13591
< 
< b2MotorJoint.h
< file
< 
< 
< 
< 
< 2013-06-18T12:51:07.000000Z
< fd02559db6a6c7ce6cfe6f7dd71d7d62
< 2012-03-19T06:31:22.740365Z
< 247
< erincatto@gmail.com
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 
< 3619
< 
< b2RopeJoint.cpp
< file
< 
< 
< 
< 
< 2013-06-18T12:51:07.000000Z
< 5a438a233b1564238b728f7cc9f86818
< 2011-09-04T22:42:14.068192Z
< 219
< erincatto@gmail.com
---
> 2013-07-02T14:40:40.000000Z
> 6f80eb831de2f07a84b4babc978d7bd7
> 2010-10-12T16:41:03.962405Z
> 7
> kristianlein
843c571
< 6603
---
> 12738
diff -r -x './svn/*' native/Box2D/Dynamics/Joints/.svn/text-base/b2DistanceJoint.cpp.svn-base ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Joints/.svn/text-base/b2DistanceJoint.cpp.svn-base
2c2
< * Copyright (c) 2006-2011 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
19,21c19,21
< #include <Box2D/Dynamics/Joints/b2DistanceJoint.h>
< #include <Box2D/Dynamics/b2Body.h>
< #include <Box2D/Dynamics/b2TimeStep.h>
---
> #include "b2DistanceJoint.h"
> #include "../b2Body.h"
> #include "../b2World.h"
41,44c41,44
< 	bodyA = b1;
< 	bodyB = b2;
< 	localAnchorA = bodyA->GetLocalPoint(anchor1);
< 	localAnchorB = bodyB->GetLocalPoint(anchor2);
---
> 	body1 = b1;
> 	body2 = b2;
> 	localAnchor1 = body1->GetLocalPoint(anchor1);
> 	localAnchor2 = body2->GetLocalPoint(anchor2);
48a49
> 
52,53c53,54
< 	m_localAnchorA = def->localAnchorA;
< 	m_localAnchorB = def->localAnchorB;
---
> 	m_localAnchor1 = def->localAnchor1;
> 	m_localAnchor2 = def->localAnchor2;
62c63
< void b2DistanceJoint::InitVelocityConstraints(const b2SolverData& data)
---
> void b2DistanceJoint::InitVelocityConstraints(const b2TimeStep& step)
64,87c65,71
< 	m_indexA = m_bodyA->m_islandIndex;
< 	m_indexB = m_bodyB->m_islandIndex;
< 	m_localCenterA = m_bodyA->m_sweep.localCenter;
< 	m_localCenterB = m_bodyB->m_sweep.localCenter;
< 	m_invMassA = m_bodyA->m_invMass;
< 	m_invMassB = m_bodyB->m_invMass;
< 	m_invIA = m_bodyA->m_invI;
< 	m_invIB = m_bodyB->m_invI;
< 
< 	b2Vec2 cA = data.positions[m_indexA].c;
< 	float32 aA = data.positions[m_indexA].a;
< 	b2Vec2 vA = data.velocities[m_indexA].v;
< 	float32 wA = data.velocities[m_indexA].w;
< 
< 	b2Vec2 cB = data.positions[m_indexB].c;
< 	float32 aB = data.positions[m_indexB].a;
< 	b2Vec2 vB = data.velocities[m_indexB].v;
< 	float32 wB = data.velocities[m_indexB].w;
< 
< 	b2Rot qA(aA), qB(aB);
< 
< 	m_rA = b2Mul(qA, m_localAnchorA - m_localCenterA);
< 	m_rB = b2Mul(qB, m_localAnchorB - m_localCenterB);
< 	m_u = cB + m_rB - cA - m_rA;
---
> 	b2Body* b1 = m_body1;
> 	b2Body* b2 = m_body2;
> 
> 	// Compute the effective mass matrix.
> 	b2Vec2 r1 = b2Mul(b1->GetXForm().R, m_localAnchor1 - b1->GetLocalCenter());
> 	b2Vec2 r2 = b2Mul(b2->GetXForm().R, m_localAnchor2 - b2->GetLocalCenter());
> 	m_u = b2->m_sweep.c + r2 - b1->m_sweep.c - r1;
100,105c84,88
< 	float32 crAu = b2Cross(m_rA, m_u);
< 	float32 crBu = b2Cross(m_rB, m_u);
< 	float32 invMass = m_invMassA + m_invIA * crAu * crAu + m_invMassB + m_invIB * crBu * crBu;
< 
< 	// Compute the effective mass matrix.
< 	m_mass = invMass != 0.0f ? 1.0f / invMass : 0.0f;
---
> 	float32 cr1u = b2Cross(r1, m_u);
> 	float32 cr2u = b2Cross(r2, m_u);
> 	float32 invMass = b1->m_invMass + b1->m_invI * cr1u * cr1u + b2->m_invMass + b2->m_invI * cr2u * cr2u;
> 	b2Assert(invMass > B2_FLT_EPSILON);
> 	m_mass = 1.0f / invMass;
121,124c104,105
< 		float32 h = data.step.dt;
< 		m_gamma = h * (d + h * k);
< 		m_gamma = m_gamma != 0.0f ? 1.0f / m_gamma : 0.0f;
< 		m_bias = C * h * k * m_gamma;
---
> 		m_gamma = 1.0f / (step.dt * (d + step.dt * k));
> 		m_bias = C * step.dt * k * m_gamma;
126,132c107
< 		invMass += m_gamma;
< 		m_mass = invMass != 0.0f ? 1.0f / invMass : 0.0f;
< 	}
< 	else
< 	{
< 		m_gamma = 0.0f;
< 		m_bias = 0.0f;
---
> 		m_mass = 1.0f / (invMass + m_gamma);
135c110
< 	if (data.step.warmStarting)
---
> 	if (step.warmStarting)
138c113
< 		m_impulse *= data.step.dtRatio;
---
> 		m_impulse *= step.dtRatio;
141,144c116,119
< 		vA -= m_invMassA * P;
< 		wA -= m_invIA * b2Cross(m_rA, P);
< 		vB += m_invMassB * P;
< 		wB += m_invIB * b2Cross(m_rB, P);
---
> 		b1->m_linearVelocity -= b1->m_invMass * P;
> 		b1->m_angularVelocity -= b1->m_invI * b2Cross(r1, P);
> 		b2->m_linearVelocity += b2->m_invMass * P;
> 		b2->m_angularVelocity += b2->m_invI * b2Cross(r2, P);
150,154d124
< 
< 	data.velocities[m_indexA].v = vA;
< 	data.velocities[m_indexA].w = wA;
< 	data.velocities[m_indexB].v = vB;
< 	data.velocities[m_indexB].w = wB;
157c127
< void b2DistanceJoint::SolveVelocityConstraints(const b2SolverData& data)
---
> void b2DistanceJoint::SolveVelocityConstraints(const b2TimeStep& step)
159,162c129,135
< 	b2Vec2 vA = data.velocities[m_indexA].v;
< 	float32 wA = data.velocities[m_indexA].w;
< 	b2Vec2 vB = data.velocities[m_indexB].v;
< 	float32 wB = data.velocities[m_indexB].w;
---
> 	B2_NOT_USED(step);
> 
> 	b2Body* b1 = m_body1;
> 	b2Body* b2 = m_body2;
> 
> 	b2Vec2 r1 = b2Mul(b1->GetXForm().R, m_localAnchor1 - b1->GetLocalCenter());
> 	b2Vec2 r2 = b2Mul(b2->GetXForm().R, m_localAnchor2 - b2->GetLocalCenter());
165,167c138,140
< 	b2Vec2 vpA = vA + b2Cross(wA, m_rA);
< 	b2Vec2 vpB = vB + b2Cross(wB, m_rB);
< 	float32 Cdot = b2Dot(m_u, vpB - vpA);
---
> 	b2Vec2 v1 = b1->m_linearVelocity + b2Cross(b1->m_angularVelocity, r1);
> 	b2Vec2 v2 = b2->m_linearVelocity + b2Cross(b2->m_angularVelocity, r2);
> 	float32 Cdot = b2Dot(m_u, v2 - v1);
173,181c146,149
< 	vA -= m_invMassA * P;
< 	wA -= m_invIA * b2Cross(m_rA, P);
< 	vB += m_invMassB * P;
< 	wB += m_invIB * b2Cross(m_rB, P);
< 
< 	data.velocities[m_indexA].v = vA;
< 	data.velocities[m_indexA].w = wA;
< 	data.velocities[m_indexB].v = vB;
< 	data.velocities[m_indexB].w = wB;
---
> 	b1->m_linearVelocity -= b1->m_invMass * P;
> 	b1->m_angularVelocity -= b1->m_invI * b2Cross(r1, P);
> 	b2->m_linearVelocity += b2->m_invMass * P;
> 	b2->m_angularVelocity += b2->m_invI * b2Cross(r2, P);
184c152
< bool b2DistanceJoint::SolvePositionConstraints(const b2SolverData& data)
---
> bool b2DistanceJoint::SolvePositionConstraints(float32 baumgarte)
185a154,155
> 	B2_NOT_USED(baumgarte);
> 
192,201c162,166
< 	b2Vec2 cA = data.positions[m_indexA].c;
< 	float32 aA = data.positions[m_indexA].a;
< 	b2Vec2 cB = data.positions[m_indexB].c;
< 	float32 aB = data.positions[m_indexB].a;
< 
< 	b2Rot qA(aA), qB(aB);
< 
< 	b2Vec2 rA = b2Mul(qA, m_localAnchorA - m_localCenterA);
< 	b2Vec2 rB = b2Mul(qB, m_localAnchorB - m_localCenterB);
< 	b2Vec2 u = cB + rB - cA - rA;
---
> 	b2Body* b1 = m_body1;
> 	b2Body* b2 = m_body2;
> 
> 	b2Vec2 r1 = b2Mul(b1->GetXForm().R, m_localAnchor1 - b1->GetLocalCenter());
> 	b2Vec2 r2 = b2Mul(b2->GetXForm().R, m_localAnchor2 - b2->GetLocalCenter());
203c168,170
< 	float32 length = u.Normalize();
---
> 	b2Vec2 d = b2->m_sweep.c + r2 - b1->m_sweep.c - r1;
> 
> 	float32 length = d.Normalize();
208c175,176
< 	b2Vec2 P = impulse * u;
---
> 	m_u = d;
> 	b2Vec2 P = impulse * m_u;
210,218c178,184
< 	cA -= m_invMassA * P;
< 	aA -= m_invIA * b2Cross(rA, P);
< 	cB += m_invMassB * P;
< 	aB += m_invIB * b2Cross(rB, P);
< 
< 	data.positions[m_indexA].c = cA;
< 	data.positions[m_indexA].a = aA;
< 	data.positions[m_indexB].c = cB;
< 	data.positions[m_indexB].a = aB;
---
> 	b1->m_sweep.c -= b1->m_invMass * P;
> 	b1->m_sweep.a -= b1->m_invI * b2Cross(r1, P);
> 	b2->m_sweep.c += b2->m_invMass * P;
> 	b2->m_sweep.a += b2->m_invI * b2Cross(r2, P);
> 
> 	b1->SynchronizeTransform();
> 	b2->SynchronizeTransform();
223c189
< b2Vec2 b2DistanceJoint::GetAnchorA() const
---
> b2Vec2 b2DistanceJoint::GetAnchor1() const
225c191
< 	return m_bodyA->GetWorldPoint(m_localAnchorA);
---
> 	return m_body1->GetWorldPoint(m_localAnchor1);
228c194
< b2Vec2 b2DistanceJoint::GetAnchorB() const
---
> b2Vec2 b2DistanceJoint::GetAnchor2() const
230c196
< 	return m_bodyB->GetWorldPoint(m_localAnchorB);
---
> 	return m_body2->GetWorldPoint(m_localAnchor2);
244,260d209
< 
< void b2DistanceJoint::Dump()
< {
< 	int32 indexA = m_bodyA->m_islandIndex;
< 	int32 indexB = m_bodyB->m_islandIndex;
< 
< 	b2Log("  b2DistanceJointDef jd;\n");
< 	b2Log("  jd.bodyA = bodies[%d];\n", indexA);
< 	b2Log("  jd.bodyB = bodies[%d];\n", indexB);
< 	b2Log("  jd.collideConnected = bool(%d);\n", m_collideConnected);
< 	b2Log("  jd.localAnchorA.Set(%.15lef, %.15lef);\n", m_localAnchorA.x, m_localAnchorA.y);
< 	b2Log("  jd.localAnchorB.Set(%.15lef, %.15lef);\n", m_localAnchorB.x, m_localAnchorB.y);
< 	b2Log("  jd.length = %.15lef;\n", m_length);
< 	b2Log("  jd.frequencyHz = %.15lef;\n", m_frequencyHz);
< 	b2Log("  jd.dampingRatio = %.15lef;\n", m_dampingRatio);
< 	b2Log("  joints[%d] = m_world->CreateJoint(&jd);\n", m_index);
< }
diff -r -x './svn/*' native/Box2D/Dynamics/Joints/.svn/text-base/b2DistanceJoint.h.svn-base ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Joints/.svn/text-base/b2DistanceJoint.h.svn-base
2c2
< * Copyright (c) 2006-2007 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
22c22
< #include <Box2D/Dynamics/Joints/b2Joint.h>
---
> #include "b2Joint.h"
35,36c35,36
< 		localAnchorA.Set(0.0f, 0.0f);
< 		localAnchorB.Set(0.0f, 0.0f);
---
> 		localAnchor1.Set(0.0f, 0.0f);
> 		localAnchor2.Set(0.0f, 0.0f);
44,45c44,45
< 	void Initialize(b2Body* bodyA, b2Body* bodyB,
< 					const b2Vec2& anchorA, const b2Vec2& anchorB);
---
> 	void Initialize(b2Body* body1, b2Body* body2,
> 					const b2Vec2& anchor1, const b2Vec2& anchor2);
47,48c47,48
< 	/// The local anchor point relative to bodyA's origin.
< 	b2Vec2 localAnchorA;
---
> 	/// The local anchor point relative to body1's origin.
> 	b2Vec2 localAnchor1;
50,51c50,51
< 	/// The local anchor point relative to bodyB's origin.
< 	b2Vec2 localAnchorB;
---
> 	/// The local anchor point relative to body2's origin.
> 	b2Vec2 localAnchor2;
53c53
< 	/// The natural length between the anchor points.
---
> 	/// The equilibrium length between the anchor points.
56,57c56
< 	/// The mass-spring-damper frequency in Hertz. A value of 0
< 	/// disables softness.
---
> 	/// The response speed.
71,72c70,71
< 	b2Vec2 GetAnchorA() const;
< 	b2Vec2 GetAnchorB() const;
---
> 	b2Vec2 GetAnchor1() const;
> 	b2Vec2 GetAnchor2() const;
74,75d72
< 	/// Get the reaction force given the inverse time step.
< 	/// Unit is N.
77,79d73
< 
< 	/// Get the reaction torque given the inverse time step.
< 	/// Unit is N*m. This is always zero for a distance joint.
82,104c76
< 	/// The local anchor point relative to bodyA's origin.
< 	const b2Vec2& GetLocalAnchorA() const { return m_localAnchorA; }
< 
< 	/// The local anchor point relative to bodyB's origin.
< 	const b2Vec2& GetLocalAnchorB() const  { return m_localAnchorB; }
< 
< 	/// Set/get the natural length.
< 	/// Manipulating the length can lead to non-physical behavior when the frequency is zero.
< 	void SetLength(float32 length);
< 	float32 GetLength() const;
< 
< 	/// Set/get frequency in Hz.
< 	void SetFrequency(float32 hz);
< 	float32 GetFrequency() const;
< 
< 	/// Set/get damping ratio.
< 	void SetDampingRatio(float32 ratio);
< 	float32 GetDampingRatio() const;
< 
< 	/// Dump joint to dmLog
< 	void Dump();
< 
< protected:
---
> 	//--------------- Internals Below -------------------
106d77
< 	friend class b2Joint;
109,111c80,82
< 	void InitVelocityConstraints(const b2SolverData& data);
< 	void SolveVelocityConstraints(const b2SolverData& data);
< 	bool SolvePositionConstraints(const b2SolverData& data);
---
> 	void InitVelocityConstraints(const b2TimeStep& step);
> 	void SolveVelocityConstraints(const b2TimeStep& step);
> 	bool SolvePositionConstraints(float32 baumgarte);
112a84,86
> 	b2Vec2 m_localAnchor1;
> 	b2Vec2 m_localAnchor2;
> 	b2Vec2 m_u;
115,119d88
< 	float32 m_bias;
< 
< 	// Solver shared
< 	b2Vec2 m_localAnchorA;
< 	b2Vec2 m_localAnchorB;
120a90
> 	float32 m_bias;
121a92
> 	float32 m_mass;		// effective mass for the constraint.
123,136d93
< 
< 	// Solver temp
< 	int32 m_indexA;
< 	int32 m_indexB;
< 	b2Vec2 m_u;
< 	b2Vec2 m_rA;
< 	b2Vec2 m_rB;
< 	b2Vec2 m_localCenterA;
< 	b2Vec2 m_localCenterB;
< 	float32 m_invMassA;
< 	float32 m_invMassB;
< 	float32 m_invIA;
< 	float32 m_invIB;
< 	float32 m_mass;
139,168d95
< inline void b2DistanceJoint::SetLength(float32 length)
< {
< 	m_length = length;
< }
< 
< inline float32 b2DistanceJoint::GetLength() const
< {
< 	return m_length;
< }
< 
< inline void b2DistanceJoint::SetFrequency(float32 hz)
< {
< 	m_frequencyHz = hz;
< }
< 
< inline float32 b2DistanceJoint::GetFrequency() const
< {
< 	return m_frequencyHz;
< }
< 
< inline void b2DistanceJoint::SetDampingRatio(float32 ratio)
< {
< 	m_dampingRatio = ratio;
< }
< 
< inline float32 b2DistanceJoint::GetDampingRatio() const
< {
< 	return m_dampingRatio;
< }
< 
Only in native/Box2D/Dynamics/Joints/.svn/text-base: b2FrictionJoint.cpp.svn-base
Only in native/Box2D/Dynamics/Joints/.svn/text-base: b2FrictionJoint.h.svn-base
diff -r -x './svn/*' native/Box2D/Dynamics/Joints/.svn/text-base/b2GearJoint.cpp.svn-base ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Joints/.svn/text-base/b2GearJoint.cpp.svn-base
2c2
< * Copyright (c) 2007-2011 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2007 Erin Catto http://www.gphysics.com
19,23c19,23
< #include <Box2D/Dynamics/Joints/b2GearJoint.h>
< #include <Box2D/Dynamics/Joints/b2RevoluteJoint.h>
< #include <Box2D/Dynamics/Joints/b2PrismaticJoint.h>
< #include <Box2D/Dynamics/b2Body.h>
< #include <Box2D/Dynamics/b2TimeStep.h>
---
> #include "b2GearJoint.h"
> #include "b2RevoluteJoint.h"
> #include "b2PrismaticJoint.h"
> #include "../b2Body.h"
> #include "../b2World.h"
27,28c27,29
< // C = (coordinate1 + ratio * coordinate2) - C0 = 0
< // J = [J1 ratio * J2]
---
> // C = C0 - (cordinate1 + ratio * coordinate2) = 0
> // Cdot = -(Cdot1 + ratio * Cdot2)
> // J = -[J1 ratio * J2]
47,48c48,49
< 	m_joint1 = def->joint1;
< 	m_joint2 = def->joint2;
---
> 	b2JointType type1 = def->joint1->GetType();
> 	b2JointType type2 = def->joint2->GetType();
50,77c51,70
< 	m_typeA = m_joint1->GetType();
< 	m_typeB = m_joint2->GetType();
< 
< 	b2Assert(m_typeA == e_revoluteJoint || m_typeA == e_prismaticJoint);
< 	b2Assert(m_typeB == e_revoluteJoint || m_typeB == e_prismaticJoint);
< 
< 	float32 coordinateA, coordinateB;
< 
< 	// TODO_ERIN there might be some problem with the joint edges in b2Joint.
< 
< 	m_bodyC = m_joint1->GetBodyA();
< 	m_bodyA = m_joint1->GetBodyB();
< 
< 	// Get geometry of joint1
< 	b2Transform xfA = m_bodyA->m_xf;
< 	float32 aA = m_bodyA->m_sweep.a;
< 	b2Transform xfC = m_bodyC->m_xf;
< 	float32 aC = m_bodyC->m_sweep.a;
< 
< 	if (m_typeA == e_revoluteJoint)
< 	{
< 		b2RevoluteJoint* revolute = (b2RevoluteJoint*)def->joint1;
< 		m_localAnchorC = revolute->m_localAnchorA;
< 		m_localAnchorA = revolute->m_localAnchorB;
< 		m_referenceAngleA = revolute->m_referenceAngle;
< 		m_localAxisC.SetZero();
< 
< 		coordinateA = aA - aC - m_referenceAngleA;
---
> 	b2Assert(type1 == e_revoluteJoint || type1 == e_prismaticJoint);
> 	b2Assert(type2 == e_revoluteJoint || type2 == e_prismaticJoint);
> 	b2Assert(def->joint1->GetBody1()->IsStatic());
> 	b2Assert(def->joint2->GetBody1()->IsStatic());
> 
> 	m_revolute1 = NULL;
> 	m_prismatic1 = NULL;
> 	m_revolute2 = NULL;
> 	m_prismatic2 = NULL;
> 
> 	float32 coordinate1, coordinate2;
> 
> 	m_ground1 = def->joint1->GetBody1();
> 	m_body1 = def->joint1->GetBody2();
> 	if (type1 == e_revoluteJoint)
> 	{
> 		m_revolute1 = (b2RevoluteJoint*)def->joint1;
> 		m_groundAnchor1 = m_revolute1->m_localAnchor1;
> 		m_localAnchor1 = m_revolute1->m_localAnchor2;
> 		coordinate1 = m_revolute1->GetJointAngle();
81,107c74,78
< 		b2PrismaticJoint* prismatic = (b2PrismaticJoint*)def->joint1;
< 		m_localAnchorC = prismatic->m_localAnchorA;
< 		m_localAnchorA = prismatic->m_localAnchorB;
< 		m_referenceAngleA = prismatic->m_referenceAngle;
< 		m_localAxisC = prismatic->m_localXAxisA;
< 
< 		b2Vec2 pC = m_localAnchorC;
< 		b2Vec2 pA = b2MulT(xfC.q, b2Mul(xfA.q, m_localAnchorA) + (xfA.p - xfC.p));
< 		coordinateA = b2Dot(pA - pC, m_localAxisC);
< 	}
< 
< 	m_bodyD = m_joint2->GetBodyA();
< 	m_bodyB = m_joint2->GetBodyB();
< 
< 	// Get geometry of joint2
< 	b2Transform xfB = m_bodyB->m_xf;
< 	float32 aB = m_bodyB->m_sweep.a;
< 	b2Transform xfD = m_bodyD->m_xf;
< 	float32 aD = m_bodyD->m_sweep.a;
< 
< 	if (m_typeB == e_revoluteJoint)
< 	{
< 		b2RevoluteJoint* revolute = (b2RevoluteJoint*)def->joint2;
< 		m_localAnchorD = revolute->m_localAnchorA;
< 		m_localAnchorB = revolute->m_localAnchorB;
< 		m_referenceAngleB = revolute->m_referenceAngle;
< 		m_localAxisD.SetZero();
---
> 		m_prismatic1 = (b2PrismaticJoint*)def->joint1;
> 		m_groundAnchor1 = m_prismatic1->m_localAnchor1;
> 		m_localAnchor1 = m_prismatic1->m_localAnchor2;
> 		coordinate1 = m_prismatic1->GetJointTranslation();
> 	}
109c80,87
< 		coordinateB = aB - aD - m_referenceAngleB;
---
> 	m_ground2 = def->joint2->GetBody1();
> 	m_body2 = def->joint2->GetBody2();
> 	if (type2 == e_revoluteJoint)
> 	{
> 		m_revolute2 = (b2RevoluteJoint*)def->joint2;
> 		m_groundAnchor2 = m_revolute2->m_localAnchor1;
> 		m_localAnchor2 = m_revolute2->m_localAnchor2;
> 		coordinate2 = m_revolute2->GetJointAngle();
113,121c91,94
< 		b2PrismaticJoint* prismatic = (b2PrismaticJoint*)def->joint2;
< 		m_localAnchorD = prismatic->m_localAnchorA;
< 		m_localAnchorB = prismatic->m_localAnchorB;
< 		m_referenceAngleB = prismatic->m_referenceAngle;
< 		m_localAxisD = prismatic->m_localXAxisA;
< 
< 		b2Vec2 pD = m_localAnchorD;
< 		b2Vec2 pB = b2MulT(xfD.q, b2Mul(xfB.q, m_localAnchorB) + (xfB.p - xfD.p));
< 		coordinateB = b2Dot(pB - pD, m_localAxisD);
---
> 		m_prismatic2 = (b2PrismaticJoint*)def->joint2;
> 		m_groundAnchor2 = m_prismatic2->m_localAnchor1;
> 		m_localAnchor2 = m_prismatic2->m_localAnchor2;
> 		coordinate2 = m_prismatic2->GetJointTranslation();
126c99
< 	m_constant = coordinateA + m_ratio * coordinateB;
---
> 	m_constant = coordinate1 + m_ratio * coordinate2;
131c104
< void b2GearJoint::InitVelocityConstraints(const b2SolverData& data)
---
> void b2GearJoint::InitVelocityConstraints(const b2TimeStep& step)
133,175c106,117
< 	m_indexA = m_bodyA->m_islandIndex;
< 	m_indexB = m_bodyB->m_islandIndex;
< 	m_indexC = m_bodyC->m_islandIndex;
< 	m_indexD = m_bodyD->m_islandIndex;
< 	m_lcA = m_bodyA->m_sweep.localCenter;
< 	m_lcB = m_bodyB->m_sweep.localCenter;
< 	m_lcC = m_bodyC->m_sweep.localCenter;
< 	m_lcD = m_bodyD->m_sweep.localCenter;
< 	m_mA = m_bodyA->m_invMass;
< 	m_mB = m_bodyB->m_invMass;
< 	m_mC = m_bodyC->m_invMass;
< 	m_mD = m_bodyD->m_invMass;
< 	m_iA = m_bodyA->m_invI;
< 	m_iB = m_bodyB->m_invI;
< 	m_iC = m_bodyC->m_invI;
< 	m_iD = m_bodyD->m_invI;
< 
< 	float32 aA = data.positions[m_indexA].a;
< 	b2Vec2 vA = data.velocities[m_indexA].v;
< 	float32 wA = data.velocities[m_indexA].w;
< 
< 	float32 aB = data.positions[m_indexB].a;
< 	b2Vec2 vB = data.velocities[m_indexB].v;
< 	float32 wB = data.velocities[m_indexB].w;
< 
< 	float32 aC = data.positions[m_indexC].a;
< 	b2Vec2 vC = data.velocities[m_indexC].v;
< 	float32 wC = data.velocities[m_indexC].w;
< 
< 	float32 aD = data.positions[m_indexD].a;
< 	b2Vec2 vD = data.velocities[m_indexD].v;
< 	float32 wD = data.velocities[m_indexD].w;
< 
< 	b2Rot qA(aA), qB(aB), qC(aC), qD(aD);
< 
< 	m_mass = 0.0f;
< 
< 	if (m_typeA == e_revoluteJoint)
< 	{
< 		m_JvAC.SetZero();
< 		m_JwA = 1.0f;
< 		m_JwC = 1.0f;
< 		m_mass += m_iA + m_iC;
---
> 	b2Body* g1 = m_ground1;
> 	b2Body* g2 = m_ground2;
> 	b2Body* b1 = m_body1;
> 	b2Body* b2 = m_body2;
> 
> 	float32 K = 0.0f;
> 	m_J.SetZero();
> 
> 	if (m_revolute1)
> 	{
> 		m_J.angular1 = -1.0f;
> 		K += b1->m_invI;
179,185c121,126
< 		b2Vec2 u = b2Mul(qC, m_localAxisC);
< 		b2Vec2 rC = b2Mul(qC, m_localAnchorC - m_lcC);
< 		b2Vec2 rA = b2Mul(qA, m_localAnchorA - m_lcA);
< 		m_JvAC = u;
< 		m_JwC = b2Cross(rC, u);
< 		m_JwA = b2Cross(rA, u);
< 		m_mass += m_mC + m_mA + m_iC * m_JwC * m_JwC + m_iA * m_JwA * m_JwA;
---
> 		b2Vec2 ug = b2Mul(g1->GetXForm().R, m_prismatic1->m_localXAxis1);
> 		b2Vec2 r = b2Mul(b1->GetXForm().R, m_localAnchor1 - b1->GetLocalCenter());
> 		float32 crug = b2Cross(r, ug);
> 		m_J.linear1 = -ug;
> 		m_J.angular1 = -crug;
> 		K += b1->m_invMass + b1->m_invI * crug * crug;
188,193c129,132
< 	if (m_typeB == e_revoluteJoint)
< 	{
< 		m_JvBD.SetZero();
< 		m_JwB = m_ratio;
< 		m_JwD = m_ratio;
< 		m_mass += m_ratio * m_ratio * (m_iB + m_iD);
---
> 	if (m_revolute2)
> 	{
> 		m_J.angular2 = -m_ratio;
> 		K += m_ratio * m_ratio * b2->m_invI;
197,203c136,141
< 		b2Vec2 u = b2Mul(qD, m_localAxisD);
< 		b2Vec2 rD = b2Mul(qD, m_localAnchorD - m_lcD);
< 		b2Vec2 rB = b2Mul(qB, m_localAnchorB - m_lcB);
< 		m_JvBD = m_ratio * u;
< 		m_JwD = m_ratio * b2Cross(rD, u);
< 		m_JwB = m_ratio * b2Cross(rB, u);
< 		m_mass += m_ratio * m_ratio * (m_mD + m_mB) + m_iD * m_JwD * m_JwD + m_iB * m_JwB * m_JwB;
---
> 		b2Vec2 ug = b2Mul(g2->GetXForm().R, m_prismatic2->m_localXAxis1);
> 		b2Vec2 r = b2Mul(b2->GetXForm().R, m_localAnchor2 - b2->GetLocalCenter());
> 		float32 crug = b2Cross(r, ug);
> 		m_J.linear2 = -m_ratio * ug;
> 		m_J.angular2 = -m_ratio * crug;
> 		K += m_ratio * m_ratio * (b2->m_invMass + b2->m_invI * crug * crug);
207c145,146
< 	m_mass = m_mass > 0.0f ? 1.0f / m_mass : 0.0f;
---
> 	b2Assert(K > 0.0f);
> 	m_mass = 1.0f / K;
209c148
< 	if (data.step.warmStarting)
---
> 	if (step.warmStarting)
211,218c150,154
< 		vA += (m_mA * m_impulse) * m_JvAC;
< 		wA += m_iA * m_impulse * m_JwA;
< 		vB += (m_mB * m_impulse) * m_JvBD;
< 		wB += m_iB * m_impulse * m_JwB;
< 		vC -= (m_mC * m_impulse) * m_JvAC;
< 		wC -= m_iC * m_impulse * m_JwC;
< 		vD -= (m_mD * m_impulse) * m_JvBD;
< 		wD -= m_iD * m_impulse * m_JwD;
---
> 		// Warm starting.
> 		b1->m_linearVelocity += b1->m_invMass * m_impulse * m_J.linear1;
> 		b1->m_angularVelocity += b1->m_invI * m_impulse * m_J.angular1;
> 		b2->m_linearVelocity += b2->m_invMass * m_impulse * m_J.linear2;
> 		b2->m_angularVelocity += b2->m_invI * m_impulse * m_J.angular2;
224,232d159
< 
< 	data.velocities[m_indexA].v = vA;
< 	data.velocities[m_indexA].w = wA;
< 	data.velocities[m_indexB].v = vB;
< 	data.velocities[m_indexB].w = wB;
< 	data.velocities[m_indexC].v = vC;
< 	data.velocities[m_indexC].w = wC;
< 	data.velocities[m_indexD].v = vD;
< 	data.velocities[m_indexD].w = wD;
235c162
< void b2GearJoint::SolveVelocityConstraints(const b2SolverData& data)
---
> void b2GearJoint::SolveVelocityConstraints(const b2TimeStep& step)
237,244c164
< 	b2Vec2 vA = data.velocities[m_indexA].v;
< 	float32 wA = data.velocities[m_indexA].w;
< 	b2Vec2 vB = data.velocities[m_indexB].v;
< 	float32 wB = data.velocities[m_indexB].w;
< 	b2Vec2 vC = data.velocities[m_indexC].v;
< 	float32 wC = data.velocities[m_indexC].w;
< 	b2Vec2 vD = data.velocities[m_indexD].v;
< 	float32 wD = data.velocities[m_indexD].w;
---
> 	B2_NOT_USED(step);
246,247c166,167
< 	float32 Cdot = b2Dot(m_JvAC, vA - vC) + b2Dot(m_JvBD, vB - vD);
< 	Cdot += (m_JwA * wA - m_JwC * wC) + (m_JwB * wB - m_JwD * wD);
---
> 	b2Body* b1 = m_body1;
> 	b2Body* b2 = m_body2;
249c169,172
< 	float32 impulse = -m_mass * Cdot;
---
> 	float32 Cdot = m_J.Compute(	b1->m_linearVelocity, b1->m_angularVelocity,
> 								b2->m_linearVelocity, b2->m_angularVelocity);
> 
> 	float32 impulse = m_mass * (-Cdot);
252,268c175,178
< 	vA += (m_mA * impulse) * m_JvAC;
< 	wA += m_iA * impulse * m_JwA;
< 	vB += (m_mB * impulse) * m_JvBD;
< 	wB += m_iB * impulse * m_JwB;
< 	vC -= (m_mC * impulse) * m_JvAC;
< 	wC -= m_iC * impulse * m_JwC;
< 	vD -= (m_mD * impulse) * m_JvBD;
< 	wD -= m_iD * impulse * m_JwD;
< 
< 	data.velocities[m_indexA].v = vA;
< 	data.velocities[m_indexA].w = wA;
< 	data.velocities[m_indexB].v = vB;
< 	data.velocities[m_indexB].w = wB;
< 	data.velocities[m_indexC].v = vC;
< 	data.velocities[m_indexC].w = wC;
< 	data.velocities[m_indexD].v = vD;
< 	data.velocities[m_indexD].w = wD;
---
> 	b1->m_linearVelocity += b1->m_invMass * impulse * m_J.linear1;
> 	b1->m_angularVelocity += b1->m_invI * impulse * m_J.angular1;
> 	b2->m_linearVelocity += b2->m_invMass * impulse * m_J.linear2;
> 	b2->m_angularVelocity += b2->m_invI * impulse * m_J.angular2;
271c181
< bool b2GearJoint::SolvePositionConstraints(const b2SolverData& data)
---
> bool b2GearJoint::SolvePositionConstraints(float32 baumgarte)
273,283c183,184
< 	b2Vec2 cA = data.positions[m_indexA].c;
< 	float32 aA = data.positions[m_indexA].a;
< 	b2Vec2 cB = data.positions[m_indexB].c;
< 	float32 aB = data.positions[m_indexB].a;
< 	b2Vec2 cC = data.positions[m_indexC].c;
< 	float32 aC = data.positions[m_indexC].a;
< 	b2Vec2 cD = data.positions[m_indexD].c;
< 	float32 aD = data.positions[m_indexD].a;
< 
< 	b2Rot qA(aA), qB(aB), qC(aC), qD(aD);
< 
---
> 	B2_NOT_USED(baumgarte);
> 	
286,290c187,188
< 	float32 coordinateA, coordinateB;
< 
< 	b2Vec2 JvAC, JvBD;
< 	float32 JwA, JwB, JwC, JwD;
< 	float32 mass = 0.0f;
---
> 	b2Body* b1 = m_body1;
> 	b2Body* b2 = m_body2;
292c190,191
< 	if (m_typeA == e_revoluteJoint)
---
> 	float32 coordinate1, coordinate2;
> 	if (m_revolute1)
294,299c193
< 		JvAC.SetZero();
< 		JwA = 1.0f;
< 		JwC = 1.0f;
< 		mass += m_iA + m_iC;
< 
< 		coordinateA = aA - aC - m_referenceAngleA;
---
> 		coordinate1 = m_revolute1->GetJointAngle();
303,321c197,198
< 		b2Vec2 u = b2Mul(qC, m_localAxisC);
< 		b2Vec2 rC = b2Mul(qC, m_localAnchorC - m_lcC);
< 		b2Vec2 rA = b2Mul(qA, m_localAnchorA - m_lcA);
< 		JvAC = u;
< 		JwC = b2Cross(rC, u);
< 		JwA = b2Cross(rA, u);
< 		mass += m_mC + m_mA + m_iC * JwC * JwC + m_iA * JwA * JwA;
< 
< 		b2Vec2 pC = m_localAnchorC - m_lcC;
< 		b2Vec2 pA = b2MulT(qC, rA + (cA - cC));
< 		coordinateA = b2Dot(pA - pC, m_localAxisC);
< 	}
< 
< 	if (m_typeB == e_revoluteJoint)
< 	{
< 		JvBD.SetZero();
< 		JwB = m_ratio;
< 		JwD = m_ratio;
< 		mass += m_ratio * m_ratio * (m_iB + m_iD);
---
> 		coordinate1 = m_prismatic1->GetJointTranslation();
> 	}
323c200,202
< 		coordinateB = aB - aD - m_referenceAngleB;
---
> 	if (m_revolute2)
> 	{
> 		coordinate2 = m_revolute2->GetJointAngle();
327,364c206,219
< 		b2Vec2 u = b2Mul(qD, m_localAxisD);
< 		b2Vec2 rD = b2Mul(qD, m_localAnchorD - m_lcD);
< 		b2Vec2 rB = b2Mul(qB, m_localAnchorB - m_lcB);
< 		JvBD = m_ratio * u;
< 		JwD = m_ratio * b2Cross(rD, u);
< 		JwB = m_ratio * b2Cross(rB, u);
< 		mass += m_ratio * m_ratio * (m_mD + m_mB) + m_iD * JwD * JwD + m_iB * JwB * JwB;
< 
< 		b2Vec2 pD = m_localAnchorD - m_lcD;
< 		b2Vec2 pB = b2MulT(qD, rB + (cB - cD));
< 		coordinateB = b2Dot(pB - pD, m_localAxisD);
< 	}
< 
< 	float32 C = (coordinateA + m_ratio * coordinateB) - m_constant;
< 
< 	float32 impulse = 0.0f;
< 	if (mass > 0.0f)
< 	{
< 		impulse = -C / mass;
< 	}
< 
< 	cA += m_mA * impulse * JvAC;
< 	aA += m_iA * impulse * JwA;
< 	cB += m_mB * impulse * JvBD;
< 	aB += m_iB * impulse * JwB;
< 	cC -= m_mC * impulse * JvAC;
< 	aC -= m_iC * impulse * JwC;
< 	cD -= m_mD * impulse * JvBD;
< 	aD -= m_iD * impulse * JwD;
< 
< 	data.positions[m_indexA].c = cA;
< 	data.positions[m_indexA].a = aA;
< 	data.positions[m_indexB].c = cB;
< 	data.positions[m_indexB].a = aB;
< 	data.positions[m_indexC].c = cC;
< 	data.positions[m_indexC].a = aC;
< 	data.positions[m_indexD].c = cD;
< 	data.positions[m_indexD].a = aD;
---
> 		coordinate2 = m_prismatic2->GetJointTranslation();
> 	}
> 
> 	float32 C = m_constant - (coordinate1 + m_ratio * coordinate2);
> 
> 	float32 impulse = m_mass * (-C);
> 
> 	b1->m_sweep.c += b1->m_invMass * impulse * m_J.linear1;
> 	b1->m_sweep.a += b1->m_invI * impulse * m_J.angular1;
> 	b2->m_sweep.c += b2->m_invMass * impulse * m_J.linear2;
> 	b2->m_sweep.a += b2->m_invI * impulse * m_J.angular2;
> 
> 	b1->SynchronizeTransform();
> 	b2->SynchronizeTransform();
370c225
< b2Vec2 b2GearJoint::GetAnchorA() const
---
> b2Vec2 b2GearJoint::GetAnchor1() const
372c227
< 	return m_bodyA->GetWorldPoint(m_localAnchorA);
---
> 	return m_body1->GetWorldPoint(m_localAnchor1);
375c230
< b2Vec2 b2GearJoint::GetAnchorB() const
---
> b2Vec2 b2GearJoint::GetAnchor2() const
377c232
< 	return m_bodyB->GetWorldPoint(m_localAnchorB);
---
> 	return m_body2->GetWorldPoint(m_localAnchor2);
382c237,238
< 	b2Vec2 P = m_impulse * m_JvAC;
---
> 	// TODO_ERIN not tested
> 	b2Vec2 P = m_impulse * m_J.linear2;
388c244,247
< 	float32 L = m_impulse * m_JwA;
---
> 	// TODO_ERIN not tested
> 	b2Vec2 r = b2Mul(m_body2->GetXForm().R, m_localAnchor2 - m_body2->GetLocalCenter());
> 	b2Vec2 P = m_impulse * m_J.linear2;
> 	float32 L = m_impulse * m_J.angular2 - b2Cross(r, P);
392,397d250
< void b2GearJoint::SetRatio(float32 ratio)
< {
< 	b2Assert(b2IsValid(ratio));
< 	m_ratio = ratio;
< }
< 
403,406d255
< void b2GearJoint::Dump()
< {
< 	int32 indexA = m_bodyA->m_islandIndex;
< 	int32 indexB = m_bodyB->m_islandIndex;
408,409d256
< 	int32 index1 = m_joint1->m_index;
< 	int32 index2 = m_joint2->m_index;
411,419d257
< 	b2Log("  b2GearJointDef jd;\n");
< 	b2Log("  jd.bodyA = bodies[%d];\n", indexA);
< 	b2Log("  jd.bodyB = bodies[%d];\n", indexB);
< 	b2Log("  jd.collideConnected = bool(%d);\n", m_collideConnected);
< 	b2Log("  jd.joint1 = joints[%d];\n", index1);
< 	b2Log("  jd.joint2 = joints[%d];\n", index2);
< 	b2Log("  jd.ratio = %.15lef;\n", m_ratio);
< 	b2Log("  joints[%d] = m_world->CreateJoint(&jd);\n", m_index);
< }
diff -r -x './svn/*' native/Box2D/Dynamics/Joints/.svn/text-base/b2GearJoint.h.svn-base ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Joints/.svn/text-base/b2GearJoint.h.svn-base
2c2
< * Copyright (c) 2006-2011 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
22c22,25
< #include <Box2D/Dynamics/Joints/b2Joint.h>
---
> #include "b2Joint.h"
> 
> class b2RevoluteJoint;
> class b2PrismaticJoint;
25a29
> /// The provided joints must attach a dynamic body to a static body.
54,55c58,59
< /// @warning You have to manually destroy the gear joint if joint1 or joint2
< /// is destroyed.
---
> /// @warning The revolute and prismatic joints must be attached to
> /// fixed bodies (which must be body1 on those joints).
59,60c63,64
< 	b2Vec2 GetAnchorA() const;
< 	b2Vec2 GetAnchorB() const;
---
> 	b2Vec2 GetAnchor1() const;
> 	b2Vec2 GetAnchor2() const;
65,66c69,70
< 	/// Get the first joint.
< 	b2Joint* GetJoint1() { return m_joint1; }
---
> 	/// Get the gear ratio.
> 	float32 GetRatio() const;
68,69c72
< 	/// Get the second joint.
< 	b2Joint* GetJoint2() { return m_joint2; }
---
> 	//--------------- Internals Below -------------------
71,73c74
< 	/// Set/Get the gear ratio.
< 	void SetRatio(float32 ratio);
< 	float32 GetRatio() const;
---
> 	b2GearJoint(const b2GearJointDef* data);
75,76c76,78
< 	/// Dump joint to dmLog
< 	void Dump();
---
> 	void InitVelocityConstraints(const b2TimeStep& step);
> 	void SolveVelocityConstraints(const b2TimeStep& step);
> 	bool SolvePositionConstraints(float32 baumgarte);
78c80,81
< protected:
---
> 	b2Body* m_ground1;
> 	b2Body* m_ground2;
80,81c83,85
< 	friend class b2Joint;
< 	b2GearJoint(const b2GearJointDef* data);
---
> 	// One of these is NULL.
> 	b2RevoluteJoint* m_revolute1;
> 	b2PrismaticJoint* m_prismatic1;
83,102c87,89
< 	void InitVelocityConstraints(const b2SolverData& data);
< 	void SolveVelocityConstraints(const b2SolverData& data);
< 	bool SolvePositionConstraints(const b2SolverData& data);
< 
< 	b2Joint* m_joint1;
< 	b2Joint* m_joint2;
< 
< 	b2JointType m_typeA;
< 	b2JointType m_typeB;
< 
< 	// Body A is connected to body C
< 	// Body B is connected to body D
< 	b2Body* m_bodyC;
< 	b2Body* m_bodyD;
< 
< 	// Solver shared
< 	b2Vec2 m_localAnchorA;
< 	b2Vec2 m_localAnchorB;
< 	b2Vec2 m_localAnchorC;
< 	b2Vec2 m_localAnchorD;
---
> 	// One of these is NULL.
> 	b2RevoluteJoint* m_revolute2;
> 	b2PrismaticJoint* m_prismatic2;
104,105c91,92
< 	b2Vec2 m_localAxisC;
< 	b2Vec2 m_localAxisD;
---
> 	b2Vec2 m_groundAnchor1;
> 	b2Vec2 m_groundAnchor2;
107,108c94,97
< 	float32 m_referenceAngleA;
< 	float32 m_referenceAngleB;
---
> 	b2Vec2 m_localAnchor1;
> 	b2Vec2 m_localAnchor2;
> 
> 	b2Jacobian m_J;
113,121c102
< 	float32 m_impulse;
< 
< 	// Solver temp
< 	int32 m_indexA, m_indexB, m_indexC, m_indexD;
< 	b2Vec2 m_lcA, m_lcB, m_lcC, m_lcD;
< 	float32 m_mA, m_mB, m_mC, m_mD;
< 	float32 m_iA, m_iB, m_iC, m_iD;
< 	b2Vec2 m_JvAC, m_JvBD;
< 	float32 m_JwA, m_JwB, m_JwC, m_JwD;
---
> 	// Effective mass
122a104,106
> 
> 	// Impulse for accumulation/warm starting.
> 	float32 m_impulse;
diff -r -x './svn/*' native/Box2D/Dynamics/Joints/.svn/text-base/b2Joint.cpp.svn-base ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Joints/.svn/text-base/b2Joint.cpp.svn-base
2c2
< * Copyright (c) 2006-2007 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
19,33c19,30
< #include <Box2D/Dynamics/Joints/b2Joint.h>
< #include <Box2D/Dynamics/Joints/b2DistanceJoint.h>
< #include <Box2D/Dynamics/Joints/b2WheelJoint.h>
< #include <Box2D/Dynamics/Joints/b2MouseJoint.h>
< #include <Box2D/Dynamics/Joints/b2RevoluteJoint.h>
< #include <Box2D/Dynamics/Joints/b2PrismaticJoint.h>
< #include <Box2D/Dynamics/Joints/b2PulleyJoint.h>
< #include <Box2D/Dynamics/Joints/b2GearJoint.h>
< #include <Box2D/Dynamics/Joints/b2WeldJoint.h>
< #include <Box2D/Dynamics/Joints/b2FrictionJoint.h>
< #include <Box2D/Dynamics/Joints/b2RopeJoint.h>
< #include <Box2D/Dynamics/Joints/b2MotorJoint.h>
< #include <Box2D/Dynamics/b2Body.h>
< #include <Box2D/Dynamics/b2World.h>
< #include <Box2D/Common/b2BlockAllocator.h>
---
> #include "b2Joint.h"
> #include "b2DistanceJoint.h"
> #include "b2LineJoint.h"
> #include "b2MouseJoint.h"
> #include "b2RevoluteJoint.h"
> #include "b2PrismaticJoint.h"
> #include "b2PulleyJoint.h"
> #include "b2GearJoint.h"
> #include "../b2Body.h"
> #include "../b2World.h"
> #include "../../Common/b2BlockAllocator.h"
> #include "../../Collision/b2BroadPhase.h"
85c82
< 	case e_wheelJoint:
---
> 	case e_lineJoint:
87,116c84,85
< 			void* mem = allocator->Allocate(sizeof(b2WheelJoint));
< 			joint = new (mem) b2WheelJoint((b2WheelJointDef*)def);
< 		}
< 		break;
< 
< 	case e_weldJoint:
< 		{
< 			void* mem = allocator->Allocate(sizeof(b2WeldJoint));
< 			joint = new (mem) b2WeldJoint((b2WeldJointDef*)def);
< 		}
< 		break;
<         
< 	case e_frictionJoint:
< 		{
< 			void* mem = allocator->Allocate(sizeof(b2FrictionJoint));
< 			joint = new (mem) b2FrictionJoint((b2FrictionJointDef*)def);
< 		}
< 		break;
< 
< 	case e_ropeJoint:
< 		{
< 			void* mem = allocator->Allocate(sizeof(b2RopeJoint));
< 			joint = new (mem) b2RopeJoint((b2RopeJointDef*)def);
< 		}
< 		break;
< 
< 	case e_motorJoint:
< 		{
< 			void* mem = allocator->Allocate(sizeof(b2MotorJoint));
< 			joint = new (mem) b2MotorJoint((b2MotorJointDef*)def);
---
> 			void* mem = allocator->Allocate(sizeof(b2LineJoint));
> 			joint = new (mem) b2LineJoint((b2LineJointDef*)def);
157,174c126,127
< 	case e_wheelJoint:
< 		allocator->Free(joint, sizeof(b2WheelJoint));
< 		break;
<     
< 	case e_weldJoint:
< 		allocator->Free(joint, sizeof(b2WeldJoint));
< 		break;
< 
< 	case e_frictionJoint:
< 		allocator->Free(joint, sizeof(b2FrictionJoint));
< 		break;
< 
< 	case e_ropeJoint:
< 		allocator->Free(joint, sizeof(b2RopeJoint));
< 		break;
< 
< 	case e_motorJoint:
< 		allocator->Free(joint, sizeof(b2MotorJoint));
---
> 	case e_lineJoint:
> 		allocator->Free(joint, sizeof(b2LineJoint));
185,186d137
< 	b2Assert(def->bodyA != def->bodyB);
< 
190,192c141,142
< 	m_bodyA = def->bodyA;
< 	m_bodyB = def->bodyB;
< 	m_index = 0;
---
> 	m_body1 = def->body1;
> 	m_body2 = def->body2;
196,210d145
< 
< 	m_edgeA.joint = NULL;
< 	m_edgeA.other = NULL;
< 	m_edgeA.prev = NULL;
< 	m_edgeA.next = NULL;
< 
< 	m_edgeB.joint = NULL;
< 	m_edgeB.other = NULL;
< 	m_edgeB.prev = NULL;
< 	m_edgeB.next = NULL;
< }
< 
< bool b2Joint::IsActive() const
< {
< 	return m_bodyA->IsActive() && m_bodyB->IsActive();
diff -r -x './svn/*' native/Box2D/Dynamics/Joints/.svn/text-base/b2Joint.h.svn-base ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Joints/.svn/text-base/b2Joint.h.svn-base
2c2
< * Copyright (c) 2006-2007 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
19,20c19,20
< #ifndef B2_JOINT_H
< #define B2_JOINT_H
---
> #ifndef JOINT_H
> #define JOINT_H
22c22
< #include <Box2D/Common/b2Math.h>
---
> #include "../../Common/b2Math.h"
26c26
< struct b2SolverData;
---
> struct b2TimeStep;
38,42c38
< 	e_wheelJoint,
<     e_weldJoint,
< 	e_frictionJoint,
< 	e_ropeJoint,
< 	e_motorJoint
---
> 	e_lineJoint
55,57c51,58
< 	b2Vec2 linear;
< 	float32 angularA;
< 	float32 angularB;
---
> 	b2Vec2 linear1;
> 	float32 angular1;
> 	b2Vec2 linear2;
> 	float32 angular2;
> 
> 	void SetZero();
> 	void Set(const b2Vec2& x1, float32 a1, const b2Vec2& x2, float32 a2);
> 	float32 Compute(const b2Vec2& x1, float32 a1, const b2Vec2& x2, float32 a2);
80,81c81,82
< 		bodyA = NULL;
< 		bodyB = NULL;
---
> 		body1 = NULL;
> 		body2 = NULL;
92c93
< 	b2Body* bodyA;
---
> 	b2Body* body1;
95c96
< 	b2Body* bodyB;
---
> 	b2Body* body2;
111c112
< 	b2Body* GetBodyA();
---
> 	b2Body* GetBody1();
114c115
< 	b2Body* GetBodyB();
---
> 	b2Body* GetBody2();
116,117c117,118
< 	/// Get the anchor point on bodyA in world coordinates.
< 	virtual b2Vec2 GetAnchorA() const = 0;
---
> 	/// Get the anchor point on body1 in world coordinates.
> 	virtual b2Vec2 GetAnchor1() const = 0;
119,120c120,121
< 	/// Get the anchor point on bodyB in world coordinates.
< 	virtual b2Vec2 GetAnchorB() const = 0;
---
> 	/// Get the anchor point on body2 in world coordinates.
> 	virtual b2Vec2 GetAnchor2() const = 0;
122c123
< 	/// Get the reaction force on bodyB at the joint anchor in Newtons.
---
> 	/// Get the reaction force on body2 at the joint anchor.
125c126
< 	/// Get the reaction torque on bodyB in N*m.
---
> 	/// Get the reaction torque on body2.
130d130
< 	const b2Joint* GetNext() const;
133c133
< 	void* GetUserData() const;
---
> 	void* GetUserData();
138,151c138
< 	/// Short-cut function to determine if either body is inactive.
< 	bool IsActive() const;
< 
< 	/// Get collide connected.
< 	/// Note: modifying the collide connect flag won't work correctly because
< 	/// the flag is only checked when fixture AABBs begin to overlap.
< 	bool GetCollideConnected() const;
< 
< 	/// Dump this joint to the log file.
< 	virtual void Dump() { b2Log("// Dump is not supported for this joint type.\n"); }
< 
< 	/// Shift the origin for any points stored in world coordinates.
< 	virtual void ShiftOrigin(const b2Vec2& newOrigin) { B2_NOT_USED(newOrigin);  }
< 
---
> 	//--------------- Internals Below -------------------
156d142
< 	friend class b2GearJoint;
164,165c150,151
< 	virtual void InitVelocityConstraints(const b2SolverData& data) = 0;
< 	virtual void SolveVelocityConstraints(const b2SolverData& data) = 0;
---
> 	virtual void InitVelocityConstraints(const b2TimeStep& step) = 0;
> 	virtual void SolveVelocityConstraints(const b2TimeStep& step) = 0;
168c154,156
< 	virtual bool SolvePositionConstraints(const b2SolverData& data) = 0;
---
> 	virtual bool SolvePositionConstraints(float32 baumgarte) = 0;
> 
> 	void ComputeXForm(b2XForm* xf, const b2Vec2& center, const b2Vec2& localCenter, float32 angle) const;
173,178c161,164
< 	b2JointEdge m_edgeA;
< 	b2JointEdge m_edgeB;
< 	b2Body* m_bodyA;
< 	b2Body* m_bodyB;
< 
< 	int32 m_index;
---
> 	b2JointEdge m_node1;
> 	b2JointEdge m_node2;
> 	b2Body* m_body1;
> 	b2Body* m_body2;
183a170,174
> 
> 	// Cache here per time step to reduce cache misses.
> 	b2Vec2 m_localCenter1, m_localCenter2;
> 	float32 m_invMass1, m_invI1;
> 	float32 m_invMass2, m_invI2;
186c177
< inline b2JointType b2Joint::GetType() const
---
> inline void b2Jacobian::SetZero()
188c179,180
< 	return m_type;
---
> 	linear1.SetZero(); angular1 = 0.0f;
> 	linear2.SetZero(); angular2 = 0.0f;
191c183
< inline b2Body* b2Joint::GetBodyA()
---
> inline void b2Jacobian::Set(const b2Vec2& x1, float32 a1, const b2Vec2& x2, float32 a2)
193c185,186
< 	return m_bodyA;
---
> 	linear1 = x1; angular1 = a1;
> 	linear2 = x2; angular2 = a2;
196c189
< inline b2Body* b2Joint::GetBodyB()
---
> inline float32 b2Jacobian::Compute(const b2Vec2& x1, float32 a1, const b2Vec2& x2, float32 a2)
198c191
< 	return m_bodyB;
---
> 	return b2Dot(linear1, x1) + angular1 * a1 + b2Dot(linear2, x2) + angular2 * a2;
201c194
< inline b2Joint* b2Joint::GetNext()
---
> inline b2JointType b2Joint::GetType() const
203c196,201
< 	return m_next;
---
> 	return m_type;
> }
> 
> inline b2Body* b2Joint::GetBody1()
> {
> 	return m_body1;
206c204,209
< inline const b2Joint* b2Joint::GetNext() const
---
> inline b2Body* b2Joint::GetBody2()
> {
> 	return m_body2;
> }
> 
> inline b2Joint* b2Joint::GetNext()
211c214
< inline void* b2Joint::GetUserData() const
---
> inline void* b2Joint::GetUserData()
221c224
< inline bool b2Joint::GetCollideConnected() const
---
> inline void b2Joint::ComputeXForm(b2XForm* xf, const b2Vec2& center, const b2Vec2& localCenter, float32 angle) const
223c226,227
< 	return m_collideConnected;
---
> 	xf->R.Set(angle);
> 	xf->position = center - b2Mul(xf->R, localCenter);
Only in ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Joints/.svn/text-base: b2LineJoint.cpp.svn-base
Only in ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Joints/.svn/text-base: b2LineJoint.h.svn-base
Only in native/Box2D/Dynamics/Joints/.svn/text-base: b2MotorJoint.cpp.svn-base
Only in native/Box2D/Dynamics/Joints/.svn/text-base: b2MotorJoint.h.svn-base
diff -r -x './svn/*' native/Box2D/Dynamics/Joints/.svn/text-base/b2MouseJoint.cpp.svn-base ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Joints/.svn/text-base/b2MouseJoint.cpp.svn-base
2c2
< * Copyright (c) 2006-2007 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
19,21c19,21
< #include <Box2D/Dynamics/Joints/b2MouseJoint.h>
< #include <Box2D/Dynamics/b2Body.h>
< #include <Box2D/Dynamics/b2TimeStep.h>
---
> #include "b2MouseJoint.h"
> #include "../b2Body.h"
> #include "../b2World.h"
34,40c34,35
< 	b2Assert(def->target.IsValid());
< 	b2Assert(b2IsValid(def->maxForce) && def->maxForce >= 0.0f);
< 	b2Assert(b2IsValid(def->frequencyHz) && def->frequencyHz >= 0.0f);
< 	b2Assert(b2IsValid(def->dampingRatio) && def->dampingRatio >= 0.0f);
< 
< 	m_targetA = def->target;
< 	m_localAnchorB = b2MulT(m_bodyB->GetTransform(), m_targetA);
---
> 	m_target = def->target;
> 	m_localAnchor = b2MulT(m_body2->GetXForm(), m_target);
54c49
< 	if (m_bodyB->IsAwake() == false)
---
> 	if (m_body2->IsSleeping())
56c51
< 		m_bodyB->SetAwake(true);
---
> 		m_body2->WakeUp();
58,88c53
< 	m_targetA = target;
< }
< 
< const b2Vec2& b2MouseJoint::GetTarget() const
< {
< 	return m_targetA;
< }
< 
< void b2MouseJoint::SetMaxForce(float32 force)
< {
< 	m_maxForce = force;
< }
< 
< float32 b2MouseJoint::GetMaxForce() const
< {
< 	return m_maxForce;
< }
< 
< void b2MouseJoint::SetFrequency(float32 hz)
< {
< 	m_frequencyHz = hz;
< }
< 
< float32 b2MouseJoint::GetFrequency() const
< {
< 	return m_frequencyHz;
< }
< 
< void b2MouseJoint::SetDampingRatio(float32 ratio)
< {
< 	m_dampingRatio = ratio;
---
> 	m_target = target;
91c56
< float32 b2MouseJoint::GetDampingRatio() const
---
> void b2MouseJoint::InitVelocityConstraints(const b2TimeStep& step)
93,108c58
< 	return m_dampingRatio;
< }
< 
< void b2MouseJoint::InitVelocityConstraints(const b2SolverData& data)
< {
< 	m_indexB = m_bodyB->m_islandIndex;
< 	m_localCenterB = m_bodyB->m_sweep.localCenter;
< 	m_invMassB = m_bodyB->m_invMass;
< 	m_invIB = m_bodyB->m_invI;
< 
< 	b2Vec2 cB = data.positions[m_indexB].c;
< 	float32 aB = data.positions[m_indexB].a;
< 	b2Vec2 vB = data.velocities[m_indexB].v;
< 	float32 wB = data.velocities[m_indexB].w;
< 
< 	b2Rot qB(aB);
---
> 	b2Body* b = m_body2;
110c60
< 	float32 mass = m_bodyB->GetMass();
---
> 	float32 mass = b->GetMass();
124,131c74,76
< 	float32 h = data.step.dt;
< 	b2Assert(d + h * k > b2_epsilon);
< 	m_gamma = h * (d + h * k);
< 	if (m_gamma != 0.0f)
< 	{
< 		m_gamma = 1.0f / m_gamma;
< 	}
< 	m_beta = h * k * m_gamma;
---
> 	b2Assert(d + step.dt * k > B2_FLT_EPSILON);
> 	m_gamma = 1.0f / (step.dt * (d + step.dt * k));
> 	m_beta = step.dt * k * m_gamma;
134c79
< 	m_rB = b2Mul(qB, m_localAnchorB - m_localCenterB);
---
> 	b2Vec2 r = b2Mul(b->GetXForm().R, m_localAnchor - b->GetLocalCenter());
139,143c84,97
< 	b2Mat22 K;
< 	K.ex.x = m_invMassB + m_invIB * m_rB.y * m_rB.y + m_gamma;
< 	K.ex.y = -m_invIB * m_rB.x * m_rB.y;
< 	K.ey.x = K.ex.y;
< 	K.ey.y = m_invMassB + m_invIB * m_rB.x * m_rB.x + m_gamma;
---
> 	float32 invMass = b->m_invMass;
> 	float32 invI = b->m_invI;
> 
> 	b2Mat22 K1;
> 	K1.col1.x = invMass;	K1.col2.x = 0.0f;
> 	K1.col1.y = 0.0f;		K1.col2.y = invMass;
> 
> 	b2Mat22 K2;
> 	K2.col1.x =  invI * r.y * r.y;	K2.col2.x = -invI * r.x * r.y;
> 	K2.col1.y = -invI * r.x * r.y;	K2.col2.y =  invI * r.x * r.x;
> 
> 	b2Mat22 K = K1 + K2;
> 	K.col1.x += m_gamma;
> 	K.col2.y += m_gamma;
147,148c101
< 	m_C = cB + m_rB - m_targetA;
< 	m_C *= m_beta;
---
> 	m_C = b->m_sweep.c + r - m_target;
151c104
< 	wB *= 0.98f;
---
> 	b->m_angularVelocity *= 0.98f;
153,165c106,109
< 	if (data.step.warmStarting)
< 	{
< 		m_impulse *= data.step.dtRatio;
< 		vB += m_invMassB * m_impulse;
< 		wB += m_invIB * b2Cross(m_rB, m_impulse);
< 	}
< 	else
< 	{
< 		m_impulse.SetZero();
< 	}
< 
< 	data.velocities[m_indexB].v = vB;
< 	data.velocities[m_indexB].w = wB;
---
> 	// Warm starting.
> 	m_impulse *= step.dtRatio;
> 	b->m_linearVelocity += invMass * m_impulse;
> 	b->m_angularVelocity += invI * b2Cross(r, m_impulse);
168c112
< void b2MouseJoint::SolveVelocityConstraints(const b2SolverData& data)
---
> void b2MouseJoint::SolveVelocityConstraints(const b2TimeStep& step)
170,171c114,116
< 	b2Vec2 vB = data.velocities[m_indexB].v;
< 	float32 wB = data.velocities[m_indexB].w;
---
> 	b2Body* b = m_body2;
> 
> 	b2Vec2 r = b2Mul(b->GetXForm().R, m_localAnchor - b->GetLocalCenter());
174,175c119,120
< 	b2Vec2 Cdot = vB + b2Cross(wB, m_rB);
< 	b2Vec2 impulse = b2Mul(m_mass, -(Cdot + m_C + m_gamma * m_impulse));
---
> 	b2Vec2 Cdot = b->m_linearVelocity + b2Cross(b->m_angularVelocity, r);
> 	b2Vec2 impulse = b2Mul(m_mass, -(Cdot + m_beta * m_C + m_gamma * m_impulse));
179c124
< 	float32 maxImpulse = data.step.dt * m_maxForce;
---
> 	float32 maxImpulse = step.dt * m_maxForce;
186,190c131,132
< 	vB += m_invMassB * impulse;
< 	wB += m_invIB * b2Cross(m_rB, impulse);
< 
< 	data.velocities[m_indexB].v = vB;
< 	data.velocities[m_indexB].w = wB;
---
> 	b->m_linearVelocity += b->m_invMass * impulse;
> 	b->m_angularVelocity += b->m_invI * b2Cross(r, impulse);
193c135
< bool b2MouseJoint::SolvePositionConstraints(const b2SolverData& data)
---
> b2Vec2 b2MouseJoint::GetAnchor1() const
195,196c137
< 	B2_NOT_USED(data);
< 	return true;
---
> 	return m_target;
199c140
< b2Vec2 b2MouseJoint::GetAnchorA() const
---
> b2Vec2 b2MouseJoint::GetAnchor2() const
201,206c142
< 	return m_targetA;
< }
< 
< b2Vec2 b2MouseJoint::GetAnchorB() const
< {
< 	return m_bodyB->GetWorldPoint(m_localAnchorB);
---
> 	return m_body2->GetWorldPoint(m_localAnchor);
218,222d153
< 
< void b2MouseJoint::ShiftOrigin(const b2Vec2& newOrigin)
< {
< 	m_targetA -= newOrigin;
< }
diff -r -x './svn/*' native/Box2D/Dynamics/Joints/.svn/text-base/b2MouseJoint.h.svn-base ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Joints/.svn/text-base/b2MouseJoint.h.svn-base
2c2
< * Copyright (c) 2006-2007 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
22c22
< #include <Box2D/Dynamics/Joints/b2Joint.h>
---
> #include "b2Joint.h"
57,59d56
< /// NOTE: this joint is not documented in the manual because it was
< /// developed to be used in the testbed. If you want to learn how to
< /// use the mouse joint, look at the testbed.
65c62
< 	b2Vec2 GetAnchorA() const;
---
> 	b2Vec2 GetAnchor1() const;
68c65
< 	b2Vec2 GetAnchorB() const;
---
> 	b2Vec2 GetAnchor2() const;
78d74
< 	const b2Vec2& GetTarget() const;
80,99c76
< 	/// Set/get the maximum force in Newtons.
< 	void SetMaxForce(float32 force);
< 	float32 GetMaxForce() const;
< 
< 	/// Set/get the frequency in Hertz.
< 	void SetFrequency(float32 hz);
< 	float32 GetFrequency() const;
< 
< 	/// Set/get the damping ratio (dimensionless).
< 	void SetDampingRatio(float32 ratio);
< 	float32 GetDampingRatio() const;
< 
< 	/// The mouse joint does not support dumping.
< 	void Dump() { b2Log("Mouse joint dumping is not supported.\n"); }
< 
< 	/// Implement b2Joint::ShiftOrigin
< 	void ShiftOrigin(const b2Vec2& newOrigin);
< 
< protected:
< 	friend class b2Joint;
---
> 	//--------------- Internals Below -------------------
103,105c80,82
< 	void InitVelocityConstraints(const b2SolverData& data);
< 	void SolveVelocityConstraints(const b2SolverData& data);
< 	bool SolvePositionConstraints(const b2SolverData& data);
---
> 	void InitVelocityConstraints(const b2TimeStep& step);
> 	void SolveVelocityConstraints(const b2TimeStep& step);
> 	bool SolvePositionConstraints(float32 baumgarte) { B2_NOT_USED(baumgarte); return true; }
107,108c84,90
< 	b2Vec2 m_localAnchorB;
< 	b2Vec2 m_targetA;
---
> 	b2Vec2 m_localAnchor;
> 	b2Vec2 m_target;
> 	b2Vec2 m_impulse;
> 
> 	b2Mat22 m_mass;		// effective mass for point-to-point constraint.
> 	b2Vec2 m_C;				// position error
> 	float32 m_maxForce;
112,115d93
< 	
< 	// Solver shared
< 	b2Vec2 m_impulse;
< 	float32 m_maxForce;
117,126d94
< 
< 	// Solver temp
< 	int32 m_indexA;
< 	int32 m_indexB;
< 	b2Vec2 m_rB;
< 	b2Vec2 m_localCenterB;
< 	float32 m_invMassB;
< 	float32 m_invIB;
< 	b2Mat22 m_mass;
< 	b2Vec2 m_C;
diff -r -x './svn/*' native/Box2D/Dynamics/Joints/.svn/text-base/b2PrismaticJoint.cpp.svn-base ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Joints/.svn/text-base/b2PrismaticJoint.cpp.svn-base
2c2
< * Copyright (c) 2006-2011 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
19,21c19,21
< #include <Box2D/Dynamics/Joints/b2PrismaticJoint.h>
< #include <Box2D/Dynamics/b2Body.h>
< #include <Box2D/Dynamics/b2TimeStep.h>
---
> #include "b2PrismaticJoint.h"
> #include "../b2Body.h"
> #include "../b2World.h"
90c90
< void b2PrismaticJointDef::Initialize(b2Body* bA, b2Body* bB, const b2Vec2& anchor, const b2Vec2& axis)
---
> void b2PrismaticJointDef::Initialize(b2Body* b1, b2Body* b2, const b2Vec2& anchor, const b2Vec2& axis)
92,97c92,97
< 	bodyA = bA;
< 	bodyB = bB;
< 	localAnchorA = bodyA->GetLocalPoint(anchor);
< 	localAnchorB = bodyB->GetLocalPoint(anchor);
< 	localAxisA = bodyA->GetLocalVector(axis);
< 	referenceAngle = bodyB->GetAngle() - bodyA->GetAngle();
---
> 	body1 = b1;
> 	body2 = b2;
> 	localAnchor1 = body1->GetLocalPoint(anchor);
> 	localAnchor2 = body2->GetLocalPoint(anchor);
> 	localAxis1 = body1->GetLocalVector(axis);
> 	referenceAngle = body2->GetAngle() - body1->GetAngle();
103,108c103,107
< 	m_localAnchorA = def->localAnchorA;
< 	m_localAnchorB = def->localAnchorB;
< 	m_localXAxisA = def->localAxisA;
< 	m_localXAxisA.Normalize();
< 	m_localYAxisA = b2Cross(1.0f, m_localXAxisA);
< 	m_referenceAngle = def->referenceAngle;
---
> 	m_localAnchor1 = def->localAnchor1;
> 	m_localAnchor2 = def->localAnchor2;
> 	m_localXAxis1 = def->localAxis1;
> 	m_localYAxis1 = b2Cross(1.0f, m_localXAxis1);
> 	m_refAngle = def->referenceAngle;
111c110
< 	m_motorMass = 0.0f;
---
> 	m_motorMass = 0.0;
116c115
< 	m_maxMotorForce = def->maxMotorForce;
---
> 	m_maxMotorForce = B2FORCE_INV_SCALE(def->maxMotorForce);
126c125
< void b2PrismaticJoint::InitVelocityConstraints(const b2SolverData& data)
---
> void b2PrismaticJoint::InitVelocityConstraints(const b2TimeStep& step)
128,145c127,128
< 	m_indexA = m_bodyA->m_islandIndex;
< 	m_indexB = m_bodyB->m_islandIndex;
< 	m_localCenterA = m_bodyA->m_sweep.localCenter;
< 	m_localCenterB = m_bodyB->m_sweep.localCenter;
< 	m_invMassA = m_bodyA->m_invMass;
< 	m_invMassB = m_bodyB->m_invMass;
< 	m_invIA = m_bodyA->m_invI;
< 	m_invIB = m_bodyB->m_invI;
< 
< 	b2Vec2 cA = data.positions[m_indexA].c;
< 	float32 aA = data.positions[m_indexA].a;
< 	b2Vec2 vA = data.velocities[m_indexA].v;
< 	float32 wA = data.velocities[m_indexA].w;
< 
< 	b2Vec2 cB = data.positions[m_indexB].c;
< 	float32 aB = data.positions[m_indexB].a;
< 	b2Vec2 vB = data.velocities[m_indexB].v;
< 	float32 wB = data.velocities[m_indexB].w;
---
> 	b2Body* b1 = m_body1;
> 	b2Body* b2 = m_body2;
147c130,132
< 	b2Rot qA(aA), qB(aB);
---
> 	// You cannot create a prismatic joint between bodies that
> 	// both have fixed rotation.
> 	b2Assert(b1->m_invI > 0.0f || b2->m_invI > 0.0f);
149,152c134,138
< 	// Compute the effective masses.
< 	b2Vec2 rA = b2Mul(qA, m_localAnchorA - m_localCenterA);
< 	b2Vec2 rB = b2Mul(qB, m_localAnchorB - m_localCenterB);
< 	b2Vec2 d = (cB - cA) + rB - rA;
---
> 	m_localCenter1 = b1->GetLocalCenter();
> 	m_localCenter2 = b2->GetLocalCenter();
> 
> 	b2XForm xf1 = b1->GetXForm();
> 	b2XForm xf2 = b2->GetXForm();
154,155c140,148
< 	float32 mA = m_invMassA, mB = m_invMassB;
< 	float32 iA = m_invIA, iB = m_invIB;
---
> 	// Compute the effective masses.
> 	b2Vec2 r1 = b2Mul(xf1.R, m_localAnchor1 - m_localCenter1);
> 	b2Vec2 r2 = b2Mul(xf2.R, m_localAnchor2 - m_localCenter2);
> 	b2Vec2 d = b2->m_sweep.c + r2 - b1->m_sweep.c - r1;
> 
> 	m_invMass1 = b1->m_invMass;
> 	m_invI1 = b1->m_invI;
> 	m_invMass2 = b2->m_invMass;
> 	m_invI2 = b2->m_invI;
159,167c152,158
< 		m_axis = b2Mul(qA, m_localXAxisA);
< 		m_a1 = b2Cross(d + rA, m_axis);
< 		m_a2 = b2Cross(rB, m_axis);
< 
< 		m_motorMass = mA + mB + iA * m_a1 * m_a1 + iB * m_a2 * m_a2;
< 		if (m_motorMass > 0.0f)
< 		{
< 			m_motorMass = 1.0f / m_motorMass;
< 		}
---
> 		m_axis = b2Mul(xf1.R, m_localXAxis1);
> 		m_a1 = b2Cross(d + r1, m_axis);
> 		m_a2 = b2Cross(r2, m_axis);
> 
> 		m_motorMass = m_invMass1 + m_invMass2 + m_invI1 * m_a1 * m_a1 + m_invI2 * m_a2 * m_a2;
> 		b2Assert(m_motorMass > B2_FLT_EPSILON);
> 		m_motorMass = 1.0f / m_motorMass;
172c163
< 		m_perp = b2Mul(qA, m_localYAxisA);
---
> 		m_perp = b2Mul(xf1.R, m_localYAxis1);
174,175c165,166
< 		m_s1 = b2Cross(d + rA, m_perp);
< 		m_s2 = b2Cross(rB, m_perp);
---
> 		m_s1 = b2Cross(d + r1, m_perp);
> 		m_s2 = b2Cross(r2, m_perp);
177,187c168,169
< 		float32 k11 = mA + mB + iA * m_s1 * m_s1 + iB * m_s2 * m_s2;
< 		float32 k12 = iA * m_s1 + iB * m_s2;
< 		float32 k13 = iA * m_s1 * m_a1 + iB * m_s2 * m_a2;
< 		float32 k22 = iA + iB;
< 		if (k22 == 0.0f)
< 		{
< 			// For bodies with fixed rotation.
< 			k22 = 1.0f;
< 		}
< 		float32 k23 = iA * m_a1 + iB * m_a2;
< 		float32 k33 = mA + mB + iA * m_a1 * m_a1 + iB * m_a2 * m_a2;
---
> 		float32 m1 = m_invMass1, m2 = m_invMass2;
> 		float32 i1 = m_invI1, i2 = m_invI2;
189,191c171,180
< 		m_K.ex.Set(k11, k12, k13);
< 		m_K.ey.Set(k12, k22, k23);
< 		m_K.ez.Set(k13, k23, k33);
---
> 		float32 k11 = m1 + m2 + i1 * m_s1 * m_s1 + i2 * m_s2 * m_s2;
> 		float32 k12 = i1 * m_s1 + i2 * m_s2;
> 		float32 k13 = i1 * m_s1 * m_a1 + i2 * m_s2 * m_a2;
> 		float32 k22 = i1 + i2;
> 		float32 k23 = i1 * m_a1 + i2 * m_a2;
> 		float32 k33 = m1 + m2 + i1 * m_a1 * m_a1 + i2 * m_a2 * m_a2;
> 
> 		m_K.col1.Set(k11, k12, k13);
> 		m_K.col2.Set(k12, k22, k23);
> 		m_K.col3.Set(k13, k23, k33);
227d215
< 		m_impulse.z = 0.0f;
235c223
< 	if (data.step.warmStarting)
---
> 	if (step.warmStarting)
238,239c226,227
< 		m_impulse *= data.step.dtRatio;
< 		m_motorImpulse *= data.step.dtRatio;
---
> 		m_impulse *= step.dtRatio;
> 		m_motorImpulse *= step.dtRatio;
242,243c230,231
< 		float32 LA = m_impulse.x * m_s1 + m_impulse.y + (m_motorImpulse + m_impulse.z) * m_a1;
< 		float32 LB = m_impulse.x * m_s2 + m_impulse.y + (m_motorImpulse + m_impulse.z) * m_a2;
---
> 		float32 L1 = m_impulse.x * m_s1 + m_impulse.y + (m_motorImpulse + m_impulse.z) * m_a1;
> 		float32 L2 = m_impulse.x * m_s2 + m_impulse.y + (m_motorImpulse + m_impulse.z) * m_a2;
245,246c233,234
< 		vA -= mA * P;
< 		wA -= iA * LA;
---
> 		b1->m_linearVelocity -= m_invMass1 * P;
> 		b1->m_angularVelocity -= m_invI1 * L1;
248,249c236,237
< 		vB += mB * P;
< 		wB += iB * LB;
---
> 		b2->m_linearVelocity += m_invMass2 * P;
> 		b2->m_angularVelocity += m_invI2 * L2;
256,260d243
< 
< 	data.velocities[m_indexA].v = vA;
< 	data.velocities[m_indexA].w = wA;
< 	data.velocities[m_indexB].v = vB;
< 	data.velocities[m_indexB].w = wB;
263c246
< void b2PrismaticJoint::SolveVelocityConstraints(const b2SolverData& data)
---
> void b2PrismaticJoint::SolveVelocityConstraints(const b2TimeStep& step)
265,268c248,249
< 	b2Vec2 vA = data.velocities[m_indexA].v;
< 	float32 wA = data.velocities[m_indexA].w;
< 	b2Vec2 vB = data.velocities[m_indexB].v;
< 	float32 wB = data.velocities[m_indexB].w;
---
> 	b2Body* b1 = m_body1;
> 	b2Body* b2 = m_body2;
270,271c251,254
< 	float32 mA = m_invMassA, mB = m_invMassB;
< 	float32 iA = m_invIA, iB = m_invIB;
---
> 	b2Vec2 v1 = b1->m_linearVelocity;
> 	float32 w1 = b1->m_angularVelocity;
> 	b2Vec2 v2 = b2->m_linearVelocity;
> 	float32 w2 = b2->m_angularVelocity;
276c259
< 		float32 Cdot = b2Dot(m_axis, vB - vA) + m_a2 * wB - m_a1 * wA;
---
> 		float32 Cdot = b2Dot(m_axis, v2 - v1) + m_a2 * w2 - m_a1 * w1;
279c262
< 		float32 maxImpulse = data.step.dt * m_maxMotorForce;
---
> 		float32 maxImpulse = step.dt * m_maxMotorForce;
284,285c267,268
< 		float32 LA = impulse * m_a1;
< 		float32 LB = impulse * m_a2;
---
> 		float32 L1 = impulse * m_a1;
> 		float32 L2 = impulse * m_a2;
287,288c270,271
< 		vA -= mA * P;
< 		wA -= iA * LA;
---
> 		v1 -= m_invMass1 * P;
> 		w1 -= m_invI1 * L1;
290,291c273,274
< 		vB += mB * P;
< 		wB += iB * LB;
---
> 		v2 += m_invMass2 * P;
> 		w2 += m_invI2 * L2;
295,296c278,279
< 	Cdot1.x = b2Dot(m_perp, vB - vA) + m_s2 * wB - m_s1 * wA;
< 	Cdot1.y = wB - wA;
---
> 	Cdot1.x = b2Dot(m_perp, v2 - v1) + m_s2 * w2 - m_s1 * w1;
> 	Cdot1.y = w2 - w1;
302c285
< 		Cdot2 = b2Dot(m_axis, vB - vA) + m_a2 * wB - m_a1 * wA;
---
> 		Cdot2 = b2Dot(m_axis, v2 - v1) + m_a2 * w2 - m_a1 * w1;
319c302
< 		b2Vec2 b = -Cdot1 - (m_impulse.z - f1.z) * b2Vec2(m_K.ez.x, m_K.ez.y);
---
> 		b2Vec2 b = -Cdot1 - (m_impulse.z - f1.z) * b2Vec2(m_K.col3.x, m_K.col3.y);
327,328c310,311
< 		float32 LA = df.x * m_s1 + df.y + df.z * m_a1;
< 		float32 LB = df.x * m_s2 + df.y + df.z * m_a2;
---
> 		float32 L1 = df.x * m_s1 + df.y + df.z * m_a1;
> 		float32 L2 = df.x * m_s2 + df.y + df.z * m_a2;
330,331c313,314
< 		vA -= mA * P;
< 		wA -= iA * LA;
---
> 		v1 -= m_invMass1 * P;
> 		w1 -= m_invI1 * L1;
333,334c316,317
< 		vB += mB * P;
< 		wB += iB * LB;
---
> 		v2 += m_invMass2 * P;
> 		w2 += m_invI2 * L2;
344,345c327,328
< 		float32 LA = df.x * m_s1 + df.y;
< 		float32 LB = df.x * m_s2 + df.y;
---
> 		float32 L1 = df.x * m_s1 + df.y;
> 		float32 L2 = df.x * m_s2 + df.y;
347,348c330,331
< 		vA -= mA * P;
< 		wA -= iA * LA;
---
> 		v1 -= m_invMass1 * P;
> 		w1 -= m_invI1 * L1;
350,351c333,334
< 		vB += mB * P;
< 		wB += iB * LB;
---
> 		v2 += m_invMass2 * P;
> 		w2 += m_invI2 * L2;
354,357c337,340
< 	data.velocities[m_indexA].v = vA;
< 	data.velocities[m_indexA].w = wA;
< 	data.velocities[m_indexB].v = vB;
< 	data.velocities[m_indexB].w = wB;
---
> 	b1->m_linearVelocity = v1;
> 	b1->m_angularVelocity = w1;
> 	b2->m_linearVelocity = v2;
> 	b2->m_angularVelocity = w2;
360c343
< bool b2PrismaticJoint::SolvePositionConstraints(const b2SolverData& data)
---
> bool b2PrismaticJoint::SolvePositionConstraints(float32 baumgarte)
362,367c345
< 	b2Vec2 cA = data.positions[m_indexA].c;
< 	float32 aA = data.positions[m_indexA].a;
< 	b2Vec2 cB = data.positions[m_indexB].c;
< 	float32 aB = data.positions[m_indexB].a;
< 
< 	b2Rot qA(aA), qB(aB);
---
> 	B2_NOT_USED(baumgarte);
369,370c347,348
< 	float32 mA = m_invMassA, mB = m_invMassB;
< 	float32 iA = m_invIA, iB = m_invIB;
---
> 	b2Body* b1 = m_body1;
> 	b2Body* b2 = m_body2;
372,375c350,351
< 	// Compute fresh Jacobians
< 	b2Vec2 rA = b2Mul(qA, m_localAnchorA - m_localCenterA);
< 	b2Vec2 rB = b2Mul(qB, m_localAnchorB - m_localCenterB);
< 	b2Vec2 d = cB + rB - cA - rA;
---
> 	b2Vec2 c1 = b1->m_sweep.c;
> 	float32 a1 = b1->m_sweep.a;
377,380c353,354
< 	b2Vec2 axis = b2Mul(qA, m_localXAxisA);
< 	float32 a1 = b2Cross(d + rA, axis);
< 	float32 a2 = b2Cross(rB, axis);
< 	b2Vec2 perp = b2Mul(qA, m_localYAxisA);
---
> 	b2Vec2 c2 = b2->m_sweep.c;
> 	float32 a2 = b2->m_sweep.a;
382,383c356,359
< 	float32 s1 = b2Cross(d + rA, perp);
< 	float32 s2 = b2Cross(rB, perp);
---
> 	// Solve linear limit constraint.
> 	float32 linearError = 0.0f, angularError = 0.0f;
> 	bool active = false;
> 	float32 C2 = 0.0f;
385,388c361
< 	b2Vec3 impulse;
< 	b2Vec2 C1;
< 	C1.x = b2Dot(perp, d);
< 	C1.y = aB - aA - m_referenceAngle;
---
> 	b2Mat22 R1(a1), R2(a2);
390,391c363,365
< 	float32 linearError = b2Abs(C1.x);
< 	float32 angularError = b2Abs(C1.y);
---
> 	b2Vec2 r1 = b2Mul(R1, m_localAnchor1 - m_localCenter1);
> 	b2Vec2 r2 = b2Mul(R2, m_localAnchor2 - m_localCenter2);
> 	b2Vec2 d = c2 + r2 - c1 - r1;
393,394d366
< 	bool active = false;
< 	float32 C2 = 0.0f;
397c369,374
< 		float32 translation = b2Dot(axis, d);
---
> 		m_axis = b2Mul(R1, m_localXAxis1);
> 
> 		m_a1 = b2Cross(d + r1, m_axis);
> 		m_a2 = b2Cross(r2, m_axis);
> 
> 		float32 translation = b2Dot(m_axis, d);
402c379
< 			linearError = b2Max(linearError, b2Abs(translation));
---
> 			linearError = b2Abs(translation);
409c386
< 			linearError = b2Max(linearError, m_lowerTranslation - translation);
---
> 			linearError = m_lowerTranslation - translation;
416c393
< 			linearError = b2Max(linearError, translation - m_upperTranslation);
---
> 			linearError = translation - m_upperTranslation;
420a398,410
> 	m_perp = b2Mul(R1, m_localYAxis1);
> 
> 	m_s1 = b2Cross(d + r1, m_perp);
> 	m_s2 = b2Cross(r2, m_perp);
> 
> 	b2Vec3 impulse;
> 	b2Vec2 C1;
> 	C1.x = b2Dot(m_perp, d);
> 	C1.y = a2 - a1 - m_refAngle;
> 
> 	linearError = b2Max(linearError, b2Abs(C1.x));
> 	angularError = b2Abs(C1.y);
> 
423,433c413,414
< 		float32 k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2;
< 		float32 k12 = iA * s1 + iB * s2;
< 		float32 k13 = iA * s1 * a1 + iB * s2 * a2;
< 		float32 k22 = iA + iB;
< 		if (k22 == 0.0f)
< 		{
< 			// For fixed rotation
< 			k22 = 1.0f;
< 		}
< 		float32 k23 = iA * a1 + iB * a2;
< 		float32 k33 = mA + mB + iA * a1 * a1 + iB * a2 * a2;
---
> 		float32 m1 = m_invMass1, m2 = m_invMass2;
> 		float32 i1 = m_invI1, i2 = m_invI2;
435,438c416,425
< 		b2Mat33 K;
< 		K.ex.Set(k11, k12, k13);
< 		K.ey.Set(k12, k22, k23);
< 		K.ez.Set(k13, k23, k33);
---
> 		float32 k11 = m1 + m2 + i1 * m_s1 * m_s1 + i2 * m_s2 * m_s2;
> 		float32 k12 = i1 * m_s1 + i2 * m_s2;
> 		float32 k13 = i1 * m_s1 * m_a1 + i2 * m_s2 * m_a2;
> 		float32 k22 = i1 + i2;
> 		float32 k23 = i1 * m_a1 + i2 * m_a2;
> 		float32 k33 = m1 + m2 + i1 * m_a1 * m_a1 + i2 * m_a2 * m_a2;
> 
> 		m_K.col1.Set(k11, k12, k13);
> 		m_K.col2.Set(k12, k22, k23);
> 		m_K.col3.Set(k13, k23, k33);
445c432
< 		impulse = K.Solve33(-C);
---
> 		impulse = m_K.Solve33(-C);
449,455c436,437
< 		float32 k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2;
< 		float32 k12 = iA * s1 + iB * s2;
< 		float32 k22 = iA + iB;
< 		if (k22 == 0.0f)
< 		{
< 			k22 = 1.0f;
< 		}
---
> 		float32 m1 = m_invMass1, m2 = m_invMass2;
> 		float32 i1 = m_invI1, i2 = m_invI2;
457,459c439,441
< 		b2Mat22 K;
< 		K.ex.Set(k11, k12);
< 		K.ey.Set(k12, k22);
---
> 		float32 k11 = m1 + m2 + i1 * m_s1 * m_s1 + i2 * m_s2 * m_s2;
> 		float32 k12 = i1 * m_s1 + i2 * m_s2;
> 		float32 k22 = i1 + i2;
461c443,446
< 		b2Vec2 impulse1 = K.Solve(-C1);
---
> 		m_K.col1.Set(k11, k12, 0.0f);
> 		m_K.col2.Set(k12, k22, 0.0f);
> 
> 		b2Vec2 impulse1 = m_K.Solve22(-C1);
467,480c452,468
< 	b2Vec2 P = impulse.x * perp + impulse.z * axis;
< 	float32 LA = impulse.x * s1 + impulse.y + impulse.z * a1;
< 	float32 LB = impulse.x * s2 + impulse.y + impulse.z * a2;
< 
< 	cA -= mA * P;
< 	aA -= iA * LA;
< 	cB += mB * P;
< 	aB += iB * LB;
< 
< 	data.positions[m_indexA].c = cA;
< 	data.positions[m_indexA].a = aA;
< 	data.positions[m_indexB].c = cB;
< 	data.positions[m_indexB].a = aB;
< 
---
> 	b2Vec2 P = impulse.x * m_perp + impulse.z * m_axis;
> 	float32 L1 = impulse.x * m_s1 + impulse.y + impulse.z * m_a1;
> 	float32 L2 = impulse.x * m_s2 + impulse.y + impulse.z * m_a2;
> 
> 	c1 -= m_invMass1 * P;
> 	a1 -= m_invI1 * L1;
> 	c2 += m_invMass2 * P;
> 	a2 += m_invI2 * L2;
> 
> 	// TODO_ERIN remove need for this.
> 	b1->m_sweep.c = c1;
> 	b1->m_sweep.a = a1;
> 	b2->m_sweep.c = c2;
> 	b2->m_sweep.a = a2;
> 	b1->SynchronizeTransform();
> 	b2->SynchronizeTransform();
> 	
484c472
< b2Vec2 b2PrismaticJoint::GetAnchorA() const
---
> b2Vec2 b2PrismaticJoint::GetAnchor1() const
486c474
< 	return m_bodyA->GetWorldPoint(m_localAnchorA);
---
> 	return m_body1->GetWorldPoint(m_localAnchor1);
489c477
< b2Vec2 b2PrismaticJoint::GetAnchorB() const
---
> b2Vec2 b2PrismaticJoint::GetAnchor2() const
491c479
< 	return m_bodyB->GetWorldPoint(m_localAnchorB);
---
> 	return m_body2->GetWorldPoint(m_localAnchor2);
506,509c494,500
< 	b2Vec2 pA = m_bodyA->GetWorldPoint(m_localAnchorA);
< 	b2Vec2 pB = m_bodyB->GetWorldPoint(m_localAnchorB);
< 	b2Vec2 d = pB - pA;
< 	b2Vec2 axis = m_bodyA->GetWorldVector(m_localXAxisA);
---
> 	b2Body* b1 = m_body1;
> 	b2Body* b2 = m_body2;
> 
> 	b2Vec2 p1 = b1->GetWorldPoint(m_localAnchor1);
> 	b2Vec2 p2 = b2->GetWorldPoint(m_localAnchor2);
> 	b2Vec2 d = p2 - p1;
> 	b2Vec2 axis = b1->GetWorldVector(m_localXAxis1);
517,518c508,509
< 	b2Body* bA = m_bodyA;
< 	b2Body* bB = m_bodyB;
---
> 	b2Body* b1 = m_body1;
> 	b2Body* b2 = m_body2;
520,523c511,514
< 	b2Vec2 rA = b2Mul(bA->m_xf.q, m_localAnchorA - bA->m_sweep.localCenter);
< 	b2Vec2 rB = b2Mul(bB->m_xf.q, m_localAnchorB - bB->m_sweep.localCenter);
< 	b2Vec2 p1 = bA->m_sweep.c + rA;
< 	b2Vec2 p2 = bB->m_sweep.c + rB;
---
> 	b2Vec2 r1 = b2Mul(b1->GetXForm().R, m_localAnchor1 - b1->GetLocalCenter());
> 	b2Vec2 r2 = b2Mul(b2->GetXForm().R, m_localAnchor2 - b2->GetLocalCenter());
> 	b2Vec2 p1 = b1->m_sweep.c + r1;
> 	b2Vec2 p2 = b2->m_sweep.c + r2;
525c516
< 	b2Vec2 axis = b2Mul(bA->m_xf.q, m_localXAxisA);
---
> 	b2Vec2 axis = b1->GetWorldVector(m_localXAxis1);
527,530c518,521
< 	b2Vec2 vA = bA->m_linearVelocity;
< 	b2Vec2 vB = bB->m_linearVelocity;
< 	float32 wA = bA->m_angularVelocity;
< 	float32 wB = bB->m_angularVelocity;
---
> 	b2Vec2 v1 = b1->m_linearVelocity;
> 	b2Vec2 v2 = b2->m_linearVelocity;
> 	float32 w1 = b1->m_angularVelocity;
> 	float32 w2 = b2->m_angularVelocity;
532c523
< 	float32 speed = b2Dot(d, b2Cross(wA, axis)) + b2Dot(axis, vB + b2Cross(wB, rB) - vA - b2Cross(wA, rA));
---
> 	float32 speed = b2Dot(d, b2Cross(w1, axis)) + b2Dot(axis, v2 + b2Cross(w2, r2) - v1 - b2Cross(w1, r1));
543,549c534,536
< 	if (flag != m_enableLimit)
< 	{
< 		m_bodyA->SetAwake(true);
< 		m_bodyB->SetAwake(true);
< 		m_enableLimit = flag;
< 		m_impulse.z = 0.0f;
< 	}
---
> 	m_body1->WakeUp();
> 	m_body2->WakeUp();
> 	m_enableLimit = flag;
565,572c552,555
< 	if (lower != m_lowerTranslation || upper != m_upperTranslation)
< 	{
< 		m_bodyA->SetAwake(true);
< 		m_bodyB->SetAwake(true);
< 		m_lowerTranslation = lower;
< 		m_upperTranslation = upper;
< 		m_impulse.z = 0.0f;
< 	}
---
> 	m_body1->WakeUp();
> 	m_body2->WakeUp();
> 	m_lowerTranslation = lower;
> 	m_upperTranslation = upper;
582,583c565,566
< 	m_bodyA->SetAwake(true);
< 	m_bodyB->SetAwake(true);
---
> 	m_body1->WakeUp();
> 	m_body2->WakeUp();
589,590c572,573
< 	m_bodyA->SetAwake(true);
< 	m_bodyB->SetAwake(true);
---
> 	m_body1->WakeUp();
> 	m_body2->WakeUp();
596,625c579,586
< 	m_bodyA->SetAwake(true);
< 	m_bodyB->SetAwake(true);
< 	m_maxMotorForce = force;
< }
< 
< float32 b2PrismaticJoint::GetMotorForce(float32 inv_dt) const
< {
< 	return inv_dt * m_motorImpulse;
< }
< 
< void b2PrismaticJoint::Dump()
< {
< 	int32 indexA = m_bodyA->m_islandIndex;
< 	int32 indexB = m_bodyB->m_islandIndex;
< 
< 	b2Log("  b2PrismaticJointDef jd;\n");
< 	b2Log("  jd.bodyA = bodies[%d];\n", indexA);
< 	b2Log("  jd.bodyB = bodies[%d];\n", indexB);
< 	b2Log("  jd.collideConnected = bool(%d);\n", m_collideConnected);
< 	b2Log("  jd.localAnchorA.Set(%.15lef, %.15lef);\n", m_localAnchorA.x, m_localAnchorA.y);
< 	b2Log("  jd.localAnchorB.Set(%.15lef, %.15lef);\n", m_localAnchorB.x, m_localAnchorB.y);
< 	b2Log("  jd.localAxisA.Set(%.15lef, %.15lef);\n", m_localXAxisA.x, m_localXAxisA.y);
< 	b2Log("  jd.referenceAngle = %.15lef;\n", m_referenceAngle);
< 	b2Log("  jd.enableLimit = bool(%d);\n", m_enableLimit);
< 	b2Log("  jd.lowerTranslation = %.15lef;\n", m_lowerTranslation);
< 	b2Log("  jd.upperTranslation = %.15lef;\n", m_upperTranslation);
< 	b2Log("  jd.enableMotor = bool(%d);\n", m_enableMotor);
< 	b2Log("  jd.motorSpeed = %.15lef;\n", m_motorSpeed);
< 	b2Log("  jd.maxMotorForce = %.15lef;\n", m_maxMotorForce);
< 	b2Log("  joints[%d] = m_world->CreateJoint(&jd);\n", m_index);
---
> 	m_body1->WakeUp();
> 	m_body2->WakeUp();
> 	m_maxMotorForce = B2FORCE_SCALE(float32(1.0))*force;
> }
> 
> float32 b2PrismaticJoint::GetMotorForce() const
> {
> 	return m_motorImpulse;
diff -r -x './svn/*' native/Box2D/Dynamics/Joints/.svn/text-base/b2PrismaticJoint.h.svn-base ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Joints/.svn/text-base/b2PrismaticJoint.h.svn-base
2c2
< * Copyright (c) 2006-2011 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
22c22
< #include <Box2D/Dynamics/Joints/b2Joint.h>
---
> #include "b2Joint.h"
35,37c35,37
< 		localAnchorA.SetZero();
< 		localAnchorB.SetZero();
< 		localAxisA.Set(1.0f, 0.0f);
---
> 		localAnchor1.SetZero();
> 		localAnchor2.SetZero();
> 		localAxis1.Set(1.0f, 0.0f);
48,49c48,49
< 	/// anchor and unit world axis.
< 	void Initialize(b2Body* bodyA, b2Body* bodyB, const b2Vec2& anchor, const b2Vec2& axis);
---
> 	/// anchor and world axis.
> 	void Initialize(b2Body* body1, b2Body* body2, const b2Vec2& anchor, const b2Vec2& axis);
51,52c51,52
< 	/// The local anchor point relative to bodyA's origin.
< 	b2Vec2 localAnchorA;
---
> 	/// The local anchor point relative to body1's origin.
> 	b2Vec2 localAnchor1;
54,55c54,55
< 	/// The local anchor point relative to bodyB's origin.
< 	b2Vec2 localAnchorB;
---
> 	/// The local anchor point relative to body2's origin.
> 	b2Vec2 localAnchor2;
57,58c57,58
< 	/// The local translation unit axis in bodyA.
< 	b2Vec2 localAxisA;
---
> 	/// The local translation axis in body1.
> 	b2Vec2 localAxis1;
60c60
< 	/// The constrained angle between the bodies: bodyB_angle - bodyA_angle.
---
> 	/// The constrained angle between the bodies: body2_angle - body1_angle.
83c83
< /// along an axis fixed in bodyA. Relative rotation is prevented. You can
---
> /// along an axis fixed in body1. Relative rotation is prevented. You can
89,90c89,90
< 	b2Vec2 GetAnchorA() const;
< 	b2Vec2 GetAnchorB() const;
---
> 	b2Vec2 GetAnchor1() const;
> 	b2Vec2 GetAnchor2() const;
95,106d94
< 	/// The local anchor point relative to bodyA's origin.
< 	const b2Vec2& GetLocalAnchorA() const { return m_localAnchorA; }
< 
< 	/// The local anchor point relative to bodyB's origin.
< 	const b2Vec2& GetLocalAnchorB() const  { return m_localAnchorB; }
< 
< 	/// The local joint axis relative to bodyA.
< 	const b2Vec2& GetLocalAxisA() const { return m_localXAxisA; }
< 
< 	/// Get the reference angle.
< 	float32 GetReferenceAngle() const { return m_referenceAngle; }
< 
142d129
< 	float32 GetMaxMotorForce() const { return m_maxMotorForce; }
144,145c131,132
< 	/// Get the current motor force given the inverse time step, usually in N.
< 	float32 GetMotorForce(float32 inv_dt) const;
---
> 	/// Get the current motor force, usually in N.
> 	float32 GetMotorForce() const;
147,148c134
< 	/// Dump to b2Log
< 	void Dump();
---
> 	//--------------- Internals Below -------------------
150,152d135
< protected:
< 	friend class b2Joint;
< 	friend class b2GearJoint;
155,164c138,152
< 	void InitVelocityConstraints(const b2SolverData& data);
< 	void SolveVelocityConstraints(const b2SolverData& data);
< 	bool SolvePositionConstraints(const b2SolverData& data);
< 
< 	// Solver shared
< 	b2Vec2 m_localAnchorA;
< 	b2Vec2 m_localAnchorB;
< 	b2Vec2 m_localXAxisA;
< 	b2Vec2 m_localYAxisA;
< 	float32 m_referenceAngle;
---
> 	void InitVelocityConstraints(const b2TimeStep& step);
> 	void SolveVelocityConstraints(const b2TimeStep& step);
> 	bool SolvePositionConstraints(float32 baumgarte);
> 
> 	b2Vec2 m_localAnchor1;
> 	b2Vec2 m_localAnchor2;
> 	b2Vec2 m_localXAxis1;
> 	b2Vec2 m_localYAxis1;
> 	float32 m_refAngle;
> 
> 	b2Vec2 m_axis, m_perp;
> 	float32 m_s1, m_s2;
> 	float32 m_a1, m_a2;
> 
> 	b2Mat33 m_K;
165a154,155
> 
> 	float32 m_motorMass;			// effective mass for motor/limit translational constraint.
166a157
> 
170a162
> 	
174,188d165
< 
< 	// Solver temp
< 	int32 m_indexA;
< 	int32 m_indexB;
< 	b2Vec2 m_localCenterA;
< 	b2Vec2 m_localCenterB;
< 	float32 m_invMassA;
< 	float32 m_invMassB;
< 	float32 m_invIA;
< 	float32 m_invIB;
< 	b2Vec2 m_axis, m_perp;
< 	float32 m_s1, m_s2;
< 	float32 m_a1, m_a2;
< 	b2Mat33 m_K;
< 	float32 m_motorMass;
diff -r -x './svn/*' native/Box2D/Dynamics/Joints/.svn/text-base/b2PulleyJoint.cpp.svn-base ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Joints/.svn/text-base/b2PulleyJoint.cpp.svn-base
2c2
< * Copyright (c) 2007 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2007 Erin Catto http://www.gphysics.com
19,21c19,21
< #include <Box2D/Dynamics/Joints/b2PulleyJoint.h>
< #include <Box2D/Dynamics/b2Body.h>
< #include <Box2D/Dynamics/b2TimeStep.h>
---
> #include "b2PulleyJoint.h"
> #include "../b2Body.h"
> #include "../b2World.h"
27c27
< // C = C0 - (length1 + ratio * length2)
---
> // C = C0 - (length1 + ratio * length2) >= 0
34,37c34,44
< 
< void b2PulleyJointDef::Initialize(b2Body* bA, b2Body* bB,
< 				const b2Vec2& groundA, const b2Vec2& groundB,
< 				const b2Vec2& anchorA, const b2Vec2& anchorB,
---
> //
> // Limit:
> // C = maxLength - length
> // u = (p - s) / norm(p - s)
> // Cdot = -dot(u, v + cross(w, r))
> // K = invMass + invI * cross(r, u)^2
> // 0 <= impulse
> 
> void b2PulleyJointDef::Initialize(b2Body* b1, b2Body* b2,
> 				const b2Vec2& ga1, const b2Vec2& ga2,
> 				const b2Vec2& anchor1, const b2Vec2& anchor2,
40,49c47,56
< 	bodyA = bA;
< 	bodyB = bB;
< 	groundAnchorA = groundA;
< 	groundAnchorB = groundB;
< 	localAnchorA = bodyA->GetLocalPoint(anchorA);
< 	localAnchorB = bodyB->GetLocalPoint(anchorB);
< 	b2Vec2 dA = anchorA - groundA;
< 	lengthA = dA.Length();
< 	b2Vec2 dB = anchorB - groundB;
< 	lengthB = dB.Length();
---
> 	body1 = b1;
> 	body2 = b2;
> 	groundAnchor1 = ga1;
> 	groundAnchor2 = ga2;
> 	localAnchor1 = body1->GetLocalPoint(anchor1);
> 	localAnchor2 = body2->GetLocalPoint(anchor2);
> 	b2Vec2 d1 = anchor1 - ga1;
> 	length1 = d1.Length();
> 	b2Vec2 d2 = anchor2 - ga2;
> 	length2 = d2.Length();
51c58,61
< 	b2Assert(ratio > b2_epsilon);
---
> 	b2Assert(ratio > B2_FLT_EPSILON);
> 	float32 C = length1 + ratio * length2;
> 	maxLength1 = C - ratio * b2_minPulleyLength;
> 	maxLength2 = (C - b2_minPulleyLength) / ratio;
57,63c67,71
< 	m_groundAnchorA = def->groundAnchorA;
< 	m_groundAnchorB = def->groundAnchorB;
< 	m_localAnchorA = def->localAnchorA;
< 	m_localAnchorB = def->localAnchorB;
< 
< 	m_lengthA = def->lengthA;
< 	m_lengthB = def->lengthB;
---
> 	m_ground = m_body1->GetWorld()->GetGroundBody();
> 	m_groundAnchor1 = def->groundAnchor1 - m_ground->GetXForm().position;
> 	m_groundAnchor2 = def->groundAnchor2 - m_ground->GetXForm().position;
> 	m_localAnchor1 = def->localAnchor1;
> 	m_localAnchor2 = def->localAnchor2;
68c76,79
< 	m_constant = def->lengthA + m_ratio * def->lengthB;
---
> 	m_constant = def->length1 + m_ratio * def->length2;
> 
> 	m_maxLength1 = b2Min(def->maxLength1, m_constant - m_ratio * b2_minPulleyLength);
> 	m_maxLength2 = b2Min(def->maxLength2, (m_constant - b2_minPulleyLength) / m_ratio);
70a82,83
> 	m_limitImpulse1 = 0.0f;
> 	m_limitImpulse2 = 0.0f;
73c86
< void b2PulleyJoint::InitVelocityConstraints(const b2SolverData& data)
---
> void b2PulleyJoint::InitVelocityConstraints(const b2TimeStep& step)
75,92c88,89
< 	m_indexA = m_bodyA->m_islandIndex;
< 	m_indexB = m_bodyB->m_islandIndex;
< 	m_localCenterA = m_bodyA->m_sweep.localCenter;
< 	m_localCenterB = m_bodyB->m_sweep.localCenter;
< 	m_invMassA = m_bodyA->m_invMass;
< 	m_invMassB = m_bodyB->m_invMass;
< 	m_invIA = m_bodyA->m_invI;
< 	m_invIB = m_bodyB->m_invI;
< 
< 	b2Vec2 cA = data.positions[m_indexA].c;
< 	float32 aA = data.positions[m_indexA].a;
< 	b2Vec2 vA = data.velocities[m_indexA].v;
< 	float32 wA = data.velocities[m_indexA].w;
< 
< 	b2Vec2 cB = data.positions[m_indexB].c;
< 	float32 aB = data.positions[m_indexB].a;
< 	b2Vec2 vB = data.velocities[m_indexB].v;
< 	float32 wB = data.velocities[m_indexB].w;
---
> 	b2Body* b1 = m_body1;
> 	b2Body* b2 = m_body2;
94c91,92
< 	b2Rot qA(aA), qB(aB);
---
> 	b2Vec2 r1 = b2Mul(b1->GetXForm().R, m_localAnchor1 - b1->GetLocalCenter());
> 	b2Vec2 r2 = b2Mul(b2->GetXForm().R, m_localAnchor2 - b2->GetLocalCenter());
96,97c94,98
< 	m_rA = b2Mul(qA, m_localAnchorA - m_localCenterA);
< 	m_rB = b2Mul(qB, m_localAnchorB - m_localCenterB);
---
> 	b2Vec2 p1 = b1->m_sweep.c + r1;
> 	b2Vec2 p2 = b2->m_sweep.c + r2;
> 
> 	b2Vec2 s1 = m_ground->GetXForm().position + m_groundAnchor1;
> 	b2Vec2 s2 = m_ground->GetXForm().position + m_groundAnchor2;
100,101c101,102
< 	m_uA = cA + m_rA - m_groundAnchorA;
< 	m_uB = cB + m_rB - m_groundAnchorB;
---
> 	m_u1 = p1 - s1;
> 	m_u2 = p2 - s2;
103,104c104,105
< 	float32 lengthA = m_uA.Length();
< 	float32 lengthB = m_uB.Length();
---
> 	float32 length1 = m_u1.Length();
> 	float32 length2 = m_u2.Length();
106c107
< 	if (lengthA > 10.0f * b2_linearSlop)
---
> 	if (length1 > b2_linearSlop)
108c109
< 		m_uA *= 1.0f / lengthA;
---
> 		m_u1 *= 1.0f / length1;
112c113
< 		m_uA.SetZero();
---
> 		m_u1.SetZero();
115c116
< 	if (lengthB > 10.0f * b2_linearSlop)
---
> 	if (length2 > b2_linearSlop)
117c118
< 		m_uB *= 1.0f / lengthB;
---
> 		m_u2 *= 1.0f / length2;
121c122
< 		m_uB.SetZero();
---
> 		m_u2.SetZero();
124,129c125,134
< 	// Compute effective mass.
< 	float32 ruA = b2Cross(m_rA, m_uA);
< 	float32 ruB = b2Cross(m_rB, m_uB);
< 
< 	float32 mA = m_invMassA + m_invIA * ruA * ruA;
< 	float32 mB = m_invMassB + m_invIB * ruB * ruB;
---
> 	float32 C = m_constant - length1 - m_ratio * length2;
> 	if (C > 0.0f)
> 	{
> 		m_state = e_inactiveLimit;
> 		m_impulse = 0.0f;
> 	}
> 	else
> 	{
> 		m_state = e_atUpperLimit;
> 	}
131c136,144
< 	m_mass = mA + m_ratio * m_ratio * mB;
---
> 	if (length1 < m_maxLength1)
> 	{
> 		m_limitState1 = e_inactiveLimit;
> 		m_limitImpulse1 = 0.0f;
> 	}
> 	else
> 	{
> 		m_limitState1 = e_atUpperLimit;
> 	}
133c146,151
< 	if (m_mass > 0.0f)
---
> 	if (length2 < m_maxLength2)
> 	{
> 		m_limitState2 = e_inactiveLimit;
> 		m_limitImpulse2 = 0.0f;
> 	}
> 	else
135c153
< 		m_mass = 1.0f / m_mass;
---
> 		m_limitState2 = e_atUpperLimit;
138c156,170
< 	if (data.step.warmStarting)
---
> 	// Compute effective mass.
> 	float32 cr1u1 = b2Cross(r1, m_u1);
> 	float32 cr2u2 = b2Cross(r2, m_u2);
> 
> 	m_limitMass1 = b1->m_invMass + b1->m_invI * cr1u1 * cr1u1;
> 	m_limitMass2 = b2->m_invMass + b2->m_invI * cr2u2 * cr2u2;
> 	m_pulleyMass = m_limitMass1 + m_ratio * m_ratio * m_limitMass2;
> 	b2Assert(m_limitMass1 > B2_FLT_EPSILON);
> 	b2Assert(m_limitMass2 > B2_FLT_EPSILON);
> 	b2Assert(m_pulleyMass > B2_FLT_EPSILON);
> 	m_limitMass1 = 1.0f / m_limitMass1;
> 	m_limitMass2 = 1.0f / m_limitMass2;
> 	m_pulleyMass = 1.0f / m_pulleyMass;
> 
> 	if (step.warmStarting)
141c173,175
< 		m_impulse *= data.step.dtRatio;
---
> 		m_impulse *= step.dtRatio;
> 		m_limitImpulse1 *= step.dtRatio;
> 		m_limitImpulse2 *= step.dtRatio;
144,150c178,183
< 		b2Vec2 PA = -(m_impulse) * m_uA;
< 		b2Vec2 PB = (-m_ratio * m_impulse) * m_uB;
< 
< 		vA += m_invMassA * PA;
< 		wA += m_invIA * b2Cross(m_rA, PA);
< 		vB += m_invMassB * PB;
< 		wB += m_invIB * b2Cross(m_rB, PB);
---
> 		b2Vec2 P1 = -(m_impulse + m_limitImpulse1) * m_u1;
> 		b2Vec2 P2 = (-m_ratio * m_impulse - m_limitImpulse2) * m_u2;
> 		b1->m_linearVelocity += b1->m_invMass * P1;
> 		b1->m_angularVelocity += b1->m_invI * b2Cross(r1, P1);
> 		b2->m_linearVelocity += b2->m_invMass * P2;
> 		b2->m_angularVelocity += b2->m_invI * b2Cross(r2, P2);
154a188,189
> 		m_limitImpulse1 = 0.0f;
> 		m_limitImpulse2 = 0.0f;
156,160d190
< 
< 	data.velocities[m_indexA].v = vA;
< 	data.velocities[m_indexA].w = wA;
< 	data.velocities[m_indexB].v = vB;
< 	data.velocities[m_indexB].w = wB;
163c193
< void b2PulleyJoint::SolveVelocityConstraints(const b2SolverData& data)
---
> void b2PulleyJoint::SolveVelocityConstraints(const b2TimeStep& step)
165,168c195
< 	b2Vec2 vA = data.velocities[m_indexA].v;
< 	float32 wA = data.velocities[m_indexA].w;
< 	b2Vec2 vB = data.velocities[m_indexB].v;
< 	float32 wB = data.velocities[m_indexB].w;
---
> 	B2_NOT_USED(step);
170,171c197,198
< 	b2Vec2 vpA = vA + b2Cross(wA, m_rA);
< 	b2Vec2 vpB = vB + b2Cross(wB, m_rB);
---
> 	b2Body* b1 = m_body1;
> 	b2Body* b2 = m_body2;
173,175c200,201
< 	float32 Cdot = -b2Dot(m_uA, vpA) - m_ratio * b2Dot(m_uB, vpB);
< 	float32 impulse = -m_mass * Cdot;
< 	m_impulse += impulse;
---
> 	b2Vec2 r1 = b2Mul(b1->GetXForm().R, m_localAnchor1 - b1->GetLocalCenter());
> 	b2Vec2 r2 = b2Mul(b2->GetXForm().R, m_localAnchor2 - b2->GetLocalCenter());
177,195c203,206
< 	b2Vec2 PA = -impulse * m_uA;
< 	b2Vec2 PB = -m_ratio * impulse * m_uB;
< 	vA += m_invMassA * PA;
< 	wA += m_invIA * b2Cross(m_rA, PA);
< 	vB += m_invMassB * PB;
< 	wB += m_invIB * b2Cross(m_rB, PB);
< 
< 	data.velocities[m_indexA].v = vA;
< 	data.velocities[m_indexA].w = wA;
< 	data.velocities[m_indexB].v = vB;
< 	data.velocities[m_indexB].w = wB;
< }
< 
< bool b2PulleyJoint::SolvePositionConstraints(const b2SolverData& data)
< {
< 	b2Vec2 cA = data.positions[m_indexA].c;
< 	float32 aA = data.positions[m_indexA].a;
< 	b2Vec2 cB = data.positions[m_indexB].c;
< 	float32 aB = data.positions[m_indexB].a;
---
> 	if (m_state == e_atUpperLimit)
> 	{
> 		b2Vec2 v1 = b1->m_linearVelocity + b2Cross(b1->m_angularVelocity, r1);
> 		b2Vec2 v2 = b2->m_linearVelocity + b2Cross(b2->m_angularVelocity, r2);
197c208,212
< 	b2Rot qA(aA), qB(aB);
---
> 		float32 Cdot = -b2Dot(m_u1, v1) - m_ratio * b2Dot(m_u2, v2);
> 		float32 impulse = m_pulleyMass * (-Cdot);
> 		float32 oldImpulse = m_impulse;
> 		m_impulse = b2Max(0.0f, m_impulse + impulse);
> 		impulse = m_impulse - oldImpulse;
199,200c214,220
< 	b2Vec2 rA = b2Mul(qA, m_localAnchorA - m_localCenterA);
< 	b2Vec2 rB = b2Mul(qB, m_localAnchorB - m_localCenterB);
---
> 		b2Vec2 P1 = -impulse * m_u1;
> 		b2Vec2 P2 = -m_ratio * impulse * m_u2;
> 		b1->m_linearVelocity += b1->m_invMass * P1;
> 		b1->m_angularVelocity += b1->m_invI * b2Cross(r1, P1);
> 		b2->m_linearVelocity += b2->m_invMass * P2;
> 		b2->m_angularVelocity += b2->m_invI * b2Cross(r2, P2);
> 	}
202,204c222,224
< 	// Get the pulley axes.
< 	b2Vec2 uA = cA + rA - m_groundAnchorA;
< 	b2Vec2 uB = cB + rB - m_groundAnchorB;
---
> 	if (m_limitState1 == e_atUpperLimit)
> 	{
> 		b2Vec2 v1 = b1->m_linearVelocity + b2Cross(b1->m_angularVelocity, r1);
206,207c226,230
< 	float32 lengthA = uA.Length();
< 	float32 lengthB = uB.Length();
---
> 		float32 Cdot = -b2Dot(m_u1, v1);
> 		float32 impulse = -m_limitMass1 * Cdot;
> 		float32 oldImpulse = m_limitImpulse1;
> 		m_limitImpulse1 = b2Max(0.0f, m_limitImpulse1 + impulse);
> 		impulse = m_limitImpulse1 - oldImpulse;
209,211c232,234
< 	if (lengthA > 10.0f * b2_linearSlop)
< 	{
< 		uA *= 1.0f / lengthA;
---
> 		b2Vec2 P1 = -impulse * m_u1;
> 		b1->m_linearVelocity += b1->m_invMass * P1;
> 		b1->m_angularVelocity += b1->m_invI * b2Cross(r1, P1);
213c236,237
< 	else
---
> 
> 	if (m_limitState2 == e_atUpperLimit)
215c239,249
< 		uA.SetZero();
---
> 		b2Vec2 v2 = b2->m_linearVelocity + b2Cross(b2->m_angularVelocity, r2);
> 
> 		float32 Cdot = -b2Dot(m_u2, v2);
> 		float32 impulse = -m_limitMass2 * Cdot;
> 		float32 oldImpulse = m_limitImpulse2;
> 		m_limitImpulse2 = b2Max(0.0f, m_limitImpulse2 + impulse);
> 		impulse = m_limitImpulse2 - oldImpulse;
> 
> 		b2Vec2 P2 = -impulse * m_u2;
> 		b2->m_linearVelocity += b2->m_invMass * P2;
> 		b2->m_angularVelocity += b2->m_invI * b2Cross(r2, P2);
216a251
> }
218c253,265
< 	if (lengthB > 10.0f * b2_linearSlop)
---
> bool b2PulleyJoint::SolvePositionConstraints(float32 baumgarte)
> {
> 	B2_NOT_USED(baumgarte);
> 
> 	b2Body* b1 = m_body1;
> 	b2Body* b2 = m_body2;
> 
> 	b2Vec2 s1 = m_ground->GetXForm().position + m_groundAnchor1;
> 	b2Vec2 s2 = m_ground->GetXForm().position + m_groundAnchor2;
> 
> 	float32 linearError = 0.0f;
> 
> 	if (m_state == e_atUpperLimit)
220c267,313
< 		uB *= 1.0f / lengthB;
---
> 		b2Vec2 r1 = b2Mul(b1->GetXForm().R, m_localAnchor1 - b1->GetLocalCenter());
> 		b2Vec2 r2 = b2Mul(b2->GetXForm().R, m_localAnchor2 - b2->GetLocalCenter());
> 
> 		b2Vec2 p1 = b1->m_sweep.c + r1;
> 		b2Vec2 p2 = b2->m_sweep.c + r2;
> 
> 		// Get the pulley axes.
> 		m_u1 = p1 - s1;
> 		m_u2 = p2 - s2;
> 
> 		float32 length1 = m_u1.Length();
> 		float32 length2 = m_u2.Length();
> 
> 		if (length1 > b2_linearSlop)
> 		{
> 			m_u1 *= 1.0f / length1;
> 		}
> 		else
> 		{
> 			m_u1.SetZero();
> 		}
> 
> 		if (length2 > b2_linearSlop)
> 		{
> 			m_u2 *= 1.0f / length2;
> 		}
> 		else
> 		{
> 			m_u2.SetZero();
> 		}
> 
> 		float32 C = m_constant - length1 - m_ratio * length2;
> 		linearError = b2Max(linearError, -C);
> 
> 		C = b2Clamp(C + b2_linearSlop, -b2_maxLinearCorrection, 0.0f);
> 		float32 impulse = -m_pulleyMass * C;
> 
> 		b2Vec2 P1 = -impulse * m_u1;
> 		b2Vec2 P2 = -m_ratio * impulse * m_u2;
> 
> 		b1->m_sweep.c += b1->m_invMass * P1;
> 		b1->m_sweep.a += b1->m_invI * b2Cross(r1, P1);
> 		b2->m_sweep.c += b2->m_invMass * P2;
> 		b2->m_sweep.a += b2->m_invI * b2Cross(r2, P2);
> 
> 		b1->SynchronizeTransform();
> 		b2->SynchronizeTransform();
222c315,316
< 	else
---
> 
> 	if (m_limitState1 == e_atUpperLimit)
224,225c318,319
< 		uB.SetZero();
< 	}
---
> 		b2Vec2 r1 = b2Mul(b1->GetXForm().R, m_localAnchor1 - b1->GetLocalCenter());
> 		b2Vec2 p1 = b1->m_sweep.c + r1;
227,229c321,322
< 	// Compute effective mass.
< 	float32 ruA = b2Cross(rA, uA);
< 	float32 ruB = b2Cross(rB, uB);
---
> 		m_u1 = p1 - s1;
> 		float32 length1 = m_u1.Length();
231,232c324,331
< 	float32 mA = m_invMassA + m_invIA * ruA * ruA;
< 	float32 mB = m_invMassB + m_invIB * ruB * ruB;
---
> 		if (length1 > b2_linearSlop)
> 		{
> 			m_u1 *= 1.0f / length1;
> 		}
> 		else
> 		{
> 			m_u1.SetZero();
> 		}
234c333,336
< 	float32 mass = mA + m_ratio * m_ratio * mB;
---
> 		float32 C = m_maxLength1 - length1;
> 		linearError = b2Max(linearError, -C);
> 		C = b2Clamp(C + b2_linearSlop, -b2_maxLinearCorrection, 0.0f);
> 		float32 impulse = -m_limitMass1 * C;
236,238c338,342
< 	if (mass > 0.0f)
< 	{
< 		mass = 1.0f / mass;
---
> 		b2Vec2 P1 = -impulse * m_u1;
> 		b1->m_sweep.c += b1->m_invMass * P1;
> 		b1->m_sweep.a += b1->m_invI * b2Cross(r1, P1);
> 
> 		b1->SynchronizeTransform();
241,242c345,348
< 	float32 C = m_constant - lengthA - m_ratio * lengthB;
< 	float32 linearError = b2Abs(C);
---
> 	if (m_limitState2 == e_atUpperLimit)
> 	{
> 		b2Vec2 r2 = b2Mul(b2->GetXForm().R, m_localAnchor2 - b2->GetLocalCenter());
> 		b2Vec2 p2 = b2->m_sweep.c + r2;
244c350,351
< 	float32 impulse = -mass * C;
---
> 		m_u2 = p2 - s2;
> 		float32 length2 = m_u2.Length();
246,247c353,360
< 	b2Vec2 PA = -impulse * uA;
< 	b2Vec2 PB = -m_ratio * impulse * uB;
---
> 		if (length2 > b2_linearSlop)
> 		{
> 			m_u2 *= 1.0f / length2;
> 		}
> 		else
> 		{
> 			m_u2.SetZero();
> 		}
249,252c362,365
< 	cA += m_invMassA * PA;
< 	aA += m_invIA * b2Cross(rA, PA);
< 	cB += m_invMassB * PB;
< 	aB += m_invIB * b2Cross(rB, PB);
---
> 		float32 C = m_maxLength2 - length2;
> 		linearError = b2Max(linearError, -C);
> 		C = b2Clamp(C + b2_linearSlop, -b2_maxLinearCorrection, 0.0f);
> 		float32 impulse = -m_limitMass2 * C;
254,257c367,372
< 	data.positions[m_indexA].c = cA;
< 	data.positions[m_indexA].a = aA;
< 	data.positions[m_indexB].c = cB;
< 	data.positions[m_indexB].a = aB;
---
> 		b2Vec2 P2 = -impulse * m_u2;
> 		b2->m_sweep.c += b2->m_invMass * P2;
> 		b2->m_sweep.a += b2->m_invI * b2Cross(r2, P2);
> 
> 		b2->SynchronizeTransform();
> 	}
262c377
< b2Vec2 b2PulleyJoint::GetAnchorA() const
---
> b2Vec2 b2PulleyJoint::GetAnchor1() const
264c379
< 	return m_bodyA->GetWorldPoint(m_localAnchorA);
---
> 	return m_body1->GetWorldPoint(m_localAnchor1);
267c382
< b2Vec2 b2PulleyJoint::GetAnchorB() const
---
> b2Vec2 b2PulleyJoint::GetAnchor2() const
269c384
< 	return m_bodyB->GetWorldPoint(m_localAnchorB);
---
> 	return m_body2->GetWorldPoint(m_localAnchor2);
274c389
< 	b2Vec2 P = m_impulse * m_uB;
---
> 	b2Vec2 P = m_impulse * m_u2;
284,289c399
< b2Vec2 b2PulleyJoint::GetGroundAnchorA() const
< {
< 	return m_groundAnchorA;
< }
< 
< b2Vec2 b2PulleyJoint::GetGroundAnchorB() const
---
> b2Vec2 b2PulleyJoint::GetGroundAnchor1() const
291c401
< 	return m_groundAnchorB;
---
> 	return m_ground->GetXForm().position + m_groundAnchor1;
294c404
< float32 b2PulleyJoint::GetLengthA() const
---
> b2Vec2 b2PulleyJoint::GetGroundAnchor2() const
296c406
< 	return m_lengthA;
---
> 	return m_ground->GetXForm().position + m_groundAnchor2;
299c409
< float32 b2PulleyJoint::GetLengthB() const
---
> float32 b2PulleyJoint::GetLength1() const
301,312c411,412
< 	return m_lengthB;
< }
< 
< float32 b2PulleyJoint::GetRatio() const
< {
< 	return m_ratio;
< }
< 
< float32 b2PulleyJoint::GetCurrentLengthA() const
< {
< 	b2Vec2 p = m_bodyA->GetWorldPoint(m_localAnchorA);
< 	b2Vec2 s = m_groundAnchorA;
---
> 	b2Vec2 p = m_body1->GetWorldPoint(m_localAnchor1);
> 	b2Vec2 s = m_ground->GetXForm().position + m_groundAnchor1;
317c417
< float32 b2PulleyJoint::GetCurrentLengthB() const
---
> float32 b2PulleyJoint::GetLength2() const
319,320c419,420
< 	b2Vec2 p = m_bodyB->GetWorldPoint(m_localAnchorB);
< 	b2Vec2 s = m_groundAnchorB;
---
> 	b2Vec2 p = m_body2->GetWorldPoint(m_localAnchor2);
> 	b2Vec2 s = m_ground->GetXForm().position + m_groundAnchor2;
325c425
< void b2PulleyJoint::Dump()
---
> float32 b2PulleyJoint::GetRatio() const
327,348c427,428
< 	int32 indexA = m_bodyA->m_islandIndex;
< 	int32 indexB = m_bodyB->m_islandIndex;
< 
< 	b2Log("  b2PulleyJointDef jd;\n");
< 	b2Log("  jd.bodyA = bodies[%d];\n", indexA);
< 	b2Log("  jd.bodyB = bodies[%d];\n", indexB);
< 	b2Log("  jd.collideConnected = bool(%d);\n", m_collideConnected);
< 	b2Log("  jd.groundAnchorA.Set(%.15lef, %.15lef);\n", m_groundAnchorA.x, m_groundAnchorA.y);
< 	b2Log("  jd.groundAnchorB.Set(%.15lef, %.15lef);\n", m_groundAnchorB.x, m_groundAnchorB.y);
< 	b2Log("  jd.localAnchorA.Set(%.15lef, %.15lef);\n", m_localAnchorA.x, m_localAnchorA.y);
< 	b2Log("  jd.localAnchorB.Set(%.15lef, %.15lef);\n", m_localAnchorB.x, m_localAnchorB.y);
< 	b2Log("  jd.lengthA = %.15lef;\n", m_lengthA);
< 	b2Log("  jd.lengthB = %.15lef;\n", m_lengthB);
< 	b2Log("  jd.ratio = %.15lef;\n", m_ratio);
< 	b2Log("  joints[%d] = m_world->CreateJoint(&jd);\n", m_index);
< }
< 
< void b2PulleyJoint::ShiftOrigin(const b2Vec2& newOrigin)
< {
< 	m_groundAnchorA -= newOrigin;
< 	m_groundAnchorB -= newOrigin;
< }
---
> 	return m_ratio;
> }
diff -r -x './svn/*' native/Box2D/Dynamics/Joints/.svn/text-base/b2PulleyJoint.h.svn-base ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Joints/.svn/text-base/b2PulleyJoint.h.svn-base
2c2
< * Copyright (c) 2006-2011 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
22c22
< #include <Box2D/Dynamics/Joints/b2Joint.h>
---
> #include "b2Joint.h"
27c27,28
< /// two dynamic body anchor points, and a pulley ratio.
---
> /// two dynamic body anchor points, max lengths for each side,
> /// and a pulley ratio.
33,38c34,41
< 		groundAnchorA.Set(-1.0f, 1.0f);
< 		groundAnchorB.Set(1.0f, 1.0f);
< 		localAnchorA.Set(-1.0f, 0.0f);
< 		localAnchorB.Set(1.0f, 0.0f);
< 		lengthA = 0.0f;
< 		lengthB = 0.0f;
---
> 		groundAnchor1.Set(-1.0f, 1.0f);
> 		groundAnchor2.Set(1.0f, 1.0f);
> 		localAnchor1.Set(-1.0f, 0.0f);
> 		localAnchor2.Set(1.0f, 0.0f);
> 		length1 = 0.0f;
> 		maxLength1 = 0.0f;
> 		length2 = 0.0f;
> 		maxLength2 = 0.0f;
44,46c47,49
< 	void Initialize(b2Body* bodyA, b2Body* bodyB,
< 					const b2Vec2& groundAnchorA, const b2Vec2& groundAnchorB,
< 					const b2Vec2& anchorA, const b2Vec2& anchorB,
---
> 	void Initialize(b2Body* body1, b2Body* body2,
> 					const b2Vec2& groundAnchor1, const b2Vec2& groundAnchor2,
> 					const b2Vec2& anchor1, const b2Vec2& anchor2,
50c53
< 	b2Vec2 groundAnchorA;
---
> 	b2Vec2 groundAnchor1;
53c56
< 	b2Vec2 groundAnchorB;
---
> 	b2Vec2 groundAnchor2;
55,56c58,59
< 	/// The local anchor point relative to bodyA's origin.
< 	b2Vec2 localAnchorA;
---
> 	/// The local anchor point relative to body1's origin.
> 	b2Vec2 localAnchor1;
58,59c61,62
< 	/// The local anchor point relative to bodyB's origin.
< 	b2Vec2 localAnchorB;
---
> 	/// The local anchor point relative to body2's origin.
> 	b2Vec2 localAnchor2;
61,62c64,65
< 	/// The a reference length for the segment attached to bodyA.
< 	float32 lengthA;
---
> 	/// The a reference length for the segment attached to body1.
> 	float32 length1;
64,65c67,74
< 	/// The a reference length for the segment attached to bodyB.
< 	float32 lengthB;
---
> 	/// The maximum length of the segment attached to body1.
> 	float32 maxLength1;
> 
> 	/// The a reference length for the segment attached to body2.
> 	float32 length2;
> 
> 	/// The maximum length of the segment attached to body2.
> 	float32 maxLength2;
75,78c84,85
< /// Warning: the pulley joint can get a bit squirrelly by itself. They often
< /// work better when combined with prismatic joints. You should also cover the
< /// the anchor points with static shapes to prevent one side from going to
< /// zero length.
---
> /// The pulley also enforces a maximum length limit on both sides. This is
> /// useful to prevent one side of the pulley hitting the top.
82,83c89,90
< 	b2Vec2 GetAnchorA() const;
< 	b2Vec2 GetAnchorB() const;
---
> 	b2Vec2 GetAnchor1() const;
> 	b2Vec2 GetAnchor2() const;
89c96
< 	b2Vec2 GetGroundAnchorA() const;
---
> 	b2Vec2 GetGroundAnchor1() const;
92c99
< 	b2Vec2 GetGroundAnchorB() const;
---
> 	b2Vec2 GetGroundAnchor2() const;
94,95c101,102
< 	/// Get the current length of the segment attached to bodyA.
< 	float32 GetLengthA() const;
---
> 	/// Get the current length of the segment attached to body1.
> 	float32 GetLength1() const;
97,98c104,105
< 	/// Get the current length of the segment attached to bodyB.
< 	float32 GetLengthB() const;
---
> 	/// Get the current length of the segment attached to body2.
> 	float32 GetLength2() const;
103,113c110
< 	/// Get the current length of the segment attached to bodyA.
< 	float32 GetCurrentLengthA() const;
< 
< 	/// Get the current length of the segment attached to bodyB.
< 	float32 GetCurrentLengthB() const;
< 
< 	/// Dump joint to dmLog
< 	void Dump();
< 
< 	/// Implement b2Joint::ShiftOrigin
< 	void ShiftOrigin(const b2Vec2& newOrigin);
---
> 	//--------------- Internals Below -------------------
115,117d111
< protected:
< 
< 	friend class b2Joint;
120,127c114,125
< 	void InitVelocityConstraints(const b2SolverData& data);
< 	void SolveVelocityConstraints(const b2SolverData& data);
< 	bool SolvePositionConstraints(const b2SolverData& data);
< 
< 	b2Vec2 m_groundAnchorA;
< 	b2Vec2 m_groundAnchorB;
< 	float32 m_lengthA;
< 	float32 m_lengthB;
---
> 	void InitVelocityConstraints(const b2TimeStep& step);
> 	void SolveVelocityConstraints(const b2TimeStep& step);
> 	bool SolvePositionConstraints(float32 baumgarte);
> 
> 	b2Body* m_ground;
> 	b2Vec2 m_groundAnchor1;
> 	b2Vec2 m_groundAnchor2;
> 	b2Vec2 m_localAnchor1;
> 	b2Vec2 m_localAnchor2;
> 
> 	b2Vec2 m_u1;
> 	b2Vec2 m_u2;
129,131d126
< 	// Solver shared
< 	b2Vec2 m_localAnchorA;
< 	b2Vec2 m_localAnchorB;
133a129,138
> 	
> 	float32 m_maxLength1;
> 	float32 m_maxLength2;
> 
> 	// Effective masses
> 	float32 m_pulleyMass;
> 	float32 m_limitMass1;
> 	float32 m_limitMass2;
> 
> 	// Impulses for accumulation/warm starting.
134a140,141
> 	float32 m_limitImpulse1;
> 	float32 m_limitImpulse2;
136,149c143,145
< 	// Solver temp
< 	int32 m_indexA;
< 	int32 m_indexB;
< 	b2Vec2 m_uA;
< 	b2Vec2 m_uB;
< 	b2Vec2 m_rA;
< 	b2Vec2 m_rB;
< 	b2Vec2 m_localCenterA;
< 	b2Vec2 m_localCenterB;
< 	float32 m_invMassA;
< 	float32 m_invMassB;
< 	float32 m_invIA;
< 	float32 m_invIB;
< 	float32 m_mass;
---
> 	b2LimitState m_state;
> 	b2LimitState m_limitState1;
> 	b2LimitState m_limitState2;
diff -r -x './svn/*' native/Box2D/Dynamics/Joints/.svn/text-base/b2RevoluteJoint.cpp.svn-base ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Joints/.svn/text-base/b2RevoluteJoint.cpp.svn-base
2c2
< * Copyright (c) 2006-2011 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
19,21c19,23
< #include <Box2D/Dynamics/Joints/b2RevoluteJoint.h>
< #include <Box2D/Dynamics/b2Body.h>
< #include <Box2D/Dynamics/b2TimeStep.h>
---
> #include "b2RevoluteJoint.h"
> #include "../b2Body.h"
> #include "../b2World.h"
> 
> #include "../b2Island.h"
36c38
< void b2RevoluteJointDef::Initialize(b2Body* bA, b2Body* bB, const b2Vec2& anchor)
---
> void b2RevoluteJointDef::Initialize(b2Body* b1, b2Body* b2, const b2Vec2& anchor)
38,42c40,44
< 	bodyA = bA;
< 	bodyB = bB;
< 	localAnchorA = bodyA->GetLocalPoint(anchor);
< 	localAnchorB = bodyB->GetLocalPoint(anchor);
< 	referenceAngle = bodyB->GetAngle() - bodyA->GetAngle();
---
> 	body1 = b1;
> 	body2 = b2;
> 	localAnchor1 = body1->GetLocalPoint(anchor);
> 	localAnchor2 = body2->GetLocalPoint(anchor);
> 	referenceAngle = body2->GetAngle() - body1->GetAngle();
48,49c50,51
< 	m_localAnchorA = def->localAnchorA;
< 	m_localAnchorB = def->localAnchorB;
---
> 	m_localAnchor1 = def->localAnchor1;
> 	m_localAnchor2 = def->localAnchor2;
64c66
< void b2RevoluteJoint::InitVelocityConstraints(const b2SolverData& data)
---
> void b2RevoluteJoint::InitVelocityConstraints(const b2TimeStep& step)
66,81c68,69
< 	m_indexA = m_bodyA->m_islandIndex;
< 	m_indexB = m_bodyB->m_islandIndex;
< 	m_localCenterA = m_bodyA->m_sweep.localCenter;
< 	m_localCenterB = m_bodyB->m_sweep.localCenter;
< 	m_invMassA = m_bodyA->m_invMass;
< 	m_invMassB = m_bodyB->m_invMass;
< 	m_invIA = m_bodyA->m_invI;
< 	m_invIB = m_bodyB->m_invI;
< 
< 	float32 aA = data.positions[m_indexA].a;
< 	b2Vec2 vA = data.velocities[m_indexA].v;
< 	float32 wA = data.velocities[m_indexA].w;
< 
< 	float32 aB = data.positions[m_indexB].a;
< 	b2Vec2 vB = data.velocities[m_indexB].v;
< 	float32 wB = data.velocities[m_indexB].w;
---
> 	b2Body* b1 = m_body1;
> 	b2Body* b2 = m_body2;
83c71,76
< 	b2Rot qA(aA), qB(aB);
---
> 	if (m_enableMotor || m_enableLimit)
> 	{
> 		// You cannot create a rotation limit between bodies that
> 		// both have fixed rotation.
> 		b2Assert(b1->m_invI > 0.0f || b2->m_invI > 0.0f);
> 	}
85,86c78,80
< 	m_rA = b2Mul(qA, m_localAnchorA - m_localCenterA);
< 	m_rB = b2Mul(qB, m_localAnchorB - m_localCenterB);
---
> 	// Compute the effective mass matrix.
> 	b2Vec2 r1 = b2Mul(b1->GetXForm().R, m_localAnchor1 - b1->GetLocalCenter());
> 	b2Vec2 r2 = b2Mul(b2->GetXForm().R, m_localAnchor2 - b2->GetLocalCenter());
93,100c87,102
< 	// K = [ mA+r1y^2*iA+mB+r2y^2*iB,  -r1y*iA*r1x-r2y*iB*r2x,          -r1y*iA-r2y*iB]
< 	//     [  -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB,           r1x*iA+r2x*iB]
< 	//     [          -r1y*iA-r2y*iB,           r1x*iA+r2x*iB,                   iA+iB]
< 
< 	float32 mA = m_invMassA, mB = m_invMassB;
< 	float32 iA = m_invIA, iB = m_invIB;
< 
< 	bool fixedRotation = (iA + iB == 0.0f);
---
> 	// K = [ m1+r1y^2*i1+m2+r2y^2*i2,  -r1y*i1*r1x-r2y*i2*r2x,          -r1y*i1-r2y*i2]
> 	//     [  -r1y*i1*r1x-r2y*i2*r2x, m1+r1x^2*i1+m2+r2x^2*i2,           r1x*i1+r2x*i2]
> 	//     [          -r1y*i1-r2y*i2,           r1x*i1+r2x*i2,                   i1+i2]
> 
> 	float32 m1 = b1->m_invMass, m2 = b2->m_invMass;
> 	float32 i1 = b1->m_invI, i2 = b2->m_invI;
> 
> 	m_mass.col1.x = m1 + m2 + r1.y * r1.y * i1 + r2.y * r2.y * i2;
> 	m_mass.col2.x = -r1.y * r1.x * i1 - r2.y * r2.x * i2;
> 	m_mass.col3.x = -r1.y * i1 - r2.y * i2;
> 	m_mass.col1.y = m_mass.col2.x;
> 	m_mass.col2.y = m1 + m2 + r1.x * r1.x * i1 + r2.x * r2.x * i2;
> 	m_mass.col3.y = r1.x * i1 + r2.x * i2;
> 	m_mass.col1.z = m_mass.col3.x;
> 	m_mass.col2.z = m_mass.col3.y;
> 	m_mass.col3.z = i1 + i2;
102,110c104
< 	m_mass.ex.x = mA + mB + m_rA.y * m_rA.y * iA + m_rB.y * m_rB.y * iB;
< 	m_mass.ey.x = -m_rA.y * m_rA.x * iA - m_rB.y * m_rB.x * iB;
< 	m_mass.ez.x = -m_rA.y * iA - m_rB.y * iB;
< 	m_mass.ex.y = m_mass.ey.x;
< 	m_mass.ey.y = mA + mB + m_rA.x * m_rA.x * iA + m_rB.x * m_rB.x * iB;
< 	m_mass.ez.y = m_rA.x * iA + m_rB.x * iB;
< 	m_mass.ex.z = m_mass.ez.x;
< 	m_mass.ey.z = m_mass.ez.y;
< 	m_mass.ez.z = iA + iB;
---
> 	m_motorMass = 1.0f / (i1 + i2);
112,118c106
< 	m_motorMass = iA + iB;
< 	if (m_motorMass > 0.0f)
< 	{
< 		m_motorMass = 1.0f / m_motorMass;
< 	}
< 
< 	if (m_enableMotor == false || fixedRotation)
---
> 	if (m_enableMotor == false)
123c111
< 	if (m_enableLimit && fixedRotation == false)
---
> 	if (m_enableLimit)
125c113
< 		float32 jointAngle = aB - aA - m_referenceAngle;
---
> 		float32 jointAngle = b2->m_sweep.a - b1->m_sweep.a - m_referenceAngle;
157c145
< 	if (data.step.warmStarting)
---
> 	if (step.warmStarting)
160,161c148,149
< 		m_impulse *= data.step.dtRatio;
< 		m_motorImpulse *= data.step.dtRatio;
---
> 		m_impulse *= step.dtRatio;
> 		m_motorImpulse *= step.dtRatio;
165,166c153,154
< 		vA -= mA * P;
< 		wA -= iA * (b2Cross(m_rA, P) + m_motorImpulse + m_impulse.z);
---
> 		b1->m_linearVelocity -= m1 * P;
> 		b1->m_angularVelocity -= i1 * (b2Cross(r1, P) + m_motorImpulse + m_impulse.z);
168,169c156,157
< 		vB += mB * P;
< 		wB += iB * (b2Cross(m_rB, P) + m_motorImpulse + m_impulse.z);
---
> 		b2->m_linearVelocity += m2 * P;
> 		b2->m_angularVelocity += i2 * (b2Cross(r2, P) + m_motorImpulse + m_impulse.z);
176,180d163
< 
< 	data.velocities[m_indexA].v = vA;
< 	data.velocities[m_indexA].w = wA;
< 	data.velocities[m_indexB].v = vB;
< 	data.velocities[m_indexB].w = wB;
183c166
< void b2RevoluteJoint::SolveVelocityConstraints(const b2SolverData& data)
---
> void b2RevoluteJoint::SolveVelocityConstraints(const b2TimeStep& step)
185,188c168,169
< 	b2Vec2 vA = data.velocities[m_indexA].v;
< 	float32 wA = data.velocities[m_indexA].w;
< 	b2Vec2 vB = data.velocities[m_indexB].v;
< 	float32 wB = data.velocities[m_indexB].w;
---
> 	b2Body* b1 = m_body1;
> 	b2Body* b2 = m_body2;
190,191c171,174
< 	float32 mA = m_invMassA, mB = m_invMassB;
< 	float32 iA = m_invIA, iB = m_invIB;
---
> 	b2Vec2 v1 = b1->m_linearVelocity;
> 	float32 w1 = b1->m_angularVelocity;
> 	b2Vec2 v2 = b2->m_linearVelocity;
> 	float32 w2 = b2->m_angularVelocity;
193c176,177
< 	bool fixedRotation = (iA + iB == 0.0f);
---
> 	float32 m1 = b1->m_invMass, m2 = b2->m_invMass;
> 	float32 i1 = b1->m_invI, i2 = b2->m_invI;
196c180
< 	if (m_enableMotor && m_limitState != e_equalLimits && fixedRotation == false)
---
> 	if (m_enableMotor && m_limitState != e_equalLimits)
198,199c182,183
< 		float32 Cdot = wB - wA - m_motorSpeed;
< 		float32 impulse = -m_motorMass * Cdot;
---
> 		float32 Cdot = w2 - w1 - m_motorSpeed;
> 		float32 impulse = m_motorMass * (-Cdot);
201c185
< 		float32 maxImpulse = data.step.dt * m_maxMotorTorque;
---
> 		float32 maxImpulse = step.dt * m_maxMotorTorque;
205,206c189,190
< 		wA -= iA * impulse;
< 		wB += iB * impulse;
---
> 		w1 -= i1 * impulse;
> 		w2 += i2 * impulse;
210c194
< 	if (m_enableLimit && m_limitState != e_inactiveLimit && fixedRotation == false)
---
> 	if (m_enableLimit && m_limitState != e_inactiveLimit)
212,213c196,201
< 		b2Vec2 Cdot1 = vB + b2Cross(wB, m_rB) - vA - b2Cross(wA, m_rA);
< 		float32 Cdot2 = wB - wA;
---
> 		b2Vec2 r1 = b2Mul(b1->GetXForm().R, m_localAnchor1 - b1->GetLocalCenter());
> 		b2Vec2 r2 = b2Mul(b2->GetXForm().R, m_localAnchor2 - b2->GetLocalCenter());
> 
> 		// Solve point-to-point constraint
> 		b2Vec2 Cdot1 = v2 + b2Cross(w2, r2) - v1 - b2Cross(w1, r1);
> 		float32 Cdot2 = w2 - w1;
216c204
< 		b2Vec3 impulse = -m_mass.Solve33(Cdot);
---
> 		b2Vec3 impulse = m_mass.Solve33(-Cdot);
227,228c215
< 				b2Vec2 rhs = -Cdot1 + m_impulse.z * b2Vec2(m_mass.ez.x, m_mass.ez.y);
< 				b2Vec2 reduced = m_mass.Solve22(rhs);
---
> 				b2Vec2 reduced = m_mass.Solve22(-Cdot1);
236,239d222
< 			else
< 			{
< 				m_impulse += impulse;
< 			}
246,247c229
< 				b2Vec2 rhs = -Cdot1 + m_impulse.z * b2Vec2(m_mass.ez.x, m_mass.ez.y);
< 				b2Vec2 reduced = m_mass.Solve22(rhs);
---
> 				b2Vec2 reduced = m_mass.Solve22(-Cdot1);
255,258d236
< 			else
< 			{
< 				m_impulse += impulse;
< 			}
263,264c241,242
< 		vA -= mA * P;
< 		wA -= iA * (b2Cross(m_rA, P) + impulse.z);
---
> 		v1 -= m1 * P;
> 		w1 -= i1 * (b2Cross(r1, P) + impulse.z);
266,267c244,245
< 		vB += mB * P;
< 		wB += iB * (b2Cross(m_rB, P) + impulse.z);
---
> 		v2 += m2 * P;
> 		w2 += i2 * (b2Cross(r2, P) + impulse.z);
270a249,251
> 		b2Vec2 r1 = b2Mul(b1->GetXForm().R, m_localAnchor1 - b1->GetLocalCenter());
> 		b2Vec2 r2 = b2Mul(b2->GetXForm().R, m_localAnchor2 - b2->GetLocalCenter());
> 
272c253
< 		b2Vec2 Cdot = vB + b2Cross(wB, m_rB) - vA - b2Cross(wA, m_rA);
---
> 		b2Vec2 Cdot = v2 + b2Cross(w2, r2) - v1 - b2Cross(w1, r1);
278,279c259,260
< 		vA -= mA * impulse;
< 		wA -= iA * b2Cross(m_rA, impulse);
---
> 		v1 -= m1 * impulse;
> 		w1 -= i1 * b2Cross(r1, impulse);
281,282c262,263
< 		vB += mB * impulse;
< 		wB += iB * b2Cross(m_rB, impulse);
---
> 		v2 += m2 * impulse;
> 		w2 += i2 * b2Cross(r2, impulse);
285,288c266,269
< 	data.velocities[m_indexA].v = vA;
< 	data.velocities[m_indexA].w = wA;
< 	data.velocities[m_indexB].v = vB;
< 	data.velocities[m_indexB].w = wB;
---
> 	b1->m_linearVelocity = v1;
> 	b1->m_angularVelocity = w1;
> 	b2->m_linearVelocity = v2;
> 	b2->m_angularVelocity = w2;
291c272
< bool b2RevoluteJoint::SolvePositionConstraints(const b2SolverData& data)
---
> bool b2RevoluteJoint::SolvePositionConstraints(float32 baumgarte)
293,296c274,276
< 	b2Vec2 cA = data.positions[m_indexA].c;
< 	float32 aA = data.positions[m_indexA].a;
< 	b2Vec2 cB = data.positions[m_indexB].c;
< 	float32 aB = data.positions[m_indexB].a;
---
> 	// TODO_ERIN block solve with limit.
> 
> 	B2_NOT_USED(baumgarte);
298c278,279
< 	b2Rot qA(aA), qB(aB);
---
> 	b2Body* b1 = m_body1;
> 	b2Body* b2 = m_body2;
303,304d283
< 	bool fixedRotation = (m_invIA + m_invIB == 0.0f);
< 
306c285
< 	if (m_enableLimit && m_limitState != e_inactiveLimit && fixedRotation == false)
---
> 	if (m_enableLimit && m_limitState != e_inactiveLimit)
308c287
< 		float32 angle = aB - aA - m_referenceAngle;
---
> 		float32 angle = b2->m_sweep.a - b1->m_sweep.a - m_referenceAngle;
337,338c316,320
< 		aA -= m_invIA * limitImpulse;
< 		aB += m_invIB * limitImpulse;
---
> 		b1->m_sweep.a -= b1->m_invI * limitImpulse;
> 		b2->m_sweep.a += b2->m_invI * limitImpulse;
> 
> 		b1->SynchronizeTransform();
> 		b2->SynchronizeTransform();
343,346c325,326
< 		qA.Set(aA);
< 		qB.Set(aB);
< 		b2Vec2 rA = b2Mul(qA, m_localAnchorA - m_localCenterA);
< 		b2Vec2 rB = b2Mul(qB, m_localAnchorB - m_localCenterB);
---
> 		b2Vec2 r1 = b2Mul(b1->GetXForm().R, m_localAnchor1 - b1->GetLocalCenter());
> 		b2Vec2 r2 = b2Mul(b2->GetXForm().R, m_localAnchor2 - b2->GetLocalCenter());
348c328
< 		b2Vec2 C = cB + rB - cA - rA;
---
> 		b2Vec2 C = b2->m_sweep.c + r2 - b1->m_sweep.c - r1;
351,352c331,332
< 		float32 mA = m_invMassA, mB = m_invMassB;
< 		float32 iA = m_invIA, iB = m_invIB;
---
> 		float32 invMass1 = b1->m_invMass, invMass2 = b2->m_invMass;
> 		float32 invI1 = b1->m_invI, invI2 = b2->m_invI;
354,358c334,346
< 		b2Mat22 K;
< 		K.ex.x = mA + mB + iA * rA.y * rA.y + iB * rB.y * rB.y;
< 		K.ex.y = -iA * rA.x * rA.y - iB * rB.x * rB.y;
< 		K.ey.x = K.ex.y;
< 		K.ey.y = mA + mB + iA * rA.x * rA.x + iB * rB.x * rB.x;
---
> 		// Handle large detachment.
> 		const float32 k_allowedStretch = 10.0f * b2_linearSlop;
> 		if (C.LengthSquared() > k_allowedStretch * k_allowedStretch)
> 		{
> 			// Use a particle solution (no rotation).
> 			b2Vec2 u = C; u.Normalize();
> 			float32 k = invMass1 + invMass2;
> 			b2Assert(k > B2_FLT_EPSILON);
> 			float32 m = 1.0f / k;
> 			b2Vec2 impulse = m * (-C);
> 			const float32 k_beta = 0.5f;
> 			b1->m_sweep.c -= k_beta * invMass1 * impulse;
> 			b2->m_sweep.c += k_beta * invMass2 * impulse;
360c348,349
< 		b2Vec2 impulse = -K.Solve(C);
---
> 			C = b2->m_sweep.c + r2 - b1->m_sweep.c - r1;
> 		}
362,363c351,353
< 		cA -= mA * impulse;
< 		aA -= iA * b2Cross(rA, impulse);
---
> 		b2Mat22 K1;
> 		K1.col1.x = invMass1 + invMass2;	K1.col2.x = 0.0f;
> 		K1.col1.y = 0.0f;					K1.col2.y = invMass1 + invMass2;
365,367c355,370
< 		cB += mB * impulse;
< 		aB += iB * b2Cross(rB, impulse);
< 	}
---
> 		b2Mat22 K2;
> 		K2.col1.x =  invI1 * r1.y * r1.y;	K2.col2.x = -invI1 * r1.x * r1.y;
> 		K2.col1.y = -invI1 * r1.x * r1.y;	K2.col2.y =  invI1 * r1.x * r1.x;
> 
> 		b2Mat22 K3;
> 		K3.col1.x =  invI2 * r2.y * r2.y;	K3.col2.x = -invI2 * r2.x * r2.y;
> 		K3.col1.y = -invI2 * r2.x * r2.y;	K3.col2.y =  invI2 * r2.x * r2.x;
> 
> 		b2Mat22 K = K1 + K2 + K3;
> 		b2Vec2 impulse = K.Solve(-C);
> 
> 		b1->m_sweep.c -= b1->m_invMass * impulse;
> 		b1->m_sweep.a -= b1->m_invI * b2Cross(r1, impulse);
> 
> 		b2->m_sweep.c += b2->m_invMass * impulse;
> 		b2->m_sweep.a += b2->m_invI * b2Cross(r2, impulse);
369,372c372,374
< 	data.positions[m_indexA].c = cA;
< 	data.positions[m_indexA].a = aA;
< 	data.positions[m_indexB].c = cB;
< 	data.positions[m_indexB].a = aB;
---
> 		b1->SynchronizeTransform();
> 		b2->SynchronizeTransform();
> 	}
377c379
< b2Vec2 b2RevoluteJoint::GetAnchorA() const
---
> b2Vec2 b2RevoluteJoint::GetAnchor1() const
379c381
< 	return m_bodyA->GetWorldPoint(m_localAnchorA);
---
> 	return m_body1->GetWorldPoint(m_localAnchor1);
382c384
< b2Vec2 b2RevoluteJoint::GetAnchorB() const
---
> b2Vec2 b2RevoluteJoint::GetAnchor2() const
384c386
< 	return m_bodyB->GetWorldPoint(m_localAnchorB);
---
> 	return m_body2->GetWorldPoint(m_localAnchor2);
400,402c402,404
< 	b2Body* bA = m_bodyA;
< 	b2Body* bB = m_bodyB;
< 	return bB->m_sweep.a - bA->m_sweep.a - m_referenceAngle;
---
> 	b2Body* b1 = m_body1;
> 	b2Body* b2 = m_body2;
> 	return b2->m_sweep.a - b1->m_sweep.a - m_referenceAngle;
407,409c409,411
< 	b2Body* bA = m_bodyA;
< 	b2Body* bB = m_bodyB;
< 	return bB->m_angularVelocity - bA->m_angularVelocity;
---
> 	b2Body* b1 = m_body1;
> 	b2Body* b2 = m_body2;
> 	return b2->m_angularVelocity - b1->m_angularVelocity;
419,420c421,422
< 	m_bodyA->SetAwake(true);
< 	m_bodyB->SetAwake(true);
---
> 	m_body1->WakeUp();
> 	m_body2->WakeUp();
424c426
< float32 b2RevoluteJoint::GetMotorTorque(float32 inv_dt) const
---
> float32 b2RevoluteJoint::GetMotorTorque() const
426c428
< 	return inv_dt * m_motorImpulse;
---
> 	return m_motorImpulse;
431,432c433,434
< 	m_bodyA->SetAwake(true);
< 	m_bodyB->SetAwake(true);
---
> 	m_body1->WakeUp();
> 	m_body2->WakeUp();
438,439c440,441
< 	m_bodyA->SetAwake(true);
< 	m_bodyB->SetAwake(true);
---
> 	m_body1->WakeUp();
> 	m_body2->WakeUp();
450,456c452,454
< 	if (flag != m_enableLimit)
< 	{
< 		m_bodyA->SetAwake(true);
< 		m_bodyB->SetAwake(true);
< 		m_enableLimit = flag;
< 		m_impulse.z = 0.0f;
< 	}
---
> 	m_body1->WakeUp();
> 	m_body2->WakeUp();
> 	m_enableLimit = flag;
472,501c470,473
< 	
< 	if (lower != m_lowerAngle || upper != m_upperAngle)
< 	{
< 		m_bodyA->SetAwake(true);
< 		m_bodyB->SetAwake(true);
< 		m_impulse.z = 0.0f;
< 		m_lowerAngle = lower;
< 		m_upperAngle = upper;
< 	}
< }
< 
< void b2RevoluteJoint::Dump()
< {
< 	int32 indexA = m_bodyA->m_islandIndex;
< 	int32 indexB = m_bodyB->m_islandIndex;
< 
< 	b2Log("  b2RevoluteJointDef jd;\n");
< 	b2Log("  jd.bodyA = bodies[%d];\n", indexA);
< 	b2Log("  jd.bodyB = bodies[%d];\n", indexB);
< 	b2Log("  jd.collideConnected = bool(%d);\n", m_collideConnected);
< 	b2Log("  jd.localAnchorA.Set(%.15lef, %.15lef);\n", m_localAnchorA.x, m_localAnchorA.y);
< 	b2Log("  jd.localAnchorB.Set(%.15lef, %.15lef);\n", m_localAnchorB.x, m_localAnchorB.y);
< 	b2Log("  jd.referenceAngle = %.15lef;\n", m_referenceAngle);
< 	b2Log("  jd.enableLimit = bool(%d);\n", m_enableLimit);
< 	b2Log("  jd.lowerAngle = %.15lef;\n", m_lowerAngle);
< 	b2Log("  jd.upperAngle = %.15lef;\n", m_upperAngle);
< 	b2Log("  jd.enableMotor = bool(%d);\n", m_enableMotor);
< 	b2Log("  jd.motorSpeed = %.15lef;\n", m_motorSpeed);
< 	b2Log("  jd.maxMotorTorque = %.15lef;\n", m_maxMotorTorque);
< 	b2Log("  joints[%d] = m_world->CreateJoint(&jd);\n", m_index);
---
> 	m_body1->WakeUp();
> 	m_body2->WakeUp();
> 	m_lowerAngle = lower;
> 	m_upperAngle = upper;
diff -r -x './svn/*' native/Box2D/Dynamics/Joints/.svn/text-base/b2RevoluteJoint.h.svn-base ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Joints/.svn/text-base/b2RevoluteJoint.h.svn-base
2c2
< * Copyright (c) 2006-2011 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
22c22
< #include <Box2D/Dynamics/Joints/b2Joint.h>
---
> #include "b2Joint.h"
40,41c40,41
< 		localAnchorA.Set(0.0f, 0.0f);
< 		localAnchorB.Set(0.0f, 0.0f);
---
> 		localAnchor1.Set(0.0f, 0.0f);
> 		localAnchor2.Set(0.0f, 0.0f);
51,53c51,53
< 	/// Initialize the bodies, anchors, and reference angle using a world
< 	/// anchor point.
< 	void Initialize(b2Body* bodyA, b2Body* bodyB, const b2Vec2& anchor);
---
> 	/// Initialize the bodies, anchors, and reference angle using the world
> 	/// anchor.
> 	void Initialize(b2Body* body1, b2Body* body2, const b2Vec2& anchor);
55,56c55,56
< 	/// The local anchor point relative to bodyA's origin.
< 	b2Vec2 localAnchorA;
---
> 	/// The local anchor point relative to body1's origin.
> 	b2Vec2 localAnchor1;
58,59c58,59
< 	/// The local anchor point relative to bodyB's origin.
< 	b2Vec2 localAnchorB;
---
> 	/// The local anchor point relative to body2's origin.
> 	b2Vec2 localAnchor2;
61c61
< 	/// The bodyB angle minus bodyA angle in the reference state (radians).
---
> 	/// The body2 angle minus body1 angle in the reference state (radians).
84c84
< /// A revolute joint constrains two bodies to share a common point while they
---
> /// A revolute joint constrains to bodies to share a common point while they
93,94c93,94
< 	b2Vec2 GetAnchorA() const;
< 	b2Vec2 GetAnchorB() const;
---
> 	b2Vec2 GetAnchor1() const;
> 	b2Vec2 GetAnchor2() const;
96,103c96,97
< 	/// The local anchor point relative to bodyA's origin.
< 	const b2Vec2& GetLocalAnchorA() const { return m_localAnchorA; }
< 
< 	/// The local anchor point relative to bodyB's origin.
< 	const b2Vec2& GetLocalAnchorB() const  { return m_localAnchorB; }
< 
< 	/// Get the reference angle.
< 	float32 GetReferenceAngle() const { return m_referenceAngle; }
---
> 	b2Vec2 GetReactionForce(float32 inv_dt) const;
> 	float32 GetReactionTorque(float32 inv_dt) const;
140d133
< 	float32 GetMaxMotorTorque() const { return m_maxMotorTorque; }
142,144c135,136
< 	/// Get the reaction force given the inverse time step.
< 	/// Unit is N.
< 	b2Vec2 GetReactionForce(float32 inv_dt) const;
---
> 	/// Get the current motor torque, usually in N-m.
> 	float32 GetMotorTorque() const;
146,152c138,139
< 	/// Get the reaction torque due to the joint limit given the inverse time step.
< 	/// Unit is N*m.
< 	float32 GetReactionTorque(float32 inv_dt) const;
< 
< 	/// Get the current motor torque given the inverse time step.
< 	/// Unit is N*m.
< 	float32 GetMotorTorque(float32 inv_dt) const;
---
> 	//--------------- Internals Below -------------------
> 	b2RevoluteJoint(const b2RevoluteJointDef* def);
154,155c141,142
< 	/// Dump to b2Log.
< 	void Dump();
---
> 	void InitVelocityConstraints(const b2TimeStep& step);
> 	void SolveVelocityConstraints(const b2TimeStep& step);
157,160c144
< protected:
< 	
< 	friend class b2Joint;
< 	friend class b2GearJoint;
---
> 	bool SolvePositionConstraints(float32 baumgarte);
162,170c146,147
< 	b2RevoluteJoint(const b2RevoluteJointDef* def);
< 
< 	void InitVelocityConstraints(const b2SolverData& data);
< 	void SolveVelocityConstraints(const b2SolverData& data);
< 	bool SolvePositionConstraints(const b2SolverData& data);
< 
< 	// Solver shared
< 	b2Vec2 m_localAnchorA;
< 	b2Vec2 m_localAnchorB;
---
> 	b2Vec2 m_localAnchor1;	// relative
> 	b2Vec2 m_localAnchor2;
173a151,153
> 	b2Mat33 m_mass;			// effective mass for point-to-point constraint.
> 	float32 m_motorMass;	// effective mass for motor/limit angular constraint.
> 	
182,195d161
< 
< 	// Solver temp
< 	int32 m_indexA;
< 	int32 m_indexB;
< 	b2Vec2 m_rA;
< 	b2Vec2 m_rB;
< 	b2Vec2 m_localCenterA;
< 	b2Vec2 m_localCenterB;
< 	float32 m_invMassA;
< 	float32 m_invMassB;
< 	float32 m_invIA;
< 	float32 m_invIB;
< 	b2Mat33 m_mass;			// effective mass for point-to-point constraint.
< 	float32 m_motorMass;	// effective mass for motor/limit angular constraint.
Only in native/Box2D/Dynamics/Joints/.svn/text-base: b2RopeJoint.cpp.svn-base
Only in native/Box2D/Dynamics/Joints/.svn/text-base: b2RopeJoint.h.svn-base
Only in native/Box2D/Dynamics/Joints/.svn/text-base: b2WeldJoint.cpp.svn-base
Only in native/Box2D/Dynamics/Joints/.svn/text-base: b2WeldJoint.h.svn-base
Only in native/Box2D/Dynamics/Joints/.svn/text-base: b2WheelJoint.cpp.svn-base
Only in native/Box2D/Dynamics/Joints/.svn/text-base: b2WheelJoint.h.svn-base
diff -r -x './svn/*' native/Box2D/Dynamics/Joints/b2DistanceJoint.cpp ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Joints/b2DistanceJoint.cpp
2c2
< * Copyright (c) 2006-2011 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
19,21c19,21
< #include <Box2D/Dynamics/Joints/b2DistanceJoint.h>
< #include <Box2D/Dynamics/b2Body.h>
< #include <Box2D/Dynamics/b2TimeStep.h>
---
> #include "b2DistanceJoint.h"
> #include "../b2Body.h"
> #include "../b2World.h"
41,44c41,44
< 	bodyA = b1;
< 	bodyB = b2;
< 	localAnchorA = bodyA->GetLocalPoint(anchor1);
< 	localAnchorB = bodyB->GetLocalPoint(anchor2);
---
> 	body1 = b1;
> 	body2 = b2;
> 	localAnchor1 = body1->GetLocalPoint(anchor1);
> 	localAnchor2 = body2->GetLocalPoint(anchor2);
48a49
> 
52,53c53,54
< 	m_localAnchorA = def->localAnchorA;
< 	m_localAnchorB = def->localAnchorB;
---
> 	m_localAnchor1 = def->localAnchor1;
> 	m_localAnchor2 = def->localAnchor2;
62c63
< void b2DistanceJoint::InitVelocityConstraints(const b2SolverData& data)
---
> void b2DistanceJoint::InitVelocityConstraints(const b2TimeStep& step)
64,87c65,71
< 	m_indexA = m_bodyA->m_islandIndex;
< 	m_indexB = m_bodyB->m_islandIndex;
< 	m_localCenterA = m_bodyA->m_sweep.localCenter;
< 	m_localCenterB = m_bodyB->m_sweep.localCenter;
< 	m_invMassA = m_bodyA->m_invMass;
< 	m_invMassB = m_bodyB->m_invMass;
< 	m_invIA = m_bodyA->m_invI;
< 	m_invIB = m_bodyB->m_invI;
< 
< 	b2Vec2 cA = data.positions[m_indexA].c;
< 	float32 aA = data.positions[m_indexA].a;
< 	b2Vec2 vA = data.velocities[m_indexA].v;
< 	float32 wA = data.velocities[m_indexA].w;
< 
< 	b2Vec2 cB = data.positions[m_indexB].c;
< 	float32 aB = data.positions[m_indexB].a;
< 	b2Vec2 vB = data.velocities[m_indexB].v;
< 	float32 wB = data.velocities[m_indexB].w;
< 
< 	b2Rot qA(aA), qB(aB);
< 
< 	m_rA = b2Mul(qA, m_localAnchorA - m_localCenterA);
< 	m_rB = b2Mul(qB, m_localAnchorB - m_localCenterB);
< 	m_u = cB + m_rB - cA - m_rA;
---
> 	b2Body* b1 = m_body1;
> 	b2Body* b2 = m_body2;
> 
> 	// Compute the effective mass matrix.
> 	b2Vec2 r1 = b2Mul(b1->GetXForm().R, m_localAnchor1 - b1->GetLocalCenter());
> 	b2Vec2 r2 = b2Mul(b2->GetXForm().R, m_localAnchor2 - b2->GetLocalCenter());
> 	m_u = b2->m_sweep.c + r2 - b1->m_sweep.c - r1;
100,105c84,88
< 	float32 crAu = b2Cross(m_rA, m_u);
< 	float32 crBu = b2Cross(m_rB, m_u);
< 	float32 invMass = m_invMassA + m_invIA * crAu * crAu + m_invMassB + m_invIB * crBu * crBu;
< 
< 	// Compute the effective mass matrix.
< 	m_mass = invMass != 0.0f ? 1.0f / invMass : 0.0f;
---
> 	float32 cr1u = b2Cross(r1, m_u);
> 	float32 cr2u = b2Cross(r2, m_u);
> 	float32 invMass = b1->m_invMass + b1->m_invI * cr1u * cr1u + b2->m_invMass + b2->m_invI * cr2u * cr2u;
> 	b2Assert(invMass > B2_FLT_EPSILON);
> 	m_mass = 1.0f / invMass;
121,124c104,105
< 		float32 h = data.step.dt;
< 		m_gamma = h * (d + h * k);
< 		m_gamma = m_gamma != 0.0f ? 1.0f / m_gamma : 0.0f;
< 		m_bias = C * h * k * m_gamma;
---
> 		m_gamma = 1.0f / (step.dt * (d + step.dt * k));
> 		m_bias = C * step.dt * k * m_gamma;
126,132c107
< 		invMass += m_gamma;
< 		m_mass = invMass != 0.0f ? 1.0f / invMass : 0.0f;
< 	}
< 	else
< 	{
< 		m_gamma = 0.0f;
< 		m_bias = 0.0f;
---
> 		m_mass = 1.0f / (invMass + m_gamma);
135c110
< 	if (data.step.warmStarting)
---
> 	if (step.warmStarting)
138c113
< 		m_impulse *= data.step.dtRatio;
---
> 		m_impulse *= step.dtRatio;
141,144c116,119
< 		vA -= m_invMassA * P;
< 		wA -= m_invIA * b2Cross(m_rA, P);
< 		vB += m_invMassB * P;
< 		wB += m_invIB * b2Cross(m_rB, P);
---
> 		b1->m_linearVelocity -= b1->m_invMass * P;
> 		b1->m_angularVelocity -= b1->m_invI * b2Cross(r1, P);
> 		b2->m_linearVelocity += b2->m_invMass * P;
> 		b2->m_angularVelocity += b2->m_invI * b2Cross(r2, P);
150,154d124
< 
< 	data.velocities[m_indexA].v = vA;
< 	data.velocities[m_indexA].w = wA;
< 	data.velocities[m_indexB].v = vB;
< 	data.velocities[m_indexB].w = wB;
157c127
< void b2DistanceJoint::SolveVelocityConstraints(const b2SolverData& data)
---
> void b2DistanceJoint::SolveVelocityConstraints(const b2TimeStep& step)
159,162c129,135
< 	b2Vec2 vA = data.velocities[m_indexA].v;
< 	float32 wA = data.velocities[m_indexA].w;
< 	b2Vec2 vB = data.velocities[m_indexB].v;
< 	float32 wB = data.velocities[m_indexB].w;
---
> 	B2_NOT_USED(step);
> 
> 	b2Body* b1 = m_body1;
> 	b2Body* b2 = m_body2;
> 
> 	b2Vec2 r1 = b2Mul(b1->GetXForm().R, m_localAnchor1 - b1->GetLocalCenter());
> 	b2Vec2 r2 = b2Mul(b2->GetXForm().R, m_localAnchor2 - b2->GetLocalCenter());
165,167c138,140
< 	b2Vec2 vpA = vA + b2Cross(wA, m_rA);
< 	b2Vec2 vpB = vB + b2Cross(wB, m_rB);
< 	float32 Cdot = b2Dot(m_u, vpB - vpA);
---
> 	b2Vec2 v1 = b1->m_linearVelocity + b2Cross(b1->m_angularVelocity, r1);
> 	b2Vec2 v2 = b2->m_linearVelocity + b2Cross(b2->m_angularVelocity, r2);
> 	float32 Cdot = b2Dot(m_u, v2 - v1);
173,181c146,149
< 	vA -= m_invMassA * P;
< 	wA -= m_invIA * b2Cross(m_rA, P);
< 	vB += m_invMassB * P;
< 	wB += m_invIB * b2Cross(m_rB, P);
< 
< 	data.velocities[m_indexA].v = vA;
< 	data.velocities[m_indexA].w = wA;
< 	data.velocities[m_indexB].v = vB;
< 	data.velocities[m_indexB].w = wB;
---
> 	b1->m_linearVelocity -= b1->m_invMass * P;
> 	b1->m_angularVelocity -= b1->m_invI * b2Cross(r1, P);
> 	b2->m_linearVelocity += b2->m_invMass * P;
> 	b2->m_angularVelocity += b2->m_invI * b2Cross(r2, P);
184c152
< bool b2DistanceJoint::SolvePositionConstraints(const b2SolverData& data)
---
> bool b2DistanceJoint::SolvePositionConstraints(float32 baumgarte)
185a154,155
> 	B2_NOT_USED(baumgarte);
> 
192,201c162,166
< 	b2Vec2 cA = data.positions[m_indexA].c;
< 	float32 aA = data.positions[m_indexA].a;
< 	b2Vec2 cB = data.positions[m_indexB].c;
< 	float32 aB = data.positions[m_indexB].a;
< 
< 	b2Rot qA(aA), qB(aB);
< 
< 	b2Vec2 rA = b2Mul(qA, m_localAnchorA - m_localCenterA);
< 	b2Vec2 rB = b2Mul(qB, m_localAnchorB - m_localCenterB);
< 	b2Vec2 u = cB + rB - cA - rA;
---
> 	b2Body* b1 = m_body1;
> 	b2Body* b2 = m_body2;
> 
> 	b2Vec2 r1 = b2Mul(b1->GetXForm().R, m_localAnchor1 - b1->GetLocalCenter());
> 	b2Vec2 r2 = b2Mul(b2->GetXForm().R, m_localAnchor2 - b2->GetLocalCenter());
203c168,170
< 	float32 length = u.Normalize();
---
> 	b2Vec2 d = b2->m_sweep.c + r2 - b1->m_sweep.c - r1;
> 
> 	float32 length = d.Normalize();
208c175,176
< 	b2Vec2 P = impulse * u;
---
> 	m_u = d;
> 	b2Vec2 P = impulse * m_u;
210,218c178,184
< 	cA -= m_invMassA * P;
< 	aA -= m_invIA * b2Cross(rA, P);
< 	cB += m_invMassB * P;
< 	aB += m_invIB * b2Cross(rB, P);
< 
< 	data.positions[m_indexA].c = cA;
< 	data.positions[m_indexA].a = aA;
< 	data.positions[m_indexB].c = cB;
< 	data.positions[m_indexB].a = aB;
---
> 	b1->m_sweep.c -= b1->m_invMass * P;
> 	b1->m_sweep.a -= b1->m_invI * b2Cross(r1, P);
> 	b2->m_sweep.c += b2->m_invMass * P;
> 	b2->m_sweep.a += b2->m_invI * b2Cross(r2, P);
> 
> 	b1->SynchronizeTransform();
> 	b2->SynchronizeTransform();
223c189
< b2Vec2 b2DistanceJoint::GetAnchorA() const
---
> b2Vec2 b2DistanceJoint::GetAnchor1() const
225c191
< 	return m_bodyA->GetWorldPoint(m_localAnchorA);
---
> 	return m_body1->GetWorldPoint(m_localAnchor1);
228c194
< b2Vec2 b2DistanceJoint::GetAnchorB() const
---
> b2Vec2 b2DistanceJoint::GetAnchor2() const
230c196
< 	return m_bodyB->GetWorldPoint(m_localAnchorB);
---
> 	return m_body2->GetWorldPoint(m_localAnchor2);
244,260d209
< 
< void b2DistanceJoint::Dump()
< {
< 	int32 indexA = m_bodyA->m_islandIndex;
< 	int32 indexB = m_bodyB->m_islandIndex;
< 
< 	b2Log("  b2DistanceJointDef jd;\n");
< 	b2Log("  jd.bodyA = bodies[%d];\n", indexA);
< 	b2Log("  jd.bodyB = bodies[%d];\n", indexB);
< 	b2Log("  jd.collideConnected = bool(%d);\n", m_collideConnected);
< 	b2Log("  jd.localAnchorA.Set(%.15lef, %.15lef);\n", m_localAnchorA.x, m_localAnchorA.y);
< 	b2Log("  jd.localAnchorB.Set(%.15lef, %.15lef);\n", m_localAnchorB.x, m_localAnchorB.y);
< 	b2Log("  jd.length = %.15lef;\n", m_length);
< 	b2Log("  jd.frequencyHz = %.15lef;\n", m_frequencyHz);
< 	b2Log("  jd.dampingRatio = %.15lef;\n", m_dampingRatio);
< 	b2Log("  joints[%d] = m_world->CreateJoint(&jd);\n", m_index);
< }
diff -r -x './svn/*' native/Box2D/Dynamics/Joints/b2DistanceJoint.h ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Joints/b2DistanceJoint.h
2c2
< * Copyright (c) 2006-2007 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
22c22
< #include <Box2D/Dynamics/Joints/b2Joint.h>
---
> #include "b2Joint.h"
35,36c35,36
< 		localAnchorA.Set(0.0f, 0.0f);
< 		localAnchorB.Set(0.0f, 0.0f);
---
> 		localAnchor1.Set(0.0f, 0.0f);
> 		localAnchor2.Set(0.0f, 0.0f);
44,45c44,45
< 	void Initialize(b2Body* bodyA, b2Body* bodyB,
< 					const b2Vec2& anchorA, const b2Vec2& anchorB);
---
> 	void Initialize(b2Body* body1, b2Body* body2,
> 					const b2Vec2& anchor1, const b2Vec2& anchor2);
47,48c47,48
< 	/// The local anchor point relative to bodyA's origin.
< 	b2Vec2 localAnchorA;
---
> 	/// The local anchor point relative to body1's origin.
> 	b2Vec2 localAnchor1;
50,51c50,51
< 	/// The local anchor point relative to bodyB's origin.
< 	b2Vec2 localAnchorB;
---
> 	/// The local anchor point relative to body2's origin.
> 	b2Vec2 localAnchor2;
53c53
< 	/// The natural length between the anchor points.
---
> 	/// The equilibrium length between the anchor points.
56,57c56
< 	/// The mass-spring-damper frequency in Hertz. A value of 0
< 	/// disables softness.
---
> 	/// The response speed.
71,72c70,71
< 	b2Vec2 GetAnchorA() const;
< 	b2Vec2 GetAnchorB() const;
---
> 	b2Vec2 GetAnchor1() const;
> 	b2Vec2 GetAnchor2() const;
74,75d72
< 	/// Get the reaction force given the inverse time step.
< 	/// Unit is N.
77,79d73
< 
< 	/// Get the reaction torque given the inverse time step.
< 	/// Unit is N*m. This is always zero for a distance joint.
82,104c76
< 	/// The local anchor point relative to bodyA's origin.
< 	const b2Vec2& GetLocalAnchorA() const { return m_localAnchorA; }
< 
< 	/// The local anchor point relative to bodyB's origin.
< 	const b2Vec2& GetLocalAnchorB() const  { return m_localAnchorB; }
< 
< 	/// Set/get the natural length.
< 	/// Manipulating the length can lead to non-physical behavior when the frequency is zero.
< 	void SetLength(float32 length);
< 	float32 GetLength() const;
< 
< 	/// Set/get frequency in Hz.
< 	void SetFrequency(float32 hz);
< 	float32 GetFrequency() const;
< 
< 	/// Set/get damping ratio.
< 	void SetDampingRatio(float32 ratio);
< 	float32 GetDampingRatio() const;
< 
< 	/// Dump joint to dmLog
< 	void Dump();
< 
< protected:
---
> 	//--------------- Internals Below -------------------
106d77
< 	friend class b2Joint;
109,111c80,82
< 	void InitVelocityConstraints(const b2SolverData& data);
< 	void SolveVelocityConstraints(const b2SolverData& data);
< 	bool SolvePositionConstraints(const b2SolverData& data);
---
> 	void InitVelocityConstraints(const b2TimeStep& step);
> 	void SolveVelocityConstraints(const b2TimeStep& step);
> 	bool SolvePositionConstraints(float32 baumgarte);
112a84,86
> 	b2Vec2 m_localAnchor1;
> 	b2Vec2 m_localAnchor2;
> 	b2Vec2 m_u;
115,119d88
< 	float32 m_bias;
< 
< 	// Solver shared
< 	b2Vec2 m_localAnchorA;
< 	b2Vec2 m_localAnchorB;
120a90
> 	float32 m_bias;
121a92
> 	float32 m_mass;		// effective mass for the constraint.
123,136d93
< 
< 	// Solver temp
< 	int32 m_indexA;
< 	int32 m_indexB;
< 	b2Vec2 m_u;
< 	b2Vec2 m_rA;
< 	b2Vec2 m_rB;
< 	b2Vec2 m_localCenterA;
< 	b2Vec2 m_localCenterB;
< 	float32 m_invMassA;
< 	float32 m_invMassB;
< 	float32 m_invIA;
< 	float32 m_invIB;
< 	float32 m_mass;
139,168d95
< inline void b2DistanceJoint::SetLength(float32 length)
< {
< 	m_length = length;
< }
< 
< inline float32 b2DistanceJoint::GetLength() const
< {
< 	return m_length;
< }
< 
< inline void b2DistanceJoint::SetFrequency(float32 hz)
< {
< 	m_frequencyHz = hz;
< }
< 
< inline float32 b2DistanceJoint::GetFrequency() const
< {
< 	return m_frequencyHz;
< }
< 
< inline void b2DistanceJoint::SetDampingRatio(float32 ratio)
< {
< 	m_dampingRatio = ratio;
< }
< 
< inline float32 b2DistanceJoint::GetDampingRatio() const
< {
< 	return m_dampingRatio;
< }
< 
Only in native/Box2D/Dynamics/Joints: b2FrictionJoint.cpp
Only in native/Box2D/Dynamics/Joints: b2FrictionJoint.h
diff -r -x './svn/*' native/Box2D/Dynamics/Joints/b2GearJoint.cpp ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Joints/b2GearJoint.cpp
2c2
< * Copyright (c) 2007-2011 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2007 Erin Catto http://www.gphysics.com
19,23c19,23
< #include <Box2D/Dynamics/Joints/b2GearJoint.h>
< #include <Box2D/Dynamics/Joints/b2RevoluteJoint.h>
< #include <Box2D/Dynamics/Joints/b2PrismaticJoint.h>
< #include <Box2D/Dynamics/b2Body.h>
< #include <Box2D/Dynamics/b2TimeStep.h>
---
> #include "b2GearJoint.h"
> #include "b2RevoluteJoint.h"
> #include "b2PrismaticJoint.h"
> #include "../b2Body.h"
> #include "../b2World.h"
27,28c27,29
< // C = (coordinate1 + ratio * coordinate2) - C0 = 0
< // J = [J1 ratio * J2]
---
> // C = C0 - (cordinate1 + ratio * coordinate2) = 0
> // Cdot = -(Cdot1 + ratio * Cdot2)
> // J = -[J1 ratio * J2]
47,48c48,49
< 	m_joint1 = def->joint1;
< 	m_joint2 = def->joint2;
---
> 	b2JointType type1 = def->joint1->GetType();
> 	b2JointType type2 = def->joint2->GetType();
50,77c51,70
< 	m_typeA = m_joint1->GetType();
< 	m_typeB = m_joint2->GetType();
< 
< 	b2Assert(m_typeA == e_revoluteJoint || m_typeA == e_prismaticJoint);
< 	b2Assert(m_typeB == e_revoluteJoint || m_typeB == e_prismaticJoint);
< 
< 	float32 coordinateA, coordinateB;
< 
< 	// TODO_ERIN there might be some problem with the joint edges in b2Joint.
< 
< 	m_bodyC = m_joint1->GetBodyA();
< 	m_bodyA = m_joint1->GetBodyB();
< 
< 	// Get geometry of joint1
< 	b2Transform xfA = m_bodyA->m_xf;
< 	float32 aA = m_bodyA->m_sweep.a;
< 	b2Transform xfC = m_bodyC->m_xf;
< 	float32 aC = m_bodyC->m_sweep.a;
< 
< 	if (m_typeA == e_revoluteJoint)
< 	{
< 		b2RevoluteJoint* revolute = (b2RevoluteJoint*)def->joint1;
< 		m_localAnchorC = revolute->m_localAnchorA;
< 		m_localAnchorA = revolute->m_localAnchorB;
< 		m_referenceAngleA = revolute->m_referenceAngle;
< 		m_localAxisC.SetZero();
< 
< 		coordinateA = aA - aC - m_referenceAngleA;
---
> 	b2Assert(type1 == e_revoluteJoint || type1 == e_prismaticJoint);
> 	b2Assert(type2 == e_revoluteJoint || type2 == e_prismaticJoint);
> 	b2Assert(def->joint1->GetBody1()->IsStatic());
> 	b2Assert(def->joint2->GetBody1()->IsStatic());
> 
> 	m_revolute1 = NULL;
> 	m_prismatic1 = NULL;
> 	m_revolute2 = NULL;
> 	m_prismatic2 = NULL;
> 
> 	float32 coordinate1, coordinate2;
> 
> 	m_ground1 = def->joint1->GetBody1();
> 	m_body1 = def->joint1->GetBody2();
> 	if (type1 == e_revoluteJoint)
> 	{
> 		m_revolute1 = (b2RevoluteJoint*)def->joint1;
> 		m_groundAnchor1 = m_revolute1->m_localAnchor1;
> 		m_localAnchor1 = m_revolute1->m_localAnchor2;
> 		coordinate1 = m_revolute1->GetJointAngle();
81,107c74,78
< 		b2PrismaticJoint* prismatic = (b2PrismaticJoint*)def->joint1;
< 		m_localAnchorC = prismatic->m_localAnchorA;
< 		m_localAnchorA = prismatic->m_localAnchorB;
< 		m_referenceAngleA = prismatic->m_referenceAngle;
< 		m_localAxisC = prismatic->m_localXAxisA;
< 
< 		b2Vec2 pC = m_localAnchorC;
< 		b2Vec2 pA = b2MulT(xfC.q, b2Mul(xfA.q, m_localAnchorA) + (xfA.p - xfC.p));
< 		coordinateA = b2Dot(pA - pC, m_localAxisC);
< 	}
< 
< 	m_bodyD = m_joint2->GetBodyA();
< 	m_bodyB = m_joint2->GetBodyB();
< 
< 	// Get geometry of joint2
< 	b2Transform xfB = m_bodyB->m_xf;
< 	float32 aB = m_bodyB->m_sweep.a;
< 	b2Transform xfD = m_bodyD->m_xf;
< 	float32 aD = m_bodyD->m_sweep.a;
< 
< 	if (m_typeB == e_revoluteJoint)
< 	{
< 		b2RevoluteJoint* revolute = (b2RevoluteJoint*)def->joint2;
< 		m_localAnchorD = revolute->m_localAnchorA;
< 		m_localAnchorB = revolute->m_localAnchorB;
< 		m_referenceAngleB = revolute->m_referenceAngle;
< 		m_localAxisD.SetZero();
---
> 		m_prismatic1 = (b2PrismaticJoint*)def->joint1;
> 		m_groundAnchor1 = m_prismatic1->m_localAnchor1;
> 		m_localAnchor1 = m_prismatic1->m_localAnchor2;
> 		coordinate1 = m_prismatic1->GetJointTranslation();
> 	}
109c80,87
< 		coordinateB = aB - aD - m_referenceAngleB;
---
> 	m_ground2 = def->joint2->GetBody1();
> 	m_body2 = def->joint2->GetBody2();
> 	if (type2 == e_revoluteJoint)
> 	{
> 		m_revolute2 = (b2RevoluteJoint*)def->joint2;
> 		m_groundAnchor2 = m_revolute2->m_localAnchor1;
> 		m_localAnchor2 = m_revolute2->m_localAnchor2;
> 		coordinate2 = m_revolute2->GetJointAngle();
113,121c91,94
< 		b2PrismaticJoint* prismatic = (b2PrismaticJoint*)def->joint2;
< 		m_localAnchorD = prismatic->m_localAnchorA;
< 		m_localAnchorB = prismatic->m_localAnchorB;
< 		m_referenceAngleB = prismatic->m_referenceAngle;
< 		m_localAxisD = prismatic->m_localXAxisA;
< 
< 		b2Vec2 pD = m_localAnchorD;
< 		b2Vec2 pB = b2MulT(xfD.q, b2Mul(xfB.q, m_localAnchorB) + (xfB.p - xfD.p));
< 		coordinateB = b2Dot(pB - pD, m_localAxisD);
---
> 		m_prismatic2 = (b2PrismaticJoint*)def->joint2;
> 		m_groundAnchor2 = m_prismatic2->m_localAnchor1;
> 		m_localAnchor2 = m_prismatic2->m_localAnchor2;
> 		coordinate2 = m_prismatic2->GetJointTranslation();
126c99
< 	m_constant = coordinateA + m_ratio * coordinateB;
---
> 	m_constant = coordinate1 + m_ratio * coordinate2;
131c104
< void b2GearJoint::InitVelocityConstraints(const b2SolverData& data)
---
> void b2GearJoint::InitVelocityConstraints(const b2TimeStep& step)
133,175c106,117
< 	m_indexA = m_bodyA->m_islandIndex;
< 	m_indexB = m_bodyB->m_islandIndex;
< 	m_indexC = m_bodyC->m_islandIndex;
< 	m_indexD = m_bodyD->m_islandIndex;
< 	m_lcA = m_bodyA->m_sweep.localCenter;
< 	m_lcB = m_bodyB->m_sweep.localCenter;
< 	m_lcC = m_bodyC->m_sweep.localCenter;
< 	m_lcD = m_bodyD->m_sweep.localCenter;
< 	m_mA = m_bodyA->m_invMass;
< 	m_mB = m_bodyB->m_invMass;
< 	m_mC = m_bodyC->m_invMass;
< 	m_mD = m_bodyD->m_invMass;
< 	m_iA = m_bodyA->m_invI;
< 	m_iB = m_bodyB->m_invI;
< 	m_iC = m_bodyC->m_invI;
< 	m_iD = m_bodyD->m_invI;
< 
< 	float32 aA = data.positions[m_indexA].a;
< 	b2Vec2 vA = data.velocities[m_indexA].v;
< 	float32 wA = data.velocities[m_indexA].w;
< 
< 	float32 aB = data.positions[m_indexB].a;
< 	b2Vec2 vB = data.velocities[m_indexB].v;
< 	float32 wB = data.velocities[m_indexB].w;
< 
< 	float32 aC = data.positions[m_indexC].a;
< 	b2Vec2 vC = data.velocities[m_indexC].v;
< 	float32 wC = data.velocities[m_indexC].w;
< 
< 	float32 aD = data.positions[m_indexD].a;
< 	b2Vec2 vD = data.velocities[m_indexD].v;
< 	float32 wD = data.velocities[m_indexD].w;
< 
< 	b2Rot qA(aA), qB(aB), qC(aC), qD(aD);
< 
< 	m_mass = 0.0f;
< 
< 	if (m_typeA == e_revoluteJoint)
< 	{
< 		m_JvAC.SetZero();
< 		m_JwA = 1.0f;
< 		m_JwC = 1.0f;
< 		m_mass += m_iA + m_iC;
---
> 	b2Body* g1 = m_ground1;
> 	b2Body* g2 = m_ground2;
> 	b2Body* b1 = m_body1;
> 	b2Body* b2 = m_body2;
> 
> 	float32 K = 0.0f;
> 	m_J.SetZero();
> 
> 	if (m_revolute1)
> 	{
> 		m_J.angular1 = -1.0f;
> 		K += b1->m_invI;
179,185c121,126
< 		b2Vec2 u = b2Mul(qC, m_localAxisC);
< 		b2Vec2 rC = b2Mul(qC, m_localAnchorC - m_lcC);
< 		b2Vec2 rA = b2Mul(qA, m_localAnchorA - m_lcA);
< 		m_JvAC = u;
< 		m_JwC = b2Cross(rC, u);
< 		m_JwA = b2Cross(rA, u);
< 		m_mass += m_mC + m_mA + m_iC * m_JwC * m_JwC + m_iA * m_JwA * m_JwA;
---
> 		b2Vec2 ug = b2Mul(g1->GetXForm().R, m_prismatic1->m_localXAxis1);
> 		b2Vec2 r = b2Mul(b1->GetXForm().R, m_localAnchor1 - b1->GetLocalCenter());
> 		float32 crug = b2Cross(r, ug);
> 		m_J.linear1 = -ug;
> 		m_J.angular1 = -crug;
> 		K += b1->m_invMass + b1->m_invI * crug * crug;
188,193c129,132
< 	if (m_typeB == e_revoluteJoint)
< 	{
< 		m_JvBD.SetZero();
< 		m_JwB = m_ratio;
< 		m_JwD = m_ratio;
< 		m_mass += m_ratio * m_ratio * (m_iB + m_iD);
---
> 	if (m_revolute2)
> 	{
> 		m_J.angular2 = -m_ratio;
> 		K += m_ratio * m_ratio * b2->m_invI;
197,203c136,141
< 		b2Vec2 u = b2Mul(qD, m_localAxisD);
< 		b2Vec2 rD = b2Mul(qD, m_localAnchorD - m_lcD);
< 		b2Vec2 rB = b2Mul(qB, m_localAnchorB - m_lcB);
< 		m_JvBD = m_ratio * u;
< 		m_JwD = m_ratio * b2Cross(rD, u);
< 		m_JwB = m_ratio * b2Cross(rB, u);
< 		m_mass += m_ratio * m_ratio * (m_mD + m_mB) + m_iD * m_JwD * m_JwD + m_iB * m_JwB * m_JwB;
---
> 		b2Vec2 ug = b2Mul(g2->GetXForm().R, m_prismatic2->m_localXAxis1);
> 		b2Vec2 r = b2Mul(b2->GetXForm().R, m_localAnchor2 - b2->GetLocalCenter());
> 		float32 crug = b2Cross(r, ug);
> 		m_J.linear2 = -m_ratio * ug;
> 		m_J.angular2 = -m_ratio * crug;
> 		K += m_ratio * m_ratio * (b2->m_invMass + b2->m_invI * crug * crug);
207c145,146
< 	m_mass = m_mass > 0.0f ? 1.0f / m_mass : 0.0f;
---
> 	b2Assert(K > 0.0f);
> 	m_mass = 1.0f / K;
209c148
< 	if (data.step.warmStarting)
---
> 	if (step.warmStarting)
211,218c150,154
< 		vA += (m_mA * m_impulse) * m_JvAC;
< 		wA += m_iA * m_impulse * m_JwA;
< 		vB += (m_mB * m_impulse) * m_JvBD;
< 		wB += m_iB * m_impulse * m_JwB;
< 		vC -= (m_mC * m_impulse) * m_JvAC;
< 		wC -= m_iC * m_impulse * m_JwC;
< 		vD -= (m_mD * m_impulse) * m_JvBD;
< 		wD -= m_iD * m_impulse * m_JwD;
---
> 		// Warm starting.
> 		b1->m_linearVelocity += b1->m_invMass * m_impulse * m_J.linear1;
> 		b1->m_angularVelocity += b1->m_invI * m_impulse * m_J.angular1;
> 		b2->m_linearVelocity += b2->m_invMass * m_impulse * m_J.linear2;
> 		b2->m_angularVelocity += b2->m_invI * m_impulse * m_J.angular2;
224,232d159
< 
< 	data.velocities[m_indexA].v = vA;
< 	data.velocities[m_indexA].w = wA;
< 	data.velocities[m_indexB].v = vB;
< 	data.velocities[m_indexB].w = wB;
< 	data.velocities[m_indexC].v = vC;
< 	data.velocities[m_indexC].w = wC;
< 	data.velocities[m_indexD].v = vD;
< 	data.velocities[m_indexD].w = wD;
235c162
< void b2GearJoint::SolveVelocityConstraints(const b2SolverData& data)
---
> void b2GearJoint::SolveVelocityConstraints(const b2TimeStep& step)
237,244c164
< 	b2Vec2 vA = data.velocities[m_indexA].v;
< 	float32 wA = data.velocities[m_indexA].w;
< 	b2Vec2 vB = data.velocities[m_indexB].v;
< 	float32 wB = data.velocities[m_indexB].w;
< 	b2Vec2 vC = data.velocities[m_indexC].v;
< 	float32 wC = data.velocities[m_indexC].w;
< 	b2Vec2 vD = data.velocities[m_indexD].v;
< 	float32 wD = data.velocities[m_indexD].w;
---
> 	B2_NOT_USED(step);
246,247c166,167
< 	float32 Cdot = b2Dot(m_JvAC, vA - vC) + b2Dot(m_JvBD, vB - vD);
< 	Cdot += (m_JwA * wA - m_JwC * wC) + (m_JwB * wB - m_JwD * wD);
---
> 	b2Body* b1 = m_body1;
> 	b2Body* b2 = m_body2;
249c169,172
< 	float32 impulse = -m_mass * Cdot;
---
> 	float32 Cdot = m_J.Compute(	b1->m_linearVelocity, b1->m_angularVelocity,
> 								b2->m_linearVelocity, b2->m_angularVelocity);
> 
> 	float32 impulse = m_mass * (-Cdot);
252,268c175,178
< 	vA += (m_mA * impulse) * m_JvAC;
< 	wA += m_iA * impulse * m_JwA;
< 	vB += (m_mB * impulse) * m_JvBD;
< 	wB += m_iB * impulse * m_JwB;
< 	vC -= (m_mC * impulse) * m_JvAC;
< 	wC -= m_iC * impulse * m_JwC;
< 	vD -= (m_mD * impulse) * m_JvBD;
< 	wD -= m_iD * impulse * m_JwD;
< 
< 	data.velocities[m_indexA].v = vA;
< 	data.velocities[m_indexA].w = wA;
< 	data.velocities[m_indexB].v = vB;
< 	data.velocities[m_indexB].w = wB;
< 	data.velocities[m_indexC].v = vC;
< 	data.velocities[m_indexC].w = wC;
< 	data.velocities[m_indexD].v = vD;
< 	data.velocities[m_indexD].w = wD;
---
> 	b1->m_linearVelocity += b1->m_invMass * impulse * m_J.linear1;
> 	b1->m_angularVelocity += b1->m_invI * impulse * m_J.angular1;
> 	b2->m_linearVelocity += b2->m_invMass * impulse * m_J.linear2;
> 	b2->m_angularVelocity += b2->m_invI * impulse * m_J.angular2;
271c181
< bool b2GearJoint::SolvePositionConstraints(const b2SolverData& data)
---
> bool b2GearJoint::SolvePositionConstraints(float32 baumgarte)
273,283c183,184
< 	b2Vec2 cA = data.positions[m_indexA].c;
< 	float32 aA = data.positions[m_indexA].a;
< 	b2Vec2 cB = data.positions[m_indexB].c;
< 	float32 aB = data.positions[m_indexB].a;
< 	b2Vec2 cC = data.positions[m_indexC].c;
< 	float32 aC = data.positions[m_indexC].a;
< 	b2Vec2 cD = data.positions[m_indexD].c;
< 	float32 aD = data.positions[m_indexD].a;
< 
< 	b2Rot qA(aA), qB(aB), qC(aC), qD(aD);
< 
---
> 	B2_NOT_USED(baumgarte);
> 	
286,290c187,188
< 	float32 coordinateA, coordinateB;
< 
< 	b2Vec2 JvAC, JvBD;
< 	float32 JwA, JwB, JwC, JwD;
< 	float32 mass = 0.0f;
---
> 	b2Body* b1 = m_body1;
> 	b2Body* b2 = m_body2;
292c190,191
< 	if (m_typeA == e_revoluteJoint)
---
> 	float32 coordinate1, coordinate2;
> 	if (m_revolute1)
294,299c193
< 		JvAC.SetZero();
< 		JwA = 1.0f;
< 		JwC = 1.0f;
< 		mass += m_iA + m_iC;
< 
< 		coordinateA = aA - aC - m_referenceAngleA;
---
> 		coordinate1 = m_revolute1->GetJointAngle();
303,321c197,198
< 		b2Vec2 u = b2Mul(qC, m_localAxisC);
< 		b2Vec2 rC = b2Mul(qC, m_localAnchorC - m_lcC);
< 		b2Vec2 rA = b2Mul(qA, m_localAnchorA - m_lcA);
< 		JvAC = u;
< 		JwC = b2Cross(rC, u);
< 		JwA = b2Cross(rA, u);
< 		mass += m_mC + m_mA + m_iC * JwC * JwC + m_iA * JwA * JwA;
< 
< 		b2Vec2 pC = m_localAnchorC - m_lcC;
< 		b2Vec2 pA = b2MulT(qC, rA + (cA - cC));
< 		coordinateA = b2Dot(pA - pC, m_localAxisC);
< 	}
< 
< 	if (m_typeB == e_revoluteJoint)
< 	{
< 		JvBD.SetZero();
< 		JwB = m_ratio;
< 		JwD = m_ratio;
< 		mass += m_ratio * m_ratio * (m_iB + m_iD);
---
> 		coordinate1 = m_prismatic1->GetJointTranslation();
> 	}
323c200,202
< 		coordinateB = aB - aD - m_referenceAngleB;
---
> 	if (m_revolute2)
> 	{
> 		coordinate2 = m_revolute2->GetJointAngle();
327,364c206,219
< 		b2Vec2 u = b2Mul(qD, m_localAxisD);
< 		b2Vec2 rD = b2Mul(qD, m_localAnchorD - m_lcD);
< 		b2Vec2 rB = b2Mul(qB, m_localAnchorB - m_lcB);
< 		JvBD = m_ratio * u;
< 		JwD = m_ratio * b2Cross(rD, u);
< 		JwB = m_ratio * b2Cross(rB, u);
< 		mass += m_ratio * m_ratio * (m_mD + m_mB) + m_iD * JwD * JwD + m_iB * JwB * JwB;
< 
< 		b2Vec2 pD = m_localAnchorD - m_lcD;
< 		b2Vec2 pB = b2MulT(qD, rB + (cB - cD));
< 		coordinateB = b2Dot(pB - pD, m_localAxisD);
< 	}
< 
< 	float32 C = (coordinateA + m_ratio * coordinateB) - m_constant;
< 
< 	float32 impulse = 0.0f;
< 	if (mass > 0.0f)
< 	{
< 		impulse = -C / mass;
< 	}
< 
< 	cA += m_mA * impulse * JvAC;
< 	aA += m_iA * impulse * JwA;
< 	cB += m_mB * impulse * JvBD;
< 	aB += m_iB * impulse * JwB;
< 	cC -= m_mC * impulse * JvAC;
< 	aC -= m_iC * impulse * JwC;
< 	cD -= m_mD * impulse * JvBD;
< 	aD -= m_iD * impulse * JwD;
< 
< 	data.positions[m_indexA].c = cA;
< 	data.positions[m_indexA].a = aA;
< 	data.positions[m_indexB].c = cB;
< 	data.positions[m_indexB].a = aB;
< 	data.positions[m_indexC].c = cC;
< 	data.positions[m_indexC].a = aC;
< 	data.positions[m_indexD].c = cD;
< 	data.positions[m_indexD].a = aD;
---
> 		coordinate2 = m_prismatic2->GetJointTranslation();
> 	}
> 
> 	float32 C = m_constant - (coordinate1 + m_ratio * coordinate2);
> 
> 	float32 impulse = m_mass * (-C);
> 
> 	b1->m_sweep.c += b1->m_invMass * impulse * m_J.linear1;
> 	b1->m_sweep.a += b1->m_invI * impulse * m_J.angular1;
> 	b2->m_sweep.c += b2->m_invMass * impulse * m_J.linear2;
> 	b2->m_sweep.a += b2->m_invI * impulse * m_J.angular2;
> 
> 	b1->SynchronizeTransform();
> 	b2->SynchronizeTransform();
370c225
< b2Vec2 b2GearJoint::GetAnchorA() const
---
> b2Vec2 b2GearJoint::GetAnchor1() const
372c227
< 	return m_bodyA->GetWorldPoint(m_localAnchorA);
---
> 	return m_body1->GetWorldPoint(m_localAnchor1);
375c230
< b2Vec2 b2GearJoint::GetAnchorB() const
---
> b2Vec2 b2GearJoint::GetAnchor2() const
377c232
< 	return m_bodyB->GetWorldPoint(m_localAnchorB);
---
> 	return m_body2->GetWorldPoint(m_localAnchor2);
382c237,238
< 	b2Vec2 P = m_impulse * m_JvAC;
---
> 	// TODO_ERIN not tested
> 	b2Vec2 P = m_impulse * m_J.linear2;
388c244,247
< 	float32 L = m_impulse * m_JwA;
---
> 	// TODO_ERIN not tested
> 	b2Vec2 r = b2Mul(m_body2->GetXForm().R, m_localAnchor2 - m_body2->GetLocalCenter());
> 	b2Vec2 P = m_impulse * m_J.linear2;
> 	float32 L = m_impulse * m_J.angular2 - b2Cross(r, P);
392,397d250
< void b2GearJoint::SetRatio(float32 ratio)
< {
< 	b2Assert(b2IsValid(ratio));
< 	m_ratio = ratio;
< }
< 
403,406d255
< void b2GearJoint::Dump()
< {
< 	int32 indexA = m_bodyA->m_islandIndex;
< 	int32 indexB = m_bodyB->m_islandIndex;
408,409d256
< 	int32 index1 = m_joint1->m_index;
< 	int32 index2 = m_joint2->m_index;
411,419d257
< 	b2Log("  b2GearJointDef jd;\n");
< 	b2Log("  jd.bodyA = bodies[%d];\n", indexA);
< 	b2Log("  jd.bodyB = bodies[%d];\n", indexB);
< 	b2Log("  jd.collideConnected = bool(%d);\n", m_collideConnected);
< 	b2Log("  jd.joint1 = joints[%d];\n", index1);
< 	b2Log("  jd.joint2 = joints[%d];\n", index2);
< 	b2Log("  jd.ratio = %.15lef;\n", m_ratio);
< 	b2Log("  joints[%d] = m_world->CreateJoint(&jd);\n", m_index);
< }
diff -r -x './svn/*' native/Box2D/Dynamics/Joints/b2GearJoint.h ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Joints/b2GearJoint.h
2c2
< * Copyright (c) 2006-2011 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
22c22,25
< #include <Box2D/Dynamics/Joints/b2Joint.h>
---
> #include "b2Joint.h"
> 
> class b2RevoluteJoint;
> class b2PrismaticJoint;
25a29
> /// The provided joints must attach a dynamic body to a static body.
54,55c58,59
< /// @warning You have to manually destroy the gear joint if joint1 or joint2
< /// is destroyed.
---
> /// @warning The revolute and prismatic joints must be attached to
> /// fixed bodies (which must be body1 on those joints).
59,60c63,64
< 	b2Vec2 GetAnchorA() const;
< 	b2Vec2 GetAnchorB() const;
---
> 	b2Vec2 GetAnchor1() const;
> 	b2Vec2 GetAnchor2() const;
65,66c69,70
< 	/// Get the first joint.
< 	b2Joint* GetJoint1() { return m_joint1; }
---
> 	/// Get the gear ratio.
> 	float32 GetRatio() const;
68,69c72
< 	/// Get the second joint.
< 	b2Joint* GetJoint2() { return m_joint2; }
---
> 	//--------------- Internals Below -------------------
71,73c74
< 	/// Set/Get the gear ratio.
< 	void SetRatio(float32 ratio);
< 	float32 GetRatio() const;
---
> 	b2GearJoint(const b2GearJointDef* data);
75,76c76,78
< 	/// Dump joint to dmLog
< 	void Dump();
---
> 	void InitVelocityConstraints(const b2TimeStep& step);
> 	void SolveVelocityConstraints(const b2TimeStep& step);
> 	bool SolvePositionConstraints(float32 baumgarte);
78c80,81
< protected:
---
> 	b2Body* m_ground1;
> 	b2Body* m_ground2;
80,81c83,85
< 	friend class b2Joint;
< 	b2GearJoint(const b2GearJointDef* data);
---
> 	// One of these is NULL.
> 	b2RevoluteJoint* m_revolute1;
> 	b2PrismaticJoint* m_prismatic1;
83,102c87,89
< 	void InitVelocityConstraints(const b2SolverData& data);
< 	void SolveVelocityConstraints(const b2SolverData& data);
< 	bool SolvePositionConstraints(const b2SolverData& data);
< 
< 	b2Joint* m_joint1;
< 	b2Joint* m_joint2;
< 
< 	b2JointType m_typeA;
< 	b2JointType m_typeB;
< 
< 	// Body A is connected to body C
< 	// Body B is connected to body D
< 	b2Body* m_bodyC;
< 	b2Body* m_bodyD;
< 
< 	// Solver shared
< 	b2Vec2 m_localAnchorA;
< 	b2Vec2 m_localAnchorB;
< 	b2Vec2 m_localAnchorC;
< 	b2Vec2 m_localAnchorD;
---
> 	// One of these is NULL.
> 	b2RevoluteJoint* m_revolute2;
> 	b2PrismaticJoint* m_prismatic2;
104,105c91,92
< 	b2Vec2 m_localAxisC;
< 	b2Vec2 m_localAxisD;
---
> 	b2Vec2 m_groundAnchor1;
> 	b2Vec2 m_groundAnchor2;
107,108c94,97
< 	float32 m_referenceAngleA;
< 	float32 m_referenceAngleB;
---
> 	b2Vec2 m_localAnchor1;
> 	b2Vec2 m_localAnchor2;
> 
> 	b2Jacobian m_J;
113,121c102
< 	float32 m_impulse;
< 
< 	// Solver temp
< 	int32 m_indexA, m_indexB, m_indexC, m_indexD;
< 	b2Vec2 m_lcA, m_lcB, m_lcC, m_lcD;
< 	float32 m_mA, m_mB, m_mC, m_mD;
< 	float32 m_iA, m_iB, m_iC, m_iD;
< 	b2Vec2 m_JvAC, m_JvBD;
< 	float32 m_JwA, m_JwB, m_JwC, m_JwD;
---
> 	// Effective mass
122a104,106
> 
> 	// Impulse for accumulation/warm starting.
> 	float32 m_impulse;
diff -r -x './svn/*' native/Box2D/Dynamics/Joints/b2Joint.cpp ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Joints/b2Joint.cpp
2c2
< * Copyright (c) 2006-2007 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
19,33c19,30
< #include <Box2D/Dynamics/Joints/b2Joint.h>
< #include <Box2D/Dynamics/Joints/b2DistanceJoint.h>
< #include <Box2D/Dynamics/Joints/b2WheelJoint.h>
< #include <Box2D/Dynamics/Joints/b2MouseJoint.h>
< #include <Box2D/Dynamics/Joints/b2RevoluteJoint.h>
< #include <Box2D/Dynamics/Joints/b2PrismaticJoint.h>
< #include <Box2D/Dynamics/Joints/b2PulleyJoint.h>
< #include <Box2D/Dynamics/Joints/b2GearJoint.h>
< #include <Box2D/Dynamics/Joints/b2WeldJoint.h>
< #include <Box2D/Dynamics/Joints/b2FrictionJoint.h>
< #include <Box2D/Dynamics/Joints/b2RopeJoint.h>
< #include <Box2D/Dynamics/Joints/b2MotorJoint.h>
< #include <Box2D/Dynamics/b2Body.h>
< #include <Box2D/Dynamics/b2World.h>
< #include <Box2D/Common/b2BlockAllocator.h>
---
> #include "b2Joint.h"
> #include "b2DistanceJoint.h"
> #include "b2LineJoint.h"
> #include "b2MouseJoint.h"
> #include "b2RevoluteJoint.h"
> #include "b2PrismaticJoint.h"
> #include "b2PulleyJoint.h"
> #include "b2GearJoint.h"
> #include "../b2Body.h"
> #include "../b2World.h"
> #include "../../Common/b2BlockAllocator.h"
> #include "../../Collision/b2BroadPhase.h"
85c82
< 	case e_wheelJoint:
---
> 	case e_lineJoint:
87,116c84,85
< 			void* mem = allocator->Allocate(sizeof(b2WheelJoint));
< 			joint = new (mem) b2WheelJoint((b2WheelJointDef*)def);
< 		}
< 		break;
< 
< 	case e_weldJoint:
< 		{
< 			void* mem = allocator->Allocate(sizeof(b2WeldJoint));
< 			joint = new (mem) b2WeldJoint((b2WeldJointDef*)def);
< 		}
< 		break;
<         
< 	case e_frictionJoint:
< 		{
< 			void* mem = allocator->Allocate(sizeof(b2FrictionJoint));
< 			joint = new (mem) b2FrictionJoint((b2FrictionJointDef*)def);
< 		}
< 		break;
< 
< 	case e_ropeJoint:
< 		{
< 			void* mem = allocator->Allocate(sizeof(b2RopeJoint));
< 			joint = new (mem) b2RopeJoint((b2RopeJointDef*)def);
< 		}
< 		break;
< 
< 	case e_motorJoint:
< 		{
< 			void* mem = allocator->Allocate(sizeof(b2MotorJoint));
< 			joint = new (mem) b2MotorJoint((b2MotorJointDef*)def);
---
> 			void* mem = allocator->Allocate(sizeof(b2LineJoint));
> 			joint = new (mem) b2LineJoint((b2LineJointDef*)def);
157,174c126,127
< 	case e_wheelJoint:
< 		allocator->Free(joint, sizeof(b2WheelJoint));
< 		break;
<     
< 	case e_weldJoint:
< 		allocator->Free(joint, sizeof(b2WeldJoint));
< 		break;
< 
< 	case e_frictionJoint:
< 		allocator->Free(joint, sizeof(b2FrictionJoint));
< 		break;
< 
< 	case e_ropeJoint:
< 		allocator->Free(joint, sizeof(b2RopeJoint));
< 		break;
< 
< 	case e_motorJoint:
< 		allocator->Free(joint, sizeof(b2MotorJoint));
---
> 	case e_lineJoint:
> 		allocator->Free(joint, sizeof(b2LineJoint));
185,186d137
< 	b2Assert(def->bodyA != def->bodyB);
< 
190,192c141,142
< 	m_bodyA = def->bodyA;
< 	m_bodyB = def->bodyB;
< 	m_index = 0;
---
> 	m_body1 = def->body1;
> 	m_body2 = def->body2;
196,210d145
< 
< 	m_edgeA.joint = NULL;
< 	m_edgeA.other = NULL;
< 	m_edgeA.prev = NULL;
< 	m_edgeA.next = NULL;
< 
< 	m_edgeB.joint = NULL;
< 	m_edgeB.other = NULL;
< 	m_edgeB.prev = NULL;
< 	m_edgeB.next = NULL;
< }
< 
< bool b2Joint::IsActive() const
< {
< 	return m_bodyA->IsActive() && m_bodyB->IsActive();
diff -r -x './svn/*' native/Box2D/Dynamics/Joints/b2Joint.h ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Joints/b2Joint.h
2c2
< * Copyright (c) 2006-2007 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
19,20c19,20
< #ifndef B2_JOINT_H
< #define B2_JOINT_H
---
> #ifndef JOINT_H
> #define JOINT_H
22c22
< #include <Box2D/Common/b2Math.h>
---
> #include "../../Common/b2Math.h"
26c26
< struct b2SolverData;
---
> struct b2TimeStep;
38,42c38
< 	e_wheelJoint,
<     e_weldJoint,
< 	e_frictionJoint,
< 	e_ropeJoint,
< 	e_motorJoint
---
> 	e_lineJoint
55,57c51,58
< 	b2Vec2 linear;
< 	float32 angularA;
< 	float32 angularB;
---
> 	b2Vec2 linear1;
> 	float32 angular1;
> 	b2Vec2 linear2;
> 	float32 angular2;
> 
> 	void SetZero();
> 	void Set(const b2Vec2& x1, float32 a1, const b2Vec2& x2, float32 a2);
> 	float32 Compute(const b2Vec2& x1, float32 a1, const b2Vec2& x2, float32 a2);
80,81c81,82
< 		bodyA = NULL;
< 		bodyB = NULL;
---
> 		body1 = NULL;
> 		body2 = NULL;
92c93
< 	b2Body* bodyA;
---
> 	b2Body* body1;
95c96
< 	b2Body* bodyB;
---
> 	b2Body* body2;
111c112
< 	b2Body* GetBodyA();
---
> 	b2Body* GetBody1();
114c115
< 	b2Body* GetBodyB();
---
> 	b2Body* GetBody2();
116,117c117,118
< 	/// Get the anchor point on bodyA in world coordinates.
< 	virtual b2Vec2 GetAnchorA() const = 0;
---
> 	/// Get the anchor point on body1 in world coordinates.
> 	virtual b2Vec2 GetAnchor1() const = 0;
119,120c120,121
< 	/// Get the anchor point on bodyB in world coordinates.
< 	virtual b2Vec2 GetAnchorB() const = 0;
---
> 	/// Get the anchor point on body2 in world coordinates.
> 	virtual b2Vec2 GetAnchor2() const = 0;
122c123
< 	/// Get the reaction force on bodyB at the joint anchor in Newtons.
---
> 	/// Get the reaction force on body2 at the joint anchor.
125c126
< 	/// Get the reaction torque on bodyB in N*m.
---
> 	/// Get the reaction torque on body2.
130d130
< 	const b2Joint* GetNext() const;
133c133
< 	void* GetUserData() const;
---
> 	void* GetUserData();
138,151c138
< 	/// Short-cut function to determine if either body is inactive.
< 	bool IsActive() const;
< 
< 	/// Get collide connected.
< 	/// Note: modifying the collide connect flag won't work correctly because
< 	/// the flag is only checked when fixture AABBs begin to overlap.
< 	bool GetCollideConnected() const;
< 
< 	/// Dump this joint to the log file.
< 	virtual void Dump() { b2Log("// Dump is not supported for this joint type.\n"); }
< 
< 	/// Shift the origin for any points stored in world coordinates.
< 	virtual void ShiftOrigin(const b2Vec2& newOrigin) { B2_NOT_USED(newOrigin);  }
< 
---
> 	//--------------- Internals Below -------------------
156d142
< 	friend class b2GearJoint;
164,165c150,151
< 	virtual void InitVelocityConstraints(const b2SolverData& data) = 0;
< 	virtual void SolveVelocityConstraints(const b2SolverData& data) = 0;
---
> 	virtual void InitVelocityConstraints(const b2TimeStep& step) = 0;
> 	virtual void SolveVelocityConstraints(const b2TimeStep& step) = 0;
168c154,156
< 	virtual bool SolvePositionConstraints(const b2SolverData& data) = 0;
---
> 	virtual bool SolvePositionConstraints(float32 baumgarte) = 0;
> 
> 	void ComputeXForm(b2XForm* xf, const b2Vec2& center, const b2Vec2& localCenter, float32 angle) const;
173,178c161,164
< 	b2JointEdge m_edgeA;
< 	b2JointEdge m_edgeB;
< 	b2Body* m_bodyA;
< 	b2Body* m_bodyB;
< 
< 	int32 m_index;
---
> 	b2JointEdge m_node1;
> 	b2JointEdge m_node2;
> 	b2Body* m_body1;
> 	b2Body* m_body2;
183a170,174
> 
> 	// Cache here per time step to reduce cache misses.
> 	b2Vec2 m_localCenter1, m_localCenter2;
> 	float32 m_invMass1, m_invI1;
> 	float32 m_invMass2, m_invI2;
186c177
< inline b2JointType b2Joint::GetType() const
---
> inline void b2Jacobian::SetZero()
188c179,180
< 	return m_type;
---
> 	linear1.SetZero(); angular1 = 0.0f;
> 	linear2.SetZero(); angular2 = 0.0f;
191c183
< inline b2Body* b2Joint::GetBodyA()
---
> inline void b2Jacobian::Set(const b2Vec2& x1, float32 a1, const b2Vec2& x2, float32 a2)
193c185,186
< 	return m_bodyA;
---
> 	linear1 = x1; angular1 = a1;
> 	linear2 = x2; angular2 = a2;
196c189
< inline b2Body* b2Joint::GetBodyB()
---
> inline float32 b2Jacobian::Compute(const b2Vec2& x1, float32 a1, const b2Vec2& x2, float32 a2)
198c191
< 	return m_bodyB;
---
> 	return b2Dot(linear1, x1) + angular1 * a1 + b2Dot(linear2, x2) + angular2 * a2;
201c194
< inline b2Joint* b2Joint::GetNext()
---
> inline b2JointType b2Joint::GetType() const
203c196,201
< 	return m_next;
---
> 	return m_type;
> }
> 
> inline b2Body* b2Joint::GetBody1()
> {
> 	return m_body1;
206c204,209
< inline const b2Joint* b2Joint::GetNext() const
---
> inline b2Body* b2Joint::GetBody2()
> {
> 	return m_body2;
> }
> 
> inline b2Joint* b2Joint::GetNext()
211c214
< inline void* b2Joint::GetUserData() const
---
> inline void* b2Joint::GetUserData()
221c224
< inline bool b2Joint::GetCollideConnected() const
---
> inline void b2Joint::ComputeXForm(b2XForm* xf, const b2Vec2& center, const b2Vec2& localCenter, float32 angle) const
223c226,227
< 	return m_collideConnected;
---
> 	xf->R.Set(angle);
> 	xf->position = center - b2Mul(xf->R, localCenter);
Only in ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Joints: b2LineJoint.cpp
Only in ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Joints: b2LineJoint.h
Only in native/Box2D/Dynamics/Joints: b2MotorJoint.cpp
Only in native/Box2D/Dynamics/Joints: b2MotorJoint.h
diff -r -x './svn/*' native/Box2D/Dynamics/Joints/b2MouseJoint.cpp ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Joints/b2MouseJoint.cpp
2c2
< * Copyright (c) 2006-2007 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
19,21c19,21
< #include <Box2D/Dynamics/Joints/b2MouseJoint.h>
< #include <Box2D/Dynamics/b2Body.h>
< #include <Box2D/Dynamics/b2TimeStep.h>
---
> #include "b2MouseJoint.h"
> #include "../b2Body.h"
> #include "../b2World.h"
34,40c34,35
< 	b2Assert(def->target.IsValid());
< 	b2Assert(b2IsValid(def->maxForce) && def->maxForce >= 0.0f);
< 	b2Assert(b2IsValid(def->frequencyHz) && def->frequencyHz >= 0.0f);
< 	b2Assert(b2IsValid(def->dampingRatio) && def->dampingRatio >= 0.0f);
< 
< 	m_targetA = def->target;
< 	m_localAnchorB = b2MulT(m_bodyB->GetTransform(), m_targetA);
---
> 	m_target = def->target;
> 	m_localAnchor = b2MulT(m_body2->GetXForm(), m_target);
54c49
< 	if (m_bodyB->IsAwake() == false)
---
> 	if (m_body2->IsSleeping())
56c51
< 		m_bodyB->SetAwake(true);
---
> 		m_body2->WakeUp();
58,88c53
< 	m_targetA = target;
< }
< 
< const b2Vec2& b2MouseJoint::GetTarget() const
< {
< 	return m_targetA;
< }
< 
< void b2MouseJoint::SetMaxForce(float32 force)
< {
< 	m_maxForce = force;
< }
< 
< float32 b2MouseJoint::GetMaxForce() const
< {
< 	return m_maxForce;
< }
< 
< void b2MouseJoint::SetFrequency(float32 hz)
< {
< 	m_frequencyHz = hz;
< }
< 
< float32 b2MouseJoint::GetFrequency() const
< {
< 	return m_frequencyHz;
< }
< 
< void b2MouseJoint::SetDampingRatio(float32 ratio)
< {
< 	m_dampingRatio = ratio;
---
> 	m_target = target;
91c56
< float32 b2MouseJoint::GetDampingRatio() const
---
> void b2MouseJoint::InitVelocityConstraints(const b2TimeStep& step)
93,108c58
< 	return m_dampingRatio;
< }
< 
< void b2MouseJoint::InitVelocityConstraints(const b2SolverData& data)
< {
< 	m_indexB = m_bodyB->m_islandIndex;
< 	m_localCenterB = m_bodyB->m_sweep.localCenter;
< 	m_invMassB = m_bodyB->m_invMass;
< 	m_invIB = m_bodyB->m_invI;
< 
< 	b2Vec2 cB = data.positions[m_indexB].c;
< 	float32 aB = data.positions[m_indexB].a;
< 	b2Vec2 vB = data.velocities[m_indexB].v;
< 	float32 wB = data.velocities[m_indexB].w;
< 
< 	b2Rot qB(aB);
---
> 	b2Body* b = m_body2;
110c60
< 	float32 mass = m_bodyB->GetMass();
---
> 	float32 mass = b->GetMass();
124,131c74,76
< 	float32 h = data.step.dt;
< 	b2Assert(d + h * k > b2_epsilon);
< 	m_gamma = h * (d + h * k);
< 	if (m_gamma != 0.0f)
< 	{
< 		m_gamma = 1.0f / m_gamma;
< 	}
< 	m_beta = h * k * m_gamma;
---
> 	b2Assert(d + step.dt * k > B2_FLT_EPSILON);
> 	m_gamma = 1.0f / (step.dt * (d + step.dt * k));
> 	m_beta = step.dt * k * m_gamma;
134c79
< 	m_rB = b2Mul(qB, m_localAnchorB - m_localCenterB);
---
> 	b2Vec2 r = b2Mul(b->GetXForm().R, m_localAnchor - b->GetLocalCenter());
139,143c84,97
< 	b2Mat22 K;
< 	K.ex.x = m_invMassB + m_invIB * m_rB.y * m_rB.y + m_gamma;
< 	K.ex.y = -m_invIB * m_rB.x * m_rB.y;
< 	K.ey.x = K.ex.y;
< 	K.ey.y = m_invMassB + m_invIB * m_rB.x * m_rB.x + m_gamma;
---
> 	float32 invMass = b->m_invMass;
> 	float32 invI = b->m_invI;
> 
> 	b2Mat22 K1;
> 	K1.col1.x = invMass;	K1.col2.x = 0.0f;
> 	K1.col1.y = 0.0f;		K1.col2.y = invMass;
> 
> 	b2Mat22 K2;
> 	K2.col1.x =  invI * r.y * r.y;	K2.col2.x = -invI * r.x * r.y;
> 	K2.col1.y = -invI * r.x * r.y;	K2.col2.y =  invI * r.x * r.x;
> 
> 	b2Mat22 K = K1 + K2;
> 	K.col1.x += m_gamma;
> 	K.col2.y += m_gamma;
147,148c101
< 	m_C = cB + m_rB - m_targetA;
< 	m_C *= m_beta;
---
> 	m_C = b->m_sweep.c + r - m_target;
151c104
< 	wB *= 0.98f;
---
> 	b->m_angularVelocity *= 0.98f;
153,165c106,109
< 	if (data.step.warmStarting)
< 	{
< 		m_impulse *= data.step.dtRatio;
< 		vB += m_invMassB * m_impulse;
< 		wB += m_invIB * b2Cross(m_rB, m_impulse);
< 	}
< 	else
< 	{
< 		m_impulse.SetZero();
< 	}
< 
< 	data.velocities[m_indexB].v = vB;
< 	data.velocities[m_indexB].w = wB;
---
> 	// Warm starting.
> 	m_impulse *= step.dtRatio;
> 	b->m_linearVelocity += invMass * m_impulse;
> 	b->m_angularVelocity += invI * b2Cross(r, m_impulse);
168c112
< void b2MouseJoint::SolveVelocityConstraints(const b2SolverData& data)
---
> void b2MouseJoint::SolveVelocityConstraints(const b2TimeStep& step)
170,171c114,116
< 	b2Vec2 vB = data.velocities[m_indexB].v;
< 	float32 wB = data.velocities[m_indexB].w;
---
> 	b2Body* b = m_body2;
> 
> 	b2Vec2 r = b2Mul(b->GetXForm().R, m_localAnchor - b->GetLocalCenter());
174,175c119,120
< 	b2Vec2 Cdot = vB + b2Cross(wB, m_rB);
< 	b2Vec2 impulse = b2Mul(m_mass, -(Cdot + m_C + m_gamma * m_impulse));
---
> 	b2Vec2 Cdot = b->m_linearVelocity + b2Cross(b->m_angularVelocity, r);
> 	b2Vec2 impulse = b2Mul(m_mass, -(Cdot + m_beta * m_C + m_gamma * m_impulse));
179c124
< 	float32 maxImpulse = data.step.dt * m_maxForce;
---
> 	float32 maxImpulse = step.dt * m_maxForce;
186,190c131,132
< 	vB += m_invMassB * impulse;
< 	wB += m_invIB * b2Cross(m_rB, impulse);
< 
< 	data.velocities[m_indexB].v = vB;
< 	data.velocities[m_indexB].w = wB;
---
> 	b->m_linearVelocity += b->m_invMass * impulse;
> 	b->m_angularVelocity += b->m_invI * b2Cross(r, impulse);
193c135
< bool b2MouseJoint::SolvePositionConstraints(const b2SolverData& data)
---
> b2Vec2 b2MouseJoint::GetAnchor1() const
195,196c137
< 	B2_NOT_USED(data);
< 	return true;
---
> 	return m_target;
199c140
< b2Vec2 b2MouseJoint::GetAnchorA() const
---
> b2Vec2 b2MouseJoint::GetAnchor2() const
201,206c142
< 	return m_targetA;
< }
< 
< b2Vec2 b2MouseJoint::GetAnchorB() const
< {
< 	return m_bodyB->GetWorldPoint(m_localAnchorB);
---
> 	return m_body2->GetWorldPoint(m_localAnchor);
218,222d153
< 
< void b2MouseJoint::ShiftOrigin(const b2Vec2& newOrigin)
< {
< 	m_targetA -= newOrigin;
< }
diff -r -x './svn/*' native/Box2D/Dynamics/Joints/b2MouseJoint.h ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Joints/b2MouseJoint.h
2c2
< * Copyright (c) 2006-2007 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
22c22
< #include <Box2D/Dynamics/Joints/b2Joint.h>
---
> #include "b2Joint.h"
57,59d56
< /// NOTE: this joint is not documented in the manual because it was
< /// developed to be used in the testbed. If you want to learn how to
< /// use the mouse joint, look at the testbed.
65c62
< 	b2Vec2 GetAnchorA() const;
---
> 	b2Vec2 GetAnchor1() const;
68c65
< 	b2Vec2 GetAnchorB() const;
---
> 	b2Vec2 GetAnchor2() const;
78d74
< 	const b2Vec2& GetTarget() const;
80,99c76
< 	/// Set/get the maximum force in Newtons.
< 	void SetMaxForce(float32 force);
< 	float32 GetMaxForce() const;
< 
< 	/// Set/get the frequency in Hertz.
< 	void SetFrequency(float32 hz);
< 	float32 GetFrequency() const;
< 
< 	/// Set/get the damping ratio (dimensionless).
< 	void SetDampingRatio(float32 ratio);
< 	float32 GetDampingRatio() const;
< 
< 	/// The mouse joint does not support dumping.
< 	void Dump() { b2Log("Mouse joint dumping is not supported.\n"); }
< 
< 	/// Implement b2Joint::ShiftOrigin
< 	void ShiftOrigin(const b2Vec2& newOrigin);
< 
< protected:
< 	friend class b2Joint;
---
> 	//--------------- Internals Below -------------------
103,105c80,82
< 	void InitVelocityConstraints(const b2SolverData& data);
< 	void SolveVelocityConstraints(const b2SolverData& data);
< 	bool SolvePositionConstraints(const b2SolverData& data);
---
> 	void InitVelocityConstraints(const b2TimeStep& step);
> 	void SolveVelocityConstraints(const b2TimeStep& step);
> 	bool SolvePositionConstraints(float32 baumgarte) { B2_NOT_USED(baumgarte); return true; }
107,108c84,90
< 	b2Vec2 m_localAnchorB;
< 	b2Vec2 m_targetA;
---
> 	b2Vec2 m_localAnchor;
> 	b2Vec2 m_target;
> 	b2Vec2 m_impulse;
> 
> 	b2Mat22 m_mass;		// effective mass for point-to-point constraint.
> 	b2Vec2 m_C;				// position error
> 	float32 m_maxForce;
112,115d93
< 	
< 	// Solver shared
< 	b2Vec2 m_impulse;
< 	float32 m_maxForce;
117,126d94
< 
< 	// Solver temp
< 	int32 m_indexA;
< 	int32 m_indexB;
< 	b2Vec2 m_rB;
< 	b2Vec2 m_localCenterB;
< 	float32 m_invMassB;
< 	float32 m_invIB;
< 	b2Mat22 m_mass;
< 	b2Vec2 m_C;
diff -r -x './svn/*' native/Box2D/Dynamics/Joints/b2PrismaticJoint.cpp ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Joints/b2PrismaticJoint.cpp
2c2
< * Copyright (c) 2006-2011 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
19,21c19,21
< #include <Box2D/Dynamics/Joints/b2PrismaticJoint.h>
< #include <Box2D/Dynamics/b2Body.h>
< #include <Box2D/Dynamics/b2TimeStep.h>
---
> #include "b2PrismaticJoint.h"
> #include "../b2Body.h"
> #include "../b2World.h"
90c90
< void b2PrismaticJointDef::Initialize(b2Body* bA, b2Body* bB, const b2Vec2& anchor, const b2Vec2& axis)
---
> void b2PrismaticJointDef::Initialize(b2Body* b1, b2Body* b2, const b2Vec2& anchor, const b2Vec2& axis)
92,97c92,97
< 	bodyA = bA;
< 	bodyB = bB;
< 	localAnchorA = bodyA->GetLocalPoint(anchor);
< 	localAnchorB = bodyB->GetLocalPoint(anchor);
< 	localAxisA = bodyA->GetLocalVector(axis);
< 	referenceAngle = bodyB->GetAngle() - bodyA->GetAngle();
---
> 	body1 = b1;
> 	body2 = b2;
> 	localAnchor1 = body1->GetLocalPoint(anchor);
> 	localAnchor2 = body2->GetLocalPoint(anchor);
> 	localAxis1 = body1->GetLocalVector(axis);
> 	referenceAngle = body2->GetAngle() - body1->GetAngle();
103,108c103,107
< 	m_localAnchorA = def->localAnchorA;
< 	m_localAnchorB = def->localAnchorB;
< 	m_localXAxisA = def->localAxisA;
< 	m_localXAxisA.Normalize();
< 	m_localYAxisA = b2Cross(1.0f, m_localXAxisA);
< 	m_referenceAngle = def->referenceAngle;
---
> 	m_localAnchor1 = def->localAnchor1;
> 	m_localAnchor2 = def->localAnchor2;
> 	m_localXAxis1 = def->localAxis1;
> 	m_localYAxis1 = b2Cross(1.0f, m_localXAxis1);
> 	m_refAngle = def->referenceAngle;
111c110
< 	m_motorMass = 0.0f;
---
> 	m_motorMass = 0.0;
116c115
< 	m_maxMotorForce = def->maxMotorForce;
---
> 	m_maxMotorForce = B2FORCE_INV_SCALE(def->maxMotorForce);
126c125
< void b2PrismaticJoint::InitVelocityConstraints(const b2SolverData& data)
---
> void b2PrismaticJoint::InitVelocityConstraints(const b2TimeStep& step)
128,145c127,128
< 	m_indexA = m_bodyA->m_islandIndex;
< 	m_indexB = m_bodyB->m_islandIndex;
< 	m_localCenterA = m_bodyA->m_sweep.localCenter;
< 	m_localCenterB = m_bodyB->m_sweep.localCenter;
< 	m_invMassA = m_bodyA->m_invMass;
< 	m_invMassB = m_bodyB->m_invMass;
< 	m_invIA = m_bodyA->m_invI;
< 	m_invIB = m_bodyB->m_invI;
< 
< 	b2Vec2 cA = data.positions[m_indexA].c;
< 	float32 aA = data.positions[m_indexA].a;
< 	b2Vec2 vA = data.velocities[m_indexA].v;
< 	float32 wA = data.velocities[m_indexA].w;
< 
< 	b2Vec2 cB = data.positions[m_indexB].c;
< 	float32 aB = data.positions[m_indexB].a;
< 	b2Vec2 vB = data.velocities[m_indexB].v;
< 	float32 wB = data.velocities[m_indexB].w;
---
> 	b2Body* b1 = m_body1;
> 	b2Body* b2 = m_body2;
147c130,132
< 	b2Rot qA(aA), qB(aB);
---
> 	// You cannot create a prismatic joint between bodies that
> 	// both have fixed rotation.
> 	b2Assert(b1->m_invI > 0.0f || b2->m_invI > 0.0f);
149,152c134,138
< 	// Compute the effective masses.
< 	b2Vec2 rA = b2Mul(qA, m_localAnchorA - m_localCenterA);
< 	b2Vec2 rB = b2Mul(qB, m_localAnchorB - m_localCenterB);
< 	b2Vec2 d = (cB - cA) + rB - rA;
---
> 	m_localCenter1 = b1->GetLocalCenter();
> 	m_localCenter2 = b2->GetLocalCenter();
> 
> 	b2XForm xf1 = b1->GetXForm();
> 	b2XForm xf2 = b2->GetXForm();
154,155c140,148
< 	float32 mA = m_invMassA, mB = m_invMassB;
< 	float32 iA = m_invIA, iB = m_invIB;
---
> 	// Compute the effective masses.
> 	b2Vec2 r1 = b2Mul(xf1.R, m_localAnchor1 - m_localCenter1);
> 	b2Vec2 r2 = b2Mul(xf2.R, m_localAnchor2 - m_localCenter2);
> 	b2Vec2 d = b2->m_sweep.c + r2 - b1->m_sweep.c - r1;
> 
> 	m_invMass1 = b1->m_invMass;
> 	m_invI1 = b1->m_invI;
> 	m_invMass2 = b2->m_invMass;
> 	m_invI2 = b2->m_invI;
159,167c152,158
< 		m_axis = b2Mul(qA, m_localXAxisA);
< 		m_a1 = b2Cross(d + rA, m_axis);
< 		m_a2 = b2Cross(rB, m_axis);
< 
< 		m_motorMass = mA + mB + iA * m_a1 * m_a1 + iB * m_a2 * m_a2;
< 		if (m_motorMass > 0.0f)
< 		{
< 			m_motorMass = 1.0f / m_motorMass;
< 		}
---
> 		m_axis = b2Mul(xf1.R, m_localXAxis1);
> 		m_a1 = b2Cross(d + r1, m_axis);
> 		m_a2 = b2Cross(r2, m_axis);
> 
> 		m_motorMass = m_invMass1 + m_invMass2 + m_invI1 * m_a1 * m_a1 + m_invI2 * m_a2 * m_a2;
> 		b2Assert(m_motorMass > B2_FLT_EPSILON);
> 		m_motorMass = 1.0f / m_motorMass;
172c163
< 		m_perp = b2Mul(qA, m_localYAxisA);
---
> 		m_perp = b2Mul(xf1.R, m_localYAxis1);
174,175c165,166
< 		m_s1 = b2Cross(d + rA, m_perp);
< 		m_s2 = b2Cross(rB, m_perp);
---
> 		m_s1 = b2Cross(d + r1, m_perp);
> 		m_s2 = b2Cross(r2, m_perp);
177,187c168,169
< 		float32 k11 = mA + mB + iA * m_s1 * m_s1 + iB * m_s2 * m_s2;
< 		float32 k12 = iA * m_s1 + iB * m_s2;
< 		float32 k13 = iA * m_s1 * m_a1 + iB * m_s2 * m_a2;
< 		float32 k22 = iA + iB;
< 		if (k22 == 0.0f)
< 		{
< 			// For bodies with fixed rotation.
< 			k22 = 1.0f;
< 		}
< 		float32 k23 = iA * m_a1 + iB * m_a2;
< 		float32 k33 = mA + mB + iA * m_a1 * m_a1 + iB * m_a2 * m_a2;
---
> 		float32 m1 = m_invMass1, m2 = m_invMass2;
> 		float32 i1 = m_invI1, i2 = m_invI2;
189,191c171,180
< 		m_K.ex.Set(k11, k12, k13);
< 		m_K.ey.Set(k12, k22, k23);
< 		m_K.ez.Set(k13, k23, k33);
---
> 		float32 k11 = m1 + m2 + i1 * m_s1 * m_s1 + i2 * m_s2 * m_s2;
> 		float32 k12 = i1 * m_s1 + i2 * m_s2;
> 		float32 k13 = i1 * m_s1 * m_a1 + i2 * m_s2 * m_a2;
> 		float32 k22 = i1 + i2;
> 		float32 k23 = i1 * m_a1 + i2 * m_a2;
> 		float32 k33 = m1 + m2 + i1 * m_a1 * m_a1 + i2 * m_a2 * m_a2;
> 
> 		m_K.col1.Set(k11, k12, k13);
> 		m_K.col2.Set(k12, k22, k23);
> 		m_K.col3.Set(k13, k23, k33);
227d215
< 		m_impulse.z = 0.0f;
235c223
< 	if (data.step.warmStarting)
---
> 	if (step.warmStarting)
238,239c226,227
< 		m_impulse *= data.step.dtRatio;
< 		m_motorImpulse *= data.step.dtRatio;
---
> 		m_impulse *= step.dtRatio;
> 		m_motorImpulse *= step.dtRatio;
242,243c230,231
< 		float32 LA = m_impulse.x * m_s1 + m_impulse.y + (m_motorImpulse + m_impulse.z) * m_a1;
< 		float32 LB = m_impulse.x * m_s2 + m_impulse.y + (m_motorImpulse + m_impulse.z) * m_a2;
---
> 		float32 L1 = m_impulse.x * m_s1 + m_impulse.y + (m_motorImpulse + m_impulse.z) * m_a1;
> 		float32 L2 = m_impulse.x * m_s2 + m_impulse.y + (m_motorImpulse + m_impulse.z) * m_a2;
245,246c233,234
< 		vA -= mA * P;
< 		wA -= iA * LA;
---
> 		b1->m_linearVelocity -= m_invMass1 * P;
> 		b1->m_angularVelocity -= m_invI1 * L1;
248,249c236,237
< 		vB += mB * P;
< 		wB += iB * LB;
---
> 		b2->m_linearVelocity += m_invMass2 * P;
> 		b2->m_angularVelocity += m_invI2 * L2;
256,260d243
< 
< 	data.velocities[m_indexA].v = vA;
< 	data.velocities[m_indexA].w = wA;
< 	data.velocities[m_indexB].v = vB;
< 	data.velocities[m_indexB].w = wB;
263c246
< void b2PrismaticJoint::SolveVelocityConstraints(const b2SolverData& data)
---
> void b2PrismaticJoint::SolveVelocityConstraints(const b2TimeStep& step)
265,268c248,249
< 	b2Vec2 vA = data.velocities[m_indexA].v;
< 	float32 wA = data.velocities[m_indexA].w;
< 	b2Vec2 vB = data.velocities[m_indexB].v;
< 	float32 wB = data.velocities[m_indexB].w;
---
> 	b2Body* b1 = m_body1;
> 	b2Body* b2 = m_body2;
270,271c251,254
< 	float32 mA = m_invMassA, mB = m_invMassB;
< 	float32 iA = m_invIA, iB = m_invIB;
---
> 	b2Vec2 v1 = b1->m_linearVelocity;
> 	float32 w1 = b1->m_angularVelocity;
> 	b2Vec2 v2 = b2->m_linearVelocity;
> 	float32 w2 = b2->m_angularVelocity;
276c259
< 		float32 Cdot = b2Dot(m_axis, vB - vA) + m_a2 * wB - m_a1 * wA;
---
> 		float32 Cdot = b2Dot(m_axis, v2 - v1) + m_a2 * w2 - m_a1 * w1;
279c262
< 		float32 maxImpulse = data.step.dt * m_maxMotorForce;
---
> 		float32 maxImpulse = step.dt * m_maxMotorForce;
284,285c267,268
< 		float32 LA = impulse * m_a1;
< 		float32 LB = impulse * m_a2;
---
> 		float32 L1 = impulse * m_a1;
> 		float32 L2 = impulse * m_a2;
287,288c270,271
< 		vA -= mA * P;
< 		wA -= iA * LA;
---
> 		v1 -= m_invMass1 * P;
> 		w1 -= m_invI1 * L1;
290,291c273,274
< 		vB += mB * P;
< 		wB += iB * LB;
---
> 		v2 += m_invMass2 * P;
> 		w2 += m_invI2 * L2;
295,296c278,279
< 	Cdot1.x = b2Dot(m_perp, vB - vA) + m_s2 * wB - m_s1 * wA;
< 	Cdot1.y = wB - wA;
---
> 	Cdot1.x = b2Dot(m_perp, v2 - v1) + m_s2 * w2 - m_s1 * w1;
> 	Cdot1.y = w2 - w1;
302c285
< 		Cdot2 = b2Dot(m_axis, vB - vA) + m_a2 * wB - m_a1 * wA;
---
> 		Cdot2 = b2Dot(m_axis, v2 - v1) + m_a2 * w2 - m_a1 * w1;
319c302
< 		b2Vec2 b = -Cdot1 - (m_impulse.z - f1.z) * b2Vec2(m_K.ez.x, m_K.ez.y);
---
> 		b2Vec2 b = -Cdot1 - (m_impulse.z - f1.z) * b2Vec2(m_K.col3.x, m_K.col3.y);
327,328c310,311
< 		float32 LA = df.x * m_s1 + df.y + df.z * m_a1;
< 		float32 LB = df.x * m_s2 + df.y + df.z * m_a2;
---
> 		float32 L1 = df.x * m_s1 + df.y + df.z * m_a1;
> 		float32 L2 = df.x * m_s2 + df.y + df.z * m_a2;
330,331c313,314
< 		vA -= mA * P;
< 		wA -= iA * LA;
---
> 		v1 -= m_invMass1 * P;
> 		w1 -= m_invI1 * L1;
333,334c316,317
< 		vB += mB * P;
< 		wB += iB * LB;
---
> 		v2 += m_invMass2 * P;
> 		w2 += m_invI2 * L2;
344,345c327,328
< 		float32 LA = df.x * m_s1 + df.y;
< 		float32 LB = df.x * m_s2 + df.y;
---
> 		float32 L1 = df.x * m_s1 + df.y;
> 		float32 L2 = df.x * m_s2 + df.y;
347,348c330,331
< 		vA -= mA * P;
< 		wA -= iA * LA;
---
> 		v1 -= m_invMass1 * P;
> 		w1 -= m_invI1 * L1;
350,351c333,334
< 		vB += mB * P;
< 		wB += iB * LB;
---
> 		v2 += m_invMass2 * P;
> 		w2 += m_invI2 * L2;
354,357c337,340
< 	data.velocities[m_indexA].v = vA;
< 	data.velocities[m_indexA].w = wA;
< 	data.velocities[m_indexB].v = vB;
< 	data.velocities[m_indexB].w = wB;
---
> 	b1->m_linearVelocity = v1;
> 	b1->m_angularVelocity = w1;
> 	b2->m_linearVelocity = v2;
> 	b2->m_angularVelocity = w2;
360c343
< bool b2PrismaticJoint::SolvePositionConstraints(const b2SolverData& data)
---
> bool b2PrismaticJoint::SolvePositionConstraints(float32 baumgarte)
362,367c345
< 	b2Vec2 cA = data.positions[m_indexA].c;
< 	float32 aA = data.positions[m_indexA].a;
< 	b2Vec2 cB = data.positions[m_indexB].c;
< 	float32 aB = data.positions[m_indexB].a;
< 
< 	b2Rot qA(aA), qB(aB);
---
> 	B2_NOT_USED(baumgarte);
369,370c347,348
< 	float32 mA = m_invMassA, mB = m_invMassB;
< 	float32 iA = m_invIA, iB = m_invIB;
---
> 	b2Body* b1 = m_body1;
> 	b2Body* b2 = m_body2;
372,375c350,351
< 	// Compute fresh Jacobians
< 	b2Vec2 rA = b2Mul(qA, m_localAnchorA - m_localCenterA);
< 	b2Vec2 rB = b2Mul(qB, m_localAnchorB - m_localCenterB);
< 	b2Vec2 d = cB + rB - cA - rA;
---
> 	b2Vec2 c1 = b1->m_sweep.c;
> 	float32 a1 = b1->m_sweep.a;
377,380c353,354
< 	b2Vec2 axis = b2Mul(qA, m_localXAxisA);
< 	float32 a1 = b2Cross(d + rA, axis);
< 	float32 a2 = b2Cross(rB, axis);
< 	b2Vec2 perp = b2Mul(qA, m_localYAxisA);
---
> 	b2Vec2 c2 = b2->m_sweep.c;
> 	float32 a2 = b2->m_sweep.a;
382,383c356,359
< 	float32 s1 = b2Cross(d + rA, perp);
< 	float32 s2 = b2Cross(rB, perp);
---
> 	// Solve linear limit constraint.
> 	float32 linearError = 0.0f, angularError = 0.0f;
> 	bool active = false;
> 	float32 C2 = 0.0f;
385,388c361
< 	b2Vec3 impulse;
< 	b2Vec2 C1;
< 	C1.x = b2Dot(perp, d);
< 	C1.y = aB - aA - m_referenceAngle;
---
> 	b2Mat22 R1(a1), R2(a2);
390,391c363,365
< 	float32 linearError = b2Abs(C1.x);
< 	float32 angularError = b2Abs(C1.y);
---
> 	b2Vec2 r1 = b2Mul(R1, m_localAnchor1 - m_localCenter1);
> 	b2Vec2 r2 = b2Mul(R2, m_localAnchor2 - m_localCenter2);
> 	b2Vec2 d = c2 + r2 - c1 - r1;
393,394d366
< 	bool active = false;
< 	float32 C2 = 0.0f;
397c369,374
< 		float32 translation = b2Dot(axis, d);
---
> 		m_axis = b2Mul(R1, m_localXAxis1);
> 
> 		m_a1 = b2Cross(d + r1, m_axis);
> 		m_a2 = b2Cross(r2, m_axis);
> 
> 		float32 translation = b2Dot(m_axis, d);
402c379
< 			linearError = b2Max(linearError, b2Abs(translation));
---
> 			linearError = b2Abs(translation);
409c386
< 			linearError = b2Max(linearError, m_lowerTranslation - translation);
---
> 			linearError = m_lowerTranslation - translation;
416c393
< 			linearError = b2Max(linearError, translation - m_upperTranslation);
---
> 			linearError = translation - m_upperTranslation;
420a398,410
> 	m_perp = b2Mul(R1, m_localYAxis1);
> 
> 	m_s1 = b2Cross(d + r1, m_perp);
> 	m_s2 = b2Cross(r2, m_perp);
> 
> 	b2Vec3 impulse;
> 	b2Vec2 C1;
> 	C1.x = b2Dot(m_perp, d);
> 	C1.y = a2 - a1 - m_refAngle;
> 
> 	linearError = b2Max(linearError, b2Abs(C1.x));
> 	angularError = b2Abs(C1.y);
> 
423,433c413,414
< 		float32 k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2;
< 		float32 k12 = iA * s1 + iB * s2;
< 		float32 k13 = iA * s1 * a1 + iB * s2 * a2;
< 		float32 k22 = iA + iB;
< 		if (k22 == 0.0f)
< 		{
< 			// For fixed rotation
< 			k22 = 1.0f;
< 		}
< 		float32 k23 = iA * a1 + iB * a2;
< 		float32 k33 = mA + mB + iA * a1 * a1 + iB * a2 * a2;
---
> 		float32 m1 = m_invMass1, m2 = m_invMass2;
> 		float32 i1 = m_invI1, i2 = m_invI2;
435,438c416,425
< 		b2Mat33 K;
< 		K.ex.Set(k11, k12, k13);
< 		K.ey.Set(k12, k22, k23);
< 		K.ez.Set(k13, k23, k33);
---
> 		float32 k11 = m1 + m2 + i1 * m_s1 * m_s1 + i2 * m_s2 * m_s2;
> 		float32 k12 = i1 * m_s1 + i2 * m_s2;
> 		float32 k13 = i1 * m_s1 * m_a1 + i2 * m_s2 * m_a2;
> 		float32 k22 = i1 + i2;
> 		float32 k23 = i1 * m_a1 + i2 * m_a2;
> 		float32 k33 = m1 + m2 + i1 * m_a1 * m_a1 + i2 * m_a2 * m_a2;
> 
> 		m_K.col1.Set(k11, k12, k13);
> 		m_K.col2.Set(k12, k22, k23);
> 		m_K.col3.Set(k13, k23, k33);
445c432
< 		impulse = K.Solve33(-C);
---
> 		impulse = m_K.Solve33(-C);
449,455c436,437
< 		float32 k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2;
< 		float32 k12 = iA * s1 + iB * s2;
< 		float32 k22 = iA + iB;
< 		if (k22 == 0.0f)
< 		{
< 			k22 = 1.0f;
< 		}
---
> 		float32 m1 = m_invMass1, m2 = m_invMass2;
> 		float32 i1 = m_invI1, i2 = m_invI2;
457,459c439,441
< 		b2Mat22 K;
< 		K.ex.Set(k11, k12);
< 		K.ey.Set(k12, k22);
---
> 		float32 k11 = m1 + m2 + i1 * m_s1 * m_s1 + i2 * m_s2 * m_s2;
> 		float32 k12 = i1 * m_s1 + i2 * m_s2;
> 		float32 k22 = i1 + i2;
461c443,446
< 		b2Vec2 impulse1 = K.Solve(-C1);
---
> 		m_K.col1.Set(k11, k12, 0.0f);
> 		m_K.col2.Set(k12, k22, 0.0f);
> 
> 		b2Vec2 impulse1 = m_K.Solve22(-C1);
467,480c452,468
< 	b2Vec2 P = impulse.x * perp + impulse.z * axis;
< 	float32 LA = impulse.x * s1 + impulse.y + impulse.z * a1;
< 	float32 LB = impulse.x * s2 + impulse.y + impulse.z * a2;
< 
< 	cA -= mA * P;
< 	aA -= iA * LA;
< 	cB += mB * P;
< 	aB += iB * LB;
< 
< 	data.positions[m_indexA].c = cA;
< 	data.positions[m_indexA].a = aA;
< 	data.positions[m_indexB].c = cB;
< 	data.positions[m_indexB].a = aB;
< 
---
> 	b2Vec2 P = impulse.x * m_perp + impulse.z * m_axis;
> 	float32 L1 = impulse.x * m_s1 + impulse.y + impulse.z * m_a1;
> 	float32 L2 = impulse.x * m_s2 + impulse.y + impulse.z * m_a2;
> 
> 	c1 -= m_invMass1 * P;
> 	a1 -= m_invI1 * L1;
> 	c2 += m_invMass2 * P;
> 	a2 += m_invI2 * L2;
> 
> 	// TODO_ERIN remove need for this.
> 	b1->m_sweep.c = c1;
> 	b1->m_sweep.a = a1;
> 	b2->m_sweep.c = c2;
> 	b2->m_sweep.a = a2;
> 	b1->SynchronizeTransform();
> 	b2->SynchronizeTransform();
> 	
484c472
< b2Vec2 b2PrismaticJoint::GetAnchorA() const
---
> b2Vec2 b2PrismaticJoint::GetAnchor1() const
486c474
< 	return m_bodyA->GetWorldPoint(m_localAnchorA);
---
> 	return m_body1->GetWorldPoint(m_localAnchor1);
489c477
< b2Vec2 b2PrismaticJoint::GetAnchorB() const
---
> b2Vec2 b2PrismaticJoint::GetAnchor2() const
491c479
< 	return m_bodyB->GetWorldPoint(m_localAnchorB);
---
> 	return m_body2->GetWorldPoint(m_localAnchor2);
506,509c494,500
< 	b2Vec2 pA = m_bodyA->GetWorldPoint(m_localAnchorA);
< 	b2Vec2 pB = m_bodyB->GetWorldPoint(m_localAnchorB);
< 	b2Vec2 d = pB - pA;
< 	b2Vec2 axis = m_bodyA->GetWorldVector(m_localXAxisA);
---
> 	b2Body* b1 = m_body1;
> 	b2Body* b2 = m_body2;
> 
> 	b2Vec2 p1 = b1->GetWorldPoint(m_localAnchor1);
> 	b2Vec2 p2 = b2->GetWorldPoint(m_localAnchor2);
> 	b2Vec2 d = p2 - p1;
> 	b2Vec2 axis = b1->GetWorldVector(m_localXAxis1);
517,518c508,509
< 	b2Body* bA = m_bodyA;
< 	b2Body* bB = m_bodyB;
---
> 	b2Body* b1 = m_body1;
> 	b2Body* b2 = m_body2;
520,523c511,514
< 	b2Vec2 rA = b2Mul(bA->m_xf.q, m_localAnchorA - bA->m_sweep.localCenter);
< 	b2Vec2 rB = b2Mul(bB->m_xf.q, m_localAnchorB - bB->m_sweep.localCenter);
< 	b2Vec2 p1 = bA->m_sweep.c + rA;
< 	b2Vec2 p2 = bB->m_sweep.c + rB;
---
> 	b2Vec2 r1 = b2Mul(b1->GetXForm().R, m_localAnchor1 - b1->GetLocalCenter());
> 	b2Vec2 r2 = b2Mul(b2->GetXForm().R, m_localAnchor2 - b2->GetLocalCenter());
> 	b2Vec2 p1 = b1->m_sweep.c + r1;
> 	b2Vec2 p2 = b2->m_sweep.c + r2;
525c516
< 	b2Vec2 axis = b2Mul(bA->m_xf.q, m_localXAxisA);
---
> 	b2Vec2 axis = b1->GetWorldVector(m_localXAxis1);
527,530c518,521
< 	b2Vec2 vA = bA->m_linearVelocity;
< 	b2Vec2 vB = bB->m_linearVelocity;
< 	float32 wA = bA->m_angularVelocity;
< 	float32 wB = bB->m_angularVelocity;
---
> 	b2Vec2 v1 = b1->m_linearVelocity;
> 	b2Vec2 v2 = b2->m_linearVelocity;
> 	float32 w1 = b1->m_angularVelocity;
> 	float32 w2 = b2->m_angularVelocity;
532c523
< 	float32 speed = b2Dot(d, b2Cross(wA, axis)) + b2Dot(axis, vB + b2Cross(wB, rB) - vA - b2Cross(wA, rA));
---
> 	float32 speed = b2Dot(d, b2Cross(w1, axis)) + b2Dot(axis, v2 + b2Cross(w2, r2) - v1 - b2Cross(w1, r1));
543,549c534,536
< 	if (flag != m_enableLimit)
< 	{
< 		m_bodyA->SetAwake(true);
< 		m_bodyB->SetAwake(true);
< 		m_enableLimit = flag;
< 		m_impulse.z = 0.0f;
< 	}
---
> 	m_body1->WakeUp();
> 	m_body2->WakeUp();
> 	m_enableLimit = flag;
565,572c552,555
< 	if (lower != m_lowerTranslation || upper != m_upperTranslation)
< 	{
< 		m_bodyA->SetAwake(true);
< 		m_bodyB->SetAwake(true);
< 		m_lowerTranslation = lower;
< 		m_upperTranslation = upper;
< 		m_impulse.z = 0.0f;
< 	}
---
> 	m_body1->WakeUp();
> 	m_body2->WakeUp();
> 	m_lowerTranslation = lower;
> 	m_upperTranslation = upper;
582,583c565,566
< 	m_bodyA->SetAwake(true);
< 	m_bodyB->SetAwake(true);
---
> 	m_body1->WakeUp();
> 	m_body2->WakeUp();
589,590c572,573
< 	m_bodyA->SetAwake(true);
< 	m_bodyB->SetAwake(true);
---
> 	m_body1->WakeUp();
> 	m_body2->WakeUp();
596,625c579,586
< 	m_bodyA->SetAwake(true);
< 	m_bodyB->SetAwake(true);
< 	m_maxMotorForce = force;
< }
< 
< float32 b2PrismaticJoint::GetMotorForce(float32 inv_dt) const
< {
< 	return inv_dt * m_motorImpulse;
< }
< 
< void b2PrismaticJoint::Dump()
< {
< 	int32 indexA = m_bodyA->m_islandIndex;
< 	int32 indexB = m_bodyB->m_islandIndex;
< 
< 	b2Log("  b2PrismaticJointDef jd;\n");
< 	b2Log("  jd.bodyA = bodies[%d];\n", indexA);
< 	b2Log("  jd.bodyB = bodies[%d];\n", indexB);
< 	b2Log("  jd.collideConnected = bool(%d);\n", m_collideConnected);
< 	b2Log("  jd.localAnchorA.Set(%.15lef, %.15lef);\n", m_localAnchorA.x, m_localAnchorA.y);
< 	b2Log("  jd.localAnchorB.Set(%.15lef, %.15lef);\n", m_localAnchorB.x, m_localAnchorB.y);
< 	b2Log("  jd.localAxisA.Set(%.15lef, %.15lef);\n", m_localXAxisA.x, m_localXAxisA.y);
< 	b2Log("  jd.referenceAngle = %.15lef;\n", m_referenceAngle);
< 	b2Log("  jd.enableLimit = bool(%d);\n", m_enableLimit);
< 	b2Log("  jd.lowerTranslation = %.15lef;\n", m_lowerTranslation);
< 	b2Log("  jd.upperTranslation = %.15lef;\n", m_upperTranslation);
< 	b2Log("  jd.enableMotor = bool(%d);\n", m_enableMotor);
< 	b2Log("  jd.motorSpeed = %.15lef;\n", m_motorSpeed);
< 	b2Log("  jd.maxMotorForce = %.15lef;\n", m_maxMotorForce);
< 	b2Log("  joints[%d] = m_world->CreateJoint(&jd);\n", m_index);
---
> 	m_body1->WakeUp();
> 	m_body2->WakeUp();
> 	m_maxMotorForce = B2FORCE_SCALE(float32(1.0))*force;
> }
> 
> float32 b2PrismaticJoint::GetMotorForce() const
> {
> 	return m_motorImpulse;
diff -r -x './svn/*' native/Box2D/Dynamics/Joints/b2PrismaticJoint.h ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Joints/b2PrismaticJoint.h
2c2
< * Copyright (c) 2006-2011 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
22c22
< #include <Box2D/Dynamics/Joints/b2Joint.h>
---
> #include "b2Joint.h"
35,37c35,37
< 		localAnchorA.SetZero();
< 		localAnchorB.SetZero();
< 		localAxisA.Set(1.0f, 0.0f);
---
> 		localAnchor1.SetZero();
> 		localAnchor2.SetZero();
> 		localAxis1.Set(1.0f, 0.0f);
48,49c48,49
< 	/// anchor and unit world axis.
< 	void Initialize(b2Body* bodyA, b2Body* bodyB, const b2Vec2& anchor, const b2Vec2& axis);
---
> 	/// anchor and world axis.
> 	void Initialize(b2Body* body1, b2Body* body2, const b2Vec2& anchor, const b2Vec2& axis);
51,52c51,52
< 	/// The local anchor point relative to bodyA's origin.
< 	b2Vec2 localAnchorA;
---
> 	/// The local anchor point relative to body1's origin.
> 	b2Vec2 localAnchor1;
54,55c54,55
< 	/// The local anchor point relative to bodyB's origin.
< 	b2Vec2 localAnchorB;
---
> 	/// The local anchor point relative to body2's origin.
> 	b2Vec2 localAnchor2;
57,58c57,58
< 	/// The local translation unit axis in bodyA.
< 	b2Vec2 localAxisA;
---
> 	/// The local translation axis in body1.
> 	b2Vec2 localAxis1;
60c60
< 	/// The constrained angle between the bodies: bodyB_angle - bodyA_angle.
---
> 	/// The constrained angle between the bodies: body2_angle - body1_angle.
83c83
< /// along an axis fixed in bodyA. Relative rotation is prevented. You can
---
> /// along an axis fixed in body1. Relative rotation is prevented. You can
89,90c89,90
< 	b2Vec2 GetAnchorA() const;
< 	b2Vec2 GetAnchorB() const;
---
> 	b2Vec2 GetAnchor1() const;
> 	b2Vec2 GetAnchor2() const;
95,106d94
< 	/// The local anchor point relative to bodyA's origin.
< 	const b2Vec2& GetLocalAnchorA() const { return m_localAnchorA; }
< 
< 	/// The local anchor point relative to bodyB's origin.
< 	const b2Vec2& GetLocalAnchorB() const  { return m_localAnchorB; }
< 
< 	/// The local joint axis relative to bodyA.
< 	const b2Vec2& GetLocalAxisA() const { return m_localXAxisA; }
< 
< 	/// Get the reference angle.
< 	float32 GetReferenceAngle() const { return m_referenceAngle; }
< 
142d129
< 	float32 GetMaxMotorForce() const { return m_maxMotorForce; }
144,145c131,132
< 	/// Get the current motor force given the inverse time step, usually in N.
< 	float32 GetMotorForce(float32 inv_dt) const;
---
> 	/// Get the current motor force, usually in N.
> 	float32 GetMotorForce() const;
147,148c134
< 	/// Dump to b2Log
< 	void Dump();
---
> 	//--------------- Internals Below -------------------
150,152d135
< protected:
< 	friend class b2Joint;
< 	friend class b2GearJoint;
155,164c138,152
< 	void InitVelocityConstraints(const b2SolverData& data);
< 	void SolveVelocityConstraints(const b2SolverData& data);
< 	bool SolvePositionConstraints(const b2SolverData& data);
< 
< 	// Solver shared
< 	b2Vec2 m_localAnchorA;
< 	b2Vec2 m_localAnchorB;
< 	b2Vec2 m_localXAxisA;
< 	b2Vec2 m_localYAxisA;
< 	float32 m_referenceAngle;
---
> 	void InitVelocityConstraints(const b2TimeStep& step);
> 	void SolveVelocityConstraints(const b2TimeStep& step);
> 	bool SolvePositionConstraints(float32 baumgarte);
> 
> 	b2Vec2 m_localAnchor1;
> 	b2Vec2 m_localAnchor2;
> 	b2Vec2 m_localXAxis1;
> 	b2Vec2 m_localYAxis1;
> 	float32 m_refAngle;
> 
> 	b2Vec2 m_axis, m_perp;
> 	float32 m_s1, m_s2;
> 	float32 m_a1, m_a2;
> 
> 	b2Mat33 m_K;
165a154,155
> 
> 	float32 m_motorMass;			// effective mass for motor/limit translational constraint.
166a157
> 
170a162
> 	
174,188d165
< 
< 	// Solver temp
< 	int32 m_indexA;
< 	int32 m_indexB;
< 	b2Vec2 m_localCenterA;
< 	b2Vec2 m_localCenterB;
< 	float32 m_invMassA;
< 	float32 m_invMassB;
< 	float32 m_invIA;
< 	float32 m_invIB;
< 	b2Vec2 m_axis, m_perp;
< 	float32 m_s1, m_s2;
< 	float32 m_a1, m_a2;
< 	b2Mat33 m_K;
< 	float32 m_motorMass;
diff -r -x './svn/*' native/Box2D/Dynamics/Joints/b2PulleyJoint.cpp ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Joints/b2PulleyJoint.cpp
2c2
< * Copyright (c) 2007 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2007 Erin Catto http://www.gphysics.com
19,21c19,21
< #include <Box2D/Dynamics/Joints/b2PulleyJoint.h>
< #include <Box2D/Dynamics/b2Body.h>
< #include <Box2D/Dynamics/b2TimeStep.h>
---
> #include "b2PulleyJoint.h"
> #include "../b2Body.h"
> #include "../b2World.h"
27c27
< // C = C0 - (length1 + ratio * length2)
---
> // C = C0 - (length1 + ratio * length2) >= 0
34,37c34,44
< 
< void b2PulleyJointDef::Initialize(b2Body* bA, b2Body* bB,
< 				const b2Vec2& groundA, const b2Vec2& groundB,
< 				const b2Vec2& anchorA, const b2Vec2& anchorB,
---
> //
> // Limit:
> // C = maxLength - length
> // u = (p - s) / norm(p - s)
> // Cdot = -dot(u, v + cross(w, r))
> // K = invMass + invI * cross(r, u)^2
> // 0 <= impulse
> 
> void b2PulleyJointDef::Initialize(b2Body* b1, b2Body* b2,
> 				const b2Vec2& ga1, const b2Vec2& ga2,
> 				const b2Vec2& anchor1, const b2Vec2& anchor2,
40,49c47,56
< 	bodyA = bA;
< 	bodyB = bB;
< 	groundAnchorA = groundA;
< 	groundAnchorB = groundB;
< 	localAnchorA = bodyA->GetLocalPoint(anchorA);
< 	localAnchorB = bodyB->GetLocalPoint(anchorB);
< 	b2Vec2 dA = anchorA - groundA;
< 	lengthA = dA.Length();
< 	b2Vec2 dB = anchorB - groundB;
< 	lengthB = dB.Length();
---
> 	body1 = b1;
> 	body2 = b2;
> 	groundAnchor1 = ga1;
> 	groundAnchor2 = ga2;
> 	localAnchor1 = body1->GetLocalPoint(anchor1);
> 	localAnchor2 = body2->GetLocalPoint(anchor2);
> 	b2Vec2 d1 = anchor1 - ga1;
> 	length1 = d1.Length();
> 	b2Vec2 d2 = anchor2 - ga2;
> 	length2 = d2.Length();
51c58,61
< 	b2Assert(ratio > b2_epsilon);
---
> 	b2Assert(ratio > B2_FLT_EPSILON);
> 	float32 C = length1 + ratio * length2;
> 	maxLength1 = C - ratio * b2_minPulleyLength;
> 	maxLength2 = (C - b2_minPulleyLength) / ratio;
57,63c67,71
< 	m_groundAnchorA = def->groundAnchorA;
< 	m_groundAnchorB = def->groundAnchorB;
< 	m_localAnchorA = def->localAnchorA;
< 	m_localAnchorB = def->localAnchorB;
< 
< 	m_lengthA = def->lengthA;
< 	m_lengthB = def->lengthB;
---
> 	m_ground = m_body1->GetWorld()->GetGroundBody();
> 	m_groundAnchor1 = def->groundAnchor1 - m_ground->GetXForm().position;
> 	m_groundAnchor2 = def->groundAnchor2 - m_ground->GetXForm().position;
> 	m_localAnchor1 = def->localAnchor1;
> 	m_localAnchor2 = def->localAnchor2;
68c76,79
< 	m_constant = def->lengthA + m_ratio * def->lengthB;
---
> 	m_constant = def->length1 + m_ratio * def->length2;
> 
> 	m_maxLength1 = b2Min(def->maxLength1, m_constant - m_ratio * b2_minPulleyLength);
> 	m_maxLength2 = b2Min(def->maxLength2, (m_constant - b2_minPulleyLength) / m_ratio);
70a82,83
> 	m_limitImpulse1 = 0.0f;
> 	m_limitImpulse2 = 0.0f;
73c86
< void b2PulleyJoint::InitVelocityConstraints(const b2SolverData& data)
---
> void b2PulleyJoint::InitVelocityConstraints(const b2TimeStep& step)
75,92c88,89
< 	m_indexA = m_bodyA->m_islandIndex;
< 	m_indexB = m_bodyB->m_islandIndex;
< 	m_localCenterA = m_bodyA->m_sweep.localCenter;
< 	m_localCenterB = m_bodyB->m_sweep.localCenter;
< 	m_invMassA = m_bodyA->m_invMass;
< 	m_invMassB = m_bodyB->m_invMass;
< 	m_invIA = m_bodyA->m_invI;
< 	m_invIB = m_bodyB->m_invI;
< 
< 	b2Vec2 cA = data.positions[m_indexA].c;
< 	float32 aA = data.positions[m_indexA].a;
< 	b2Vec2 vA = data.velocities[m_indexA].v;
< 	float32 wA = data.velocities[m_indexA].w;
< 
< 	b2Vec2 cB = data.positions[m_indexB].c;
< 	float32 aB = data.positions[m_indexB].a;
< 	b2Vec2 vB = data.velocities[m_indexB].v;
< 	float32 wB = data.velocities[m_indexB].w;
---
> 	b2Body* b1 = m_body1;
> 	b2Body* b2 = m_body2;
94c91,92
< 	b2Rot qA(aA), qB(aB);
---
> 	b2Vec2 r1 = b2Mul(b1->GetXForm().R, m_localAnchor1 - b1->GetLocalCenter());
> 	b2Vec2 r2 = b2Mul(b2->GetXForm().R, m_localAnchor2 - b2->GetLocalCenter());
96,97c94,98
< 	m_rA = b2Mul(qA, m_localAnchorA - m_localCenterA);
< 	m_rB = b2Mul(qB, m_localAnchorB - m_localCenterB);
---
> 	b2Vec2 p1 = b1->m_sweep.c + r1;
> 	b2Vec2 p2 = b2->m_sweep.c + r2;
> 
> 	b2Vec2 s1 = m_ground->GetXForm().position + m_groundAnchor1;
> 	b2Vec2 s2 = m_ground->GetXForm().position + m_groundAnchor2;
100,101c101,102
< 	m_uA = cA + m_rA - m_groundAnchorA;
< 	m_uB = cB + m_rB - m_groundAnchorB;
---
> 	m_u1 = p1 - s1;
> 	m_u2 = p2 - s2;
103,104c104,105
< 	float32 lengthA = m_uA.Length();
< 	float32 lengthB = m_uB.Length();
---
> 	float32 length1 = m_u1.Length();
> 	float32 length2 = m_u2.Length();
106c107
< 	if (lengthA > 10.0f * b2_linearSlop)
---
> 	if (length1 > b2_linearSlop)
108c109
< 		m_uA *= 1.0f / lengthA;
---
> 		m_u1 *= 1.0f / length1;
112c113
< 		m_uA.SetZero();
---
> 		m_u1.SetZero();
115c116
< 	if (lengthB > 10.0f * b2_linearSlop)
---
> 	if (length2 > b2_linearSlop)
117c118
< 		m_uB *= 1.0f / lengthB;
---
> 		m_u2 *= 1.0f / length2;
121c122
< 		m_uB.SetZero();
---
> 		m_u2.SetZero();
124,129c125,134
< 	// Compute effective mass.
< 	float32 ruA = b2Cross(m_rA, m_uA);
< 	float32 ruB = b2Cross(m_rB, m_uB);
< 
< 	float32 mA = m_invMassA + m_invIA * ruA * ruA;
< 	float32 mB = m_invMassB + m_invIB * ruB * ruB;
---
> 	float32 C = m_constant - length1 - m_ratio * length2;
> 	if (C > 0.0f)
> 	{
> 		m_state = e_inactiveLimit;
> 		m_impulse = 0.0f;
> 	}
> 	else
> 	{
> 		m_state = e_atUpperLimit;
> 	}
131c136,144
< 	m_mass = mA + m_ratio * m_ratio * mB;
---
> 	if (length1 < m_maxLength1)
> 	{
> 		m_limitState1 = e_inactiveLimit;
> 		m_limitImpulse1 = 0.0f;
> 	}
> 	else
> 	{
> 		m_limitState1 = e_atUpperLimit;
> 	}
133c146,151
< 	if (m_mass > 0.0f)
---
> 	if (length2 < m_maxLength2)
> 	{
> 		m_limitState2 = e_inactiveLimit;
> 		m_limitImpulse2 = 0.0f;
> 	}
> 	else
135c153
< 		m_mass = 1.0f / m_mass;
---
> 		m_limitState2 = e_atUpperLimit;
138c156,170
< 	if (data.step.warmStarting)
---
> 	// Compute effective mass.
> 	float32 cr1u1 = b2Cross(r1, m_u1);
> 	float32 cr2u2 = b2Cross(r2, m_u2);
> 
> 	m_limitMass1 = b1->m_invMass + b1->m_invI * cr1u1 * cr1u1;
> 	m_limitMass2 = b2->m_invMass + b2->m_invI * cr2u2 * cr2u2;
> 	m_pulleyMass = m_limitMass1 + m_ratio * m_ratio * m_limitMass2;
> 	b2Assert(m_limitMass1 > B2_FLT_EPSILON);
> 	b2Assert(m_limitMass2 > B2_FLT_EPSILON);
> 	b2Assert(m_pulleyMass > B2_FLT_EPSILON);
> 	m_limitMass1 = 1.0f / m_limitMass1;
> 	m_limitMass2 = 1.0f / m_limitMass2;
> 	m_pulleyMass = 1.0f / m_pulleyMass;
> 
> 	if (step.warmStarting)
141c173,175
< 		m_impulse *= data.step.dtRatio;
---
> 		m_impulse *= step.dtRatio;
> 		m_limitImpulse1 *= step.dtRatio;
> 		m_limitImpulse2 *= step.dtRatio;
144,150c178,183
< 		b2Vec2 PA = -(m_impulse) * m_uA;
< 		b2Vec2 PB = (-m_ratio * m_impulse) * m_uB;
< 
< 		vA += m_invMassA * PA;
< 		wA += m_invIA * b2Cross(m_rA, PA);
< 		vB += m_invMassB * PB;
< 		wB += m_invIB * b2Cross(m_rB, PB);
---
> 		b2Vec2 P1 = -(m_impulse + m_limitImpulse1) * m_u1;
> 		b2Vec2 P2 = (-m_ratio * m_impulse - m_limitImpulse2) * m_u2;
> 		b1->m_linearVelocity += b1->m_invMass * P1;
> 		b1->m_angularVelocity += b1->m_invI * b2Cross(r1, P1);
> 		b2->m_linearVelocity += b2->m_invMass * P2;
> 		b2->m_angularVelocity += b2->m_invI * b2Cross(r2, P2);
154a188,189
> 		m_limitImpulse1 = 0.0f;
> 		m_limitImpulse2 = 0.0f;
156,160d190
< 
< 	data.velocities[m_indexA].v = vA;
< 	data.velocities[m_indexA].w = wA;
< 	data.velocities[m_indexB].v = vB;
< 	data.velocities[m_indexB].w = wB;
163c193
< void b2PulleyJoint::SolveVelocityConstraints(const b2SolverData& data)
---
> void b2PulleyJoint::SolveVelocityConstraints(const b2TimeStep& step)
165,168c195
< 	b2Vec2 vA = data.velocities[m_indexA].v;
< 	float32 wA = data.velocities[m_indexA].w;
< 	b2Vec2 vB = data.velocities[m_indexB].v;
< 	float32 wB = data.velocities[m_indexB].w;
---
> 	B2_NOT_USED(step);
170,171c197,198
< 	b2Vec2 vpA = vA + b2Cross(wA, m_rA);
< 	b2Vec2 vpB = vB + b2Cross(wB, m_rB);
---
> 	b2Body* b1 = m_body1;
> 	b2Body* b2 = m_body2;
173,175c200,201
< 	float32 Cdot = -b2Dot(m_uA, vpA) - m_ratio * b2Dot(m_uB, vpB);
< 	float32 impulse = -m_mass * Cdot;
< 	m_impulse += impulse;
---
> 	b2Vec2 r1 = b2Mul(b1->GetXForm().R, m_localAnchor1 - b1->GetLocalCenter());
> 	b2Vec2 r2 = b2Mul(b2->GetXForm().R, m_localAnchor2 - b2->GetLocalCenter());
177,195c203,206
< 	b2Vec2 PA = -impulse * m_uA;
< 	b2Vec2 PB = -m_ratio * impulse * m_uB;
< 	vA += m_invMassA * PA;
< 	wA += m_invIA * b2Cross(m_rA, PA);
< 	vB += m_invMassB * PB;
< 	wB += m_invIB * b2Cross(m_rB, PB);
< 
< 	data.velocities[m_indexA].v = vA;
< 	data.velocities[m_indexA].w = wA;
< 	data.velocities[m_indexB].v = vB;
< 	data.velocities[m_indexB].w = wB;
< }
< 
< bool b2PulleyJoint::SolvePositionConstraints(const b2SolverData& data)
< {
< 	b2Vec2 cA = data.positions[m_indexA].c;
< 	float32 aA = data.positions[m_indexA].a;
< 	b2Vec2 cB = data.positions[m_indexB].c;
< 	float32 aB = data.positions[m_indexB].a;
---
> 	if (m_state == e_atUpperLimit)
> 	{
> 		b2Vec2 v1 = b1->m_linearVelocity + b2Cross(b1->m_angularVelocity, r1);
> 		b2Vec2 v2 = b2->m_linearVelocity + b2Cross(b2->m_angularVelocity, r2);
197c208,212
< 	b2Rot qA(aA), qB(aB);
---
> 		float32 Cdot = -b2Dot(m_u1, v1) - m_ratio * b2Dot(m_u2, v2);
> 		float32 impulse = m_pulleyMass * (-Cdot);
> 		float32 oldImpulse = m_impulse;
> 		m_impulse = b2Max(0.0f, m_impulse + impulse);
> 		impulse = m_impulse - oldImpulse;
199,200c214,220
< 	b2Vec2 rA = b2Mul(qA, m_localAnchorA - m_localCenterA);
< 	b2Vec2 rB = b2Mul(qB, m_localAnchorB - m_localCenterB);
---
> 		b2Vec2 P1 = -impulse * m_u1;
> 		b2Vec2 P2 = -m_ratio * impulse * m_u2;
> 		b1->m_linearVelocity += b1->m_invMass * P1;
> 		b1->m_angularVelocity += b1->m_invI * b2Cross(r1, P1);
> 		b2->m_linearVelocity += b2->m_invMass * P2;
> 		b2->m_angularVelocity += b2->m_invI * b2Cross(r2, P2);
> 	}
202,204c222,224
< 	// Get the pulley axes.
< 	b2Vec2 uA = cA + rA - m_groundAnchorA;
< 	b2Vec2 uB = cB + rB - m_groundAnchorB;
---
> 	if (m_limitState1 == e_atUpperLimit)
> 	{
> 		b2Vec2 v1 = b1->m_linearVelocity + b2Cross(b1->m_angularVelocity, r1);
206,207c226,230
< 	float32 lengthA = uA.Length();
< 	float32 lengthB = uB.Length();
---
> 		float32 Cdot = -b2Dot(m_u1, v1);
> 		float32 impulse = -m_limitMass1 * Cdot;
> 		float32 oldImpulse = m_limitImpulse1;
> 		m_limitImpulse1 = b2Max(0.0f, m_limitImpulse1 + impulse);
> 		impulse = m_limitImpulse1 - oldImpulse;
209,211c232,234
< 	if (lengthA > 10.0f * b2_linearSlop)
< 	{
< 		uA *= 1.0f / lengthA;
---
> 		b2Vec2 P1 = -impulse * m_u1;
> 		b1->m_linearVelocity += b1->m_invMass * P1;
> 		b1->m_angularVelocity += b1->m_invI * b2Cross(r1, P1);
213c236,237
< 	else
---
> 
> 	if (m_limitState2 == e_atUpperLimit)
215c239,249
< 		uA.SetZero();
---
> 		b2Vec2 v2 = b2->m_linearVelocity + b2Cross(b2->m_angularVelocity, r2);
> 
> 		float32 Cdot = -b2Dot(m_u2, v2);
> 		float32 impulse = -m_limitMass2 * Cdot;
> 		float32 oldImpulse = m_limitImpulse2;
> 		m_limitImpulse2 = b2Max(0.0f, m_limitImpulse2 + impulse);
> 		impulse = m_limitImpulse2 - oldImpulse;
> 
> 		b2Vec2 P2 = -impulse * m_u2;
> 		b2->m_linearVelocity += b2->m_invMass * P2;
> 		b2->m_angularVelocity += b2->m_invI * b2Cross(r2, P2);
216a251
> }
218c253,265
< 	if (lengthB > 10.0f * b2_linearSlop)
---
> bool b2PulleyJoint::SolvePositionConstraints(float32 baumgarte)
> {
> 	B2_NOT_USED(baumgarte);
> 
> 	b2Body* b1 = m_body1;
> 	b2Body* b2 = m_body2;
> 
> 	b2Vec2 s1 = m_ground->GetXForm().position + m_groundAnchor1;
> 	b2Vec2 s2 = m_ground->GetXForm().position + m_groundAnchor2;
> 
> 	float32 linearError = 0.0f;
> 
> 	if (m_state == e_atUpperLimit)
220c267,313
< 		uB *= 1.0f / lengthB;
---
> 		b2Vec2 r1 = b2Mul(b1->GetXForm().R, m_localAnchor1 - b1->GetLocalCenter());
> 		b2Vec2 r2 = b2Mul(b2->GetXForm().R, m_localAnchor2 - b2->GetLocalCenter());
> 
> 		b2Vec2 p1 = b1->m_sweep.c + r1;
> 		b2Vec2 p2 = b2->m_sweep.c + r2;
> 
> 		// Get the pulley axes.
> 		m_u1 = p1 - s1;
> 		m_u2 = p2 - s2;
> 
> 		float32 length1 = m_u1.Length();
> 		float32 length2 = m_u2.Length();
> 
> 		if (length1 > b2_linearSlop)
> 		{
> 			m_u1 *= 1.0f / length1;
> 		}
> 		else
> 		{
> 			m_u1.SetZero();
> 		}
> 
> 		if (length2 > b2_linearSlop)
> 		{
> 			m_u2 *= 1.0f / length2;
> 		}
> 		else
> 		{
> 			m_u2.SetZero();
> 		}
> 
> 		float32 C = m_constant - length1 - m_ratio * length2;
> 		linearError = b2Max(linearError, -C);
> 
> 		C = b2Clamp(C + b2_linearSlop, -b2_maxLinearCorrection, 0.0f);
> 		float32 impulse = -m_pulleyMass * C;
> 
> 		b2Vec2 P1 = -impulse * m_u1;
> 		b2Vec2 P2 = -m_ratio * impulse * m_u2;
> 
> 		b1->m_sweep.c += b1->m_invMass * P1;
> 		b1->m_sweep.a += b1->m_invI * b2Cross(r1, P1);
> 		b2->m_sweep.c += b2->m_invMass * P2;
> 		b2->m_sweep.a += b2->m_invI * b2Cross(r2, P2);
> 
> 		b1->SynchronizeTransform();
> 		b2->SynchronizeTransform();
222c315,316
< 	else
---
> 
> 	if (m_limitState1 == e_atUpperLimit)
224,225c318,319
< 		uB.SetZero();
< 	}
---
> 		b2Vec2 r1 = b2Mul(b1->GetXForm().R, m_localAnchor1 - b1->GetLocalCenter());
> 		b2Vec2 p1 = b1->m_sweep.c + r1;
227,229c321,322
< 	// Compute effective mass.
< 	float32 ruA = b2Cross(rA, uA);
< 	float32 ruB = b2Cross(rB, uB);
---
> 		m_u1 = p1 - s1;
> 		float32 length1 = m_u1.Length();
231,232c324,331
< 	float32 mA = m_invMassA + m_invIA * ruA * ruA;
< 	float32 mB = m_invMassB + m_invIB * ruB * ruB;
---
> 		if (length1 > b2_linearSlop)
> 		{
> 			m_u1 *= 1.0f / length1;
> 		}
> 		else
> 		{
> 			m_u1.SetZero();
> 		}
234c333,336
< 	float32 mass = mA + m_ratio * m_ratio * mB;
---
> 		float32 C = m_maxLength1 - length1;
> 		linearError = b2Max(linearError, -C);
> 		C = b2Clamp(C + b2_linearSlop, -b2_maxLinearCorrection, 0.0f);
> 		float32 impulse = -m_limitMass1 * C;
236,238c338,342
< 	if (mass > 0.0f)
< 	{
< 		mass = 1.0f / mass;
---
> 		b2Vec2 P1 = -impulse * m_u1;
> 		b1->m_sweep.c += b1->m_invMass * P1;
> 		b1->m_sweep.a += b1->m_invI * b2Cross(r1, P1);
> 
> 		b1->SynchronizeTransform();
241,242c345,348
< 	float32 C = m_constant - lengthA - m_ratio * lengthB;
< 	float32 linearError = b2Abs(C);
---
> 	if (m_limitState2 == e_atUpperLimit)
> 	{
> 		b2Vec2 r2 = b2Mul(b2->GetXForm().R, m_localAnchor2 - b2->GetLocalCenter());
> 		b2Vec2 p2 = b2->m_sweep.c + r2;
244c350,351
< 	float32 impulse = -mass * C;
---
> 		m_u2 = p2 - s2;
> 		float32 length2 = m_u2.Length();
246,247c353,360
< 	b2Vec2 PA = -impulse * uA;
< 	b2Vec2 PB = -m_ratio * impulse * uB;
---
> 		if (length2 > b2_linearSlop)
> 		{
> 			m_u2 *= 1.0f / length2;
> 		}
> 		else
> 		{
> 			m_u2.SetZero();
> 		}
249,252c362,365
< 	cA += m_invMassA * PA;
< 	aA += m_invIA * b2Cross(rA, PA);
< 	cB += m_invMassB * PB;
< 	aB += m_invIB * b2Cross(rB, PB);
---
> 		float32 C = m_maxLength2 - length2;
> 		linearError = b2Max(linearError, -C);
> 		C = b2Clamp(C + b2_linearSlop, -b2_maxLinearCorrection, 0.0f);
> 		float32 impulse = -m_limitMass2 * C;
254,257c367,372
< 	data.positions[m_indexA].c = cA;
< 	data.positions[m_indexA].a = aA;
< 	data.positions[m_indexB].c = cB;
< 	data.positions[m_indexB].a = aB;
---
> 		b2Vec2 P2 = -impulse * m_u2;
> 		b2->m_sweep.c += b2->m_invMass * P2;
> 		b2->m_sweep.a += b2->m_invI * b2Cross(r2, P2);
> 
> 		b2->SynchronizeTransform();
> 	}
262c377
< b2Vec2 b2PulleyJoint::GetAnchorA() const
---
> b2Vec2 b2PulleyJoint::GetAnchor1() const
264c379
< 	return m_bodyA->GetWorldPoint(m_localAnchorA);
---
> 	return m_body1->GetWorldPoint(m_localAnchor1);
267c382
< b2Vec2 b2PulleyJoint::GetAnchorB() const
---
> b2Vec2 b2PulleyJoint::GetAnchor2() const
269c384
< 	return m_bodyB->GetWorldPoint(m_localAnchorB);
---
> 	return m_body2->GetWorldPoint(m_localAnchor2);
274c389
< 	b2Vec2 P = m_impulse * m_uB;
---
> 	b2Vec2 P = m_impulse * m_u2;
284,289c399
< b2Vec2 b2PulleyJoint::GetGroundAnchorA() const
< {
< 	return m_groundAnchorA;
< }
< 
< b2Vec2 b2PulleyJoint::GetGroundAnchorB() const
---
> b2Vec2 b2PulleyJoint::GetGroundAnchor1() const
291c401
< 	return m_groundAnchorB;
---
> 	return m_ground->GetXForm().position + m_groundAnchor1;
294c404
< float32 b2PulleyJoint::GetLengthA() const
---
> b2Vec2 b2PulleyJoint::GetGroundAnchor2() const
296c406
< 	return m_lengthA;
---
> 	return m_ground->GetXForm().position + m_groundAnchor2;
299c409
< float32 b2PulleyJoint::GetLengthB() const
---
> float32 b2PulleyJoint::GetLength1() const
301,312c411,412
< 	return m_lengthB;
< }
< 
< float32 b2PulleyJoint::GetRatio() const
< {
< 	return m_ratio;
< }
< 
< float32 b2PulleyJoint::GetCurrentLengthA() const
< {
< 	b2Vec2 p = m_bodyA->GetWorldPoint(m_localAnchorA);
< 	b2Vec2 s = m_groundAnchorA;
---
> 	b2Vec2 p = m_body1->GetWorldPoint(m_localAnchor1);
> 	b2Vec2 s = m_ground->GetXForm().position + m_groundAnchor1;
317c417
< float32 b2PulleyJoint::GetCurrentLengthB() const
---
> float32 b2PulleyJoint::GetLength2() const
319,320c419,420
< 	b2Vec2 p = m_bodyB->GetWorldPoint(m_localAnchorB);
< 	b2Vec2 s = m_groundAnchorB;
---
> 	b2Vec2 p = m_body2->GetWorldPoint(m_localAnchor2);
> 	b2Vec2 s = m_ground->GetXForm().position + m_groundAnchor2;
325c425
< void b2PulleyJoint::Dump()
---
> float32 b2PulleyJoint::GetRatio() const
327,348c427,428
< 	int32 indexA = m_bodyA->m_islandIndex;
< 	int32 indexB = m_bodyB->m_islandIndex;
< 
< 	b2Log("  b2PulleyJointDef jd;\n");
< 	b2Log("  jd.bodyA = bodies[%d];\n", indexA);
< 	b2Log("  jd.bodyB = bodies[%d];\n", indexB);
< 	b2Log("  jd.collideConnected = bool(%d);\n", m_collideConnected);
< 	b2Log("  jd.groundAnchorA.Set(%.15lef, %.15lef);\n", m_groundAnchorA.x, m_groundAnchorA.y);
< 	b2Log("  jd.groundAnchorB.Set(%.15lef, %.15lef);\n", m_groundAnchorB.x, m_groundAnchorB.y);
< 	b2Log("  jd.localAnchorA.Set(%.15lef, %.15lef);\n", m_localAnchorA.x, m_localAnchorA.y);
< 	b2Log("  jd.localAnchorB.Set(%.15lef, %.15lef);\n", m_localAnchorB.x, m_localAnchorB.y);
< 	b2Log("  jd.lengthA = %.15lef;\n", m_lengthA);
< 	b2Log("  jd.lengthB = %.15lef;\n", m_lengthB);
< 	b2Log("  jd.ratio = %.15lef;\n", m_ratio);
< 	b2Log("  joints[%d] = m_world->CreateJoint(&jd);\n", m_index);
< }
< 
< void b2PulleyJoint::ShiftOrigin(const b2Vec2& newOrigin)
< {
< 	m_groundAnchorA -= newOrigin;
< 	m_groundAnchorB -= newOrigin;
< }
---
> 	return m_ratio;
> }
diff -r -x './svn/*' native/Box2D/Dynamics/Joints/b2PulleyJoint.h ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Joints/b2PulleyJoint.h
2c2
< * Copyright (c) 2006-2011 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
22c22
< #include <Box2D/Dynamics/Joints/b2Joint.h>
---
> #include "b2Joint.h"
27c27,28
< /// two dynamic body anchor points, and a pulley ratio.
---
> /// two dynamic body anchor points, max lengths for each side,
> /// and a pulley ratio.
33,38c34,41
< 		groundAnchorA.Set(-1.0f, 1.0f);
< 		groundAnchorB.Set(1.0f, 1.0f);
< 		localAnchorA.Set(-1.0f, 0.0f);
< 		localAnchorB.Set(1.0f, 0.0f);
< 		lengthA = 0.0f;
< 		lengthB = 0.0f;
---
> 		groundAnchor1.Set(-1.0f, 1.0f);
> 		groundAnchor2.Set(1.0f, 1.0f);
> 		localAnchor1.Set(-1.0f, 0.0f);
> 		localAnchor2.Set(1.0f, 0.0f);
> 		length1 = 0.0f;
> 		maxLength1 = 0.0f;
> 		length2 = 0.0f;
> 		maxLength2 = 0.0f;
44,46c47,49
< 	void Initialize(b2Body* bodyA, b2Body* bodyB,
< 					const b2Vec2& groundAnchorA, const b2Vec2& groundAnchorB,
< 					const b2Vec2& anchorA, const b2Vec2& anchorB,
---
> 	void Initialize(b2Body* body1, b2Body* body2,
> 					const b2Vec2& groundAnchor1, const b2Vec2& groundAnchor2,
> 					const b2Vec2& anchor1, const b2Vec2& anchor2,
50c53
< 	b2Vec2 groundAnchorA;
---
> 	b2Vec2 groundAnchor1;
53c56
< 	b2Vec2 groundAnchorB;
---
> 	b2Vec2 groundAnchor2;
55,56c58,59
< 	/// The local anchor point relative to bodyA's origin.
< 	b2Vec2 localAnchorA;
---
> 	/// The local anchor point relative to body1's origin.
> 	b2Vec2 localAnchor1;
58,59c61,62
< 	/// The local anchor point relative to bodyB's origin.
< 	b2Vec2 localAnchorB;
---
> 	/// The local anchor point relative to body2's origin.
> 	b2Vec2 localAnchor2;
61,62c64,65
< 	/// The a reference length for the segment attached to bodyA.
< 	float32 lengthA;
---
> 	/// The a reference length for the segment attached to body1.
> 	float32 length1;
64,65c67,74
< 	/// The a reference length for the segment attached to bodyB.
< 	float32 lengthB;
---
> 	/// The maximum length of the segment attached to body1.
> 	float32 maxLength1;
> 
> 	/// The a reference length for the segment attached to body2.
> 	float32 length2;
> 
> 	/// The maximum length of the segment attached to body2.
> 	float32 maxLength2;
75,78c84,85
< /// Warning: the pulley joint can get a bit squirrelly by itself. They often
< /// work better when combined with prismatic joints. You should also cover the
< /// the anchor points with static shapes to prevent one side from going to
< /// zero length.
---
> /// The pulley also enforces a maximum length limit on both sides. This is
> /// useful to prevent one side of the pulley hitting the top.
82,83c89,90
< 	b2Vec2 GetAnchorA() const;
< 	b2Vec2 GetAnchorB() const;
---
> 	b2Vec2 GetAnchor1() const;
> 	b2Vec2 GetAnchor2() const;
89c96
< 	b2Vec2 GetGroundAnchorA() const;
---
> 	b2Vec2 GetGroundAnchor1() const;
92c99
< 	b2Vec2 GetGroundAnchorB() const;
---
> 	b2Vec2 GetGroundAnchor2() const;
94,95c101,102
< 	/// Get the current length of the segment attached to bodyA.
< 	float32 GetLengthA() const;
---
> 	/// Get the current length of the segment attached to body1.
> 	float32 GetLength1() const;
97,98c104,105
< 	/// Get the current length of the segment attached to bodyB.
< 	float32 GetLengthB() const;
---
> 	/// Get the current length of the segment attached to body2.
> 	float32 GetLength2() const;
103,113c110
< 	/// Get the current length of the segment attached to bodyA.
< 	float32 GetCurrentLengthA() const;
< 
< 	/// Get the current length of the segment attached to bodyB.
< 	float32 GetCurrentLengthB() const;
< 
< 	/// Dump joint to dmLog
< 	void Dump();
< 
< 	/// Implement b2Joint::ShiftOrigin
< 	void ShiftOrigin(const b2Vec2& newOrigin);
---
> 	//--------------- Internals Below -------------------
115,117d111
< protected:
< 
< 	friend class b2Joint;
120,127c114,125
< 	void InitVelocityConstraints(const b2SolverData& data);
< 	void SolveVelocityConstraints(const b2SolverData& data);
< 	bool SolvePositionConstraints(const b2SolverData& data);
< 
< 	b2Vec2 m_groundAnchorA;
< 	b2Vec2 m_groundAnchorB;
< 	float32 m_lengthA;
< 	float32 m_lengthB;
---
> 	void InitVelocityConstraints(const b2TimeStep& step);
> 	void SolveVelocityConstraints(const b2TimeStep& step);
> 	bool SolvePositionConstraints(float32 baumgarte);
> 
> 	b2Body* m_ground;
> 	b2Vec2 m_groundAnchor1;
> 	b2Vec2 m_groundAnchor2;
> 	b2Vec2 m_localAnchor1;
> 	b2Vec2 m_localAnchor2;
> 
> 	b2Vec2 m_u1;
> 	b2Vec2 m_u2;
129,131d126
< 	// Solver shared
< 	b2Vec2 m_localAnchorA;
< 	b2Vec2 m_localAnchorB;
133a129,138
> 	
> 	float32 m_maxLength1;
> 	float32 m_maxLength2;
> 
> 	// Effective masses
> 	float32 m_pulleyMass;
> 	float32 m_limitMass1;
> 	float32 m_limitMass2;
> 
> 	// Impulses for accumulation/warm starting.
134a140,141
> 	float32 m_limitImpulse1;
> 	float32 m_limitImpulse2;
136,149c143,145
< 	// Solver temp
< 	int32 m_indexA;
< 	int32 m_indexB;
< 	b2Vec2 m_uA;
< 	b2Vec2 m_uB;
< 	b2Vec2 m_rA;
< 	b2Vec2 m_rB;
< 	b2Vec2 m_localCenterA;
< 	b2Vec2 m_localCenterB;
< 	float32 m_invMassA;
< 	float32 m_invMassB;
< 	float32 m_invIA;
< 	float32 m_invIB;
< 	float32 m_mass;
---
> 	b2LimitState m_state;
> 	b2LimitState m_limitState1;
> 	b2LimitState m_limitState2;
diff -r -x './svn/*' native/Box2D/Dynamics/Joints/b2RevoluteJoint.cpp ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Joints/b2RevoluteJoint.cpp
2c2
< * Copyright (c) 2006-2011 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
19,21c19,23
< #include <Box2D/Dynamics/Joints/b2RevoluteJoint.h>
< #include <Box2D/Dynamics/b2Body.h>
< #include <Box2D/Dynamics/b2TimeStep.h>
---
> #include "b2RevoluteJoint.h"
> #include "../b2Body.h"
> #include "../b2World.h"
> 
> #include "../b2Island.h"
36c38
< void b2RevoluteJointDef::Initialize(b2Body* bA, b2Body* bB, const b2Vec2& anchor)
---
> void b2RevoluteJointDef::Initialize(b2Body* b1, b2Body* b2, const b2Vec2& anchor)
38,42c40,44
< 	bodyA = bA;
< 	bodyB = bB;
< 	localAnchorA = bodyA->GetLocalPoint(anchor);
< 	localAnchorB = bodyB->GetLocalPoint(anchor);
< 	referenceAngle = bodyB->GetAngle() - bodyA->GetAngle();
---
> 	body1 = b1;
> 	body2 = b2;
> 	localAnchor1 = body1->GetLocalPoint(anchor);
> 	localAnchor2 = body2->GetLocalPoint(anchor);
> 	referenceAngle = body2->GetAngle() - body1->GetAngle();
48,49c50,51
< 	m_localAnchorA = def->localAnchorA;
< 	m_localAnchorB = def->localAnchorB;
---
> 	m_localAnchor1 = def->localAnchor1;
> 	m_localAnchor2 = def->localAnchor2;
64c66
< void b2RevoluteJoint::InitVelocityConstraints(const b2SolverData& data)
---
> void b2RevoluteJoint::InitVelocityConstraints(const b2TimeStep& step)
66,81c68,69
< 	m_indexA = m_bodyA->m_islandIndex;
< 	m_indexB = m_bodyB->m_islandIndex;
< 	m_localCenterA = m_bodyA->m_sweep.localCenter;
< 	m_localCenterB = m_bodyB->m_sweep.localCenter;
< 	m_invMassA = m_bodyA->m_invMass;
< 	m_invMassB = m_bodyB->m_invMass;
< 	m_invIA = m_bodyA->m_invI;
< 	m_invIB = m_bodyB->m_invI;
< 
< 	float32 aA = data.positions[m_indexA].a;
< 	b2Vec2 vA = data.velocities[m_indexA].v;
< 	float32 wA = data.velocities[m_indexA].w;
< 
< 	float32 aB = data.positions[m_indexB].a;
< 	b2Vec2 vB = data.velocities[m_indexB].v;
< 	float32 wB = data.velocities[m_indexB].w;
---
> 	b2Body* b1 = m_body1;
> 	b2Body* b2 = m_body2;
83c71,76
< 	b2Rot qA(aA), qB(aB);
---
> 	if (m_enableMotor || m_enableLimit)
> 	{
> 		// You cannot create a rotation limit between bodies that
> 		// both have fixed rotation.
> 		b2Assert(b1->m_invI > 0.0f || b2->m_invI > 0.0f);
> 	}
85,86c78,80
< 	m_rA = b2Mul(qA, m_localAnchorA - m_localCenterA);
< 	m_rB = b2Mul(qB, m_localAnchorB - m_localCenterB);
---
> 	// Compute the effective mass matrix.
> 	b2Vec2 r1 = b2Mul(b1->GetXForm().R, m_localAnchor1 - b1->GetLocalCenter());
> 	b2Vec2 r2 = b2Mul(b2->GetXForm().R, m_localAnchor2 - b2->GetLocalCenter());
93,100c87,102
< 	// K = [ mA+r1y^2*iA+mB+r2y^2*iB,  -r1y*iA*r1x-r2y*iB*r2x,          -r1y*iA-r2y*iB]
< 	//     [  -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB,           r1x*iA+r2x*iB]
< 	//     [          -r1y*iA-r2y*iB,           r1x*iA+r2x*iB,                   iA+iB]
< 
< 	float32 mA = m_invMassA, mB = m_invMassB;
< 	float32 iA = m_invIA, iB = m_invIB;
< 
< 	bool fixedRotation = (iA + iB == 0.0f);
---
> 	// K = [ m1+r1y^2*i1+m2+r2y^2*i2,  -r1y*i1*r1x-r2y*i2*r2x,          -r1y*i1-r2y*i2]
> 	//     [  -r1y*i1*r1x-r2y*i2*r2x, m1+r1x^2*i1+m2+r2x^2*i2,           r1x*i1+r2x*i2]
> 	//     [          -r1y*i1-r2y*i2,           r1x*i1+r2x*i2,                   i1+i2]
> 
> 	float32 m1 = b1->m_invMass, m2 = b2->m_invMass;
> 	float32 i1 = b1->m_invI, i2 = b2->m_invI;
> 
> 	m_mass.col1.x = m1 + m2 + r1.y * r1.y * i1 + r2.y * r2.y * i2;
> 	m_mass.col2.x = -r1.y * r1.x * i1 - r2.y * r2.x * i2;
> 	m_mass.col3.x = -r1.y * i1 - r2.y * i2;
> 	m_mass.col1.y = m_mass.col2.x;
> 	m_mass.col2.y = m1 + m2 + r1.x * r1.x * i1 + r2.x * r2.x * i2;
> 	m_mass.col3.y = r1.x * i1 + r2.x * i2;
> 	m_mass.col1.z = m_mass.col3.x;
> 	m_mass.col2.z = m_mass.col3.y;
> 	m_mass.col3.z = i1 + i2;
102,110c104
< 	m_mass.ex.x = mA + mB + m_rA.y * m_rA.y * iA + m_rB.y * m_rB.y * iB;
< 	m_mass.ey.x = -m_rA.y * m_rA.x * iA - m_rB.y * m_rB.x * iB;
< 	m_mass.ez.x = -m_rA.y * iA - m_rB.y * iB;
< 	m_mass.ex.y = m_mass.ey.x;
< 	m_mass.ey.y = mA + mB + m_rA.x * m_rA.x * iA + m_rB.x * m_rB.x * iB;
< 	m_mass.ez.y = m_rA.x * iA + m_rB.x * iB;
< 	m_mass.ex.z = m_mass.ez.x;
< 	m_mass.ey.z = m_mass.ez.y;
< 	m_mass.ez.z = iA + iB;
---
> 	m_motorMass = 1.0f / (i1 + i2);
112,118c106
< 	m_motorMass = iA + iB;
< 	if (m_motorMass > 0.0f)
< 	{
< 		m_motorMass = 1.0f / m_motorMass;
< 	}
< 
< 	if (m_enableMotor == false || fixedRotation)
---
> 	if (m_enableMotor == false)
123c111
< 	if (m_enableLimit && fixedRotation == false)
---
> 	if (m_enableLimit)
125c113
< 		float32 jointAngle = aB - aA - m_referenceAngle;
---
> 		float32 jointAngle = b2->m_sweep.a - b1->m_sweep.a - m_referenceAngle;
157c145
< 	if (data.step.warmStarting)
---
> 	if (step.warmStarting)
160,161c148,149
< 		m_impulse *= data.step.dtRatio;
< 		m_motorImpulse *= data.step.dtRatio;
---
> 		m_impulse *= step.dtRatio;
> 		m_motorImpulse *= step.dtRatio;
165,166c153,154
< 		vA -= mA * P;
< 		wA -= iA * (b2Cross(m_rA, P) + m_motorImpulse + m_impulse.z);
---
> 		b1->m_linearVelocity -= m1 * P;
> 		b1->m_angularVelocity -= i1 * (b2Cross(r1, P) + m_motorImpulse + m_impulse.z);
168,169c156,157
< 		vB += mB * P;
< 		wB += iB * (b2Cross(m_rB, P) + m_motorImpulse + m_impulse.z);
---
> 		b2->m_linearVelocity += m2 * P;
> 		b2->m_angularVelocity += i2 * (b2Cross(r2, P) + m_motorImpulse + m_impulse.z);
176,180d163
< 
< 	data.velocities[m_indexA].v = vA;
< 	data.velocities[m_indexA].w = wA;
< 	data.velocities[m_indexB].v = vB;
< 	data.velocities[m_indexB].w = wB;
183c166
< void b2RevoluteJoint::SolveVelocityConstraints(const b2SolverData& data)
---
> void b2RevoluteJoint::SolveVelocityConstraints(const b2TimeStep& step)
185,188c168,169
< 	b2Vec2 vA = data.velocities[m_indexA].v;
< 	float32 wA = data.velocities[m_indexA].w;
< 	b2Vec2 vB = data.velocities[m_indexB].v;
< 	float32 wB = data.velocities[m_indexB].w;
---
> 	b2Body* b1 = m_body1;
> 	b2Body* b2 = m_body2;
190,191c171,174
< 	float32 mA = m_invMassA, mB = m_invMassB;
< 	float32 iA = m_invIA, iB = m_invIB;
---
> 	b2Vec2 v1 = b1->m_linearVelocity;
> 	float32 w1 = b1->m_angularVelocity;
> 	b2Vec2 v2 = b2->m_linearVelocity;
> 	float32 w2 = b2->m_angularVelocity;
193c176,177
< 	bool fixedRotation = (iA + iB == 0.0f);
---
> 	float32 m1 = b1->m_invMass, m2 = b2->m_invMass;
> 	float32 i1 = b1->m_invI, i2 = b2->m_invI;
196c180
< 	if (m_enableMotor && m_limitState != e_equalLimits && fixedRotation == false)
---
> 	if (m_enableMotor && m_limitState != e_equalLimits)
198,199c182,183
< 		float32 Cdot = wB - wA - m_motorSpeed;
< 		float32 impulse = -m_motorMass * Cdot;
---
> 		float32 Cdot = w2 - w1 - m_motorSpeed;
> 		float32 impulse = m_motorMass * (-Cdot);
201c185
< 		float32 maxImpulse = data.step.dt * m_maxMotorTorque;
---
> 		float32 maxImpulse = step.dt * m_maxMotorTorque;
205,206c189,190
< 		wA -= iA * impulse;
< 		wB += iB * impulse;
---
> 		w1 -= i1 * impulse;
> 		w2 += i2 * impulse;
210c194
< 	if (m_enableLimit && m_limitState != e_inactiveLimit && fixedRotation == false)
---
> 	if (m_enableLimit && m_limitState != e_inactiveLimit)
212,213c196,201
< 		b2Vec2 Cdot1 = vB + b2Cross(wB, m_rB) - vA - b2Cross(wA, m_rA);
< 		float32 Cdot2 = wB - wA;
---
> 		b2Vec2 r1 = b2Mul(b1->GetXForm().R, m_localAnchor1 - b1->GetLocalCenter());
> 		b2Vec2 r2 = b2Mul(b2->GetXForm().R, m_localAnchor2 - b2->GetLocalCenter());
> 
> 		// Solve point-to-point constraint
> 		b2Vec2 Cdot1 = v2 + b2Cross(w2, r2) - v1 - b2Cross(w1, r1);
> 		float32 Cdot2 = w2 - w1;
216c204
< 		b2Vec3 impulse = -m_mass.Solve33(Cdot);
---
> 		b2Vec3 impulse = m_mass.Solve33(-Cdot);
227,228c215
< 				b2Vec2 rhs = -Cdot1 + m_impulse.z * b2Vec2(m_mass.ez.x, m_mass.ez.y);
< 				b2Vec2 reduced = m_mass.Solve22(rhs);
---
> 				b2Vec2 reduced = m_mass.Solve22(-Cdot1);
236,239d222
< 			else
< 			{
< 				m_impulse += impulse;
< 			}
246,247c229
< 				b2Vec2 rhs = -Cdot1 + m_impulse.z * b2Vec2(m_mass.ez.x, m_mass.ez.y);
< 				b2Vec2 reduced = m_mass.Solve22(rhs);
---
> 				b2Vec2 reduced = m_mass.Solve22(-Cdot1);
255,258d236
< 			else
< 			{
< 				m_impulse += impulse;
< 			}
263,264c241,242
< 		vA -= mA * P;
< 		wA -= iA * (b2Cross(m_rA, P) + impulse.z);
---
> 		v1 -= m1 * P;
> 		w1 -= i1 * (b2Cross(r1, P) + impulse.z);
266,267c244,245
< 		vB += mB * P;
< 		wB += iB * (b2Cross(m_rB, P) + impulse.z);
---
> 		v2 += m2 * P;
> 		w2 += i2 * (b2Cross(r2, P) + impulse.z);
270a249,251
> 		b2Vec2 r1 = b2Mul(b1->GetXForm().R, m_localAnchor1 - b1->GetLocalCenter());
> 		b2Vec2 r2 = b2Mul(b2->GetXForm().R, m_localAnchor2 - b2->GetLocalCenter());
> 
272c253
< 		b2Vec2 Cdot = vB + b2Cross(wB, m_rB) - vA - b2Cross(wA, m_rA);
---
> 		b2Vec2 Cdot = v2 + b2Cross(w2, r2) - v1 - b2Cross(w1, r1);
278,279c259,260
< 		vA -= mA * impulse;
< 		wA -= iA * b2Cross(m_rA, impulse);
---
> 		v1 -= m1 * impulse;
> 		w1 -= i1 * b2Cross(r1, impulse);
281,282c262,263
< 		vB += mB * impulse;
< 		wB += iB * b2Cross(m_rB, impulse);
---
> 		v2 += m2 * impulse;
> 		w2 += i2 * b2Cross(r2, impulse);
285,288c266,269
< 	data.velocities[m_indexA].v = vA;
< 	data.velocities[m_indexA].w = wA;
< 	data.velocities[m_indexB].v = vB;
< 	data.velocities[m_indexB].w = wB;
---
> 	b1->m_linearVelocity = v1;
> 	b1->m_angularVelocity = w1;
> 	b2->m_linearVelocity = v2;
> 	b2->m_angularVelocity = w2;
291c272
< bool b2RevoluteJoint::SolvePositionConstraints(const b2SolverData& data)
---
> bool b2RevoluteJoint::SolvePositionConstraints(float32 baumgarte)
293,296c274,276
< 	b2Vec2 cA = data.positions[m_indexA].c;
< 	float32 aA = data.positions[m_indexA].a;
< 	b2Vec2 cB = data.positions[m_indexB].c;
< 	float32 aB = data.positions[m_indexB].a;
---
> 	// TODO_ERIN block solve with limit.
> 
> 	B2_NOT_USED(baumgarte);
298c278,279
< 	b2Rot qA(aA), qB(aB);
---
> 	b2Body* b1 = m_body1;
> 	b2Body* b2 = m_body2;
303,304d283
< 	bool fixedRotation = (m_invIA + m_invIB == 0.0f);
< 
306c285
< 	if (m_enableLimit && m_limitState != e_inactiveLimit && fixedRotation == false)
---
> 	if (m_enableLimit && m_limitState != e_inactiveLimit)
308c287
< 		float32 angle = aB - aA - m_referenceAngle;
---
> 		float32 angle = b2->m_sweep.a - b1->m_sweep.a - m_referenceAngle;
337,338c316,320
< 		aA -= m_invIA * limitImpulse;
< 		aB += m_invIB * limitImpulse;
---
> 		b1->m_sweep.a -= b1->m_invI * limitImpulse;
> 		b2->m_sweep.a += b2->m_invI * limitImpulse;
> 
> 		b1->SynchronizeTransform();
> 		b2->SynchronizeTransform();
343,346c325,326
< 		qA.Set(aA);
< 		qB.Set(aB);
< 		b2Vec2 rA = b2Mul(qA, m_localAnchorA - m_localCenterA);
< 		b2Vec2 rB = b2Mul(qB, m_localAnchorB - m_localCenterB);
---
> 		b2Vec2 r1 = b2Mul(b1->GetXForm().R, m_localAnchor1 - b1->GetLocalCenter());
> 		b2Vec2 r2 = b2Mul(b2->GetXForm().R, m_localAnchor2 - b2->GetLocalCenter());
348c328
< 		b2Vec2 C = cB + rB - cA - rA;
---
> 		b2Vec2 C = b2->m_sweep.c + r2 - b1->m_sweep.c - r1;
351,352c331,332
< 		float32 mA = m_invMassA, mB = m_invMassB;
< 		float32 iA = m_invIA, iB = m_invIB;
---
> 		float32 invMass1 = b1->m_invMass, invMass2 = b2->m_invMass;
> 		float32 invI1 = b1->m_invI, invI2 = b2->m_invI;
354,358c334,346
< 		b2Mat22 K;
< 		K.ex.x = mA + mB + iA * rA.y * rA.y + iB * rB.y * rB.y;
< 		K.ex.y = -iA * rA.x * rA.y - iB * rB.x * rB.y;
< 		K.ey.x = K.ex.y;
< 		K.ey.y = mA + mB + iA * rA.x * rA.x + iB * rB.x * rB.x;
---
> 		// Handle large detachment.
> 		const float32 k_allowedStretch = 10.0f * b2_linearSlop;
> 		if (C.LengthSquared() > k_allowedStretch * k_allowedStretch)
> 		{
> 			// Use a particle solution (no rotation).
> 			b2Vec2 u = C; u.Normalize();
> 			float32 k = invMass1 + invMass2;
> 			b2Assert(k > B2_FLT_EPSILON);
> 			float32 m = 1.0f / k;
> 			b2Vec2 impulse = m * (-C);
> 			const float32 k_beta = 0.5f;
> 			b1->m_sweep.c -= k_beta * invMass1 * impulse;
> 			b2->m_sweep.c += k_beta * invMass2 * impulse;
360c348,349
< 		b2Vec2 impulse = -K.Solve(C);
---
> 			C = b2->m_sweep.c + r2 - b1->m_sweep.c - r1;
> 		}
362,363c351,353
< 		cA -= mA * impulse;
< 		aA -= iA * b2Cross(rA, impulse);
---
> 		b2Mat22 K1;
> 		K1.col1.x = invMass1 + invMass2;	K1.col2.x = 0.0f;
> 		K1.col1.y = 0.0f;					K1.col2.y = invMass1 + invMass2;
365,367c355,370
< 		cB += mB * impulse;
< 		aB += iB * b2Cross(rB, impulse);
< 	}
---
> 		b2Mat22 K2;
> 		K2.col1.x =  invI1 * r1.y * r1.y;	K2.col2.x = -invI1 * r1.x * r1.y;
> 		K2.col1.y = -invI1 * r1.x * r1.y;	K2.col2.y =  invI1 * r1.x * r1.x;
> 
> 		b2Mat22 K3;
> 		K3.col1.x =  invI2 * r2.y * r2.y;	K3.col2.x = -invI2 * r2.x * r2.y;
> 		K3.col1.y = -invI2 * r2.x * r2.y;	K3.col2.y =  invI2 * r2.x * r2.x;
> 
> 		b2Mat22 K = K1 + K2 + K3;
> 		b2Vec2 impulse = K.Solve(-C);
> 
> 		b1->m_sweep.c -= b1->m_invMass * impulse;
> 		b1->m_sweep.a -= b1->m_invI * b2Cross(r1, impulse);
> 
> 		b2->m_sweep.c += b2->m_invMass * impulse;
> 		b2->m_sweep.a += b2->m_invI * b2Cross(r2, impulse);
369,372c372,374
< 	data.positions[m_indexA].c = cA;
< 	data.positions[m_indexA].a = aA;
< 	data.positions[m_indexB].c = cB;
< 	data.positions[m_indexB].a = aB;
---
> 		b1->SynchronizeTransform();
> 		b2->SynchronizeTransform();
> 	}
377c379
< b2Vec2 b2RevoluteJoint::GetAnchorA() const
---
> b2Vec2 b2RevoluteJoint::GetAnchor1() const
379c381
< 	return m_bodyA->GetWorldPoint(m_localAnchorA);
---
> 	return m_body1->GetWorldPoint(m_localAnchor1);
382c384
< b2Vec2 b2RevoluteJoint::GetAnchorB() const
---
> b2Vec2 b2RevoluteJoint::GetAnchor2() const
384c386
< 	return m_bodyB->GetWorldPoint(m_localAnchorB);
---
> 	return m_body2->GetWorldPoint(m_localAnchor2);
400,402c402,404
< 	b2Body* bA = m_bodyA;
< 	b2Body* bB = m_bodyB;
< 	return bB->m_sweep.a - bA->m_sweep.a - m_referenceAngle;
---
> 	b2Body* b1 = m_body1;
> 	b2Body* b2 = m_body2;
> 	return b2->m_sweep.a - b1->m_sweep.a - m_referenceAngle;
407,409c409,411
< 	b2Body* bA = m_bodyA;
< 	b2Body* bB = m_bodyB;
< 	return bB->m_angularVelocity - bA->m_angularVelocity;
---
> 	b2Body* b1 = m_body1;
> 	b2Body* b2 = m_body2;
> 	return b2->m_angularVelocity - b1->m_angularVelocity;
419,420c421,422
< 	m_bodyA->SetAwake(true);
< 	m_bodyB->SetAwake(true);
---
> 	m_body1->WakeUp();
> 	m_body2->WakeUp();
424c426
< float32 b2RevoluteJoint::GetMotorTorque(float32 inv_dt) const
---
> float32 b2RevoluteJoint::GetMotorTorque() const
426c428
< 	return inv_dt * m_motorImpulse;
---
> 	return m_motorImpulse;
431,432c433,434
< 	m_bodyA->SetAwake(true);
< 	m_bodyB->SetAwake(true);
---
> 	m_body1->WakeUp();
> 	m_body2->WakeUp();
438,439c440,441
< 	m_bodyA->SetAwake(true);
< 	m_bodyB->SetAwake(true);
---
> 	m_body1->WakeUp();
> 	m_body2->WakeUp();
450,456c452,454
< 	if (flag != m_enableLimit)
< 	{
< 		m_bodyA->SetAwake(true);
< 		m_bodyB->SetAwake(true);
< 		m_enableLimit = flag;
< 		m_impulse.z = 0.0f;
< 	}
---
> 	m_body1->WakeUp();
> 	m_body2->WakeUp();
> 	m_enableLimit = flag;
472,501c470,473
< 	
< 	if (lower != m_lowerAngle || upper != m_upperAngle)
< 	{
< 		m_bodyA->SetAwake(true);
< 		m_bodyB->SetAwake(true);
< 		m_impulse.z = 0.0f;
< 		m_lowerAngle = lower;
< 		m_upperAngle = upper;
< 	}
< }
< 
< void b2RevoluteJoint::Dump()
< {
< 	int32 indexA = m_bodyA->m_islandIndex;
< 	int32 indexB = m_bodyB->m_islandIndex;
< 
< 	b2Log("  b2RevoluteJointDef jd;\n");
< 	b2Log("  jd.bodyA = bodies[%d];\n", indexA);
< 	b2Log("  jd.bodyB = bodies[%d];\n", indexB);
< 	b2Log("  jd.collideConnected = bool(%d);\n", m_collideConnected);
< 	b2Log("  jd.localAnchorA.Set(%.15lef, %.15lef);\n", m_localAnchorA.x, m_localAnchorA.y);
< 	b2Log("  jd.localAnchorB.Set(%.15lef, %.15lef);\n", m_localAnchorB.x, m_localAnchorB.y);
< 	b2Log("  jd.referenceAngle = %.15lef;\n", m_referenceAngle);
< 	b2Log("  jd.enableLimit = bool(%d);\n", m_enableLimit);
< 	b2Log("  jd.lowerAngle = %.15lef;\n", m_lowerAngle);
< 	b2Log("  jd.upperAngle = %.15lef;\n", m_upperAngle);
< 	b2Log("  jd.enableMotor = bool(%d);\n", m_enableMotor);
< 	b2Log("  jd.motorSpeed = %.15lef;\n", m_motorSpeed);
< 	b2Log("  jd.maxMotorTorque = %.15lef;\n", m_maxMotorTorque);
< 	b2Log("  joints[%d] = m_world->CreateJoint(&jd);\n", m_index);
---
> 	m_body1->WakeUp();
> 	m_body2->WakeUp();
> 	m_lowerAngle = lower;
> 	m_upperAngle = upper;
diff -r -x './svn/*' native/Box2D/Dynamics/Joints/b2RevoluteJoint.h ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/Joints/b2RevoluteJoint.h
2c2
< * Copyright (c) 2006-2011 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
22c22
< #include <Box2D/Dynamics/Joints/b2Joint.h>
---
> #include "b2Joint.h"
40,41c40,41
< 		localAnchorA.Set(0.0f, 0.0f);
< 		localAnchorB.Set(0.0f, 0.0f);
---
> 		localAnchor1.Set(0.0f, 0.0f);
> 		localAnchor2.Set(0.0f, 0.0f);
51,53c51,53
< 	/// Initialize the bodies, anchors, and reference angle using a world
< 	/// anchor point.
< 	void Initialize(b2Body* bodyA, b2Body* bodyB, const b2Vec2& anchor);
---
> 	/// Initialize the bodies, anchors, and reference angle using the world
> 	/// anchor.
> 	void Initialize(b2Body* body1, b2Body* body2, const b2Vec2& anchor);
55,56c55,56
< 	/// The local anchor point relative to bodyA's origin.
< 	b2Vec2 localAnchorA;
---
> 	/// The local anchor point relative to body1's origin.
> 	b2Vec2 localAnchor1;
58,59c58,59
< 	/// The local anchor point relative to bodyB's origin.
< 	b2Vec2 localAnchorB;
---
> 	/// The local anchor point relative to body2's origin.
> 	b2Vec2 localAnchor2;
61c61
< 	/// The bodyB angle minus bodyA angle in the reference state (radians).
---
> 	/// The body2 angle minus body1 angle in the reference state (radians).
84c84
< /// A revolute joint constrains two bodies to share a common point while they
---
> /// A revolute joint constrains to bodies to share a common point while they
93,94c93,94
< 	b2Vec2 GetAnchorA() const;
< 	b2Vec2 GetAnchorB() const;
---
> 	b2Vec2 GetAnchor1() const;
> 	b2Vec2 GetAnchor2() const;
96,103c96,97
< 	/// The local anchor point relative to bodyA's origin.
< 	const b2Vec2& GetLocalAnchorA() const { return m_localAnchorA; }
< 
< 	/// The local anchor point relative to bodyB's origin.
< 	const b2Vec2& GetLocalAnchorB() const  { return m_localAnchorB; }
< 
< 	/// Get the reference angle.
< 	float32 GetReferenceAngle() const { return m_referenceAngle; }
---
> 	b2Vec2 GetReactionForce(float32 inv_dt) const;
> 	float32 GetReactionTorque(float32 inv_dt) const;
140d133
< 	float32 GetMaxMotorTorque() const { return m_maxMotorTorque; }
142,144c135,136
< 	/// Get the reaction force given the inverse time step.
< 	/// Unit is N.
< 	b2Vec2 GetReactionForce(float32 inv_dt) const;
---
> 	/// Get the current motor torque, usually in N-m.
> 	float32 GetMotorTorque() const;
146,152c138,139
< 	/// Get the reaction torque due to the joint limit given the inverse time step.
< 	/// Unit is N*m.
< 	float32 GetReactionTorque(float32 inv_dt) const;
< 
< 	/// Get the current motor torque given the inverse time step.
< 	/// Unit is N*m.
< 	float32 GetMotorTorque(float32 inv_dt) const;
---
> 	//--------------- Internals Below -------------------
> 	b2RevoluteJoint(const b2RevoluteJointDef* def);
154,155c141,142
< 	/// Dump to b2Log.
< 	void Dump();
---
> 	void InitVelocityConstraints(const b2TimeStep& step);
> 	void SolveVelocityConstraints(const b2TimeStep& step);
157,160c144
< protected:
< 	
< 	friend class b2Joint;
< 	friend class b2GearJoint;
---
> 	bool SolvePositionConstraints(float32 baumgarte);
162,170c146,147
< 	b2RevoluteJoint(const b2RevoluteJointDef* def);
< 
< 	void InitVelocityConstraints(const b2SolverData& data);
< 	void SolveVelocityConstraints(const b2SolverData& data);
< 	bool SolvePositionConstraints(const b2SolverData& data);
< 
< 	// Solver shared
< 	b2Vec2 m_localAnchorA;
< 	b2Vec2 m_localAnchorB;
---
> 	b2Vec2 m_localAnchor1;	// relative
> 	b2Vec2 m_localAnchor2;
173a151,153
> 	b2Mat33 m_mass;			// effective mass for point-to-point constraint.
> 	float32 m_motorMass;	// effective mass for motor/limit angular constraint.
> 	
182,195d161
< 
< 	// Solver temp
< 	int32 m_indexA;
< 	int32 m_indexB;
< 	b2Vec2 m_rA;
< 	b2Vec2 m_rB;
< 	b2Vec2 m_localCenterA;
< 	b2Vec2 m_localCenterB;
< 	float32 m_invMassA;
< 	float32 m_invMassB;
< 	float32 m_invIA;
< 	float32 m_invIB;
< 	b2Mat33 m_mass;			// effective mass for point-to-point constraint.
< 	float32 m_motorMass;	// effective mass for motor/limit angular constraint.
Only in native/Box2D/Dynamics/Joints: b2RopeJoint.cpp
Only in native/Box2D/Dynamics/Joints: b2RopeJoint.h
Only in native/Box2D/Dynamics/Joints: b2WeldJoint.cpp
Only in native/Box2D/Dynamics/Joints: b2WeldJoint.h
Only in native/Box2D/Dynamics/Joints: b2WheelJoint.cpp
Only in native/Box2D/Dynamics/Joints: b2WheelJoint.h
diff -r -x './svn/*' native/Box2D/Dynamics/b2Body.cpp ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/b2Body.cpp
2c2
< * Copyright (c) 2006-2007 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
19,23c19,25
< #include <Box2D/Dynamics/b2Body.h>
< #include <Box2D/Dynamics/b2Fixture.h>
< #include <Box2D/Dynamics/b2World.h>
< #include <Box2D/Dynamics/Contacts/b2Contact.h>
< #include <Box2D/Dynamics/Joints/b2Joint.h>
---
> #include "b2Body.h"
> #include "b2World.h"
> #include "Joints/b2Joint.h"
> #include "../Collision/Shapes/b2Shape.h"
> #include "../Collision/Shapes/b2EdgeShape.h"
> 
> 
27,32c29
< 	b2Assert(bd->position.IsValid());
< 	b2Assert(bd->linearVelocity.IsValid());
< 	b2Assert(b2IsValid(bd->angle));
< 	b2Assert(b2IsValid(bd->angularVelocity));
< 	b2Assert(b2IsValid(bd->angularDamping) && bd->angularDamping >= 0.0f);
< 	b2Assert(b2IsValid(bd->linearDamping) && bd->linearDamping >= 0.0f);
---
> 	b2Assert(world->m_lock == false);
36c33
< 	if (bd->bullet)
---
> 	if (bd->isBullet)
46,50c43
< 		m_flags |= e_autoSleepFlag;
< 	}
< 	if (bd->awake)
< 	{
< 		m_flags |= e_awakeFlag;
---
> 		m_flags |= e_allowSleepFlag;
52c45
< 	if (bd->active)
---
> 	if (bd->isSleeping)
54c47
< 		m_flags |= e_activeFlag;
---
> 		m_flags |= e_sleepFlag;
59,60c52,53
< 	m_xf.p = bd->position;
< 	m_xf.q.Set(bd->angle);
---
> 	m_xf.position = bd->position;
> 	m_xf.R.Set(bd->angle);
62,67c55,58
< 	m_sweep.localCenter.SetZero();
< 	m_sweep.c0 = m_xf.p;
< 	m_sweep.c = m_xf.p;
< 	m_sweep.a0 = bd->angle;
< 	m_sweep.a = bd->angle;
< 	m_sweep.alpha0 = 0.0f;
---
> 	m_sweep.localCenter = bd->massData.center;
> 	m_sweep.t0 = 1.0f;
> 	m_sweep.a0 = m_sweep.a = bd->angle;
> 	m_sweep.c0 = m_sweep.c = b2Mul(m_xf, m_sweep.localCenter);
70a62
> 	m_controllerList = NULL;
74,76d65
< 	m_linearVelocity = bd->linearVelocity;
< 	m_angularVelocity = bd->angularVelocity;
< 
79d67
< 	m_gravityScale = bd->gravityScale;
81c69
< 	m_force.SetZero();
---
> 	m_force.Set(0.0f, 0.0f);
83a72,74
> 	m_linearVelocity.SetZero();
> 	m_angularVelocity = 0.0f;
> 
86c77,81
< 	m_type = bd->type;
---
> 	m_invMass = 0.0f;
> 	m_I = 0.0f;
> 	m_invI = 0.0f;
> 
> 	m_mass = bd->massData.mass;
88c83
< 	if (m_type == b2_dynamicBody)
---
> 	if (m_mass > 0.0f)
90,91c85
< 		m_mass = 1.0f;
< 		m_invMass = 1.0f;
---
> 		m_invMass = 1.0f / m_mass;
93c87,88
< 	else
---
> 
> 	if ((m_flags & b2Body::e_fixedRotationFlag) == 0)
95,96c90,95
< 		m_mass = 0.0f;
< 		m_invMass = 0.0f;
---
> 		m_I = bd->massData.I;
> 	}
> 	
> 	if (m_I > 0.0f)
> 	{
> 		m_invI = 1.0f / m_I;
99,100c98,105
< 	m_I = 0.0f;
< 	m_invI = 0.0f;
---
> 	if (m_invMass == 0.0f && m_invI == 0.0f)
> 	{
> 		m_type = e_staticType;
> 	}
> 	else
> 	{
> 		m_type = e_dynamicType;
> 	}
104,105c109,110
< 	m_fixtureList = NULL;
< 	m_fixtureCount = 0;
---
> 	m_shapeList = NULL;
> 	m_shapeCount = 0;
109a115
> 	b2Assert(m_world->m_lock == false);
113,119d118
< void b2Body::SetType(b2BodyType type)
< {
< 	b2Assert(m_world->IsLocked() == false);
< 	if (m_world->IsLocked() == true)
< 	{
< 		return;
< 	}
121,163c120,130
< 	if (m_type == type)
< 	{
< 		return;
< 	}
< 
< 	m_type = type;
< 
< 	ResetMassData();
< 
< 	if (m_type == b2_staticBody)
< 	{
< 		m_linearVelocity.SetZero();
< 		m_angularVelocity = 0.0f;
< 		m_sweep.a0 = m_sweep.a;
< 		m_sweep.c0 = m_sweep.c;
< 		SynchronizeFixtures();
< 	}
< 
< 	SetAwake(true);
< 
< 	m_force.SetZero();
< 	m_torque = 0.0f;
< 
< 	// Delete the attached contacts.
< 	b2ContactEdge* ce = m_contactList;
< 	while (ce)
< 	{
< 		b2ContactEdge* ce0 = ce;
< 		ce = ce->next;
< 		m_world->m_contactManager.Destroy(ce0->contact);
< 	}
< 	m_contactList = NULL;
< 
< 	// Touch the proxies so that new contacts will be created (when appropriate)
< 	b2BroadPhase* broadPhase = &m_world->m_contactManager.m_broadPhase;
< 	for (b2Fixture* f = m_fixtureList; f; f = f->m_next)
< 	{
< 		int32 proxyCount = f->m_proxyCount;
< 		for (int32 i = 0; i < proxyCount; ++i)
< 		{
< 			broadPhase->TouchProxy(f->m_proxies[i].proxyId);
< 		}
< 	}
---
> float32 connectEdges(b2EdgeShape * const & s1, b2EdgeShape * const & s2, float32 angle1)
> {
> 	float32 angle2 = b2Atan2(s2->GetDirectionVector().y, s2->GetDirectionVector().x);
> 	b2Vec2 core = tanf((angle2 - angle1) * 0.5f) * s2->GetDirectionVector();
> 	core = b2_toiSlop * (core - s2->GetNormalVector()) + s2->GetVertex1();
> 	b2Vec2 cornerDir = s1->GetDirectionVector() + s2->GetDirectionVector();
> 	cornerDir.Normalize();
> 	bool convex = b2Dot(s1->GetDirectionVector(), s2->GetNormalVector()) > 0.0f;
> 	s1->SetNextEdge(s2, core, cornerDir, convex);
> 	s2->SetPrevEdge(s1, core, cornerDir, convex);
> 	return angle2;
166c133
< b2Fixture* b2Body::CreateFixture(const b2FixtureDef* def)
---
> b2Shape* b2Body::CreateShape(b2ShapeDef* def)
168,169c135,136
< 	b2Assert(m_world->IsLocked() == false);
< 	if (m_world->IsLocked() == true)
---
> 	b2Assert(m_world->m_lock == false);
> 	if (m_world->m_lock == true)
173,183c140,185
< 
< 	b2BlockAllocator* allocator = &m_world->m_blockAllocator;
< 
< 	void* memory = allocator->Allocate(sizeof(b2Fixture));
< 	b2Fixture* fixture = new (memory) b2Fixture;
< 	fixture->Create(allocator, this, def);
< 
< 	if (m_flags & e_activeFlag)
< 	{
< 		b2BroadPhase* broadPhase = &m_world->m_contactManager.m_broadPhase;
< 		fixture->CreateProxies(broadPhase, m_xf);
---
> 	
> 	
> 	// TODO: Decide on a better place to initialize edgeShapes. (b2Shape::Create() can't
> 	//       return more than one shape to add to parent body... maybe it should add
> 	//       shapes directly to the body instead of returning them?)
> 	if (def->type == e_edgeShape) {
> 		b2EdgeChainDef* edgeDef = (b2EdgeChainDef*)def;
> 		b2Vec2 v1;
> 		b2Vec2 v2;
> 		int i;
> 		
> 		if (edgeDef->isALoop) {
> 			v1 = edgeDef->vertices[edgeDef->vertexCount-1];
> 			i = 0;
> 		} else {
> 			v1 = edgeDef->vertices[0];
> 			i = 1;
> 		}
> 		
> 		b2EdgeShape* s0 = NULL;
> 		b2EdgeShape* s1 = NULL;
> 		b2EdgeShape* s2 = NULL;
> 		float32 angle = 0.0f;
> 		for (; i < edgeDef->vertexCount; i++) {
> 			v2 = edgeDef->vertices[i];
> 			
> 			void* mem = m_world->m_blockAllocator.Allocate(sizeof(b2EdgeShape));
> 			s2 = new (mem) b2EdgeShape(v1, v2, def);
> 			s2->m_next = m_shapeList;
> 			m_shapeList = s2;
> 			++m_shapeCount;
> 			s2->m_body = this;
> 			s2->CreateProxy(m_world->m_broadPhase, m_xf);
> 			s2->UpdateSweepRadius(m_sweep.localCenter);
> 			
> 			if (s1 == NULL) {
> 				s0 = s2;
> 				angle = b2Atan2(s2->GetDirectionVector().y, s2->GetDirectionVector().x);
> 			} else {
> 				angle = connectEdges(s1, s2, angle);
> 			}
> 			s1 = s2;
> 			v1 = v2;
> 		}
> 		if (edgeDef->isALoop) connectEdges(s1, s0, angle);
> 		return s0;
184a187,188
> 	
> 	b2Shape* s = b2Shape::Create(def, &m_world->m_blockAllocator);
186,188c190,192
< 	fixture->m_next = m_fixtureList;
< 	m_fixtureList = fixture;
< 	++m_fixtureCount;
---
> 	s->m_next = m_shapeList;
> 	m_shapeList = s;
> 	++m_shapeCount;
190c194
< 	fixture->m_body = this;
---
> 	s->m_body = this;
192,196c196,197
< 	// Adjust mass properties if needed.
< 	if (fixture->m_density > 0.0f)
< 	{
< 		ResetMassData();
< 	}
---
> 	// Add the shape to the world's broad-phase.
> 	s->CreateProxy(m_world->m_broadPhase, m_xf);
198,200c199,200
< 	// Let the world know we have a new fixture. This will cause new contacts
< 	// to be created at the beginning of the next time step.
< 	m_world->m_flags |= b2World::e_newFixture;
---
> 	// Compute the sweep radius for CCD.
> 	s->UpdateSweepRadius(m_sweep.localCenter);
202c202
< 	return fixture;
---
> 	return s;
205c205
< b2Fixture* b2Body::CreateFixture(const b2Shape* shape, float32 density)
---
> void b2Body::DestroyShape(b2Shape* s)
207,217c207,208
< 	b2FixtureDef def;
< 	def.shape = shape;
< 	def.density = density;
< 
< 	return CreateFixture(&def);
< }
< 
< void b2Body::DestroyFixture(b2Fixture* fixture)
< {
< 	b2Assert(m_world->IsLocked() == false);
< 	if (m_world->IsLocked() == true)
---
> 	b2Assert(m_world->m_lock == false);
> 	if (m_world->m_lock == true)
222c213,214
< 	b2Assert(fixture->m_body == this);
---
> 	b2Assert(s->GetBody() == this);
> 	s->DestroyProxy(m_world->m_broadPhase);
224,226c216,217
< 	// Remove the fixture from this body's singly linked list.
< 	b2Assert(m_fixtureCount > 0);
< 	b2Fixture** node = &m_fixtureList;
---
> 	b2Assert(m_shapeCount > 0);
> 	b2Shape** node = &m_shapeList;
230c221
< 		if (*node == fixture)
---
> 		if (*node == s)
232c223
< 			*node = fixture->m_next;
---
> 			*node = s->m_next;
243,251c234,235
< 	// Destroy any contacts associated with the fixture.
< 	b2ContactEdge* edge = m_contactList;
< 	while (edge)
< 	{
< 		b2Contact* c = edge->contact;
< 		edge = edge->next;
< 
< 		b2Fixture* fixtureA = c->GetFixtureA();
< 		b2Fixture* fixtureB = c->GetFixtureB();
---
> 	s->m_body = NULL;
> 	s->m_next = NULL;
253,259c237
< 		if (fixture == fixtureA || fixture == fixtureB)
< 		{
< 			// This destroys the contact and removes it from
< 			// this body's contact list.
< 			m_world->m_contactManager.Destroy(c);
< 		}
< 	}
---
> 	--m_shapeCount;
261c239,240
< 	b2BlockAllocator* allocator = &m_world->m_blockAllocator;
---
> 	b2Shape::Destroy(s, &m_world->m_blockAllocator);
> }
263c242,246
< 	if (m_flags & e_activeFlag)
---
> // TODO_ERIN adjust linear velocity and torque to account for movement of center.
> void b2Body::SetMass(const b2MassData* massData)
> {
> 	b2Assert(m_world->m_lock == false);
> 	if (m_world->m_lock == true)
265,266c248
< 		b2BroadPhase* broadPhase = &m_world->m_contactManager.m_broadPhase;
< 		fixture->DestroyProxies(broadPhase);
---
> 		return;
269,284d250
< 	fixture->Destroy(allocator);
< 	fixture->m_body = NULL;
< 	fixture->m_next = NULL;
< 	fixture->~b2Fixture();
< 	allocator->Free(fixture, sizeof(b2Fixture));
< 
< 	--m_fixtureCount;
< 
< 	// Reset the mass data.
< 	ResetMassData();
< }
< 
< void b2Body::ResetMassData()
< {
< 	// Compute mass data from shapes. Each shape has its own density.
< 	m_mass = 0.0f;
288d253
< 	m_sweep.localCenter.SetZero();
290,291c255,257
< 	// Static and kinematic bodies have zero mass.
< 	if (m_type == b2_staticBody || m_type == b2_kinematicBody)
---
> 	m_mass = massData->mass;
> 
> 	if (m_mass > 0.0f)
293,296c259
< 		m_sweep.c0 = m_xf.p;
< 		m_sweep.c = m_xf.p;
< 		m_sweep.a0 = m_sweep.a;
< 		return;
---
> 		m_invMass = 1.0f / m_mass;
299,303c262
< 	b2Assert(m_type == b2_dynamicBody);
< 
< 	// Accumulate mass over all fixtures.
< 	b2Vec2 localCenter = b2Vec2_zero;
< 	for (b2Fixture* f = m_fixtureList; f; f = f->m_next)
---
> 	if ((m_flags & b2Body::e_fixedRotationFlag) == 0)
305,314c264
< 		if (f->m_density == 0.0f)
< 		{
< 			continue;
< 		}
< 
< 		b2MassData massData;
< 		f->GetMassData(&massData);
< 		m_mass += massData.mass;
< 		localCenter += massData.mass * massData.center;
< 		m_I += massData.I;
---
> 		m_I = massData->I;
317,318c267
< 	// Compute center of mass.
< 	if (m_mass > 0.0f)
---
> 	if (m_I > 0.0f)
320,321c269
< 		m_invMass = 1.0f / m_mass;
< 		localCenter *= m_invMass;
---
> 		m_invI = 1.0f / m_I;
323c271,277
< 	else
---
> 
> 	// Move center of mass.
> 	m_sweep.localCenter = massData->center;
> 	m_sweep.c0 = m_sweep.c = b2Mul(m_xf, m_sweep.localCenter);
> 
> 	// Update the sweep radii of all child shapes.
> 	for (b2Shape* s = m_shapeList; s; s = s->m_next)
325,327c279
< 		// Force all dynamic bodies to have a positive mass.
< 		m_mass = 1.0f;
< 		m_invMass = 1.0f;
---
> 		s->UpdateSweepRadius(m_sweep.localCenter);
330c282,283
< 	if (m_I > 0.0f && (m_flags & e_fixedRotationFlag) == 0)
---
> 	int16 oldType = m_type;
> 	if (m_invMass == 0.0f && m_invI == 0.0f)
332,336c285
< 		// Center the inertia about the center of mass.
< 		m_I -= m_mass * b2Dot(localCenter, localCenter);
< 		b2Assert(m_I > 0.0f);
< 		m_invI = 1.0f / m_I;
< 
---
> 		m_type = e_staticType;
340,341c289
< 		m_I = 0.0f;
< 		m_invI = 0.0f;
---
> 		m_type = e_dynamicType;
344,356c292,293
< 	// Move center of mass.
< 	b2Vec2 oldCenter = m_sweep.c;
< 	m_sweep.localCenter = localCenter;
< 	m_sweep.c0 = m_sweep.c = b2Mul(m_xf, m_sweep.localCenter);
< 
< 	// Update center of mass velocity.
< 	m_linearVelocity += b2Cross(m_angularVelocity, m_sweep.c - oldCenter);
< }
< 
< void b2Body::SetMassData(const b2MassData* massData)
< {
< 	b2Assert(m_world->IsLocked() == false);
< 	if (m_world->IsLocked() == true)
---
> 	// If the body type changed, we need to refilter the broad-phase proxies.
> 	if (oldType != m_type)
358c295,298
< 		return;
---
> 		for (b2Shape* s = m_shapeList; s; s = s->m_next)
> 		{
> 			s->RefilterProxy(m_world->m_broadPhase, m_xf);
> 		}
359a300
> }
361c302,306
< 	if (m_type != b2_dynamicBody)
---
> // TODO_ERIN adjust linear velocity and torque to account for movement of center.
> void b2Body::SetMassFromShapes()
> {
> 	b2Assert(m_world->m_lock == false);
> 	if (m_world->m_lock == true)
365a311,312
> 	// Compute mass data from shapes. Each shape has its own density.
> 	m_mass = 0.0f;
370,371c317,318
< 	m_mass = massData->mass;
< 	if (m_mass <= 0.0f)
---
> 	b2Vec2 center = b2Vec2_zero;
> 	for (b2Shape* s = m_shapeList; s; s = s->m_next)
373c320,324
< 		m_mass = 1.0f;
---
> 		b2MassData massData;
> 		s->ComputeMass(&massData);
> 		m_mass += massData.mass;
> 		center += massData.mass * massData.center;
> 		m_I += massData.I;
376c327,332
< 	m_invMass = 1.0f / m_mass;
---
> 	// Compute center of mass, and shift the origin to the COM.
> 	if (m_mass > 0.0f)
> 	{
> 		m_invMass = 1.0f / m_mass;
> 		center *= m_invMass;
> 	}
378c334
< 	if (massData->I > 0.0f && (m_flags & b2Body::e_fixedRotationFlag) == 0)
---
> 	if (m_I > 0.0f && (m_flags & e_fixedRotationFlag) == 0)
380c336,337
< 		m_I = massData->I - m_mass * b2Dot(massData->center, massData->center);
---
> 		// Center the inertia about the center of mass.
> 		m_I -= m_mass * b2Dot(center, center);
383a341,345
> 	else
> 	{
> 		m_I = 0.0f;
> 		m_invI = 0.0f;
> 	}
386,387c348
< 	b2Vec2 oldCenter = m_sweep.c;
< 	m_sweep.localCenter =  massData->center;
---
> 	m_sweep.localCenter = center;
390,392c351,355
< 	// Update center of mass velocity.
< 	m_linearVelocity += b2Cross(m_angularVelocity, m_sweep.c - oldCenter);
< }
---
> 	// Update the sweep radii of all child shapes.
> 	for (b2Shape* s = m_shapeList; s; s = s->m_next)
> 	{
> 		s->UpdateSweepRadius(m_sweep.localCenter);
> 	}
394,397c357,358
< bool b2Body::ShouldCollide(const b2Body* other) const
< {
< 	// At least one body should be dynamic.
< 	if (m_type != b2_dynamicBody && other->m_type != b2_dynamicBody)
---
> 	int16 oldType = m_type;
> 	if (m_invMass == 0.0f && m_invI == 0.0f)
399c360,364
< 		return false;
---
> 		m_type = e_staticType;
> 	}
> 	else
> 	{
> 		m_type = e_dynamicType;
402,403c367,368
< 	// Does a joint prevent collision?
< 	for (b2JointEdge* jn = m_jointList; jn; jn = jn->next)
---
> 	// If the body type changed, we need to refilter the broad-phase proxies.
> 	if (oldType != m_type)
405c370
< 		if (jn->other == other)
---
> 		for (b2Shape* s = m_shapeList; s; s = s->m_next)
407,410c372
< 			if (jn->joint->m_collideConnected == false)
< 			{
< 				return false;
< 			}
---
> 			s->RefilterProxy(m_world->m_broadPhase, m_xf);
413,414d374
< 
< 	return true;
417c377
< void b2Body::SetTransform(const b2Vec2& position, float32 angle)
---
> bool b2Body::SetXForm(const b2Vec2& position, float32 angle)
419,420c379,380
< 	b2Assert(m_world->IsLocked() == false);
< 	if (m_world->IsLocked() == true)
---
> 	b2Assert(m_world->m_lock == false);
> 	if (m_world->m_lock == true)
422c382
< 		return;
---
> 		return true;
425,435c385
< 	m_xf.q.Set(angle);
< 	m_xf.p = position;
< 
< 	m_sweep.c = b2Mul(m_xf, m_sweep.localCenter);
< 	m_sweep.a = angle;
< 
< 	m_sweep.c0 = m_sweep.c;
< 	m_sweep.a0 = angle;
< 
< 	b2BroadPhase* broadPhase = &m_world->m_contactManager.m_broadPhase;
< 	for (b2Fixture* f = m_fixtureList; f; f = f->m_next)
---
> 	if (IsFrozen())
437c387
< 		f->Synchronize(broadPhase, m_xf, m_xf);
---
> 		return false;
440,441c390,391
< 	m_world->m_contactManager.FindNewContacts();
< }
---
> 	m_xf.R.Set(angle);
> 	m_xf.position = position;
443,447c393,394
< void b2Body::SynchronizeFixtures()
< {
< 	b2Transform xf1;
< 	xf1.q.Set(m_sweep.a0);
< 	xf1.p = m_sweep.c0 - b2Mul(xf1.q, m_sweep.localCenter);
---
> 	m_sweep.c0 = m_sweep.c = b2Mul(m_xf, m_sweep.localCenter);
> 	m_sweep.a0 = m_sweep.a = angle;
449,450c396,397
< 	b2BroadPhase* broadPhase = &m_world->m_contactManager.m_broadPhase;
< 	for (b2Fixture* f = m_fixtureList; f; f = f->m_next)
---
> 	bool freeze = false;
> 	for (b2Shape* s = m_shapeList; s; s = s->m_next)
452,454c399
< 		f->Synchronize(broadPhase, xf1, m_xf);
< 	}
< }
---
> 		bool inRange = s->Synchronize(m_world->m_broadPhase, m_xf, m_xf);
456,462c401,405
< void b2Body::SetActive(bool flag)
< {
< 	b2Assert(m_world->IsLocked() == false);
< 
< 	if (flag == IsActive())
< 	{
< 		return;
---
> 		if (inRange == false)
> 		{
> 			freeze = true;
> 			break;
> 		}
465c408
< 	if (flag)
---
> 	if (freeze == true)
467,471c410,413
< 		m_flags |= e_activeFlag;
< 
< 		// Create all proxies.
< 		b2BroadPhase* broadPhase = &m_world->m_contactManager.m_broadPhase;
< 		for (b2Fixture* f = m_fixtureList; f; f = f->m_next)
---
> 		m_flags |= e_frozenFlag;
> 		m_linearVelocity.SetZero();
> 		m_angularVelocity = 0.0f;
> 		for (b2Shape* s = m_shapeList; s; s = s->m_next)
473c415
< 			f->CreateProxies(broadPhase, m_xf);
---
> 			s->DestroyProxy(m_world->m_broadPhase);
476c418,419
< 		// Contacts are created the next time step.
---
> 		// Failure
> 		return false;
478,480d420
< 	else
< 	{
< 		m_flags &= ~e_activeFlag;
482,487c422,423
< 		// Destroy all proxies.
< 		b2BroadPhase* broadPhase = &m_world->m_contactManager.m_broadPhase;
< 		for (b2Fixture* f = m_fixtureList; f; f = f->m_next)
< 		{
< 			f->DestroyProxies(broadPhase);
< 		}
---
> 	// Success
> 	m_world->m_broadPhase->Commit();
489,498c425,427
< 		// Destroy the attached contacts.
< 		b2ContactEdge* ce = m_contactList;
< 		while (ce)
< 		{
< 			b2ContactEdge* ce0 = ce;
< 			ce = ce->next;
< 			m_world->m_contactManager.Destroy(ce0->contact);
< 		}
< 		m_contactList = NULL;
< 	}
---
> 	// make sure java objects are updated:
> 	ClearJNIUpdated();
> 	return true;
501c430
< void b2Body::SetFixedRotation(bool flag)
---
> bool b2Body::SynchronizeShapes()
503,507c432,434
< 	bool status = (m_flags & e_fixedRotationFlag) == e_fixedRotationFlag;
< 	if (status == flag)
< 	{
< 		return;
< 	}
---
> 	b2XForm xf1;
> 	xf1.R.Set(m_sweep.a0);
> 	xf1.position = m_sweep.c0 - b2Mul(xf1.R, m_sweep.localCenter);
509,513c436,437
< 	if (flag)
< 	{
< 		m_flags |= e_fixedRotationFlag;
< 	}
< 	else
---
> 	bool inRange = true;
> 	for (b2Shape* s = m_shapeList; s; s = s->m_next)
515c439,443
< 		m_flags &= ~e_fixedRotationFlag;
---
> 		inRange = s->Synchronize(m_world->m_broadPhase, xf1, m_xf);
> 		if (inRange == false)
> 		{
> 			break;
> 		}
518,525c446,454
< 	m_angularVelocity = 0.0f;
< 
< 	ResetMassData();
< }
< 
< void b2Body::Dump()
< {
< 	int32 bodyIndex = m_islandIndex;
---
> 	if (inRange == false)
> 	{
> 		m_flags |= e_frozenFlag;
> 		m_linearVelocity.SetZero();
> 		m_angularVelocity = 0.0f;
> 		for (b2Shape* s = m_shapeList; s; s = s->m_next)
> 		{
> 			s->DestroyProxy(m_world->m_broadPhase);
> 		}
527,548c456,457
< 	b2Log("{\n");
< 	b2Log("  b2BodyDef bd;\n");
< 	b2Log("  bd.type = b2BodyType(%d);\n", m_type);
< 	b2Log("  bd.position.Set(%.15lef, %.15lef);\n", m_xf.p.x, m_xf.p.y);
< 	b2Log("  bd.angle = %.15lef;\n", m_sweep.a);
< 	b2Log("  bd.linearVelocity.Set(%.15lef, %.15lef);\n", m_linearVelocity.x, m_linearVelocity.y);
< 	b2Log("  bd.angularVelocity = %.15lef;\n", m_angularVelocity);
< 	b2Log("  bd.linearDamping = %.15lef;\n", m_linearDamping);
< 	b2Log("  bd.angularDamping = %.15lef;\n", m_angularDamping);
< 	b2Log("  bd.allowSleep = bool(%d);\n", m_flags & e_autoSleepFlag);
< 	b2Log("  bd.awake = bool(%d);\n", m_flags & e_awakeFlag);
< 	b2Log("  bd.fixedRotation = bool(%d);\n", m_flags & e_fixedRotationFlag);
< 	b2Log("  bd.bullet = bool(%d);\n", m_flags & e_bulletFlag);
< 	b2Log("  bd.active = bool(%d);\n", m_flags & e_activeFlag);
< 	b2Log("  bd.gravityScale = %.15lef;\n", m_gravityScale);
< 	b2Log("  bodies[%d] = m_world->CreateBody(&bd);\n", m_islandIndex);
< 	b2Log("\n");
< 	for (b2Fixture* f = m_fixtureList; f; f = f->m_next)
< 	{
< 		b2Log("  {\n");
< 		f->Dump(bodyIndex);
< 		b2Log("  }\n");
---
> 		// Failure
> 		return false;
550c459,461
< 	b2Log("}\n");
---
> 
> 	// Success
> 	return true;
diff -r -x './svn/*' native/Box2D/Dynamics/b2Body.h ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/b2Body.h
2c2
< * Copyright (c) 2006-2011 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
22,24c22,27
< #include <Box2D/Common/b2Math.h>
< #include <Box2D/Collision/Shapes/b2Shape.h>
< #include <memory>
---
> #include "../Common/b2Math.h"
> #include "../Collision/Shapes/b2Shape.h"
> #include "Joints/b2Joint.h"
> #include "Controllers/b2Controller.h"
> 
> #include <new>
26d28
< class b2Fixture;
31d32
< struct b2FixtureDef;
34,47c35
< 
< /// The body type.
< /// static: zero mass, zero velocity, may be manually moved
< /// kinematic: zero mass, non-zero velocity set by user, moved by solver
< /// dynamic: positive mass, non-zero velocity determined by forces, moved by solver
< enum b2BodyType
< {
< 	b2_staticBody = 0,
< 	b2_kinematicBody,
< 	b2_dynamicBody
< 
< 	// TODO_ERIN
< 	//b2_bulletBody,
< };
---
> struct b2ControllerEdge;
50c38
< /// You can safely re-use body definitions. Shapes are added to a body after construction.
---
> /// You can safely re-use body definitions.
55a44,46
> 		massData.center.SetZero();
> 		massData.mass = 0.0f;
> 		massData.I = 0.0f;
59,60d49
< 		linearVelocity.Set(0.0f, 0.0f);
< 		angularVelocity = 0.0f;
64c53
< 		awake = true;
---
> 		isSleeping = false;
66,69c55
< 		bullet = false;
< 		type = b2_staticBody;
< 		active = true;
< 		gravityScale = 1.0f;
---
> 		isBullet = false;
72,74c58,64
< 	/// The body type: static, kinematic, or dynamic.
< 	/// Note: if a dynamic body would have zero mass, the mass is set to one.
< 	b2BodyType type;
---
> 	/// You can use this to initialized the mass properties of the body.
> 	/// If you prefer, you can set the mass properties after the shapes
> 	/// have been added using b2Body::SetMassFromShapes.
> 	b2MassData massData;
> 
> 	/// Use this to store application specific body data.
> 	void* userData;
83,88d72
< 	/// The linear velocity of the body's origin in world co-ordinates.
< 	b2Vec2 linearVelocity;
< 
< 	/// The angular velocity of the body.
< 	float32 angularVelocity;
< 
103,104c87,88
< 	/// Is this body initially awake or sleeping?
< 	bool awake;
---
> 	/// Is this body initially sleeping?
> 	bool isSleeping;
111c95
< 	/// kinematic and static bodies. This setting is only considered on dynamic bodies.
---
> 	/// static bodies.
113,122c97
< 	bool bullet;
< 
< 	/// Does this body start out active?
< 	bool active;
< 
< 	/// Use this to store application specific body data.
< 	void* userData;
< 
< 	/// Scale the gravity applied to this body.
< 	float32 gravityScale;
---
> 	bool isBullet;
125c100
< /// A rigid body. These are created via b2World::CreateBody.
---
> /// A rigid body.
129,134c104,105
< 	/// Creates a fixture and attach it to this body. Use this function if you need
< 	/// to set some fixture parameters, like friction. Otherwise you can create the
< 	/// fixture directly from a shape.
< 	/// If the density is non-zero, this function automatically updates the mass of the body.
< 	/// Contacts are not created until the next time step.
< 	/// @param def the fixture definition.
---
> 	/// Creates a shape and attach it to this body.
> 	/// @param shapeDef the shape definition.
136c107
< 	b2Fixture* CreateFixture(const b2FixtureDef* def);
---
> 	b2Shape* CreateShape(b2ShapeDef* shapeDef);
138,143c109,112
< 	/// Creates a fixture from a shape and attach it to this body.
< 	/// This is a convenience function. Use b2FixtureDef if you need to set parameters
< 	/// like friction, restitution, user data, or filtering.
< 	/// If the density is non-zero, this function automatically updates the mass of the body.
< 	/// @param shape the shape to be cloned.
< 	/// @param density the shape density (set to zero for static bodies).
---
> 	/// Destroy a shape. This removes the shape from the broad-phase and
> 	/// therefore destroys any contacts associated with this shape. All shapes
> 	/// attached to a body are implicitly destroyed when the body is destroyed.
> 	/// @param shape the shape to be removed.
145c114
< 	b2Fixture* CreateFixture(const b2Shape* shape, float32 density);
---
> 	void DestroyShape(b2Shape* shape);
147,154c116,120
< 	/// Destroy a fixture. This removes the fixture from the broad-phase and
< 	/// destroys all contacts associated with this fixture. This will
< 	/// automatically adjust the mass of the body if the body is dynamic and the
< 	/// fixture has positive density.
< 	/// All fixtures attached to a body are implicitly destroyed when the body is destroyed.
< 	/// @param fixture the fixture to be removed.
< 	/// @warning This function is locked during callbacks.
< 	void DestroyFixture(b2Fixture* fixture);
---
> 	/// Set the mass properties. Note that this changes the center of mass position.
> 	/// If you are not sure how to compute mass properties, use SetMassFromShapes.
> 	/// The inertia tensor is assumed to be relative to the center of mass.
> 	/// @param massData the mass properties.
> 	void SetMass(const b2MassData* massData);
156c122,127
< 	/// Set the position of the body's origin and rotation.
---
> 	/// Compute the mass properties from the attached shapes. You typically call this
> 	/// after adding all the shapes. If you add or remove shapes later, you may want
> 	/// to call this again. Note that this changes the center of mass position.
> 	void SetMassFromShapes();
> 
> 	/// Set the position of the body's origin and rotation (radians).
158,161c129,134
< 	/// Manipulating a body's transform may cause non-physical behavior.
< 	/// @param position the world position of the body's local origin.
< 	/// @param angle the world rotation in radians.
< 	void SetTransform(const b2Vec2& position, float32 angle);
---
> 	/// @param position the new world position of the body's origin (not necessarily
> 	/// the center of mass).
> 	/// @param angle the new world rotation angle of the body in radians.
> 	/// @return false if the movement put a shape outside the world. In this case the
> 	/// body is automatically frozen.
> 	bool SetXForm(const b2Vec2& position, float32 angle);
165c138
< 	const b2Transform& GetTransform() const;
---
> 	const b2XForm& GetXForm() const;
187c160
< 	const b2Vec2& GetLinearVelocity() const;
---
> 	b2Vec2 GetLinearVelocity() const;
202,208c175
< 	/// @param wake also wake up the body
< 	void ApplyForce(const b2Vec2& force, const b2Vec2& point, bool wake);
< 
< 	/// Apply a force to the center of mass. This wakes up the body.
< 	/// @param force the world force vector, usually in Newtons (N).
< 	/// @param wake also wake up the body
< 	void ApplyForceToCenter(const b2Vec2& force, bool wake);
---
> 	void ApplyForce(const b2Vec2& force, const b2Vec2& point);
214,215c181
< 	/// @param wake also wake up the body
< 	void ApplyTorque(float32 torque, bool wake);
---
> 	void ApplyTorque(float32 torque);
222,228c188
< 	/// @param wake also wake up the body
< 	void ApplyLinearImpulse(const b2Vec2& impulse, const b2Vec2& point, bool wake);
< 
< 	/// Apply an angular impulse.
< 	/// @param impulse the angular impulse in units of kg*m*m/s
< 	/// @param wake also wake up the body
< 	void ApplyAngularImpulse(float32 impulse, bool wake);
---
> 	void ApplyImpulse(const b2Vec2& impulse, const b2Vec2& point);
234c194
< 	/// Get the rotational inertia of the body about the local origin.
---
> 	/// Get the central rotational inertia of the body.
238,253d197
< 	/// Get the mass data of the body.
< 	/// @return a struct containing the mass, inertia and center of the body.
< 	void GetMassData(b2MassData* data) const;
< 
< 	/// Set the mass properties to override the mass properties of the fixtures.
< 	/// Note that this changes the center of mass position.
< 	/// Note that creating or destroying fixtures can also alter the mass.
< 	/// This function has no effect if the body isn't dynamic.
< 	/// @param massData the mass properties.
< 	void SetMassData(const b2MassData* data);
< 
< 	/// This resets the mass properties to the sum of the mass properties of the fixtures.
< 	/// This normally does not need to be called unless you called SetMassData to override
< 	/// the mass and you later want to reset the mass.
< 	void ResetMassData();
< 
284,285c228,229
< 	/// Get the linear damping of the body.
< 	float32 GetLinearDamping() const;
---
> 	/// Is this body treated like a bullet for continuous collision detection?
> 	bool IsBullet() const;
287,288c231,232
< 	/// Set the linear damping of the body.
< 	void SetLinearDamping(float32 linearDamping);
---
> 	/// Should this body be treated like a bullet for continuous collision detection?
> 	void SetBullet(bool flag);
290,291c234,235
< 	/// Get the angular damping of the body.
< 	float32 GetAngularDamping() const;
---
> 	/// Is this body static (immovable)?
> 	bool IsStatic() const;
293,294c237,238
< 	/// Set the angular damping of the body.
< 	void SetAngularDamping(float32 angularDamping);
---
> 	/// Is this body dynamic (movable)?
> 	bool IsDynamic() const;
296,297c240,241
< 	/// Get the gravity scale of the body.
< 	float32 GetGravityScale() const;
---
> 	/// Is this body frozen?
> 	bool IsFrozen() const;
299,300c243,244
< 	/// Set the gravity scale of the body.
< 	void SetGravityScale(float32 scale);
---
> 	/// Is this body sleeping (not simulating).
> 	bool IsSleeping() const;
302,303c246,247
< 	/// Set the type of this body. This may alter the mass and velocity.
< 	void SetType(b2BodyType type);
---
> 	// Is the JNI java object of this object aware of new position?
> 	bool IsJNIUpdated() const;
305,306c249,250
< 	/// Get the type of this body.
< 	b2BodyType GetType() const;
---
> 	/// You can disable sleeping on this body.
> 	void AllowSleeping(bool flag);
308,309c252,255
< 	/// Should this body be treated like a bullet for continuous collision detection?
< 	void SetBullet(bool flag);
---
> 	// inform body that JNI java object has been updated
> 	void SetJNIUpdated();
> 	// inform body that JNI java object is outdated
> 	void ClearJNIUpdated();
311,312c257,258
< 	/// Is this body treated like a bullet for continuous collision detection?
< 	bool IsBullet() const;
---
> 	/// Wake up this body so it will begin simulating.
> 	void WakeUp();
314,357c260,265
< 	/// You can disable sleeping on this body. If you disable sleeping, the
< 	/// body will be woken.
< 	void SetSleepingAllowed(bool flag);
< 
< 	/// Is this body allowed to sleep
< 	bool IsSleepingAllowed() const;
< 
< 	/// Set the sleep state of the body. A sleeping body has very
< 	/// low CPU cost.
< 	/// @param flag set to true to wake the body, false to put it to sleep.
< 	void SetAwake(bool flag);
< 
< 	/// Get the sleeping state of this body.
< 	/// @return true if the body is sleeping.
< 	bool IsAwake() const;
< 
< 	/// Set the active state of the body. An inactive body is not
< 	/// simulated and cannot be collided with or woken up.
< 	/// If you pass a flag of true, all fixtures will be added to the
< 	/// broad-phase.
< 	/// If you pass a flag of false, all fixtures will be removed from
< 	/// the broad-phase and all contacts will be destroyed.
< 	/// Fixtures and joints are otherwise unaffected. You may continue
< 	/// to create/destroy fixtures and joints on inactive bodies.
< 	/// Fixtures on an inactive body are implicitly inactive and will
< 	/// not participate in collisions, ray-casts, or queries.
< 	/// Joints connected to an inactive body are implicitly inactive.
< 	/// An inactive body is still owned by a b2World object and remains
< 	/// in the body list.
< 	void SetActive(bool flag);
< 
< 	/// Get the active state of the body.
< 	bool IsActive() const;
< 
< 	/// Set this body to have fixed rotation. This causes the mass
< 	/// to be reset.
< 	void SetFixedRotation(bool flag);
< 
< 	/// Does this body have fixed rotation?
< 	bool IsFixedRotation() const;
< 
< 	/// Get the list of all fixtures attached to this body.
< 	b2Fixture* GetFixtureList();
< 	const b2Fixture* GetFixtureList() const;
---
> 	/// Put this body to sleep so it will stop simulating.
> 	/// This also sets the velocity to zero.
> 	void PutToSleep();
> 
> 	/// Get the list of all shapes attached to this body.
> 	b2Shape* GetShapeList();
361d268
< 	const b2JointEdge* GetJointList() const;
363,367c270,271
< 	/// Get the list of all contacts attached to this body.
< 	/// @warning this list changes during the time step and you may
< 	/// miss some collisions if you don't use b2ContactListener.
< 	b2ContactEdge* GetContactList();
< 	const b2ContactEdge* GetContactList() const;
---
> 	/// Get the list of all controllers attached to this body.
> 	b2ControllerEdge* GetControllerList();
371d274
< 	const b2Body* GetNext() const;
374c277
< 	void* GetUserData() const;
---
> 	void* GetUserData();
381,384d283
< 	const b2World* GetWorld() const;
< 
< 	/// Dump this body to a log file
< 	void Dump();
392d290
< 	friend class b2Contact;
395d292
< 	friend class b2FrictionJoint;
397c294
< 	friend class b2MotorJoint;
---
> 	friend class b2LineJoint;
402,404c299,300
< 	friend class b2RopeJoint;
< 	friend class b2WeldJoint;
< 	friend class b2WheelJoint;
---
> 
> 	friend class b2Controller;
409,415c305,320
< 		e_islandFlag		= 0x0001,
< 		e_awakeFlag			= 0x0002,
< 		e_autoSleepFlag		= 0x0004,
< 		e_bulletFlag		= 0x0008,
< 		e_fixedRotationFlag	= 0x0010,
< 		e_activeFlag		= 0x0020,
< 		e_toiFlag			= 0x0040
---
> 		e_frozenFlag		= 0x0002,
> 		e_islandFlag		= 0x0004,
> 		e_sleepFlag			= 0x0008,
> 		e_allowSleepFlag	= 0x0010,
> 		e_bulletFlag		= 0x0020,
> 		e_fixedRotationFlag	= 0x0040,
> 
> 		e_jniUpdatedFlag	= 0x0080,
> 	};
> 
> 	// m_type
> 	enum
> 	{
> 		e_staticType,
> 		e_dynamicType,
> 		e_maxTypes,
421c326,327
< 	void SynchronizeFixtures();
---
> 	bool SynchronizeShapes();
> 
426c332
< 	bool ShouldCollide(const b2Body* other) const;
---
> 	bool IsConnected(const b2Body* other) const;
430,431d335
< 	b2BodyType m_type;
< 
432a337
> 	int16 m_type;
436,437c341,342
< 	b2Transform m_xf;		// the body origin transform
< 	b2Sweep m_sweep;		// the swept motion for CCD
---
> 	b2XForm m_xf;		// the body origin transform
> 	b2Sweep m_sweep;	// the swept motion for CCD
449,450c354,355
< 	b2Fixture* m_fixtureList;
< 	int32 m_fixtureCount;
---
> 	b2Shape* m_shapeList;
> 	int32 m_shapeCount;
455c360
< 	float32 m_mass, m_invMass;
---
> 	b2ControllerEdge* m_controllerList;
457c362
< 	// Rotational inertia about the center of mass.
---
> 	float32 m_mass, m_invMass;
459a365,366
> public:
> 
462d368
< 	float32 m_gravityScale;
463a370
> private:
469,474c376
< inline b2BodyType b2Body::GetType() const
< {
< 	return m_type;
< }
< 
< inline const b2Transform& b2Body::GetTransform() const
---
> inline const b2XForm& b2Body::GetXForm() const
481c383
< 	return m_xf.p;
---
> 	return m_xf.position;
501,510d402
< 	if (m_type == b2_staticBody)
< 	{
< 		return;
< 	}
< 
< 	if (b2Dot(v,v) > 0.0f)
< 	{
< 		SetAwake(true);
< 	}
< 
514c406
< inline const b2Vec2& b2Body::GetLinearVelocity() const
---
> inline b2Vec2 b2Body::GetLinearVelocity() const
521,530d412
< 	if (m_type == b2_staticBody)
< 	{
< 		return;
< 	}
< 
< 	if (w * w > 0.0f)
< 	{
< 		SetAwake(true);
< 	}
< 
546,553c428
< 	return m_I + m_mass * b2Dot(m_sweep.localCenter, m_sweep.localCenter);
< }
< 
< inline void b2Body::GetMassData(b2MassData* data) const
< {
< 	data->mass = m_mass;
< 	data->I = m_I + m_mass * b2Dot(m_sweep.localCenter, m_sweep.localCenter);
< 	data->center = m_sweep.localCenter;
---
> 	return m_I;
563c438
< 	return b2Mul(m_xf.q, localVector);
---
> 	return b2Mul(m_xf.R, localVector);
573c448
< 	return b2MulT(m_xf.q, worldVector);
---
> 	return b2MulT(m_xf.R, worldVector);
586,611c461
< inline float32 b2Body::GetLinearDamping() const
< {
< 	return m_linearDamping;
< }
< 
< inline void b2Body::SetLinearDamping(float32 linearDamping)
< {
< 	m_linearDamping = linearDamping;
< }
< 
< inline float32 b2Body::GetAngularDamping() const
< {
< 	return m_angularDamping;
< }
< 
< inline void b2Body::SetAngularDamping(float32 angularDamping)
< {
< 	m_angularDamping = angularDamping;
< }
< 
< inline float32 b2Body::GetGravityScale() const
< {
< 	return m_gravityScale;
< }
< 
< inline void b2Body::SetGravityScale(float32 scale)
---
> inline bool b2Body::IsBullet() const
613c463
< 	m_gravityScale = scale;
---
> 	return (m_flags & e_bulletFlag) == e_bulletFlag;
628c478
< inline bool b2Body::IsBullet() const
---
> inline bool b2Body::IsStatic() const
630c480
< 	return (m_flags & e_bulletFlag) == e_bulletFlag;
---
> 	return m_type == e_staticType;
633c483
< inline void b2Body::SetAwake(bool flag)
---
> inline bool b2Body::IsDynamic() const
635,651c485
< 	if (flag)
< 	{
< 		if ((m_flags & e_awakeFlag) == 0)
< 		{
< 			m_flags |= e_awakeFlag;
< 			m_sleepTime = 0.0f;
< 		}
< 	}
< 	else
< 	{
< 		m_flags &= ~e_awakeFlag;
< 		m_sleepTime = 0.0f;
< 		m_linearVelocity.SetZero();
< 		m_angularVelocity = 0.0f;
< 		m_force.SetZero();
< 		m_torque = 0.0f;
< 	}
---
> 	return m_type == e_dynamicType;
654c488
< inline bool b2Body::IsAwake() const
---
> inline bool b2Body::IsFrozen() const
656c490
< 	return (m_flags & e_awakeFlag) == e_awakeFlag;
---
> 	return (m_flags & e_frozenFlag) == e_frozenFlag;
659c493
< inline bool b2Body::IsActive() const
---
> inline bool b2Body::IsSleeping() const
661c495
< 	return (m_flags & e_activeFlag) == e_activeFlag;
---
> 	return (m_flags & e_sleepFlag) == e_sleepFlag;
664c498
< inline bool b2Body::IsFixedRotation() const
---
> inline bool b2Body::IsJNIUpdated() const
666c500
< 	return (m_flags & e_fixedRotationFlag) == e_fixedRotationFlag;
---
> 	return (m_flags & e_jniUpdatedFlag) == e_jniUpdatedFlag;
669c503
< inline void b2Body::SetSleepingAllowed(bool flag)
---
> inline void b2Body::AllowSleeping(bool flag)
673c507
< 		m_flags |= e_autoSleepFlag;
---
> 		m_flags |= e_allowSleepFlag;
677,678c511,512
< 		m_flags &= ~e_autoSleepFlag;
< 		SetAwake(true);
---
> 		m_flags &= ~e_allowSleepFlag;
> 		WakeUp();
682c516
< inline bool b2Body::IsSleepingAllowed() const
---
> inline void b2Body::SetJNIUpdated()
684c518
< 	return (m_flags & e_autoSleepFlag) == e_autoSleepFlag;
---
> 	m_flags |= e_jniUpdatedFlag;
686,687c520
< 
< inline b2Fixture* b2Body::GetFixtureList()
---
> inline void b2Body::ClearJNIUpdated()
689c522
< 	return m_fixtureList;
---
> 	m_flags &= ~e_jniUpdatedFlag;
692c525
< inline const b2Fixture* b2Body::GetFixtureList() const
---
> inline void b2Body::WakeUp()
694c527,529
< 	return m_fixtureList;
---
> 	m_flags &= ~e_sleepFlag;
> 	m_sleepTime = 0.0f;
> 	ClearJNIUpdated();
697c532
< inline b2JointEdge* b2Body::GetJointList()
---
> inline void b2Body::PutToSleep()
699c534,539
< 	return m_jointList;
---
> 	m_flags |= e_sleepFlag;
> 	m_sleepTime = 0.0f;
> 	m_linearVelocity.SetZero();
> 	m_angularVelocity = 0.0f;
> 	m_force.SetZero();
> 	m_torque = 0.0f;
702c542
< inline const b2JointEdge* b2Body::GetJointList() const
---
> inline b2Shape* b2Body::GetShapeList()
704c544
< 	return m_jointList;
---
> 	return m_shapeList;
707c547
< inline b2ContactEdge* b2Body::GetContactList()
---
> inline b2JointEdge* b2Body::GetJointList()
709c549
< 	return m_contactList;
---
> 	return m_jointList;
712c552
< inline const b2ContactEdge* b2Body::GetContactList() const
---
> inline b2ControllerEdge* b2Body::GetControllerList()
714c554
< 	return m_contactList;
---
> 	return m_controllerList;
722c562
< inline const b2Body* b2Body::GetNext() const
---
> inline void* b2Body::GetUserData()
724c564
< 	return m_next;
---
> 	return m_userData;
732c572
< inline void* b2Body::GetUserData() const
---
> inline bool b2Body::IsConnected(const b2Body* other) const
734,739c574
< 	return m_userData;
< }
< 
< inline void b2Body::ApplyForce(const b2Vec2& force, const b2Vec2& point, bool wake)
< {
< 	if (m_type != b2_dynamicBody)
---
> 	for (b2JointEdge* jn = m_jointList; jn; jn = jn->next)
741c576,577
< 		return;
---
> 		if (jn->other == other)
> 			return jn->joint->m_collideConnected == false;
744,754c580
< 	if (wake && (m_flags & e_awakeFlag) == 0)
< 	{
< 		SetAwake(true);
< 	}
< 
< 	// Don't accumulate a force if the body is sleeping.
< 	if (m_flags & e_awakeFlag)
< 	{
< 		m_force += force;
< 		m_torque += b2Cross(point - m_sweep.c, force);
< 	}
---
> 	return false;
757c583
< inline void b2Body::ApplyForceToCenter(const b2Vec2& force, bool wake)
---
> inline void b2Body::ApplyForce(const b2Vec2& force, const b2Vec2& point)
759,789c585
< 	if (m_type != b2_dynamicBody)
< 	{
< 		return;
< 	}
< 
< 	if (wake && (m_flags & e_awakeFlag) == 0)
< 	{
< 		SetAwake(true);
< 	}
< 
< 	// Don't accumulate a force if the body is sleeping
< 	if (m_flags & e_awakeFlag)
< 	{
< 		m_force += force;
< 	}
< }
< 
< inline void b2Body::ApplyTorque(float32 torque, bool wake)
< {
< 	if (m_type != b2_dynamicBody)
< 	{
< 		return;
< 	}
< 
< 	if (wake && (m_flags & e_awakeFlag) == 0)
< 	{
< 		SetAwake(true);
< 	}
< 
< 	// Don't accumulate a force if the body is sleeping
< 	if (m_flags & e_awakeFlag)
---
> 	if (IsSleeping())
791c587
< 		m_torque += torque;
---
> 		WakeUp();
792a589,590
> 	m_force += force;
> 	m_torque += b2Cross(point - m_sweep.c, force);
795c593
< inline void b2Body::ApplyLinearImpulse(const b2Vec2& impulse, const b2Vec2& point, bool wake)
---
> inline void b2Body::ApplyTorque(float32 torque)
797c595
< 	if (m_type != b2_dynamicBody)
---
> 	if (IsSleeping())
799,811c597
< 		return;
< 	}
< 
< 	if (wake && (m_flags & e_awakeFlag) == 0)
< 	{
< 		SetAwake(true);
< 	}
< 
< 	// Don't accumulate velocity if the body is sleeping
< 	if (m_flags & e_awakeFlag)
< 	{
< 		m_linearVelocity += m_invMass * impulse;
< 		m_angularVelocity += m_invI * b2Cross(point - m_sweep.c, impulse);
---
> 		WakeUp();
812a599
> 	m_torque += torque;
815c602
< inline void b2Body::ApplyAngularImpulse(float32 impulse, bool wake)
---
> inline void b2Body::ApplyImpulse(const b2Vec2& impulse, const b2Vec2& point)
817c604
< 	if (m_type != b2_dynamicBody)
---
> 	if (IsSleeping())
819,830c606
< 		return;
< 	}
< 
< 	if (wake && (m_flags & e_awakeFlag) == 0)
< 	{
< 		SetAwake(true);
< 	}
< 
< 	// Don't accumulate velocity if the body is sleeping
< 	if (m_flags & e_awakeFlag)
< 	{
< 		m_angularVelocity += m_invI * impulse;
---
> 		WakeUp();
831a608,609
> 	m_linearVelocity += m_invMass * impulse;
> 	m_angularVelocity += m_invI * b2Cross(point - m_sweep.c, impulse);
836,837c614,615
< 	m_xf.q.Set(m_sweep.a);
< 	m_xf.p = m_sweep.c - b2Mul(m_xf.q, m_sweep.localCenter);
---
> 	m_xf.R.Set(m_sweep.a);
> 	m_xf.position = m_sweep.c - b2Mul(m_xf.R, m_sweep.localCenter);
840c618
< inline void b2Body::Advance(float32 alpha)
---
> inline void b2Body::Advance(float32 t)
842,843c620,621
< 	// Advance to the new safe time. This doesn't sync the broad-phase.
< 	m_sweep.Advance(alpha);
---
> 	// Advance to the new safe time.
> 	m_sweep.Advance(t);
846,847c624
< 	m_xf.q.Set(m_sweep.a);
< 	m_xf.p = m_sweep.c - b2Mul(m_xf.q, m_sweep.localCenter);
---
> 	SynchronizeTransform();
855,859d631
< inline const b2World* b2Body::GetWorld() const
< {
< 	return m_world;
< }
< 
diff -r -x './svn/*' native/Box2D/Dynamics/b2ContactManager.cpp ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/b2ContactManager.cpp
2c2
< * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
19,28c19,25
< #include <Box2D/Dynamics/b2ContactManager.h>
< #include <Box2D/Dynamics/b2Body.h>
< #include <Box2D/Dynamics/b2Fixture.h>
< #include <Box2D/Dynamics/b2WorldCallbacks.h>
< #include <Box2D/Dynamics/Contacts/b2Contact.h>
< 
< b2ContactFilter b2_defaultFilter;
< b2ContactListener b2_defaultListener;
< 
< b2ContactManager::b2ContactManager()
---
> #include "b2ContactManager.h"
> #include "b2World.h"
> #include "b2Body.h"
> 
> // This is a callback from the broadphase when two AABB proxies begin
> // to overlap. We create a b2Contact to manage the narrow phase.
> void* b2ContactManager::PairAdded(void* proxyUserData1, void* proxyUserData2)
30,35c27,28
< 	m_contactList = NULL;
< 	m_contactCount = 0;
< 	m_contactFilter = &b2_defaultFilter;
< 	m_contactListener = &b2_defaultListener;
< 	m_allocator = NULL;
< }
---
> 	b2Shape* shape1 = (b2Shape*)proxyUserData1;
> 	b2Shape* shape2 = (b2Shape*)proxyUserData2;
37,42c30,31
< void b2ContactManager::Destroy(b2Contact* c)
< {
< 	b2Fixture* fixtureA = c->GetFixtureA();
< 	b2Fixture* fixtureB = c->GetFixtureB();
< 	b2Body* bodyA = fixtureA->GetBody();
< 	b2Body* bodyB = fixtureB->GetBody();
---
> 	b2Body* body1 = shape1->GetBody();
> 	b2Body* body2 = shape2->GetBody();
44c33
< 	if (m_contactListener && c->IsTouching())
---
> 	if (body1->IsStatic() && body2->IsStatic())
46c35
< 		m_contactListener->EndContact(c);
---
> 		return &m_nullContact;
49,50c38
< 	// Remove from the world.
< 	if (c->m_prev)
---
> 	if (shape1->GetBody() == shape2->GetBody())
52c40
< 		c->m_prev->m_next = c->m_next;
---
> 		return &m_nullContact;
55c43
< 	if (c->m_next)
---
> 	if (body2->IsConnected(body1))
57c45
< 		c->m_next->m_prev = c->m_prev;
---
> 		return &m_nullContact;
60c48
< 	if (c == m_contactList)
---
> 	if (m_world->m_contactFilter != NULL && m_world->m_contactFilter->ShouldCollide(shape1, shape2) == false)
62c50
< 		m_contactList = c->m_next;
---
> 		return &m_nullContact;
65,69c53,54
< 	// Remove from body 1
< 	if (c->m_nodeA.prev)
< 	{
< 		c->m_nodeA.prev->next = c->m_nodeA.next;
< 	}
---
> 	// Call the factory.
> 	b2Contact* c = b2Contact::Create(shape1, shape2, &m_world->m_blockAllocator);
71c56
< 	if (c->m_nodeA.next)
---
> 	if (c == NULL)
73c58
< 		c->m_nodeA.next->prev = c->m_nodeA.prev;
---
> 		return &m_nullContact;
76,79c61,65
< 	if (&c->m_nodeA == bodyA->m_contactList)
< 	{
< 		bodyA->m_contactList = c->m_nodeA.next;
< 	}
---
> 	// Contact creation may swap shapes.
> 	shape1 = c->GetShape1();
> 	shape2 = c->GetShape2();
> 	body1 = shape1->GetBody();
> 	body2 = shape2->GetBody();
81,82c67,70
< 	// Remove from body 2
< 	if (c->m_nodeB.prev)
---
> 	// Insert into the world.
> 	c->m_prev = NULL;
> 	c->m_next = m_world->m_contactList;
> 	if (m_world->m_contactList != NULL)
84c72
< 		c->m_nodeB.prev->next = c->m_nodeB.next;
---
> 		m_world->m_contactList->m_prev = c;
85a74
> 	m_world->m_contactList = c;
87,90c76
< 	if (c->m_nodeB.next)
< 	{
< 		c->m_nodeB.next->prev = c->m_nodeB.prev;
< 	}
---
> 	// Connect to island graph.
92c78,84
< 	if (&c->m_nodeB == bodyB->m_contactList)
---
> 	// Connect to body 1
> 	c->m_node1.contact = c;
> 	c->m_node1.other = body2;
> 
> 	c->m_node1.prev = NULL;
> 	c->m_node1.next = body1->m_contactList;
> 	if (body1->m_contactList != NULL)
94c86
< 		bodyB->m_contactList = c->m_nodeB.next;
---
> 		body1->m_contactList->prev = &c->m_node1;
95a88
> 	body1->m_contactList = &c->m_node1;
97,100c90,92
< 	// Call the factory.
< 	b2Contact::Destroy(c, m_allocator);
< 	--m_contactCount;
< }
---
> 	// Connect to body 2
> 	c->m_node2.contact = c;
> 	c->m_node2.other = body1;
102,109c94,96
< // This is the top level collision call for the time step. Here
< // all the narrow phase collision is processed for the world
< // contact list.
< void b2ContactManager::Collide()
< {
< 	// Update awake contacts.
< 	b2Contact* c = m_contactList;
< 	while (c)
---
> 	c->m_node2.prev = NULL;
> 	c->m_node2.next = body2->m_contactList;
> 	if (body2->m_contactList != NULL)
111,168c98
< 		b2Fixture* fixtureA = c->GetFixtureA();
< 		b2Fixture* fixtureB = c->GetFixtureB();
< 		int32 indexA = c->GetChildIndexA();
< 		int32 indexB = c->GetChildIndexB();
< 		b2Body* bodyA = fixtureA->GetBody();
< 		b2Body* bodyB = fixtureB->GetBody();
< 		 
< 		// Is this contact flagged for filtering?
< 		if (c->m_flags & b2Contact::e_filterFlag)
< 		{
< 			// Should these bodies collide?
< 			if (bodyB->ShouldCollide(bodyA) == false)
< 			{
< 				b2Contact* cNuke = c;
< 				c = cNuke->GetNext();
< 				Destroy(cNuke);
< 				continue;
< 			}
< 
< 			// Check user filtering.
< 			if (m_contactFilter && m_contactFilter->ShouldCollide(fixtureA, fixtureB) == false)
< 			{
< 				b2Contact* cNuke = c;
< 				c = cNuke->GetNext();
< 				Destroy(cNuke);
< 				continue;
< 			}
< 
< 			// Clear the filtering flag.
< 			c->m_flags &= ~b2Contact::e_filterFlag;
< 		}
< 
< 		bool activeA = bodyA->IsAwake() && bodyA->m_type != b2_staticBody;
< 		bool activeB = bodyB->IsAwake() && bodyB->m_type != b2_staticBody;
< 
< 		// At least one body must be awake and it must be dynamic or kinematic.
< 		if (activeA == false && activeB == false)
< 		{
< 			c = c->GetNext();
< 			continue;
< 		}
< 
< 		int32 proxyIdA = fixtureA->m_proxies[indexA].proxyId;
< 		int32 proxyIdB = fixtureB->m_proxies[indexB].proxyId;
< 		bool overlap = m_broadPhase.TestOverlap(proxyIdA, proxyIdB);
< 
< 		// Here we destroy contacts that cease to overlap in the broad-phase.
< 		if (overlap == false)
< 		{
< 			b2Contact* cNuke = c;
< 			c = cNuke->GetNext();
< 			Destroy(cNuke);
< 			continue;
< 		}
< 
< 		// The contact persists.
< 		c->Update(m_contactListener);
< 		c = c->GetNext();
---
> 		body2->m_contactList->prev = &c->m_node2;
170c100
< }
---
> 	body2->m_contactList = &c->m_node2;
172,174c102,103
< void b2ContactManager::FindNewContacts()
< {
< 	m_broadPhase.UpdatePairs(this);
---
> 	++m_world->m_contactCount;
> 	return c;
177c106,108
< void b2ContactManager::AddPair(void* proxyUserDataA, void* proxyUserDataB)
---
> // This is a callback from the broadphase when two AABB proxies cease
> // to overlap. We retire the b2Contact.
> void b2ContactManager::PairRemoved(void* proxyUserData1, void* proxyUserData2, void* pairUserData)
179,183c110,111
< 	b2FixtureProxy* proxyA = (b2FixtureProxy*)proxyUserDataA;
< 	b2FixtureProxy* proxyB = (b2FixtureProxy*)proxyUserDataB;
< 
< 	b2Fixture* fixtureA = proxyA->fixture;
< 	b2Fixture* fixtureB = proxyB->fixture;
---
> 	B2_NOT_USED(proxyUserData1);
> 	B2_NOT_USED(proxyUserData2);
185,189c113,116
< 	int32 indexA = proxyA->childIndex;
< 	int32 indexB = proxyB->childIndex;
< 
< 	b2Body* bodyA = fixtureA->GetBody();
< 	b2Body* bodyB = fixtureB->GetBody();
---
> 	if (pairUserData == NULL)
> 	{
> 		return;
> 	}
191,192c118,119
< 	// Are the fixtures on the same body?
< 	if (bodyA == bodyB)
---
> 	b2Contact* c = (b2Contact*)pairUserData;
> 	if (c == &m_nullContact)
197,201c124,144
< 	// TODO_ERIN use a hash table to remove a potential bottleneck when both
< 	// bodies have a lot of contacts.
< 	// Does a contact already exist?
< 	b2ContactEdge* edge = bodyB->GetContactList();
< 	while (edge)
---
> 	// An attached body is being destroyed, we must destroy this contact
> 	// immediately to avoid orphaned shape pointers.
> 	Destroy(c);
> }
> 
> void b2ContactManager::Destroy(b2Contact* c)
> {
> 	b2Shape* shape1 = c->GetShape1();
> 	b2Shape* shape2 = c->GetShape2();
> 	b2Body* body1 = shape1->GetBody();
> 	b2Body* body2 = shape2->GetBody();
> 
> 	b2ContactPoint cp;
> 	cp.shape1 = shape1;
> 	cp.shape2 = shape2;
> 	cp.friction = b2MixFriction(shape1->GetFriction(), shape2->GetFriction());
> 	cp.restitution = b2MixRestitution(shape1->GetRestitution(), shape2->GetRestitution());
> 
> 	// Inform the user that this contact is ending.
> 	int32 manifoldCount = c->GetManifoldCount();
> 	if (manifoldCount > 0 && m_world->m_contactListener)
203,208c146
< 		if (edge->other == bodyA)
< 		{
< 			b2Fixture* fA = edge->contact->GetFixtureA();
< 			b2Fixture* fB = edge->contact->GetFixtureB();
< 			int32 iA = edge->contact->GetChildIndexA();
< 			int32 iB = edge->contact->GetChildIndexB();
---
> 		b2Manifold* manifolds = c->GetManifolds();
210,214c148,151
< 			if (fA == fixtureA && fB == fixtureB && iA == indexA && iB == indexB)
< 			{
< 				// A contact already exists.
< 				return;
< 			}
---
> 		for (int32 i = 0; i < manifoldCount; ++i)
> 		{
> 			b2Manifold* manifold = manifolds + i;
> 			cp.normal = manifold->normal;
216c153
< 			if (fA == fixtureB && fB == fixtureA && iA == indexB && iB == indexA)
---
> 			for (int32 j = 0; j < manifold->pointCount; ++j)
218,219c155,162
< 				// A contact already exists.
< 				return;
---
> 				b2ManifoldPoint* mp = manifold->points + j;
> 				cp.position = body1->GetWorldPoint(mp->localPoint1);
> 				b2Vec2 v1 = body1->GetLinearVelocityFromLocalPoint(mp->localPoint1);
> 				b2Vec2 v2 = body2->GetLinearVelocityFromLocalPoint(mp->localPoint2);
> 				cp.velocity = v2 - v1;
> 				cp.separation = mp->separation;
> 				cp.id = mp->id;
> 				m_world->m_contactListener->Remove(&cp);
222,223d164
< 
< 		edge = edge->next;
226,227c167,168
< 	// Does a joint override collision? Is at least one body dynamic?
< 	if (bodyB->ShouldCollide(bodyA) == false)
---
> 	// Remove from the world.
> 	if (c->m_prev)
229c170
< 		return;
---
> 		c->m_prev->m_next = c->m_next;
232,233c173
< 	// Check user filtering.
< 	if (m_contactFilter && m_contactFilter->ShouldCollide(fixtureA, fixtureB) == false)
---
> 	if (c->m_next)
235c175
< 		return;
---
> 		c->m_next->m_prev = c->m_prev;
238,240c178
< 	// Call the factory.
< 	b2Contact* c = b2Contact::Create(fixtureA, indexA, fixtureB, indexB, m_allocator);
< 	if (c == NULL)
---
> 	if (c == m_world->m_contactList)
242c180
< 		return;
---
> 		m_world->m_contactList = c->m_next;
245,256c183,184
< 	// Contact creation may swap fixtures.
< 	fixtureA = c->GetFixtureA();
< 	fixtureB = c->GetFixtureB();
< 	indexA = c->GetChildIndexA();
< 	indexB = c->GetChildIndexB();
< 	bodyA = fixtureA->GetBody();
< 	bodyB = fixtureB->GetBody();
< 
< 	// Insert into the world.
< 	c->m_prev = NULL;
< 	c->m_next = m_contactList;
< 	if (m_contactList != NULL)
---
> 	// Remove from body 1
> 	if (c->m_node1.prev)
258c186
< 		m_contactList->m_prev = c;
---
> 		c->m_node1.prev->next = c->m_node1.next;
260d187
< 	m_contactList = c;
262,266c189,192
< 	// Connect to island graph.
< 
< 	// Connect to body A
< 	c->m_nodeA.contact = c;
< 	c->m_nodeA.other = bodyB;
---
> 	if (c->m_node1.next)
> 	{
> 		c->m_node1.next->prev = c->m_node1.prev;
> 	}
268,270c194
< 	c->m_nodeA.prev = NULL;
< 	c->m_nodeA.next = bodyA->m_contactList;
< 	if (bodyA->m_contactList != NULL)
---
> 	if (&c->m_node1 == body1->m_contactList)
272c196
< 		bodyA->m_contactList->prev = &c->m_nodeA;
---
> 		body1->m_contactList = c->m_node1.next;
274d197
< 	bodyA->m_contactList = &c->m_nodeA;
276,278c199,203
< 	// Connect to body B
< 	c->m_nodeB.contact = c;
< 	c->m_nodeB.other = bodyA;
---
> 	// Remove from body 2
> 	if (c->m_node2.prev)
> 	{
> 		c->m_node2.prev->next = c->m_node2.next;
> 	}
280,282c205
< 	c->m_nodeB.prev = NULL;
< 	c->m_nodeB.next = bodyB->m_contactList;
< 	if (bodyB->m_contactList != NULL)
---
> 	if (c->m_node2.next)
284c207
< 		bodyB->m_contactList->prev = &c->m_nodeB;
---
> 		c->m_node2.next->prev = c->m_node2.prev;
286d208
< 	bodyB->m_contactList = &c->m_nodeB;
288,289c210
< 	// Wake up the bodies
< 	if (fixtureA->IsSensor() == false && fixtureB->IsSensor() == false)
---
> 	if (&c->m_node2 == body2->m_contactList)
291,292c212
< 		bodyA->SetAwake(true);
< 		bodyB->SetAwake(true);
---
> 		body2->m_contactList = c->m_node2.next;
295c215,236
< 	++m_contactCount;
---
> 	// Call the factory.
> 	b2Contact::Destroy(c, &m_world->m_blockAllocator);
> 	--m_world->m_contactCount;
> }
> 
> // This is the top level collision call for the time step. Here
> // all the narrow phase collision is processed for the world
> // contact list.
> void b2ContactManager::Collide()
> {
> 	// Update awake contacts.
> 	for (b2Contact* c = m_world->m_contactList; c; c = c->GetNext())
> 	{
> 		b2Body* body1 = c->GetShape1()->GetBody();
> 		b2Body* body2 = c->GetShape2()->GetBody();
> 		if (body1->IsSleeping() && body2->IsSleeping())
> 		{
> 			continue;
> 		}
> 
> 		c->Update(m_world->m_contactListener);
> 	}
diff -r -x './svn/*' native/Box2D/Dynamics/b2ContactManager.h ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/b2ContactManager.h
2c2
< * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
22c22,23
< #include <Box2D/Collision/b2BroadPhase.h>
---
> #include "../Collision/b2BroadPhase.h"
> #include "../Dynamics/Contacts/b2NullContact.h"
23a25
> class b2World;
25,27c27
< class b2ContactFilter;
< class b2ContactListener;
< class b2BlockAllocator;
---
> struct b2TimeStep;
30c30
< class b2ContactManager
---
> class b2ContactManager : public b2PairCallback
33c33
< 	b2ContactManager();
---
> 	b2ContactManager() : m_world(NULL), m_destroyImmediate(false) {}
35,36c35,36
< 	// Broad-phase callback.
< 	void AddPair(void* proxyUserDataA, void* proxyUserDataB);
---
> 	// Implements PairCallback
> 	void* PairAdded(void* proxyUserData1, void* proxyUserData2);
38c38,39
< 	void FindNewContacts();
---
> 	// Implements PairCallback
> 	void PairRemoved(void* proxyUserData1, void* proxyUserData2, void* pairUserData);
43,49c44,51
<             
< 	b2BroadPhase m_broadPhase;
< 	b2Contact* m_contactList;
< 	int32 m_contactCount;
< 	b2ContactFilter* m_contactFilter;
< 	b2ContactListener* m_contactListener;
< 	b2BlockAllocator* m_allocator;
---
> 
> 	b2World* m_world;
> 
> 	// This lets us provide broadphase proxy pair user data for
> 	// contacts that shouldn't exist.
> 	b2NullContact m_nullContact;
> 
> 	bool m_destroyImmediate;
Only in native/Box2D/Dynamics: b2Fixture.cpp
Only in native/Box2D/Dynamics: b2Fixture.h
diff -r -x './svn/*' native/Box2D/Dynamics/b2Island.cpp ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/b2Island.cpp
2c2
< * Copyright (c) 2006-2011 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
19,28c19,25
< #include <Box2D/Collision/b2Distance.h>
< #include <Box2D/Dynamics/b2Island.h>
< #include <Box2D/Dynamics/b2Body.h>
< #include <Box2D/Dynamics/b2Fixture.h>
< #include <Box2D/Dynamics/b2World.h>
< #include <Box2D/Dynamics/Contacts/b2Contact.h>
< #include <Box2D/Dynamics/Contacts/b2ContactSolver.h>
< #include <Box2D/Dynamics/Joints/b2Joint.h>
< #include <Box2D/Common/b2StackAllocator.h>
< #include <Box2D/Common/b2Timer.h>
---
> #include "b2Island.h"
> #include "b2Body.h"
> #include "b2World.h"
> #include "Contacts/b2Contact.h"
> #include "Contacts/b2ContactSolver.h"
> #include "Joints/b2Joint.h"
> #include "../Common/b2StackAllocator.h"
183c180
< void b2Island::Solve(b2Profile* profile, const b2TimeStep& step, const b2Vec2& gravity, bool allowSleep)
---
> void b2Island::Solve(const b2TimeStep& step, const b2Vec2& gravity, bool allowSleep)
185,189c182
< 	b2Timer timer;
< 
< 	float32 h = step.dt;
< 
< 	// Integrate velocities and apply damping. Initialize the body state.
---
> 	// Integrate velocities and apply damping.
194,197c187,188
< 		b2Vec2 c = b->m_sweep.c;
< 		float32 a = b->m_sweep.a;
< 		b2Vec2 v = b->m_linearVelocity;
< 		float32 w = b->m_angularVelocity;
---
> 		if (b->IsStatic())
> 			continue;
199,201c190,196
< 		// Store positions for continuous collision.
< 		b->m_sweep.c0 = b->m_sweep.c;
< 		b->m_sweep.a0 = b->m_sweep.a;
---
> 		// Integrate velocities.
> 		b->m_linearVelocity += step.dt * (gravity + b->m_invMass * b->m_force);
> 		b->m_angularVelocity += step.dt * b->m_invI * b->m_torque;
> 
> 		// Reset forces.
> 		b->m_force.Set(0.0f, 0.0f);
> 		b->m_torque = 0.0f;
203c198,227
< 		if (b->m_type == b2_dynamicBody)
---
> 		// Apply damping.
> 		// ODE: dv/dt + c * v = 0
> 		// Solution: v(t) = v0 * exp(-c * t)
> 		// Time step: v(t + dt) = v0 * exp(-c * (t + dt)) = v0 * exp(-c * t) * exp(-c * dt) = v * exp(-c * dt)
> 		// v2 = exp(-c * dt) * v1
> 		// Taylor expansion:
> 		// v2 = (1.0f - c * dt) * v1
> 		b->m_linearVelocity *= b2Clamp(1.0f - step.dt * b->m_linearDamping, 0.0f, 1.0f);
> 		b->m_angularVelocity *= b2Clamp(1.0f - step.dt * b->m_angularDamping, 0.0f, 1.0f);
> 
> 		// Check for large velocities.
> #ifdef TARGET_FLOAT32_IS_FIXED
> 		// Fixed point code written this way to prevent
> 		// overflows, float code is optimized for speed
> 
> 		float32 vMagnitude = b->m_linearVelocity.Length();
> 		if(vMagnitude > b2_maxLinearVelocity) {
> 			b->m_linearVelocity *= b2_maxLinearVelocity/vMagnitude;
> 		}
> 		b->m_angularVelocity = b2Clamp(b->m_angularVelocity, 
> 			-b2_maxAngularVelocity, b2_maxAngularVelocity);
> 
> #else
> 
> 		if (b2Dot(b->m_linearVelocity, b->m_linearVelocity) > b2_maxLinearVelocitySquared)
> 		{
> 			b->m_linearVelocity.Normalize();
> 			b->m_linearVelocity *= b2_maxLinearVelocity;
> 		}
> 		if (b->m_angularVelocity * b->m_angularVelocity > b2_maxAngularVelocitySquared)
205,217c229,236
< 			// Integrate velocities.
< 			v += h * (b->m_gravityScale * gravity + b->m_invMass * b->m_force);
< 			w += h * b->m_invI * b->m_torque;
< 
< 			// Apply damping.
< 			// ODE: dv/dt + c * v = 0
< 			// Solution: v(t) = v0 * exp(-c * t)
< 			// Time step: v(t + dt) = v0 * exp(-c * (t + dt)) = v0 * exp(-c * t) * exp(-c * dt) = v * exp(-c * dt)
< 			// v2 = exp(-c * dt) * v1
< 			// Taylor expansion:
< 			// v2 = (1.0f - c * dt) * v1
< 			v *= b2Clamp(1.0f - h * b->m_linearDamping, 0.0f, 1.0f);
< 			w *= b2Clamp(1.0f - h * b->m_angularDamping, 0.0f, 1.0f);
---
> 			if (b->m_angularVelocity < 0.0f)
> 			{
> 				b->m_angularVelocity = -b2_maxAngularVelocity;
> 			}
> 			else
> 			{
> 				b->m_angularVelocity = b2_maxAngularVelocity;
> 			}
218a238
> #endif
220,223d239
< 		m_positions[i].c = c;
< 		m_positions[i].a = a;
< 		m_velocities[i].v = v;
< 		m_velocities[i].w = w;
226,232c242
< 	timer.Reset();
< 
< 	// Solver data
< 	b2SolverData solverData;
< 	solverData.step = step;
< 	solverData.positions = m_positions;
< 	solverData.velocities = m_velocities;
---
> 	b2ContactSolver contactSolver(step, m_contacts, m_contactCount, m_allocator);
235,244c245
< 	b2ContactSolverDef contactSolverDef;
< 	contactSolverDef.step = step;
< 	contactSolverDef.contacts = m_contacts;
< 	contactSolverDef.count = m_contactCount;
< 	contactSolverDef.positions = m_positions;
< 	contactSolverDef.velocities = m_velocities;
< 	contactSolverDef.allocator = m_allocator;
< 
< 	b2ContactSolver contactSolver(&contactSolverDef);
< 	contactSolver.InitializeVelocityConstraints();
---
> 	contactSolver.InitVelocityConstraints(step);
246,250d246
< 	if (step.warmStarting)
< 	{
< 		contactSolver.WarmStart();
< 	}
< 	
253c249
< 		m_joints[i]->InitVelocityConstraints(solverData);
---
> 		m_joints[i]->InitVelocityConstraints(step);
256,259c252
< 	profile->solveInit = timer.GetMilliseconds();
< 
< 	// Solve velocity constraints
< 	timer.Reset();
---
> 	// Solve velocity constraints.
264c257
< 			m_joints[j]->SolveVelocityConstraints(solverData);
---
> 			m_joints[j]->SolveVelocityConstraints(step);
270,272c263,264
< 	// Store impulses for warm starting
< 	contactSolver.StoreImpulses();
< 	profile->solveVelocity = timer.GetMilliseconds();
---
> 	// Post-solve (store impulses for warm starting).
> 	contactSolver.FinalizeVelocityConstraints();
274c266
< 	// Integrate positions
---
> 	// Integrate positions.
277,288c269
< 		b2Vec2 c = m_positions[i].c;
< 		float32 a = m_positions[i].a;
< 		b2Vec2 v = m_velocities[i].v;
< 		float32 w = m_velocities[i].w;
< 
< 		// Check for large velocities
< 		b2Vec2 translation = h * v;
< 		if (b2Dot(translation, translation) > b2_maxTranslationSquared)
< 		{
< 			float32 ratio = b2_maxTranslation / translation.Length();
< 			v *= ratio;
< 		}
---
> 		b2Body* b = m_bodies[i];
290,295c271,276
< 		float32 rotation = h * w;
< 		if (rotation * rotation > b2_maxRotationSquared)
< 		{
< 			float32 ratio = b2_maxRotation / b2Abs(rotation);
< 			w *= ratio;
< 		}
---
> 		if (b->IsStatic())
> 			continue;
> 
> 		// Store positions for continuous collision.
> 		b->m_sweep.c0 = b->m_sweep.c;
> 		b->m_sweep.a0 = b->m_sweep.a;
298,299c279,280
< 		c += h * v;
< 		a += h * w;
---
> 		b->m_sweep.c += step.dt * b->m_linearVelocity;
> 		b->m_sweep.a += step.dt * b->m_angularVelocity;
301,304c282,285
< 		m_positions[i].c = c;
< 		m_positions[i].a = a;
< 		m_velocities[i].v = v;
< 		m_velocities[i].w = w;
---
> 		// Compute new transform
> 		b->SynchronizeTransform();
> 
> 		// Note: shapes are synchronized later.
307,309c288
< 	// Solve position constraints
< 	timer.Reset();
< 	bool positionSolved = false;
---
> 	// Iterate over constraints.
312c291
< 		bool contactsOkay = contactSolver.SolvePositionConstraints();
---
> 		bool contactsOkay = contactSolver.SolvePositionConstraints(b2_contactBaumgarte);
317c296
< 			bool jointOkay = m_joints[i]->SolvePositionConstraints(solverData);
---
> 			bool jointOkay = m_joints[i]->SolvePositionConstraints(b2_contactBaumgarte);
324d302
< 			positionSolved = true;
329,342c307
< 	// Copy state buffers back to the bodies
< 	for (int32 i = 0; i < m_bodyCount; ++i)
< 	{
< 		b2Body* body = m_bodies[i];
< 		body->m_sweep.c = m_positions[i].c;
< 		body->m_sweep.a = m_positions[i].a;
< 		body->m_linearVelocity = m_velocities[i].v;
< 		body->m_angularVelocity = m_velocities[i].w;
< 		body->SynchronizeTransform();
< 	}
< 
< 	profile->solvePosition = timer.GetMilliseconds();
< 
< 	Report(contactSolver.m_velocityConstraints);
---
> 	Report(contactSolver.m_constraints);
346c311
< 		float32 minSleepTime = b2_maxFloat;
---
> 		float32 minSleepTime = B2_FLT_MAX;
347a313
> #ifndef TARGET_FLOAT32_IS_FIXED
349a316
> #endif
354c321
< 			if (b->GetType() == b2_staticBody)
---
> 			if (b->m_invMass == 0.0f)
359c326,337
< 			if ((b->m_flags & b2Body::e_autoSleepFlag) == 0 ||
---
> 			if ((b->m_flags & b2Body::e_allowSleepFlag) == 0)
> 			{
> 				b->m_sleepTime = 0.0f;
> 				minSleepTime = 0.0f;
> 			}
> 
> 			if ((b->m_flags & b2Body::e_allowSleepFlag) == 0 ||
> #ifdef TARGET_FLOAT32_IS_FIXED
> 				b2Abs(b->m_angularVelocity) > b2_angularSleepTolerance ||
> 				b2Abs(b->m_linearVelocity.x) > b2_linearSleepTolerance ||
> 				b2Abs(b->m_linearVelocity.y) > b2_linearSleepTolerance)
> #else
361a340
> #endif
368c347
< 				b->m_sleepTime += h;
---
> 				b->m_sleepTime += step.dt;
373c352
< 		if (minSleepTime >= b2_timeToSleep && positionSolved)
---
> 		if (minSleepTime >= b2_timeToSleep)
378c357,359
< 				b->SetAwake(false);
---
> 				b->m_flags |= b2Body::e_sleepFlag;
> 				b->m_linearVelocity = b2Vec2_zero;
> 				b->m_angularVelocity = 0.0f;
384c365
< void b2Island::SolveTOI(const b2TimeStep& subStep, int32 toiIndexA, int32 toiIndexB)
---
> void b2Island::SolveTOI(b2TimeStep& subStep)
386,387c367
< 	b2Assert(toiIndexA < m_bodyCount);
< 	b2Assert(toiIndexB < m_bodyCount);
---
> 	b2ContactSolver contactSolver(subStep, m_contacts, m_contactCount, m_allocator);
389,416c369
< 	// Initialize the body state.
< 	for (int32 i = 0; i < m_bodyCount; ++i)
< 	{
< 		b2Body* b = m_bodies[i];
< 		m_positions[i].c = b->m_sweep.c;
< 		m_positions[i].a = b->m_sweep.a;
< 		m_velocities[i].v = b->m_linearVelocity;
< 		m_velocities[i].w = b->m_angularVelocity;
< 	}
< 
< 	b2ContactSolverDef contactSolverDef;
< 	contactSolverDef.contacts = m_contacts;
< 	contactSolverDef.count = m_contactCount;
< 	contactSolverDef.allocator = m_allocator;
< 	contactSolverDef.step = subStep;
< 	contactSolverDef.positions = m_positions;
< 	contactSolverDef.velocities = m_velocities;
< 	b2ContactSolver contactSolver(&contactSolverDef);
< 
< 	// Solve position constraints.
< 	for (int32 i = 0; i < subStep.positionIterations; ++i)
< 	{
< 		bool contactsOkay = contactSolver.SolveTOIPositionConstraints(toiIndexA, toiIndexB);
< 		if (contactsOkay)
< 		{
< 			break;
< 		}
< 	}
---
> 	// No warm starting needed for TOI contact events.
418,420c371,373
< #if 0
< 	// Is the new position really safe?
< 	for (int32 i = 0; i < m_contactCount; ++i)
---
> 	// Warm starting for joints is off for now, but we need to
> 	// call this function to compute Jacobians.
> 	for (int32 i = 0; i < m_jointCount; ++i)
422,447c375
< 		b2Contact* c = m_contacts[i];
< 		b2Fixture* fA = c->GetFixtureA();
< 		b2Fixture* fB = c->GetFixtureB();
< 
< 		b2Body* bA = fA->GetBody();
< 		b2Body* bB = fB->GetBody();
< 
< 		int32 indexA = c->GetChildIndexA();
< 		int32 indexB = c->GetChildIndexB();
< 
< 		b2DistanceInput input;
< 		input.proxyA.Set(fA->GetShape(), indexA);
< 		input.proxyB.Set(fB->GetShape(), indexB);
< 		input.transformA = bA->GetTransform();
< 		input.transformB = bB->GetTransform();
< 		input.useRadii = false;
< 
< 		b2DistanceOutput output;
< 		b2SimplexCache cache;
< 		cache.count = 0;
< 		b2Distance(&output, &cache, &input);
< 
< 		if (output.distance == 0 || cache.count == 3)
< 		{
< 			cache.count += 0;
< 		}
---
> 		m_joints[i]->InitVelocityConstraints(subStep);
449,459d376
< #endif
< 
< 	// Leap of faith to new safe state.
< 	m_bodies[toiIndexA]->m_sweep.c0 = m_positions[toiIndexA].c;
< 	m_bodies[toiIndexA]->m_sweep.a0 = m_positions[toiIndexA].a;
< 	m_bodies[toiIndexB]->m_sweep.c0 = m_positions[toiIndexB].c;
< 	m_bodies[toiIndexB]->m_sweep.a0 = m_positions[toiIndexB].a;
< 
< 	// No warm starting is needed for TOI events because warm
< 	// starting impulses were applied in the discrete solver.
< 	contactSolver.InitializeVelocityConstraints();
464a382,385
> 		for (int32 j = 0; j < m_jointCount; ++j)
> 		{
> 			m_joints[j]->SolveVelocityConstraints(subStep);
> 		}
470,472c391
< 	float32 h = subStep.dt;
< 
< 	// Integrate positions
---
> 	// Integrate positions.
475,486c394
< 		b2Vec2 c = m_positions[i].c;
< 		float32 a = m_positions[i].a;
< 		b2Vec2 v = m_velocities[i].v;
< 		float32 w = m_velocities[i].w;
< 
< 		// Check for large velocities
< 		b2Vec2 translation = h * v;
< 		if (b2Dot(translation, translation) > b2_maxTranslationSquared)
< 		{
< 			float32 ratio = b2_maxTranslation / translation.Length();
< 			v *= ratio;
< 		}
---
> 		b2Body* b = m_bodies[i];
488,493c396,401
< 		float32 rotation = h * w;
< 		if (rotation * rotation > b2_maxRotationSquared)
< 		{
< 			float32 ratio = b2_maxRotation / b2Abs(rotation);
< 			w *= ratio;
< 		}
---
> 		if (b->IsStatic())
> 			continue;
> 
> 		// Store positions for continuous collision.
> 		b->m_sweep.c0 = b->m_sweep.c;
> 		b->m_sweep.a0 = b->m_sweep.a;
496,497c404,408
< 		c += h * v;
< 		a += h * w;
---
> 		b->m_sweep.c += subStep.dt * b->m_linearVelocity;
> 		b->m_sweep.a += subStep.dt * b->m_angularVelocity;
> 
> 		// Compute new transform
> 		b->SynchronizeTransform();
499,510c410
< 		m_positions[i].c = c;
< 		m_positions[i].a = a;
< 		m_velocities[i].v = v;
< 		m_velocities[i].w = w;
< 
< 		// Sync bodies
< 		b2Body* body = m_bodies[i];
< 		body->m_sweep.c = c;
< 		body->m_sweep.a = a;
< 		body->m_linearVelocity = v;
< 		body->m_angularVelocity = w;
< 		body->SynchronizeTransform();
---
> 		// Note: shapes are synchronized later.
513c413,431
< 	Report(contactSolver.m_velocityConstraints);
---
> 	// Solve position constraints.
> 	const float32 k_toiBaumgarte = 0.75f;
> 	for (int32 i = 0; i < subStep.positionIterations; ++i)
> 	{
> 		bool contactsOkay = contactSolver.SolvePositionConstraints(k_toiBaumgarte);
> 		bool jointsOkay = true;
> 		for (int32 j = 0; j < m_jointCount; ++j)
> 		{
> 			bool jointOkay = m_joints[j]->SolvePositionConstraints(k_toiBaumgarte);
> 			jointsOkay = jointsOkay && jointOkay;
> 		}
> 		
> 		if (contactsOkay && jointsOkay)
> 		{
> 			break;
> 		}
> 	}
> 
> 	Report(contactSolver.m_constraints);
516c434
< void b2Island::Report(const b2ContactVelocityConstraint* constraints)
---
> void b2Island::Report(b2ContactConstraint* constraints)
525a444,465
> 		b2ContactConstraint* cc = constraints + i;
> 		b2ContactResult cr;
> 		cr.shape1 = c->GetShape1();
> 		cr.shape2 = c->GetShape2();
> 		b2Body* b1 = cr.shape1->GetBody();
> 		int32 manifoldCount = c->GetManifoldCount();
> 		b2Manifold* manifolds = c->GetManifolds();
> 		for (int32 j = 0; j < manifoldCount; ++j)
> 		{
> 			b2Manifold* manifold = manifolds + j;
> 			cr.normal = manifold->normal;
> 			for (int32 k = 0; k < manifold->pointCount; ++k)
> 			{
> 				b2ManifoldPoint* point = manifold->points + k;
> 				b2ContactConstraintPoint* ccp = cc->points + k;
> 				cr.position = b1->GetWorldPoint(point->localPoint1);
> 
> 				// TOI constraint results are not stored, so get
> 				// the result from the constraint.
> 				cr.normalImpulse = ccp->normalImpulse;
> 				cr.tangentImpulse = ccp->tangentImpulse;
> 				cr.id = point->id;
527,534c467,468
< 		const b2ContactVelocityConstraint* vc = constraints + i;
< 		
< 		b2ContactImpulse impulse;
< 		impulse.count = vc->pointCount;
< 		for (int32 j = 0; j < vc->pointCount; ++j)
< 		{
< 			impulse.normalImpulses[j] = vc->points[j].normalImpulse;
< 			impulse.tangentImpulses[j] = vc->points[j].tangentImpulse;
---
> 				m_listener->Result(&cr);
> 			}
536,537d469
< 
< 		m_listener->PostSolve(c, &impulse);
diff -r -x './svn/*' native/Box2D/Dynamics/b2Island.h ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/b2Island.h
2c2
< * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
22,24c22,23
< #include <Box2D/Common/b2Math.h>
< #include <Box2D/Dynamics/b2Body.h>
< #include <Box2D/Dynamics/b2TimeStep.h>
---
> #include "../Common/b2Math.h"
> #include "b2Body.h"
30,31c29,42
< struct b2ContactVelocityConstraint;
< struct b2Profile;
---
> struct b2ContactConstraint;
> struct b2TimeStep;
> 
> struct b2Position
> {
> 	b2Vec2 x;
> 	float32 a;
> };
> 
> struct b2Velocity
> {
> 	b2Vec2 v;
> 	float32 w;
> };
33d43
< /// This is an internal class.
48c58
< 	void Solve(b2Profile* profile, const b2TimeStep& step, const b2Vec2& gravity, bool allowSleep);
---
> 	void Solve(const b2TimeStep& step, const b2Vec2& gravity, bool allowSleep);
50c60
< 	void SolveTOI(const b2TimeStep& subStep, int32 toiIndexA, int32 toiIndexB);
---
> 	void SolveTOI(b2TimeStep& subStep);
56,57c66
< 		m_bodies[m_bodyCount] = body;
< 		++m_bodyCount;
---
> 		m_bodies[m_bodyCount++] = body;
72c81
< 	void Report(const b2ContactVelocityConstraint* constraints);
---
> 	void Report(b2ContactConstraint* constraints);
90a100,101
> 
> 	int32 m_positionIterationCount;
Only in native/Box2D/Dynamics: b2TimeStep.h
diff -r -x './svn/*' native/Box2D/Dynamics/b2World.cpp ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/b2World.cpp
2c2
< * Copyright (c) 2006-2011 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
19,34c19,29
< #include <Box2D/Dynamics/b2World.h>
< #include <Box2D/Dynamics/b2Body.h>
< #include <Box2D/Dynamics/b2Fixture.h>
< #include <Box2D/Dynamics/b2Island.h>
< #include <Box2D/Dynamics/Joints/b2PulleyJoint.h>
< #include <Box2D/Dynamics/Contacts/b2Contact.h>
< #include <Box2D/Dynamics/Contacts/b2ContactSolver.h>
< #include <Box2D/Collision/b2Collision.h>
< #include <Box2D/Collision/b2BroadPhase.h>
< #include <Box2D/Collision/Shapes/b2CircleShape.h>
< #include <Box2D/Collision/Shapes/b2EdgeShape.h>
< #include <Box2D/Collision/Shapes/b2ChainShape.h>
< #include <Box2D/Collision/Shapes/b2PolygonShape.h>
< #include <Box2D/Collision/b2TimeOfImpact.h>
< #include <Box2D/Common/b2Draw.h>
< #include <Box2D/Common/b2Timer.h>
---
> #include "b2World.h"
> #include "b2Body.h"
> #include "b2Island.h"
> #include "Joints/b2PulleyJoint.h"
> #include "Contacts/b2Contact.h"
> #include "Contacts/b2ContactSolver.h"
> #include "../Collision/b2Collision.h"
> #include "../Collision/Shapes/b2CircleShape.h"
> #include "../Collision/Shapes/b2PolygonShape.h"
> #include "../Collision/Shapes/b2EdgeShape.h"
> 
36,37c31,32
< // b2World::b2World(b2Vec2 const& gravity)
< b2World::b2World(const b2Vec2& gravity)
---
> 
> b2World::b2World(const b2AABB& worldAABB, const b2Vec2& gravity, bool doSleep)
39a35,37
> 	m_boundaryListener = NULL;
> 	m_contactFilter = &b2_defaultFilter;
> 	m_contactListener = NULL;
42a41
> 	m_contactList = NULL;
43a43
> 	m_controllerList = NULL;
45a46
> 	m_contactCount = 0;
46a48
> 	m_controllerCount = 0;
50,52d51
< 	m_subStepping = false;
< 
< 	m_stepComplete = true;
54c53
< 	m_allowSleep = true;
---
> 	m_allowSleep = doSleep;
57c56
< 	m_flags = e_clearForces;
---
> 	m_lock = false;
61c60,62
< 	m_contactManager.m_allocator = &m_blockAllocator;
---
> 	m_contactManager.m_world = this;
> 	void* mem = b2Alloc(sizeof(b2BroadPhase));
> 	m_broadPhase = new (mem) b2BroadPhase(worldAABB, &m_contactManager);
63c64,65
< 	memset(&m_profile, 0, sizeof(b2Profile));
---
> 	b2BodyDef bd;
> 	m_groundBody = CreateBody(&bd);
68,84c70,72
< 	// Some shapes allocate using b2Alloc.
< 	b2Body* b = m_bodyList;
< 	while (b)
< 	{
< 		b2Body* bNext = b->m_next;
< 
< 		b2Fixture* f = b->m_fixtureList;
< 		while (f)
< 		{
< 			b2Fixture* fNext = f->m_next;
< 			f->m_proxyCount = 0;
< 			f->Destroy(&m_blockAllocator);
< 			f = fNext;
< 		}
< 
< 		b = bNext;
< 	}
---
> 	DestroyBody(m_groundBody);
> 	m_broadPhase->~b2BroadPhase();
> 	b2Free(m_broadPhase);
91a80,84
> void b2World::SetBoundaryListener(b2BoundaryListener* listener)
> {
> 	m_boundaryListener = listener;
> }
> 
94c87
< 	m_contactManager.m_contactFilter = filter;
---
> 	m_contactFilter = filter;
99c92
< 	m_contactManager.m_contactListener = listener;
---
> 	m_contactListener = listener;
102c95
< void b2World::SetDebugDraw(b2Draw* debugDraw)
---
> void b2World::SetDebugDraw(b2DebugDraw* debugDraw)
109,110c102,103
< 	b2Assert(IsLocked() == false);
< 	if (IsLocked())
---
> 	b2Assert(m_lock == false);
> 	if (m_lock == true)
134,135c127,128
< 	b2Assert(IsLocked() == false);
< 	if (IsLocked())
---
> 	b2Assert(m_lock == false);
> 	if (m_lock == true)
141,142c134,135
< 	b2JointEdge* je = b->m_jointList;
< 	while (je)
---
> 	b2JointEdge* jn = b->m_jointList;
> 	while (jn)
144,145c137,138
< 		b2JointEdge* je0 = je;
< 		je = je->next;
---
> 		b2JointEdge* jn0 = jn;
> 		jn = jn->next;
149c142
< 			m_destructionListener->SayGoodbye(je0->joint);
---
> 			m_destructionListener->SayGoodbye(jn0->joint);
152,154c145
< 		DestroyJoint(je0->joint);
< 
< 		b->m_jointList = je;
---
> 		DestroyJoint(jn0->joint);
156d146
< 	b->m_jointList = NULL;
158,160c148,150
< 	// Delete the attached contacts.
< 	b2ContactEdge* ce = b->m_contactList;
< 	while (ce)
---
> 	//Detach controllers attached to this body
> 	b2ControllerEdge* ce = b->m_controllerList;
> 	while(ce)
162,164c152,155
< 		b2ContactEdge* ce0 = ce;
< 		ce = ce->next;
< 		m_contactManager.Destroy(ce0->contact);
---
> 		b2ControllerEdge* ce0 = ce;
> 		ce = ce->nextController;
> 
> 		ce0->controller->RemoveBody(b);
166d156
< 	b->m_contactList = NULL;
168,170c158,161
< 	// Delete the attached fixtures. This destroys broad-phase proxies.
< 	b2Fixture* f = b->m_fixtureList;
< 	while (f)
---
> 	// Delete the attached shapes. This destroys broad-phase
> 	// proxies and pairs, leading to the destruction of contacts.
> 	b2Shape* s = b->m_shapeList;
> 	while (s)
172,173c163,164
< 		b2Fixture* f0 = f;
< 		f = f->m_next;
---
> 		b2Shape* s0 = s;
> 		s = s->m_next;
177c168
< 			m_destructionListener->SayGoodbye(f0);
---
> 			m_destructionListener->SayGoodbye(s0);
180,186c171,172
< 		f0->DestroyProxies(&m_contactManager.m_broadPhase);
< 		f0->Destroy(&m_blockAllocator);
< 		f0->~b2Fixture();
< 		m_blockAllocator.Free(f0, sizeof(b2Fixture));
< 
< 		b->m_fixtureList = f;
< 		b->m_fixtureCount -= 1;
---
> 		s0->DestroyProxy(m_broadPhase);
> 		b2Shape::Destroy(s0, &m_blockAllocator);
188,189d173
< 	b->m_fixtureList = NULL;
< 	b->m_fixtureCount = 0;
214,218c198
< 	b2Assert(IsLocked() == false);
< 	if (IsLocked())
< 	{
< 		return NULL;
< 	}
---
> 	b2Assert(m_lock == false);
233,245c213,225
< 	j->m_edgeA.joint = j;
< 	j->m_edgeA.other = j->m_bodyB;
< 	j->m_edgeA.prev = NULL;
< 	j->m_edgeA.next = j->m_bodyA->m_jointList;
< 	if (j->m_bodyA->m_jointList) j->m_bodyA->m_jointList->prev = &j->m_edgeA;
< 	j->m_bodyA->m_jointList = &j->m_edgeA;
< 
< 	j->m_edgeB.joint = j;
< 	j->m_edgeB.other = j->m_bodyA;
< 	j->m_edgeB.prev = NULL;
< 	j->m_edgeB.next = j->m_bodyB->m_jointList;
< 	if (j->m_bodyB->m_jointList) j->m_bodyB->m_jointList->prev = &j->m_edgeB;
< 	j->m_bodyB->m_jointList = &j->m_edgeB;
---
> 	j->m_node1.joint = j;
> 	j->m_node1.other = j->m_body2;
> 	j->m_node1.prev = NULL;
> 	j->m_node1.next = j->m_body1->m_jointList;
> 	if (j->m_body1->m_jointList) j->m_body1->m_jointList->prev = &j->m_node1;
> 	j->m_body1->m_jointList = &j->m_node1;
> 
> 	j->m_node2.joint = j;
> 	j->m_node2.other = j->m_body1;
> 	j->m_node2.prev = NULL;
> 	j->m_node2.next = j->m_body2->m_jointList;
> 	if (j->m_body2->m_jointList) j->m_body2->m_jointList->prev = &j->m_node2;
> 	j->m_body2->m_jointList = &j->m_node2;
247,250c227
< 	b2Body* bodyA = def->bodyA;
< 	b2Body* bodyB = def->bodyB;
< 
< 	// If the joint prevents collisions, then flag any contacts for filtering.
---
> 	// If the joint prevents collisions, then reset collision filtering.
253,254c230,232
< 		b2ContactEdge* edge = bodyB->GetContactList();
< 		while (edge)
---
> 		// Reset the proxies on the body with the minimum number of shapes.
> 		b2Body* b = def->body1->m_shapeCount < def->body2->m_shapeCount ? def->body1 : def->body2;
> 		for (b2Shape* s = b->m_shapeList; s; s = s->m_next)
256,263c234
< 			if (edge->other == bodyA)
< 			{
< 				// Flag the contact for filtering at the next time step (where either
< 				// body is awake).
< 				edge->contact->FlagForFiltering();
< 			}
< 
< 			edge = edge->next;
---
> 			s->RefilterProxy(m_broadPhase, b->GetXForm());
267,268d237
< 	// Note: creating a joint doesn't wake the bodies.
< 
274,278c243
< 	b2Assert(IsLocked() == false);
< 	if (IsLocked())
< 	{
< 		return;
< 	}
---
> 	b2Assert(m_lock == false);
299,300c264,265
< 	b2Body* bodyA = j->m_bodyA;
< 	b2Body* bodyB = j->m_bodyB;
---
> 	b2Body* body1 = j->m_body1;
> 	b2Body* body2 = j->m_body2;
303,304c268,269
< 	bodyA->SetAwake(true);
< 	bodyB->SetAwake(true);
---
> 	body1->WakeUp();
> 	body2->WakeUp();
307c272
< 	if (j->m_edgeA.prev)
---
> 	if (j->m_node1.prev)
309c274
< 		j->m_edgeA.prev->next = j->m_edgeA.next;
---
> 		j->m_node1.prev->next = j->m_node1.next;
312c277
< 	if (j->m_edgeA.next)
---
> 	if (j->m_node1.next)
314c279
< 		j->m_edgeA.next->prev = j->m_edgeA.prev;
---
> 		j->m_node1.next->prev = j->m_node1.prev;
317c282
< 	if (&j->m_edgeA == bodyA->m_jointList)
---
> 	if (&j->m_node1 == body1->m_jointList)
319c284
< 		bodyA->m_jointList = j->m_edgeA.next;
---
> 		body1->m_jointList = j->m_node1.next;
322,323c287,288
< 	j->m_edgeA.prev = NULL;
< 	j->m_edgeA.next = NULL;
---
> 	j->m_node1.prev = NULL;
> 	j->m_node1.next = NULL;
326c291
< 	if (j->m_edgeB.prev)
---
> 	if (j->m_node2.prev)
328c293
< 		j->m_edgeB.prev->next = j->m_edgeB.next;
---
> 		j->m_node2.prev->next = j->m_node2.next;
331c296
< 	if (j->m_edgeB.next)
---
> 	if (j->m_node2.next)
333c298
< 		j->m_edgeB.next->prev = j->m_edgeB.prev;
---
> 		j->m_node2.next->prev = j->m_node2.prev;
336c301
< 	if (&j->m_edgeB == bodyB->m_jointList)
---
> 	if (&j->m_node2 == body2->m_jointList)
338c303
< 		bodyB->m_jointList = j->m_edgeB.next;
---
> 		body2->m_jointList = j->m_node2.next;
341,342c306,307
< 	j->m_edgeB.prev = NULL;
< 	j->m_edgeB.next = NULL;
---
> 	j->m_node2.prev = NULL;
> 	j->m_node2.next = NULL;
349c314
< 	// If the joint prevents collisions, then flag any contacts for filtering.
---
> 	// If the joint prevents collisions, then reset collision filtering.
352,362c317,321
< 		b2ContactEdge* edge = bodyB->GetContactList();
< 		while (edge)
< 		{
< 			if (edge->other == bodyA)
< 			{
< 				// Flag the contact for filtering at the next time step (where either
< 				// body is awake).
< 				edge->contact->FlagForFiltering();
< 			}
< 
< 			edge = edge->next;
---
> 		// Reset the proxies on the body with the minimum number of shapes.
> 		b2Body* b = body1->m_shapeCount < body2->m_shapeCount ? body1 : body2;
> 		for (b2Shape* s = b->m_shapeList; s; s = s->m_next)
> 		{
> 			s->RefilterProxy(m_broadPhase, b->GetXForm());
365a325,351
> 
> b2Controller* b2World::CreateController(b2ControllerDef* def)
> {
> 	b2Controller* controller = def->Create(&m_blockAllocator);
> 
> 	controller->m_next = m_controllerList;
> 	controller->m_prev = NULL;
> 	if(m_controllerList)
> 		m_controllerList->m_prev = controller;
> 	m_controllerList = controller;
> 	++m_controllerCount;
> 
> 	controller->m_world = this;
> 
> 	return controller;
> }
> 
> void b2World::DestroyController(b2Controller* controller)
> {
> 	b2Assert(m_controllerCount>0);
> 	if(controller->m_next)
> 		controller->m_next->m_prev = controller->m_prev;
> 	if(controller->m_prev)
> 		controller->m_prev->m_next = controller->m_next;
> 	if(controller == m_controllerList)
> 		m_controllerList = controller->m_next;
> 	--m_controllerCount;
367,368c353,356
< //
< void b2World::SetAllowSleeping(bool flag)
---
> 	b2Controller::Destroy(controller, &m_blockAllocator);
> }
> 
> void b2World::Refilter(b2Shape* shape)
370,373c358
< 	if (flag == m_allowSleep)
< 	{
< 		return;
< 	}
---
> 	b2Assert(m_lock == false);
375,382c360
< 	m_allowSleep = flag;
< 	if (m_allowSleep == false)
< 	{
< 		for (b2Body* b = m_bodyList; b; b = b->m_next)
< 		{
< 			b->SetAwake(true);
< 		}
< 	}
---
> 	shape->RefilterProxy(m_broadPhase, shape->GetBody()->GetXForm());
388,390c366,370
< 	m_profile.solveInit = 0.0f;
< 	m_profile.solveVelocity = 0.0f;
< 	m_profile.solvePosition = 0.0f;
---
> 	// Step all controlls
> 	for(b2Controller* controller = m_controllerList;controller;controller=controller->m_next)
> 	{
> 		controller->Step(step);
> 	}
393,397c373
< 	b2Island island(m_bodyCount,
< 					m_contactManager.m_contactCount,
< 					m_jointCount,
< 					&m_stackAllocator,
< 					m_contactManager.m_contactListener);
---
> 	b2Island island(m_bodyCount, m_contactCount, m_jointCount, &m_stackAllocator, m_contactListener);
404c380
< 	for (b2Contact* c = m_contactManager.m_contactList; c; c = c->m_next)
---
> 	for (b2Contact* c = m_contactList; c; c = c->m_next)
418,423c394
< 		if (seed->m_flags & b2Body::e_islandFlag)
< 		{
< 			continue;
< 		}
< 
< 		if (seed->IsAwake() == false || seed->IsActive() == false)
---
> 		if (seed->m_flags & (b2Body::e_islandFlag | b2Body::e_sleepFlag | b2Body::e_frozenFlag))
428,429c399
< 		// The seed can be dynamic or kinematic.
< 		if (seed->GetType() == b2_staticBody)
---
> 		if (seed->IsStatic())
445d414
< 			b2Assert(b->IsActive() == true);
449c418
< 			b->SetAwake(true);
---
> 			b->m_flags &= ~b2Body::e_sleepFlag;
453c422
< 			if (b->GetType() == b2_staticBody)
---
> 			if (b->IsStatic())
459c428
< 			for (b2ContactEdge* ce = b->m_contactList; ce; ce = ce->next)
---
> 			for (b2ContactEdge* cn = b->m_contactList; cn; cn = cn->next)
461,462d429
< 				b2Contact* contact = ce->contact;
< 
464,471c431
< 				if (contact->m_flags & b2Contact::e_islandFlag)
< 				{
< 					continue;
< 				}
< 
< 				// Is this contact solid and touching?
< 				if (contact->IsEnabled() == false ||
< 					contact->IsTouching() == false)
---
> 				if (cn->contact->m_flags & (b2Contact::e_islandFlag | b2Contact::e_nonSolidFlag))
476,479c436,437
< 				// Skip sensors.
< 				bool sensorA = contact->m_fixtureA->m_isSensor;
< 				bool sensorB = contact->m_fixtureB->m_isSensor;
< 				if (sensorA || sensorB)
---
> 				// Is this contact touching?
> 				if (cn->contact->GetManifoldCount() == 0)
484,485c442,443
< 				island.Add(contact);
< 				contact->m_flags |= b2Contact::e_islandFlag;
---
> 				island.Add(cn->contact);
> 				cn->contact->m_flags |= b2Contact::e_islandFlag;
487c445
< 				b2Body* other = ce->other;
---
> 				b2Body* other = cn->other;
501c459
< 			for (b2JointEdge* je = b->m_jointList; je; je = je->next)
---
> 			for (b2JointEdge* jn = b->m_jointList; jn; jn = jn->next)
503,511c461
< 				if (je->joint->m_islandFlag == true)
< 				{
< 					continue;
< 				}
< 
< 				b2Body* other = je->other;
< 
< 				// Don't simulate joints connected to inactive bodies.
< 				if (other->IsActive() == false)
---
> 				if (jn->joint->m_islandFlag == true)
516,517c466,467
< 				island.Add(je->joint);
< 				je->joint->m_islandFlag = true;
---
> 				island.Add(jn->joint);
> 				jn->joint->m_islandFlag = true;
518a469
> 				b2Body* other = jn->other;
530,534c481
< 		b2Profile profile;
< 		island.Solve(&profile, step, m_gravity, m_allowSleep);
< 		m_profile.solveInit += profile.solveInit;
< 		m_profile.solveVelocity += profile.solveVelocity;
< 		m_profile.solvePosition += profile.solvePosition;
---
> 		island.Solve(step, m_gravity, m_allowSleep);
541c488
< 			if (b->GetType() == b2_staticBody)
---
> 			if (b->IsStatic())
549a497,498
> 	// Synchronize shapes, check for out of range bodies.
> 	for (b2Body* b = m_bodyList; b; b = b->GetNext())
551,553c500
< 		b2Timer timer;
< 		// Synchronize fixtures, check for out of range bodies.
< 		for (b2Body* b = m_bodyList; b; b = b->GetNext())
---
> 		if (b->m_flags & (b2Body::e_sleepFlag | b2Body::e_frozenFlag))
555,564c502,503
< 			// If a body was not in an island then it did not move.
< 			if ((b->m_flags & b2Body::e_islandFlag) == 0)
< 			{
< 				continue;
< 			}
< 
< 			if (b->GetType() == b2_staticBody)
< 			{
< 				continue;
< 			}
---
> 			continue;
> 		}
566,567c505,507
< 			// Update fixtures (for broad-phase).
< 			b->SynchronizeFixtures();
---
> 		if (b->IsStatic())
> 		{
> 			continue;
568a509,513
> 		
> 		// Update shapes (for broad-phase). If the shapes go out of
> 		// the world AABB then shapes and contacts may be destroyed,
> 		// including contacts that are
> 		bool inRange = b->SynchronizeShapes();
570,572c515,519
< 		// Look for new contacts.
< 		m_contactManager.FindNewContacts();
< 		m_profile.broadphase = timer.GetMilliseconds();
---
> 		// Did the body's shapes leave the world?
> 		if (inRange == false && m_boundaryListener != NULL)
> 		{
> 			m_boundaryListener->Violation(b);
> 		}
573a521,524
> 
> 	// Commit shape proxy movements to the broad-phase so that new contacts are created.
> 	// Also, some contacts can be destroyed.
> 	m_broadPhase->Commit();
579c530,542
< 	b2Island island(2 * b2_maxTOIContacts, b2_maxTOIContacts, 0, &m_stackAllocator, m_contactManager.m_contactListener);
---
> 	// Reserve an island and a queue for TOI island solution.
> 	b2Island island(m_bodyCount, b2_maxTOIContactsPerIsland, b2_maxTOIJointsPerIsland, &m_stackAllocator, m_contactListener);
> 	
> 	//Simple one pass queue
> 	//Relies on the fact that we're only making one pass
> 	//through and each body can only be pushed/popped once.
> 	//To push: 
> 	//  queue[queueStart+queueSize++] = newElement;
> 	//To pop: 
> 	//	poppedElement = queue[queueStart++];
> 	//  --queueSize;
> 	int32 queueCapacity = m_bodyCount;
> 	b2Body** queue = (b2Body**)m_stackAllocator.Allocate(queueCapacity* sizeof(b2Body*));
581c544
< 	if (m_stepComplete)
---
> 	for (b2Body* b = m_bodyList; b; b = b->m_next)
583,587c546,548
< 		for (b2Body* b = m_bodyList; b; b = b->m_next)
< 		{
< 			b->m_flags &= ~b2Body::e_islandFlag;
< 			b->m_sweep.alpha0 = 0.0f;
< 		}
---
> 		b->m_flags &= ~b2Body::e_islandFlag;
> 		b->m_sweep.t0 = 0.0f;
> 	}
589,595c550,558
< 		for (b2Contact* c = m_contactManager.m_contactList; c; c = c->m_next)
< 		{
< 			// Invalidate TOI
< 			c->m_flags &= ~(b2Contact::e_toiFlag | b2Contact::e_islandFlag);
< 			c->m_toiCount = 0;
< 			c->m_toi = 1.0f;
< 		}
---
> 	for (b2Contact* c = m_contactList; c; c = c->m_next)
> 	{
> 		// Invalidate TOI
> 		c->m_flags &= ~(b2Contact::e_toiFlag | b2Contact::e_islandFlag);
> 	}
> 
> 	for (b2Joint* j = m_jointList; j; j = j->m_next)
> 	{
>             j->m_islandFlag = false;
603c566
< 		float32 minAlpha = 1.0f;
---
> 		float32 minTOI = 1.0f;
605c568
< 		for (b2Contact* c = m_contactManager.m_contactList; c; c = c->m_next)
---
> 		for (b2Contact* c = m_contactList; c; c = c->m_next)
607,608c570
< 			// Is this contact disabled?
< 			if (c->IsEnabled() == false)
---
> 			if (c->m_flags & (b2Contact::e_slowFlag | b2Contact::e_nonSolidFlag))
613,617c575
< 			// Prevent excessive sub-stepping.
< 			if (c->m_toiCount > b2_maxSubSteps)
< 			{
< 				continue;
< 			}
---
> 			// TODO_ERIN keep a counter on the contact, only respond to M TOIs per contact.
619c577
< 			float32 alpha = 1.0f;
---
> 			float32 toi = 1.0f;
623c581
< 				alpha = c->m_toi;
---
> 				toi = c->m_toi;
627,653c585,589
< 				b2Fixture* fA = c->GetFixtureA();
< 				b2Fixture* fB = c->GetFixtureB();
< 
< 				// Is there a sensor?
< 				if (fA->IsSensor() || fB->IsSensor())
< 				{
< 					continue;
< 				}
< 
< 				b2Body* bA = fA->GetBody();
< 				b2Body* bB = fB->GetBody();
< 
< 				b2BodyType typeA = bA->m_type;
< 				b2BodyType typeB = bB->m_type;
< 				b2Assert(typeA == b2_dynamicBody || typeB == b2_dynamicBody);
< 
< 				bool activeA = bA->IsAwake() && typeA != b2_staticBody;
< 				bool activeB = bB->IsAwake() && typeB != b2_staticBody;
< 
< 				// Is at least one body active (awake and dynamic or kinematic)?
< 				if (activeA == false && activeB == false)
< 				{
< 					continue;
< 				}
< 
< 				bool collideA = bA->IsBullet() || typeA != b2_dynamicBody;
< 				bool collideB = bB->IsBullet() || typeB != b2_dynamicBody;
---
> 				// Compute the TOI for this contact.
> 				b2Shape* s1 = c->GetShape1();
> 				b2Shape* s2 = c->GetShape2();
> 				b2Body* b1 = s1->GetBody();
> 				b2Body* b2 = s2->GetBody();
655,656c591
< 				// Are these two non-bullet dynamic bodies?
< 				if (collideA == false && collideB == false)
---
> 				if ((b1->IsStatic() || b1->IsSleeping()) && (b2->IsStatic() || b2->IsSleeping()))
661d595
< 				// Compute the TOI for this contact.
663,665c597,599
< 				float32 alpha0 = bA->m_sweep.alpha0;
< 
< 				if (bA->m_sweep.alpha0 < bB->m_sweep.alpha0)
---
> 				float32 t0 = b1->m_sweep.t0;
> 				
> 				if (b1->m_sweep.t0 < b2->m_sweep.t0)
667,668c601,602
< 					alpha0 = bB->m_sweep.alpha0;
< 					bA->m_sweep.Advance(alpha0);
---
> 					t0 = b2->m_sweep.t0;
> 					b1->m_sweep.Advance(t0);
670c604
< 				else if (bB->m_sweep.alpha0 < bA->m_sweep.alpha0)
---
> 				else if (b2->m_sweep.t0 < b1->m_sweep.t0)
672,673c606,607
< 					alpha0 = bA->m_sweep.alpha0;
< 					bB->m_sweep.Advance(alpha0);
---
> 					t0 = b1->m_sweep.t0;
> 					b2->m_sweep.Advance(t0);
676c610
< 				b2Assert(alpha0 < 1.0f);
---
> 				b2Assert(t0 < 1.0f);
678,679c612,613
< 				int32 indexA = c->GetChildIndexA();
< 				int32 indexB = c->GetChildIndexB();
---
> 				// Compute the time of impact.
> 				toi = b2TimeOfImpact(c->m_shape1, b1->m_sweep, c->m_shape2, b2->m_sweep);
681,687c615
< 				// Compute the time of impact in interval [0, minTOI]
< 				b2TOIInput input;
< 				input.proxyA.Set(fA->GetShape(), indexA);
< 				input.proxyB.Set(fB->GetShape(), indexB);
< 				input.sweepA = bA->m_sweep;
< 				input.sweepB = bB->m_sweep;
< 				input.tMax = 1.0f;
---
> 				b2Assert(0.0f <= toi && toi <= 1.0f);
689,694c617,618
< 				b2TOIOutput output;
< 				b2TimeOfImpact(&output, &input);
< 
< 				// Beta is the fraction of the remaining portion of the .
< 				float32 beta = output.t;
< 				if (output.state == b2TOIOutput::e_touching)
---
> 				// If the TOI is in range ...
> 				if (0.0f < toi && toi < 1.0f)
696,700c620,621
< 					alpha = b2Min(alpha0 + (1.0f - alpha0) * beta, 1.0f);
< 				}
< 				else
< 				{
< 					alpha = 1.0f;
---
> 					// Interpolate on the actual range.
> 					toi = b2Min((1.0f - toi) * t0 + toi, 1.0f);
703c624,625
< 				c->m_toi = alpha;
---
> 
> 				c->m_toi = toi;
707c629
< 			if (alpha < minAlpha)
---
> 			if (B2_FLT_EPSILON < toi && toi < minTOI)
711c633
< 				minAlpha = alpha;
---
> 				minTOI = toi;
715c637
< 		if (minContact == NULL || 1.0f - 10.0f * b2_epsilon < minAlpha)
---
> 		if (minContact == NULL || 1.0f - 100.0f * B2_FLT_EPSILON < minTOI)
718d639
< 			m_stepComplete = true;
723,732c644,649
< 		b2Fixture* fA = minContact->GetFixtureA();
< 		b2Fixture* fB = minContact->GetFixtureB();
< 		b2Body* bA = fA->GetBody();
< 		b2Body* bB = fB->GetBody();
< 
< 		b2Sweep backup1 = bA->m_sweep;
< 		b2Sweep backup2 = bB->m_sweep;
< 
< 		bA->Advance(minAlpha);
< 		bB->Advance(minAlpha);
---
> 		b2Shape* s1 = minContact->GetShape1();
> 		b2Shape* s2 = minContact->GetShape2();
> 		b2Body* b1 = s1->GetBody();
> 		b2Body* b2 = s2->GetBody();
> 		b1->Advance(minTOI);
> 		b2->Advance(minTOI);
735c652
< 		minContact->Update(m_contactManager.m_contactListener);
---
> 		minContact->Update(m_contactListener);
737d653
< 		++minContact->m_toiCount;
739,740c655
< 		// Is the contact solid?
< 		if (minContact->IsEnabled() == false || minContact->IsTouching() == false)
---
> 		if (minContact->GetManifoldCount() == 0)
742,747c657,658
< 			// Restore the sweeps.
< 			minContact->SetEnabled(false);
< 			bA->m_sweep = backup1;
< 			bB->m_sweep = backup2;
< 			bA->SynchronizeTransform();
< 			bB->SynchronizeTransform();
---
> 			// This shouldn't happen. Numerical error?
> 			//b2Assert(false);
751,752c662,667
< 		bA->SetAwake(true);
< 		bB->SetAwake(true);
---
> 		// Build the TOI island. We need a dynamic seed.
> 		b2Body* seed = b1;
> 		if (seed->IsStatic())
> 		{
> 			seed = b2;
> 		}
754c669
< 		// Build the island
---
> 		// Reset island and queue.
756,849c671,684
< 		island.Add(bA);
< 		island.Add(bB);
< 		island.Add(minContact);
< 
< 		bA->m_flags |= b2Body::e_islandFlag;
< 		bB->m_flags |= b2Body::e_islandFlag;
< 		minContact->m_flags |= b2Contact::e_islandFlag;
< 
< 		// Get contacts on bodyA and bodyB.
< 		b2Body* bodies[2] = {bA, bB};
< 		for (int32 i = 0; i < 2; ++i)
< 		{
< 			b2Body* body = bodies[i];
< 			if (body->m_type == b2_dynamicBody)
< 			{
< 				for (b2ContactEdge* ce = body->m_contactList; ce; ce = ce->next)
< 				{
< 					if (island.m_bodyCount == island.m_bodyCapacity)
< 					{
< 						break;
< 					}
< 
< 					if (island.m_contactCount == island.m_contactCapacity)
< 					{
< 						break;
< 					}
< 
< 					b2Contact* contact = ce->contact;
< 
< 					// Has this contact already been added to the island?
< 					if (contact->m_flags & b2Contact::e_islandFlag)
< 					{
< 						continue;
< 					}
< 
< 					// Only add static, kinematic, or bullet bodies.
< 					b2Body* other = ce->other;
< 					if (other->m_type == b2_dynamicBody &&
< 						body->IsBullet() == false && other->IsBullet() == false)
< 					{
< 						continue;
< 					}
< 
< 					// Skip sensors.
< 					bool sensorA = contact->m_fixtureA->m_isSensor;
< 					bool sensorB = contact->m_fixtureB->m_isSensor;
< 					if (sensorA || sensorB)
< 					{
< 						continue;
< 					}
< 
< 					// Tentatively advance the body to the TOI.
< 					b2Sweep backup = other->m_sweep;
< 					if ((other->m_flags & b2Body::e_islandFlag) == 0)
< 					{
< 						other->Advance(minAlpha);
< 					}
< 
< 					// Update the contact points
< 					contact->Update(m_contactManager.m_contactListener);
< 
< 					// Was the contact disabled by the user?
< 					if (contact->IsEnabled() == false)
< 					{
< 						other->m_sweep = backup;
< 						other->SynchronizeTransform();
< 						continue;
< 					}
< 
< 					// Are there contact points?
< 					if (contact->IsTouching() == false)
< 					{
< 						other->m_sweep = backup;
< 						other->SynchronizeTransform();
< 						continue;
< 					}
< 
< 					// Add the contact to the island
< 					contact->m_flags |= b2Contact::e_islandFlag;
< 					island.Add(contact);
< 
< 					// Has the other body already been added to the island?
< 					if (other->m_flags & b2Body::e_islandFlag)
< 					{
< 						continue;
< 					}
< 					
< 					// Add the other body to the island.
< 					other->m_flags |= b2Body::e_islandFlag;
< 
< 					if (other->m_type != b2_staticBody)
< 					{
< 						other->SetAwake(true);
< 					}
---
> 		
> 		int32 queueStart = 0; // starting index for queue
> 		int32 queueSize = 0;  // elements in queue
> 		queue[queueStart + queueSize++] = seed;
> 		seed->m_flags |= b2Body::e_islandFlag;
> 
> 		// Perform a breadth first search (BFS) on the contact/joint graph.
> 		while (queueSize > 0)
> 		{
> 			// Grab the next body off the stack and add it to the island.
> 			b2Body* b = queue[queueStart++];
> 			--queueSize;
> 			
> 			island.Add(b);
851c686,768
< 					island.Add(other);
---
> 			// Make sure the body is awake.
> 			b->m_flags &= ~b2Body::e_sleepFlag;
> 
> 			// To keep islands as small as possible, we don't
> 			// propagate islands across static bodies.
> 			if (b->IsStatic())
> 			{
> 				continue;
> 			}
> 
> 			// Search all contacts connected to this body.
> 			for (b2ContactEdge* cEdge = b->m_contactList; cEdge; cEdge = cEdge->next)
> 			{
> 				// Does the TOI island still have space for contacts?
> 				if (island.m_contactCount == island.m_contactCapacity)
> 				{
> 					continue;
> 				}
> 
> 				// Has this contact already been added to an island? Skip slow or non-solid contacts.
> 				if (cEdge->contact->m_flags & (b2Contact::e_islandFlag | b2Contact::e_slowFlag | b2Contact::e_nonSolidFlag))
> 				{
> 					continue;
> 				}
> 
> 				// Is this contact touching? For performance we are not updating this contact.
> 				if (cEdge->contact->GetManifoldCount() == 0)
> 				{
> 					continue;
> 				}
> 
> 				island.Add(cEdge->contact);
> 				cEdge->contact->m_flags |= b2Contact::e_islandFlag;
> 
> 				// Update other body.
> 				b2Body* other = cEdge->other;
> 
> 				// Was the other body already added to this island?
> 				if (other->m_flags & b2Body::e_islandFlag)
> 				{
> 					continue;
> 				}
> 
> 				// March forward, this can do no harm since this is the min TOI.
> 				if (other->IsStatic() == false)
> 				{
> 					other->Advance(minTOI);
> 					other->WakeUp();
> 				}
> 
> 				b2Assert(queueStart + queueSize < queueCapacity);
> 				queue[queueStart + queueSize] = other;
> 				++queueSize;
> 				other->m_flags |= b2Body::e_islandFlag;
> 			}
> 			
> 			for (b2JointEdge* jEdge = b->m_jointList; jEdge; jEdge = jEdge->next)
> 			{
> 				if (island.m_jointCount == island.m_jointCapacity)
> 				{
> 					continue;
> 				}
> 				
> 				if (jEdge->joint->m_islandFlag == true)
> 				{
> 					continue;
> 				}
> 				
> 				island.Add(jEdge->joint);
> 				
> 				jEdge->joint->m_islandFlag = true;
> 				
> 				b2Body* other = jEdge->other;
> 				
> 				if (other->m_flags & b2Body::e_islandFlag)
> 				{
> 					continue;
> 				}
> 				
> 				if (!other->IsStatic())
> 				{
> 					other->Advance(minTOI);
> 					other->WakeUp();
852a770,774
> 				
> 				b2Assert(queueStart + queueSize < queueCapacity);
> 				queue[queueStart + queueSize] = other;
> 				++queueSize;
> 				other->m_flags |= b2Body::e_islandFlag;
857c779,780
< 		subStep.dt = (1.0f - minAlpha) * step.dt;
---
> 		subStep.warmStarting = false;
> 		subStep.dt = (1.0f - minTOI) * step.dt;
859,860c782
< 		subStep.dtRatio = 1.0f;
< 		subStep.positionIterations = 20;
---
> 		subStep.dtRatio = 0.0f;
862,863c784,786
< 		subStep.warmStarting = false;
< 		island.SolveTOI(subStep, bA->m_islandIndex, bB->m_islandIndex);
---
> 		subStep.positionIterations = step.positionIterations;
> 
> 		island.SolveTOI(subStep);
865c788
< 		// Reset island flags and synchronize broad-phase proxies.
---
> 		// Post solve cleanup.
868,869c791,793
< 			b2Body* body = island.m_bodies[i];
< 			body->m_flags &= ~b2Body::e_islandFlag;
---
> 			// Allow bodies to participate in future TOI islands.
> 			b2Body* b = island.m_bodies[i];
> 			b->m_flags &= ~b2Body::e_islandFlag;
871c795
< 			if (body->m_type != b2_dynamicBody)
---
> 			if (b->m_flags & (b2Body::e_sleepFlag | b2Body::e_frozenFlag))
876c800,803
< 			body->SynchronizeFixtures();
---
> 			if (b->IsStatic())
> 			{
> 				continue;
> 			}
878,879c805,811
< 			// Invalidate all contact TOIs on this displaced body.
< 			for (b2ContactEdge* ce = body->m_contactList; ce; ce = ce->next)
---
> 			// Update shapes (for broad-phase). If the shapes go out of
> 			// the world AABB then shapes and contacts may be destroyed,
> 			// including contacts that are
> 			bool inRange = b->SynchronizeShapes();
> 
> 			// Did the body's shapes leave the world?
> 			if (inRange == false && m_boundaryListener != NULL)
881c813,820
< 				ce->contact->m_flags &= ~(b2Contact::e_toiFlag | b2Contact::e_islandFlag);
---
> 				m_boundaryListener->Violation(b);
> 			}
> 
> 			// Invalidate all contact TOIs associated with this body. Some of these
> 			// may not be in the island because they were not touching.
> 			for (b2ContactEdge* cn = b->m_contactList; cn; cn = cn->next)
> 			{
> 				cn->contact->m_flags &= ~b2Contact::e_toiFlag;
885,887c824,829
< 		// Commit fixture proxy movements to the broad-phase so that new contacts are created.
< 		// Also, some contacts can be destroyed.
< 		m_contactManager.FindNewContacts();
---
> 		for (int32 i = 0; i < island.m_contactCount; ++i)
> 		{
> 			// Allow contacts to participate in future TOI islands.
> 			b2Contact* c = island.m_contacts[i];
> 			c->m_flags &= ~(b2Contact::e_toiFlag | b2Contact::e_islandFlag);
> 		}
889c831
< 		if (m_subStepping)
---
> 		for (int32 i = 0; i < island.m_jointCount; ++i)
891,892c833,835
< 			m_stepComplete = false;
< 			break;
---
> 			// Allow joints to participate in future TOI islands.
> 			b2Joint* j = island.m_joints[i];
> 			j->m_islandFlag = false;
893a837,840
> 		
> 		// Commit shape proxy movements to the broad-phase so that new contacts are created.
> 		// Also, some contacts can be destroyed.
> 		m_broadPhase->Commit();
894a842,843
> 
> 	m_stackAllocator.Free(queue);
899,908c848
< 	b2Timer stepTimer;
< 
< 	// If new fixtures were added, we need to find the new contacts.
< 	if (m_flags & e_newFixture)
< 	{
< 		m_contactManager.FindNewContacts();
< 		m_flags &= ~e_newFixture;
< 	}
< 
< 	m_flags |= e_locked;
---
> 	m_lock = true;
927,932c867,868
< 	// Update contacts. This is where some contacts are destroyed.
< 	{
< 		b2Timer timer;
< 		m_contactManager.Collide();
< 		m_profile.collide = timer.GetMilliseconds();
< 	}
---
> 	// Update contacts.
> 	m_contactManager.Collide();
935c871
< 	if (m_stepComplete && step.dt > 0.0f)
---
> 	if (step.dt > 0.0f)
937d872
< 		b2Timer timer;
939d873
< 		m_profile.solve = timer.GetMilliseconds();
945d878
< 		b2Timer timer;
947,952d879
< 		m_profile.solveTOI = timer.GetMilliseconds();
< 	}
< 
< 	if (step.dt > 0.0f)
< 	{
< 		m_inv_dt0 = step.inv_dt;
955,958c882,883
< 	if (m_flags & e_clearForces)
< 	{
< 		ClearForces();
< 	}
---
> 	// Draw debug information.
> 	DrawDebugData();
960,962c885,886
< 	m_flags &= ~e_locked;
< 
< 	m_profile.step = stepTimer.GetMilliseconds();
---
> 	m_inv_dt0 = step.inv_dt;
> 	m_lock = false;
965c889
< void b2World::ClearForces()
---
> int32 b2World::Query(const b2AABB& aabb, b2Shape** shapes, int32 maxCount)
967c891,895
< 	for (b2Body* body = m_bodyList; body; body = body->GetNext())
---
> 	void** results = (void**)m_stackAllocator.Allocate(maxCount * sizeof(void*));
> 
> 	int32 count = m_broadPhase->Query(aabb, results, maxCount);
> 
> 	for (int32 i = 0; i < count; ++i)
969,970c897
< 		body->m_force.SetZero();
< 		body->m_torque = 0.0f;
---
> 		shapes[i] = (b2Shape*)results[i];
971a899,901
> 
> 	m_stackAllocator.Free(results);
> 	return count;
974c904
< struct b2WorldQueryWrapper
---
> int32 b2World::Raycast(const b2Segment& segment, b2Shape** shapes, int32 maxCount, bool solidShapes, void* userData)
976c906,914
< 	bool QueryCallback(int32 proxyId)
---
> 	m_raycastSegment = &segment;
> 	m_raycastUserData = userData;
> 	m_raycastSolidShape = solidShapes;
> 
> 	void** results = (void**)m_stackAllocator.Allocate(maxCount * sizeof(void*));
> 
> 	int32 count = m_broadPhase->QuerySegment(segment,results,maxCount, &RaycastSortKey);
> 
> 	for (int32 i = 0; i < count; ++i)
978,979c916
< 		b2FixtureProxy* proxy = (b2FixtureProxy*)broadPhase->GetUserData(proxyId);
< 		return callback->ReportFixture(proxy->fixture);
---
> 		shapes[i] = (b2Shape*)results[i];
982,991c919,920
< 	const b2BroadPhase* broadPhase;
< 	b2QueryCallback* callback;
< };
< 
< void b2World::QueryAABB(b2QueryCallback* callback, const b2AABB& aabb) const
< {
< 	b2WorldQueryWrapper wrapper;
< 	wrapper.broadPhase = &m_contactManager.m_broadPhase;
< 	wrapper.callback = callback;
< 	m_contactManager.m_broadPhase.Query(&wrapper, aabb);
---
> 	m_stackAllocator.Free(results);
> 	return count;
994c923
< struct b2WorldRayCastWrapper
---
> b2Shape* b2World::RaycastOne(const b2Segment& segment, float32* lambda, b2Vec2* normal, bool solidShapes, void* userData)
996,1003c925,926
< 	float32 RayCastCallback(const b2RayCastInput& input, int32 proxyId)
< 	{
< 		void* userData = broadPhase->GetUserData(proxyId);
< 		b2FixtureProxy* proxy = (b2FixtureProxy*)userData;
< 		b2Fixture* fixture = proxy->fixture;
< 		int32 index = proxy->childIndex;
< 		b2RayCastOutput output;
< 		bool hit = fixture->RayCast(&output, input, index);
---
> 	int32 maxCount = 1;
> 	b2Shape* shape;
1005,1010c928
< 		if (hit)
< 		{
< 			float32 fraction = output.fraction;
< 			b2Vec2 point = (1.0f - fraction) * input.p1 + fraction * input.p2;
< 			return callback->ReportFixture(fixture, point, output.normal, fraction);
< 		}
---
> 	int32 count = Raycast(segment, &shape, maxCount, solidShapes, userData);
1012,1013c930,931
< 		return input.maxFraction;
< 	}
---
> 	if(count==0)
> 		return NULL;
1015,1017c933
< 	const b2BroadPhase* broadPhase;
< 	b2RayCastCallback* callback;
< };
---
> 	b2Assert(count==1);
1019,1028c935,940
< void b2World::RayCast(b2RayCastCallback* callback, const b2Vec2& point1, const b2Vec2& point2) const
< {
< 	b2WorldRayCastWrapper wrapper;
< 	wrapper.broadPhase = &m_contactManager.m_broadPhase;
< 	wrapper.callback = callback;
< 	b2RayCastInput input;
< 	input.maxFraction = 1.0f;
< 	input.p1 = point1;
< 	input.p2 = point2;
< 	m_contactManager.m_broadPhase.RayCast(&wrapper, input);
---
> 	//Redundantly do TestSegment a second time, as the previous one's results are inaccessible
> 
> 	const b2XForm xf = shape->GetBody()->GetXForm();
> 	shape->TestSegment(xf, lambda, normal,segment,1);
> 	//We already know it returns true
> 	return shape;
1031c943
< void b2World::DrawShape(b2Fixture* fixture, const b2Transform& xf, const b2Color& color)
---
> void b2World::DrawShape(b2Shape* shape, const b2XForm& xf, const b2Color& color, bool core)
1033c945,947
< 	switch (fixture->GetType())
---
> 	b2Color coreColor(0.9f, 0.6f, 0.6f);
> 
> 	switch (shape->GetType())
1035c949
< 	case b2Shape::e_circle:
---
> 	case e_circleShape:
1037c951
< 			b2CircleShape* circle = (b2CircleShape*)fixture->GetShape();
---
> 			b2CircleShape* circle = (b2CircleShape*)shape;
1039,1041c953,955
< 			b2Vec2 center = b2Mul(xf, circle->m_p);
< 			float32 radius = circle->m_radius;
< 			b2Vec2 axis = b2Mul(xf.q, b2Vec2(1.0f, 0.0f));
---
> 			b2Vec2 center = b2Mul(xf, circle->GetLocalPosition());
> 			float32 radius = circle->GetRadius();
> 			b2Vec2 axis = xf.R.col1;
1044,1054d957
< 		}
< 		break;
< 
< 	case b2Shape::e_edge:
< 		{
< 			b2EdgeShape* edge = (b2EdgeShape*)fixture->GetShape();
< 			b2Vec2 v1 = b2Mul(xf, edge->m_vertex1);
< 			b2Vec2 v2 = b2Mul(xf, edge->m_vertex2);
< 			m_debugDraw->DrawSegment(v1, v2, color);
< 		}
< 		break;
1056,1068c959,961
< 	case b2Shape::e_chain:
< 		{
< 			b2ChainShape* chain = (b2ChainShape*)fixture->GetShape();
< 			int32 count = chain->m_count;
< 			const b2Vec2* vertices = chain->m_vertices;
< 
< 			b2Vec2 v1 = b2Mul(xf, vertices[0]);
< 			for (int32 i = 1; i < count; ++i)
< 			{
< 				b2Vec2 v2 = b2Mul(xf, vertices[i]);
< 				m_debugDraw->DrawSegment(v1, v2, color);
< 				m_debugDraw->DrawCircle(v1, 0.05f, color);
< 				v1 = v2;
---
> 			if (core)
> 			{
> 				m_debugDraw->DrawCircle(center, radius - b2_toiSlop, coreColor);
1073c966
< 	case b2Shape::e_polygon:
---
> 	case e_polygonShape:
1075,1076c968,971
< 			b2PolygonShape* poly = (b2PolygonShape*)fixture->GetShape();
< 			int32 vertexCount = poly->m_count;
---
> 			b2PolygonShape* poly = (b2PolygonShape*)shape;
> 			int32 vertexCount = poly->GetVertexCount();
> 			const b2Vec2* localVertices = poly->GetVertices();
> 
1082c977
< 				vertices[i] = b2Mul(xf, poly->m_vertices[i]);
---
> 				vertices[i] = b2Mul(xf, localVertices[i]);
1085a981,1003
> 
> 			if (core)
> 			{
> 				const b2Vec2* localCoreVertices = poly->GetCoreVertices();
> 				for (int32 i = 0; i < vertexCount; ++i)
> 				{
> 					vertices[i] = b2Mul(xf, localCoreVertices[i]);
> 				}
> 				m_debugDraw->DrawPolygon(vertices, vertexCount, coreColor);
> 			}
> 		}
> 		break;
> 		
> 	case e_edgeShape:
> 		{
> 			b2EdgeShape* edge = (b2EdgeShape*)shape;
> 			
> 			m_debugDraw->DrawSegment(b2Mul(xf, edge->GetVertex1()), b2Mul(xf, edge->GetVertex2()), color);
> 			
> 			if (core)
> 			{
> 				m_debugDraw->DrawSegment(b2Mul(xf, edge->GetCoreVertex1()), b2Mul(xf, edge->GetCoreVertex2()), coreColor);
> 			}
1088,1090d1005
<             
<     default:
<         break;
1096,1103c1011,1018
< 	b2Body* bodyA = joint->GetBodyA();
< 	b2Body* bodyB = joint->GetBodyB();
< 	const b2Transform& xf1 = bodyA->GetTransform();
< 	const b2Transform& xf2 = bodyB->GetTransform();
< 	b2Vec2 x1 = xf1.p;
< 	b2Vec2 x2 = xf2.p;
< 	b2Vec2 p1 = joint->GetAnchorA();
< 	b2Vec2 p2 = joint->GetAnchorB();
---
> 	b2Body* b1 = joint->GetBody1();
> 	b2Body* b2 = joint->GetBody2();
> 	const b2XForm& xf1 = b1->GetXForm();
> 	const b2XForm& xf2 = b2->GetXForm();
> 	b2Vec2 x1 = xf1.position;
> 	b2Vec2 x2 = xf2.position;
> 	b2Vec2 p1 = joint->GetAnchor1();
> 	b2Vec2 p2 = joint->GetAnchor2();
1116,1117c1031,1032
< 			b2Vec2 s1 = pulley->GetGroundAnchorA();
< 			b2Vec2 s2 = pulley->GetGroundAnchorB();
---
> 			b2Vec2 s1 = pulley->GetGroundAnchor1();
> 			b2Vec2 s2 = pulley->GetGroundAnchor2();
1144c1059
< 	if (flags & b2Draw::e_shapeBit)
---
> 	if (flags & b2DebugDraw::e_shapeBit)
1145a1061,1062
> 		bool core = (flags & b2DebugDraw::e_coreShapeBit) == b2DebugDraw::e_coreShapeBit;
> 
1148,1149c1065,1066
< 			const b2Transform& xf = b->GetTransform();
< 			for (b2Fixture* f = b->GetFixtureList(); f; f = f->GetNext())
---
> 			const b2XForm& xf = b->GetXForm();
> 			for (b2Shape* s = b->GetShapeList(); s; s = s->GetNext())
1151,1159c1068
< 				if (b->IsActive() == false)
< 				{
< 					DrawShape(f, xf, b2Color(0.5f, 0.5f, 0.3f));
< 				}
< 				else if (b->GetType() == b2_staticBody)
< 				{
< 					DrawShape(f, xf, b2Color(0.5f, 0.9f, 0.5f));
< 				}
< 				else if (b->GetType() == b2_kinematicBody)
---
> 				if (b->IsStatic())
1161c1070
< 					DrawShape(f, xf, b2Color(0.5f, 0.5f, 0.9f));
---
> 					DrawShape(s, xf, b2Color(0.5f, 0.9f, 0.5f), core);
1163c1072
< 				else if (b->IsAwake() == false)
---
> 				else if (b->IsSleeping())
1165c1074
< 					DrawShape(f, xf, b2Color(0.6f, 0.6f, 0.6f));
---
> 					DrawShape(s, xf, b2Color(0.5f, 0.5f, 0.9f), core);
1169c1078
< 					DrawShape(f, xf, b2Color(0.9f, 0.7f, 0.7f));
---
> 					DrawShape(s, xf, b2Color(0.9f, 0.9f, 0.9f), core);
1175c1084
< 	if (flags & b2Draw::e_jointBit)
---
> 	if (flags & b2DebugDraw::e_jointBit)
1179c1088,1099
< 			DrawJoint(j);
---
> 			if (j->GetType() != e_mouseJoint)
> 			{
> 				DrawJoint(j);
> 			}
> 		}
> 	}
> 
> 	if (flags & b2DebugDraw::e_controllerBit)
> 	{
> 		for (b2Controller* c = m_controllerList; c; c= c->GetNext())
> 		{
> 			c->Draw(m_debugDraw);
1183c1103
< 	if (flags & b2Draw::e_pairBit)
---
> 	if (flags & b2DebugDraw::e_pairBit)
1185,1186c1105,1110
< 		b2Color color(0.3f, 0.9f, 0.9f);
< 		for (b2Contact* c = m_contactManager.m_contactList; c; c = c->GetNext())
---
> 		b2BroadPhase* bp = m_broadPhase;
> 		b2Vec2 invQ;
> 		invQ.Set(1.0f / bp->m_quantizationFactor.x, 1.0f / bp->m_quantizationFactor.y);
> 		b2Color color(0.9f, 0.9f, 0.3f);
> 
> 		for (int32 i = 0; i < b2_tableCapacity; ++i)
1188,1189c1112,1127
< 			//b2Fixture* fixtureA = c->GetFixtureA();
< 			//b2Fixture* fixtureB = c->GetFixtureB();
---
> 			uint16 index = bp->m_pairManager.m_hashTable[i];
> 			while (index != b2_nullPair)
> 			{
> 				b2Pair* pair = bp->m_pairManager.m_pairs + index;
> 				b2Proxy* p1 = bp->m_proxyPool + pair->proxyId1;
> 				b2Proxy* p2 = bp->m_proxyPool + pair->proxyId2;
> 
> 				b2AABB b1, b2;
> 				b1.lowerBound.x = bp->m_worldAABB.lowerBound.x + invQ.x * bp->m_bounds[0][p1->lowerBounds[0]].value;
> 				b1.lowerBound.y = bp->m_worldAABB.lowerBound.y + invQ.y * bp->m_bounds[1][p1->lowerBounds[1]].value;
> 				b1.upperBound.x = bp->m_worldAABB.lowerBound.x + invQ.x * bp->m_bounds[0][p1->upperBounds[0]].value;
> 				b1.upperBound.y = bp->m_worldAABB.lowerBound.y + invQ.y * bp->m_bounds[1][p1->upperBounds[1]].value;
> 				b2.lowerBound.x = bp->m_worldAABB.lowerBound.x + invQ.x * bp->m_bounds[0][p2->lowerBounds[0]].value;
> 				b2.lowerBound.y = bp->m_worldAABB.lowerBound.y + invQ.y * bp->m_bounds[1][p2->lowerBounds[1]].value;
> 				b2.upperBound.x = bp->m_worldAABB.lowerBound.x + invQ.x * bp->m_bounds[0][p2->upperBounds[0]].value;
> 				b2.upperBound.y = bp->m_worldAABB.lowerBound.y + invQ.y * bp->m_bounds[1][p2->upperBounds[1]].value;
1191,1192c1129,1130
< 			//b2Vec2 cA = fixtureA->GetAABB().GetCenter();
< 			//b2Vec2 cB = fixtureB->GetAABB().GetCenter();
---
> 				b2Vec2 x1 = 0.5f * (b1.lowerBound + b1.upperBound);
> 				b2Vec2 x2 = 0.5f * (b2.lowerBound + b2.upperBound);
1194c1132,1135
< 			//m_debugDraw->DrawSegment(cA, cB, color);
---
> 				m_debugDraw->DrawSegment(x1, x2, color);
> 
> 				index = pair->next;
> 			}
1198c1139
< 	if (flags & b2Draw::e_aabbBit)
---
> 	if (flags & b2DebugDraw::e_aabbBit)
1200,1201c1141,1143
< 		b2Color color(0.9f, 0.3f, 0.9f);
< 		b2BroadPhase* bp = &m_contactManager.m_broadPhase;
---
> 		b2BroadPhase* bp = m_broadPhase;
> 		b2Vec2 worldLower = bp->m_worldAABB.lowerBound;
> 		b2Vec2 worldUpper = bp->m_worldAABB.upperBound;
1203c1145,1148
< 		for (b2Body* b = m_bodyList; b; b = b->GetNext())
---
> 		b2Vec2 invQ;
> 		invQ.Set(1.0f / bp->m_quantizationFactor.x, 1.0f / bp->m_quantizationFactor.y);
> 		b2Color color(0.9f, 0.3f, 0.9f);
> 		for (int32 i = 0; i < b2_maxProxies; ++i)
1205c1150,1151
< 			if (b->IsActive() == false)
---
> 			b2Proxy* p = bp->m_proxyPool + i;
> 			if (p->IsValid() == false)
1210c1156,1186
< 			for (b2Fixture* f = b->GetFixtureList(); f; f = f->GetNext())
---
> 			b2AABB b;
> 			b.lowerBound.x = worldLower.x + invQ.x * bp->m_bounds[0][p->lowerBounds[0]].value;
> 			b.lowerBound.y = worldLower.y + invQ.y * bp->m_bounds[1][p->lowerBounds[1]].value;
> 			b.upperBound.x = worldLower.x + invQ.x * bp->m_bounds[0][p->upperBounds[0]].value;
> 			b.upperBound.y = worldLower.y + invQ.y * bp->m_bounds[1][p->upperBounds[1]].value;
> 
> 			b2Vec2 vs[4];
> 			vs[0].Set(b.lowerBound.x, b.lowerBound.y);
> 			vs[1].Set(b.upperBound.x, b.lowerBound.y);
> 			vs[2].Set(b.upperBound.x, b.upperBound.y);
> 			vs[3].Set(b.lowerBound.x, b.upperBound.y);
> 
> 			m_debugDraw->DrawPolygon(vs, 4, color);
> 		}
> 
> 		b2Vec2 vs[4];
> 		vs[0].Set(worldLower.x, worldLower.y);
> 		vs[1].Set(worldUpper.x, worldLower.y);
> 		vs[2].Set(worldUpper.x, worldUpper.y);
> 		vs[3].Set(worldLower.x, worldUpper.y);
> 		m_debugDraw->DrawPolygon(vs, 4, b2Color(0.3f, 0.9f, 0.9f));
> 	}
> 
> 	if (flags & b2DebugDraw::e_obbBit)
> 	{
> 		b2Color color(0.5f, 0.3f, 0.5f);
> 
> 		for (b2Body* b = m_bodyList; b; b = b->GetNext())
> 		{
> 			const b2XForm& xf = b->GetXForm();
> 			for (b2Shape* s = b->GetShapeList(); s; s = s->GetNext())
1212c1188
< 				for (int32 i = 0; i < f->m_proxyCount; ++i)
---
> 				if (s->GetType() != e_polygonShape)
1214,1220c1190,1200
< 					b2FixtureProxy* proxy = f->m_proxies + i;
< 					b2AABB aabb = bp->GetFatAABB(proxy->proxyId);
< 					b2Vec2 vs[4];
< 					vs[0].Set(aabb.lowerBound.x, aabb.lowerBound.y);
< 					vs[1].Set(aabb.upperBound.x, aabb.lowerBound.y);
< 					vs[2].Set(aabb.upperBound.x, aabb.upperBound.y);
< 					vs[3].Set(aabb.lowerBound.x, aabb.upperBound.y);
---
> 					continue;
> 				}
> 
> 				b2PolygonShape* poly = (b2PolygonShape*)s;
> 				const b2OBB& obb = poly->GetOBB();
> 				b2Vec2 h = obb.extents;
> 				b2Vec2 vs[4];
> 				vs[0].Set(-h.x, -h.y);
> 				vs[1].Set( h.x, -h.y);
> 				vs[2].Set( h.x,  h.y);
> 				vs[3].Set(-h.x,  h.y);
1222c1202,1205
< 					m_debugDraw->DrawPolygon(vs, 4, color);
---
> 				for (int32 i = 0; i < 4; ++i)
> 				{
> 					vs[i] = obb.center + b2Mul(obb.R, vs[i]);
> 					vs[i] = b2Mul(xf, vs[i]);
1223a1207,1208
> 
> 				m_debugDraw->DrawPolygon(vs, 4, color);
1228c1213
< 	if (flags & b2Draw::e_centerOfMassBit)
---
> 	if (flags & b2DebugDraw::e_centerOfMassBit)
1232,1234c1217,1219
< 			b2Transform xf = b->GetTransform();
< 			xf.p = b->GetWorldCenter();
< 			m_debugDraw->DrawTransform(xf);
---
> 			b2XForm xf = b->GetXForm();
> 			xf.position = b->GetWorldCenter();
> 			m_debugDraw->DrawXForm(xf);
1239,1244c1224
< int32 b2World::GetProxyCount() const
< {
< 	return m_contactManager.m_broadPhase.GetProxyCount();
< }
< 
< int32 b2World::GetTreeHeight() const
---
> void b2World::Validate()
1246c1226
< 	return m_contactManager.m_broadPhase.GetTreeHeight();
---
> 	m_broadPhase->Validate();
1249c1229
< int32 b2World::GetTreeBalance() const
---
> int32 b2World::GetProxyCount() const
1251c1231
< 	return m_contactManager.m_broadPhase.GetTreeBalance();
---
> 	return m_broadPhase->m_proxyCount;
1254c1234
< float32 b2World::GetTreeQuality() const
---
> int32 b2World::GetPairCount() const
1256c1236
< 	return m_contactManager.m_broadPhase.GetTreeQuality();
---
> 	return m_broadPhase->m_pairManager.m_pairCount;
1259c1239
< void b2World::ShiftOrigin(const b2Vec2& newOrigin)
---
> bool b2World::InRange(const b2AABB& aabb) const
1261,1279c1241
< 	b2Assert((m_flags & e_locked) == 0);
< 	if ((m_flags & e_locked) == e_locked)
< 	{
< 		return;
< 	}
< 
< 	for (b2Body* b = m_bodyList; b; b = b->m_next)
< 	{
< 		b->m_xf.p -= newOrigin;
< 		b->m_sweep.c0 -= newOrigin;
< 		b->m_sweep.c -= newOrigin;
< 	}
< 
< 	for (b2Joint* j = m_jointList; j; j = j->m_next)
< 	{
< 		j->ShiftOrigin(newOrigin);
< 	}
< 
< 	m_contactManager.m_broadPhase.ShiftOrigin(newOrigin);
---
> 	return m_broadPhase->InRange(aabb);
1282c1244
< void b2World::Dump()
---
> float32 b2World::RaycastSortKey(void* data)
1284,1287c1246,1249
< 	if ((m_flags & e_locked) == e_locked)
< 	{
< 		return;
< 	}
---
> 	b2Shape* shape = (b2Shape*)data;
> 	b2Body* body = shape->GetBody();
> 	b2World* world = body->GetWorld();
> 	const b2XForm xf = body->GetXForm();
1289,1290c1251,1252
< 	b2Log("b2Vec2 g(%.15lef, %.15lef);\n", m_gravity.x, m_gravity.y);
< 	b2Log("m_world->SetGravity(g);\n");
---
> 	if(world->m_contactFilter && !world->m_contactFilter->RayCollide(world->m_raycastUserData,shape))
> 		return -1;
1292,1300c1254,1255
< 	b2Log("b2Body** bodies = (b2Body**)b2Alloc(%d * sizeof(b2Body*));\n", m_bodyCount);
< 	b2Log("b2Joint** joints = (b2Joint**)b2Alloc(%d * sizeof(b2Joint*));\n", m_jointCount);
< 	int32 i = 0;
< 	for (b2Body* b = m_bodyList; b; b = b->m_next)
< 	{
< 		b->m_islandIndex = i;
< 		b->Dump();
< 		++i;
< 	}
---
> 	float32 lambda;
> 	b2SegmentCollide collide = shape->TestSegment(xf, &lambda, &world->m_raycastNormal, *world->m_raycastSegment,1);
1302,1320c1257,1260
< 	i = 0;
< 	for (b2Joint* j = m_jointList; j; j = j->m_next)
< 	{
< 		j->m_index = i;
< 		++i;
< 	}
< 
< 	// First pass on joints, skip gear joints.
< 	for (b2Joint* j = m_jointList; j; j = j->m_next)
< 	{
< 		if (j->m_type == e_gearJoint)
< 		{
< 			continue;
< 		}
< 
< 		b2Log("{\n");
< 		j->Dump();
< 		b2Log("}\n");
< 	}
---
> 	if(world->m_raycastSolidShape && collide==e_missCollide)
> 		return -1;
> 	if(!world->m_raycastSolidShape && collide!=e_hitCollide)
> 		return -1;
1322,1338c1262
< 	// Second pass on joints, only gear joints.
< 	for (b2Joint* j = m_jointList; j; j = j->m_next)
< 	{
< 		if (j->m_type != e_gearJoint)
< 		{
< 			continue;
< 		}
< 
< 		b2Log("{\n");
< 		j->Dump();
< 		b2Log("}\n");
< 	}
< 
< 	b2Log("b2Free(joints);\n");
< 	b2Log("b2Free(bodies);\n");
< 	b2Log("joints = NULL;\n");
< 	b2Log("bodies = NULL;\n");
---
> 	return lambda;
1339a1264
> 
diff -r -x './svn/*' native/Box2D/Dynamics/b2World.h ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/b2World.h
2c2
< * Copyright (c) 2006-2011 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
22,27c22,26
< #include <Box2D/Common/b2Math.h>
< #include <Box2D/Common/b2BlockAllocator.h>
< #include <Box2D/Common/b2StackAllocator.h>
< #include <Box2D/Dynamics/b2ContactManager.h>
< #include <Box2D/Dynamics/b2WorldCallbacks.h>
< #include <Box2D/Dynamics/b2TimeStep.h>
---
> #include "../Common/b2Math.h"
> #include "../Common/b2BlockAllocator.h"
> #include "../Common/b2StackAllocator.h"
> #include "b2ContactManager.h"
> #include "b2WorldCallbacks.h"
29a29
> struct b2ShapeDef;
31d30
< struct b2Color;
34,35d32
< class b2Draw;
< class b2Fixture;
36a34,48
> class b2Shape;
> class b2Contact;
> class b2BroadPhase;
> class b2Controller;
> class b2ControllerDef;
> 
> struct b2TimeStep
> {
> 	float32 dt;			// time step
> 	float32 inv_dt;		// inverse time step (0 if dt == 0).
> 	float32 dtRatio;	// dt * inv_dt0
> 	int32 velocityIterations;
> 	int32 positionIterations;
> 	bool warmStarting;
> };
44a57
> 	/// @param worldAABB a bounding box that completely encompasses all your shapes.
46c59,60
< 	b2World(const b2Vec2& gravity);
---
> 	/// @param doSleep improve performance by not simulating inactive bodies.
> 	b2World(const b2AABB& worldAABB, const b2Vec2& gravity, bool doSleep);
51,52c65
< 	/// Register a destruction listener. The listener is owned by you and must
< 	/// remain in scope.
---
> 	/// Register a destruction listener.
54a68,70
> 	/// Register a broad-phase boundary listener.
> 	void SetBoundaryListener(b2BoundaryListener* listener);
> 
56,57c72
< 	/// Otherwise the default filter is used (b2_defaultFilter). The listener is
< 	/// owned by you and must remain in scope. 
---
> 	/// Otherwise the default filter is used (b2_defaultFilter).
60,61c75
< 	/// Register a contact event listener. The listener is owned by you and must
< 	/// remain in scope.
---
> 	/// Register a contact event listener
65,67c79,81
< 	/// inside with b2World::DrawDebugData method. The debug draw object is owned
< 	/// by you and must remain in scope.
< 	void SetDebugDraw(b2Draw* debugDraw);
---
> 	/// inside the b2World::Step method, so make sure your renderer is ready to
> 	/// consume draw commands when you call Step().
> 	void SetDebugDraw(b2DebugDraw* debugDraw);
88a103,112
> 	/// Add a controller to the world.
> 	b2Controller* CreateController(b2ControllerDef* def);
> 
> 	/// Removes a controller from the world.
> 	void DestroyController(b2Controller* controller);
> 
> 	/// The world provides a single static ground body with no collision shapes.
> 	/// You can use this to simplify the creation of joints and static shapes.
> 	b2Body* GetGroundBody();
> 
94,108c118
< 	void Step(	float32 timeStep,
< 				int32 velocityIterations,
< 				int32 positionIterations);
< 
< 	/// Manually clear the force buffer on all bodies. By default, forces are cleared automatically
< 	/// after each call to Step. The default behavior is modified by calling SetAutoClearForces.
< 	/// The purpose of this function is to support sub-stepping. Sub-stepping is often used to maintain
< 	/// a fixed sized time step under a variable frame-rate.
< 	/// When you perform sub-stepping you will disable auto clearing of forces and instead call
< 	/// ClearForces after all sub-steps are complete in one pass of your game loop.
< 	/// @see SetAutoClearForces
< 	void ClearForces();
< 
< 	/// Call this to draw shapes and other debug draw data.
< 	void DrawDebugData();
---
> 	void Step(float32 timeStep, int32 velocityIterations, int32 positionIterations);
110,112c120,122
< 	/// Query the world for all fixtures that potentially overlap the
< 	/// provided AABB.
< 	/// @param callback a user implemented callback class.
---
> 	/// Query the world for all shapes that potentially overlap the
> 	/// provided AABB. You provide a shape pointer buffer of specified
> 	/// size. The number of shapes found is returned.
114c124,150
< 	void QueryAABB(b2QueryCallback* callback, const b2AABB& aabb) const;
---
> 	/// @param shapes a user allocated shape pointer array of size maxCount (or greater).
> 	/// @param maxCount the capacity of the shapes array.
> 	/// @return the number of shapes found in aabb.
> 	int32 Query(const b2AABB& aabb, b2Shape** shapes, int32 maxCount);
> 
> 	/// Query the world for all shapes that intersect a given segment. You provide a shap
> 	/// pointer buffer of specified size. The number of shapes found is returned, and the buffer
> 	/// is filled in order of intersection
> 	/// @param segment defines the begin and end point of the ray cast, from p1 to p2.
> 	/// Use b2Segment.Extend to create (semi-)infinite rays
> 	/// @param shapes a user allocated shape pointer array of size maxCount (or greater).
> 	/// @param maxCount the capacity of the shapes array
> 	/// @param solidShapes determines if shapes that the ray starts in are counted as hits.
> 	/// @param userData passed through the worlds contact filter, with method RayCollide. This can be used to filter valid shapes
> 	/// @returns the number of shapes found
> 	int32 Raycast(const b2Segment& segment, b2Shape** shapes, int32 maxCount, bool solidShapes, void* userData);
> 
> 	/// Performs a raycast as with Raycast, finding the first intersecting shape.
> 	/// @param segment defines the begin and end point of the ray cast, from p1 to p2.
> 	/// Use b2Segment.Extend to create (semi-)infinite rays	
> 	/// @param lambda returns the hit fraction. You can use this to compute the contact point
> 	/// p = (1 - lambda) * segment.p1 + lambda * segment.p2.
> 	/// @param normal returns the normal at the contact point. If there is no intersection, the normal
> 	/// is not set.
> 	/// @param solidShapes determines if shapes that the ray starts in are counted as hits.
> 	/// @returns the colliding shape shape, or null if not found
> 	b2Shape* RaycastOne(const b2Segment& segment, float32* lambda, b2Vec2* normal, bool solidShapes, void* userData);
116,122c152,153
< 	/// Ray-cast the world for all fixtures in the path of the ray. Your callback
< 	/// controls whether you get the closest point, any point, or n-points.
< 	/// The ray-cast ignores shapes that contain the starting point.
< 	/// @param callback a user implemented callback class.
< 	/// @param point1 the ray starting point
< 	/// @param point2 the ray ending point
< 	void RayCast(b2RayCastCallback* callback, const b2Vec2& point1, const b2Vec2& point2) const;
---
> 	/// Check if the AABB is within the broadphase limits.
> 	bool InRange(const b2AABB& aabb) const;
128d158
< 	const b2Body* GetBodyList() const;
134d163
< 	const b2Joint* GetJointList() const;
136,146c165,171
< 	/// Get the world contact list. With the returned contact, use b2Contact::GetNext to get
< 	/// the next contact in the world list. A NULL contact indicates the end of the list.
< 	/// @return the head of the world contact list.
< 	/// @warning contacts are created and destroyed in the middle of a time step.
< 	/// Use b2ContactListener to avoid missing contacts.
< 	b2Contact* GetContactList();
< 	const b2Contact* GetContactList() const;
< 
< 	/// Enable/disable sleep.
< 	void SetAllowSleeping(bool flag);
< 	bool GetAllowSleeping() const { return m_allowSleep; }
---
> 	/// Get the world controller list. With the returned controller, use b2Controller::GetNext to get
> 	/// the next controller in the world list. A NULL controller indicates the end of the list.
> 	/// @return the head of the world controller list.
> 	b2Controller* GetControllerList();
> 
> 	/// Re-filter a shape. This re-runs contact filtering on a shape.
> 	void Refilter(b2Shape* shape);
150d174
< 	bool GetWarmStarting() const { return m_warmStarting; }
154d177
< 	bool GetContinuousPhysics() const { return m_continuousPhysics; }
156,158c179,180
< 	/// Enable/disable single stepped continuous physics. For testing.
< 	void SetSubStepping(bool flag) { m_subStepping = flag; }
< 	bool GetSubStepping() const { return m_subStepping; }
---
> 	/// Perform validation of internal data structures.
> 	void Validate();
162a185,187
> 	/// Get the number of broad-phase pairs.
> 	int32 GetPairCount() const;
> 
172,180c197,198
< 	/// Get the height of the dynamic tree.
< 	int32 GetTreeHeight() const;
< 
< 	/// Get the balance of the dynamic tree.
< 	int32 GetTreeBalance() const;
< 
< 	/// Get the quality metric of the dynamic tree. The smaller the better.
< 	/// The minimum is 1.
< 	float32 GetTreeQuality() const;
---
> 	/// Get the number of controllers.
> 	int32 GetControllerCount() const;
188,211d205
< 	/// Is the world locked (in the middle of a time step).
< 	bool IsLocked() const;
< 
< 	/// Set flag to control automatic clearing of forces after each time step.
< 	void SetAutoClearForces(bool flag);
< 
< 	/// Get the flag that controls automatic clearing of forces after each time step.
< 	bool GetAutoClearForces() const;
< 
< 	/// Shift the world origin. Useful for large worlds.
< 	/// The body shift formula is: position -= newOrigin
< 	/// @param newOrigin the new origin with respect to the old origin
< 	void ShiftOrigin(const b2Vec2& newOrigin);
< 
< 	/// Get the contact manager for testing.
< 	const b2ContactManager& GetContactManager() const;
< 
< 	/// Get the current profile.
< 	const b2Profile& GetProfile() const;
< 
< 	/// Dump the world into the log file.
< 	/// @warning this should be called outside of a time step.
< 	void Dump();
< 
214,221d207
< 	// m_flags
< 	enum
< 	{
< 		e_newFixture	= 0x0001,
< 		e_locked		= 0x0002,
< 		e_clearForces	= 0x0004
< 	};
< 
223d208
< 	friend class b2Fixture;
231c216,220
< 	void DrawShape(b2Fixture* shape, const b2Transform& xf, const b2Color& color);
---
> 	void DrawShape(b2Shape* shape, const b2XForm& xf, const b2Color& color, bool core);
> 	void DrawDebugData();
> 
> 	//Is it safe to pass private static function pointers?
> 	static float32 RaycastSortKey(void* shape);
236c225
< 	int32 m_flags;
---
> 	bool m_lock;
237a227
> 	b2BroadPhase* m_broadPhase;
241a232,241
> 	b2Controller* m_controllerList;
> 
> 	b2Vec2 m_raycastNormal;
> 	void* m_raycastUserData;
> 	const b2Segment* m_raycastSegment;
> 	bool m_raycastSolidShape;
> 
> 
> 	// Do not access
> 	b2Contact* m_contactList;
243a244
> 	int32 m_contactCount;
244a246
> 	int32 m_controllerCount;
248a251,252
> 	b2Body* m_groundBody;
> 
250c254,257
< 	b2Draw* m_debugDraw;
---
> 	b2BoundaryListener* m_boundaryListener;
> 	b2ContactFilter* m_contactFilter;
> 	b2ContactListener* m_contactListener;
> 	b2DebugDraw* m_debugDraw;
256c263
< 	// These are for debugging the solver.
---
> 	// This is for debugging the solver.
258,261d264
< 	bool m_continuousPhysics;
< 	bool m_subStepping;
< 
< 	bool m_stepComplete;
263c266,267
< 	b2Profile m_profile;
---
> 	// This is for debugging the solver.
> 	bool m_continuousPhysics;
266c270
< inline b2Body* b2World::GetBodyList()
---
> inline b2Body* b2World::GetGroundBody()
268c272
< 	return m_bodyList;
---
> 	return m_groundBody;
271c275
< inline const b2Body* b2World::GetBodyList() const
---
> inline b2Body* b2World::GetBodyList()
281,286c285
< inline const b2Joint* b2World::GetJointList() const
< {
< 	return m_jointList;
< }
< 
< inline b2Contact* b2World::GetContactList()
---
> inline b2Controller* b2World::GetControllerList()
288,293c287
< 	return m_contactManager.m_contactList;
< }
< 
< inline const b2Contact* b2World::GetContactList() const
< {
< 	return m_contactManager.m_contactList;
---
> 	return m_controllerList;
308c302,307
< 	return m_contactManager.m_contactCount;
---
> 	return m_contactCount;
> }
> 
> inline int32 b2World::GetControllerCount() const
> {
> 	return m_controllerCount;
321,353d319
< inline bool b2World::IsLocked() const
< {
< 	return (m_flags & e_locked) == e_locked;
< }
< 
< inline void b2World::SetAutoClearForces(bool flag)
< {
< 	if (flag)
< 	{
< 		m_flags |= e_clearForces;
< 	}
< 	else
< 	{
< 		m_flags &= ~e_clearForces;
< 	}
< }
< 
< /// Get the flag that controls automatic clearing of forces after each time step.
< inline bool b2World::GetAutoClearForces() const
< {
< 	return (m_flags & e_clearForces) == e_clearForces;
< }
< 
< inline const b2ContactManager& b2World::GetContactManager() const
< {
< 	return m_contactManager;
< }
< 
< inline const b2Profile& b2World::GetProfile() const
< {
< 	return m_profile;
< }
< 
diff -r -x './svn/*' native/Box2D/Dynamics/b2WorldCallbacks.cpp ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/b2WorldCallbacks.cpp
2c2
< * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
19,20c19,22
< #include <Box2D/Dynamics/b2WorldCallbacks.h>
< #include <Box2D/Dynamics/b2Fixture.h>
---
> #include "b2WorldCallbacks.h"
> #include "../Collision/Shapes/b2Shape.h"
> 
> b2ContactFilter b2_defaultFilter;
24c26
< bool b2ContactFilter::ShouldCollide(b2Fixture* fixtureA, b2Fixture* fixtureB)
---
> bool b2ContactFilter::ShouldCollide(b2Shape* shape1, b2Shape* shape2)
26,27c28,29
< 	const b2Filter& filterA = fixtureA->GetFilterData();
< 	const b2Filter& filterB = fixtureB->GetFilterData();
---
> 	const b2FilterData& filter1 = shape1->GetFilterData();
> 	const b2FilterData& filter2 = shape2->GetFilterData();
29c31
< 	if (filterA.groupIndex == filterB.groupIndex && filterA.groupIndex != 0)
---
> 	if (filter1.groupIndex == filter2.groupIndex && filter1.groupIndex != 0)
31c33
< 		return filterA.groupIndex > 0;
---
> 		return filter1.groupIndex > 0;
34c36
< 	bool collide = (filterA.maskBits & filterB.categoryBits) != 0 && (filterA.categoryBits & filterB.maskBits) != 0;
---
> 	bool collide = (filter1.maskBits & filter2.categoryBits) != 0 && (filter1.categoryBits & filter2.maskBits) != 0;
36a39,71
> 
> bool b2ContactFilter::RayCollide(void* userData, b2Shape* shape)
> {
> 	//By default, cast userData as a shape, and then collide if the shapes would collide
> 	if(!userData)
> 		return true;
> 	return ShouldCollide((b2Shape*)userData,shape);
> }
> 
> b2DebugDraw::b2DebugDraw()
> {
> 	m_drawFlags = 0;
> }
> 
> void b2DebugDraw::SetFlags(uint32 flags)
> {
> 	m_drawFlags = flags;
> }
> 
> uint32 b2DebugDraw::GetFlags() const
> {
> 	return m_drawFlags;
> }
> 
> void b2DebugDraw::AppendFlags(uint32 flags)
> {
> 	m_drawFlags |= flags;
> }
> 
> void b2DebugDraw::ClearFlags(uint32 flags)
> {
> 	m_drawFlags &= ~flags;
> }
diff -r -x './svn/*' native/Box2D/Dynamics/b2WorldCallbacks.h ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/Dynamics/b2WorldCallbacks.h
2c2
< * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
---
> * Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
22c22
< #include <Box2D/Common/b2Settings.h>
---
> #include "../Common/b2Settings.h"
25,26c25,26
< struct b2Transform;
< class b2Fixture;
---
> struct b2XForm;
> class b2Shape;
29a30
> struct b2ContactPoint;
31d31
< struct b2Manifold;
33c33
< /// Joints and fixtures are destroyed when their associated
---
> /// Joints and shapes are destroyed when their associated
45c45
< 	/// Called when any fixture is about to be destroyed due
---
> 	/// Called when any shape is about to be destroyed due
47c47
< 	virtual void SayGoodbye(b2Fixture* fixture) = 0;
---
> 	virtual void SayGoodbye(b2Shape* shape) = 0;
49a50,62
> 
> /// This is called when a body's shape passes outside of the world boundary.
> class b2BoundaryListener
> {
> public:
> 	virtual ~b2BoundaryListener() {}
> 
> 	/// This is called for each body that leaves the world boundary.
> 	/// @warning you can't modify the world inside this callback.
> 	virtual void Violation(b2Body* body) = 0;
> };
> 
> 
59,60c72
< 	virtual bool ShouldCollide(b2Fixture* fixtureA, b2Fixture* fixtureB);
< };
---
> 	virtual bool ShouldCollide(b2Shape* shape1, b2Shape* shape2);
62,69c74,75
< /// Contact impulses for reporting. Impulses are used instead of forces because
< /// sub-step forces may approach infinity for rigid body collisions. These
< /// match up one-to-one with the contact points in b2Manifold.
< struct b2ContactImpulse
< {
< 	float32 normalImpulses[b2_maxManifoldPoints];
< 	float32 tangentImpulses[b2_maxManifoldPoints];
< 	int32 count;
---
> 	/// Return true if the given shape should be considered for ray intersection
> 	virtual bool RayCollide(void* userData, b2Shape* b2Shape);
72c78,81
< /// Implement this class to get contact information. You can use these results for
---
> /// The default contact filter.
> extern b2ContactFilter b2_defaultFilter;
> 
> /// Implement this class to get collision results. You can use these results for
79a89
> /// @warning The contact separation is the last computed value.
86,87c96,98
< 	/// Called when two fixtures begin to touch.
< 	virtual void BeginContact(b2Contact* contact) { B2_NOT_USED(contact); }
---
> 	/// Called when a contact point is added. This includes the geometry
> 	/// and the forces.
> 	virtual void Add(const b2ContactPoint* point) { B2_NOT_USED(point); }
89,90c100,102
< 	/// Called when two fixtures cease to touch.
< 	virtual void EndContact(b2Contact* contact) { B2_NOT_USED(contact); }
---
> 	/// Called when a contact point persists. This includes the geometry
> 	/// and the forces.
> 	virtual void Persist(const b2ContactPoint* point) { B2_NOT_USED(point); }
92,118c104,109
< 	/// This is called after a contact is updated. This allows you to inspect a
< 	/// contact before it goes to the solver. If you are careful, you can modify the
< 	/// contact manifold (e.g. disable contact).
< 	/// A copy of the old manifold is provided so that you can detect changes.
< 	/// Note: this is called only for awake bodies.
< 	/// Note: this is called even when the number of contact points is zero.
< 	/// Note: this is not called for sensors.
< 	/// Note: if you set the number of contact points to zero, you will not
< 	/// get an EndContact callback. However, you may get a BeginContact callback
< 	/// the next step.
< 	virtual void PreSolve(b2Contact* contact, const b2Manifold* oldManifold)
< 	{
< 		B2_NOT_USED(contact);
< 		B2_NOT_USED(oldManifold);
< 	}
< 
< 	/// This lets you inspect a contact after the solver is finished. This is useful
< 	/// for inspecting impulses.
< 	/// Note: the contact manifold does not include time of impact impulses, which can be
< 	/// arbitrarily large if the sub-step is small. Hence the impulse is provided explicitly
< 	/// in a separate data structure.
< 	/// Note: this is only called for contacts that are touching, solid, and awake.
< 	virtual void PostSolve(b2Contact* contact, const b2ContactImpulse* impulse)
< 	{
< 		B2_NOT_USED(contact);
< 		B2_NOT_USED(impulse);
< 	}
---
> 	/// Called when a contact point is removed. This includes the last
> 	/// computed geometry and forces.
> 	virtual void Remove(const b2ContactPoint* point) { B2_NOT_USED(point); }
> 
> 	/// Called after a contact point is solved.
> 	virtual void Result(const b2ContactResult* point) { B2_NOT_USED(point); }
121,123c112,113
< /// Callback class for AABB queries.
< /// See b2World::Query
< class b2QueryCallback
---
> /// Color for debug drawing. Each value has the range [0,1].
> struct b2Color
125,130c115,117
< public:
< 	virtual ~b2QueryCallback() {}
< 
< 	/// Called for each fixture found in the query AABB.
< 	/// @return false to terminate the query.
< 	virtual bool ReportFixture(b2Fixture* fixture) = 0;
---
> 	b2Color() {}
> 	b2Color(float32 r, float32 g, float32 b) : r(r), g(g), b(b) {}
> 	float32 r, g, b;
133,135c120,122
< /// Callback class for ray casts.
< /// See b2World::RayCast
< class b2RayCastCallback
---
> /// Implement and register this class with a b2World to provide debug drawing of physics
> /// entities in your game.
> class b2DebugDraw
138c125,170
< 	virtual ~b2RayCastCallback() {}
---
> 	b2DebugDraw();
> 
> 	virtual ~b2DebugDraw() {}
> 
> 	enum
> 	{
> 		e_shapeBit				= 0x0001, ///< draw shapes
> 		e_jointBit				= 0x0002, ///< draw joint connections
> 		e_coreShapeBit			= 0x0004, ///< draw core (TOI) shapes
> 		e_aabbBit				= 0x0008, ///< draw axis aligned bounding boxes
> 		e_obbBit				= 0x0010, ///< draw oriented bounding boxes
> 		e_pairBit				= 0x0020, ///< draw broad-phase pairs
> 		e_centerOfMassBit		= 0x0040, ///< draw center of mass frame
> 		e_controllerBit			= 0x0080, ///< draw controllers
> 	};
> 
> 	/// Set the drawing flags.
> 	void SetFlags(uint32 flags);
> 
> 	/// Get the drawing flags.
> 	uint32 GetFlags() const;
> 	
> 	/// Append flags to the current flags.
> 	void AppendFlags(uint32 flags);
> 
> 	/// Clear flags from the current flags.
> 	void ClearFlags(uint32 flags);
> 
> 	/// Draw a closed polygon provided in CCW order.
> 	virtual void DrawPolygon(const b2Vec2* vertices, int32 vertexCount, const b2Color& color) = 0;
> 
> 	/// Draw a solid closed polygon provided in CCW order.
> 	virtual void DrawSolidPolygon(const b2Vec2* vertices, int32 vertexCount, const b2Color& color) = 0;
> 
> 	/// Draw a circle.
> 	virtual void DrawCircle(const b2Vec2& center, float32 radius, const b2Color& color) = 0;
> 	
> 	/// Draw a solid circle.
> 	virtual void DrawSolidCircle(const b2Vec2& center, float32 radius, const b2Vec2& axis, const b2Color& color) = 0;
> 	
> 	/// Draw a line segment.
> 	virtual void DrawSegment(const b2Vec2& p1, const b2Vec2& p2, const b2Color& color) = 0;
> 
> 	/// Draw a transform. Choose your own length scale.
> 	/// @param xf a transform.
> 	virtual void DrawXForm(const b2XForm& xf) = 0;
140,152c172,173
< 	/// Called for each fixture found in the query. You control how the ray cast
< 	/// proceeds by returning a float:
< 	/// return -1: ignore this fixture and continue
< 	/// return 0: terminate the ray cast
< 	/// return fraction: clip the ray to this point
< 	/// return 1: don't clip the ray and continue
< 	/// @param fixture the fixture hit by the ray
< 	/// @param point the point of initial intersection
< 	/// @param normal the normal vector at the point of intersection
< 	/// @return -1 to filter, 0 to terminate, fraction to clip the ray for
< 	/// closest hit, 1 to continue
< 	virtual float32 ReportFixture(	b2Fixture* fixture, const b2Vec2& point,
< 									const b2Vec2& normal, float32 fraction) = 0;
---
> protected:
> 	uint32 m_drawFlags;
Only in ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d: Headers
diff -r -x './svn/*' native/Box2D/JNIBox2DBody.cpp ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/JNIBox2DBody.cpp
8c8
< #include "jni/JNIBody.h"
---
> #include "Headers/gen/com_kristianlm_robotanks_box2dbridge_jnibox2d_JNIBox2DBody.h"
71c71,72
< 	b2PolygonShape pd;
---
> 	b2PolygonDef pd;
> 	pd.density = density;
88c89,90
< 			shapeList[i] = bodyList[ID]->CreateFixture(&pd, density);
---
> 			shapeList[i] = bodyList[ID]->CreateShape(&pd);
> 
114,117c116,118
< 	b2PolygonShape pd;
<         int lenV = len / 3;
<         b2Vec2 vertices[lenV];
< 	// pd.vertexCount = len / 3;
---
> 	b2PolygonDef pd;
> 	pd.density = density;
> 	pd.vertexCount = len / 3;
121c122
< 		vertices[i].Set(vl[i * 3 + 0], vl[i * 3 + 1]);
---
> 		pd.vertices[i].Set(vl[i * 3 + 0], vl[i * 3 + 1]);
123c124
<         // pd->Set(&vertices[0],lenV);
---
> 
130c131
< 	b2Fixture* shape = bodyList[bodyID]->CreateFixture(&pd, density);
---
> 	b2Shape* shape = bodyList[bodyID]->CreateShape(&pd);
188c189
< 	bodyList[ID]->ApplyForce(force, point, false);
---
> 	bodyList[ID]->ApplyForce(force, point);
207c208
< 	bodyList[ID]->ApplyTorque(torque, false);
---
> 	bodyList[ID]->ApplyTorque(torque);
231c232
< 	bodyList[ID]->ResetMassData();
---
> 	bodyList[ID]->SetMassFromShapes();
249,250c250,251
< 	bodyList[ID]->SetLinearDamping(liDa);
< 	bodyList[ID]->SetAngularDamping(anDa);
---
> 	bodyList[ID]->m_linearDamping = liDa;
> 	bodyList[ID]->m_angularDamping = anDa;
266c267
< 	b2Fixture* s = bodyList[ID]->GetFixtureList();
---
> 	b2Shape* s = bodyList[ID]->GetShapeList();
268c269
< 	b2Filter filter;
---
> 	b2FilterData filter;
274c275
< 	s->Refilter();
---
> 	world->Refilter(s);
305c306
< 	b2Filter shapeFD = bodyList[bodyID]->GetFixtureList()->GetFilterData();
---
> 	b2FilterData shapeFD = bodyList[bodyID]->GetShapeList()->GetFilterData();
344c345
< 	bodyList[bodyID]->DestroyFixture(shapeList[shapeID]);
---
> 	bodyList[bodyID]->DestroyShape(shapeList[shapeID]);
364c365
< 	bodyList[id]->SetTransform(pos, bodyList[id]->GetAngle());
---
> 	bodyList[id]->SetXForm(pos, bodyList[id]->GetAngle());
diff -r -x './svn/*' native/Box2D/JNIBox2DShape.cpp ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/JNIBox2DShape.cpp
9c9
< #include "jni/JNIShape.h"
---
> #include "Headers/gen/com_kristianlm_robotanks_box2dbridge_jnibox2d_JNIBox2DShape.h"
diff -r -x './svn/*' native/Box2D/JNIBox2DWorld.cpp ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/JNIBox2DWorld.cpp
10c10
< #include "jni/JNIWorld.h"
---
> #include "Headers/gen/com_kristianlm_robotanks_box2dbridge_jnibox2d_JNIBox2DWorld.h"
42c42
< b2Fixture* shapeList[MAX_SHAPES];
---
> b2Shape* shapeList[MAX_SHAPES];
90,92c90,91
<         //TODO: How do I do aabb now...
< 	// world = new b2World(aabb, gravity, canSleep);
< 	world = new b2World(gravity);
---
> 	world = new b2World(aabb, gravity, canSleep);
> 	
94,95c93,94
<         // TODO: Not sure here....
< 	// bodyList[0] = world->GetGroundBody();
---
> 
> 	bodyList[0] = world->GetGroundBody();
235,265c234,235
< int starting = false;
< jmethodID g_mid;
< jobject g_obj;
< jclass g_clazz;
< JavaVM * g_vm;
< 
< class MyQueryCallback : public b2QueryCallback {
<   public:
<       // std::vector<b2Body*> foundBodies;
<       bool ReportFixture(b2Fixture* fixture) {
<           printf("In Callback");
<           JNIEnv * g_env;
<           int getEnvStat = g_vm->GetEnv((void **)&g_env, JNI_VERSION_1_6);
<           b2Body* body = fixture->GetBody();
<           float x = body->GetWorldCenter().x,
<                         y = body->GetWorldCenter().y,
<                         vx = body->GetLinearVelocity().x,
<                         vy = body->GetLinearVelocity().y,
<                         angle = body->GetAngle(),
<                         avel = body->GetAngularVelocity(),
<                         inertiaInv = 1.0f / body->GetInertia();
<           g_env->CallVoidMethod((jobject)body->GetUserData(), callbackSetData, x, y, vx, vy, angle, avel, inertiaInv);
<           // foundBodies.push_back( body ); 
<           // if(!body->IsStatic() || !body->IsJNIUpdated()) {
<             // updateBodyData(env, body);
<             // env->SetObjectArrayElement(array, i, JNIShape);
<           // }            
<           jobject JNIShape = (jobject) fixture->GetUserData();
<           return true;//keep going to find all fixtures in the query area
<       }
<  };
---
> JNIEXPORT jint JNICALL Java_com_kristianlm_robotanks_box2dbridge_jnibox2d_JNIBox2DWorld_nShapeQuery
>   (JNIEnv *env, jobject, jfloat x1, jfloat y1, jfloat x2, jfloat y2, jint maxCount, jobjectArray array) {
268,282d237
< 
< JNIEXPORT void JNICALL Java_com_kristianlm_robotanks_box2dbridge_jnibox2d_JNIBox2DWorld_nShapeQuery
<   (JNIEnv *env, jobject obj, jfloat x1, jfloat y1, jfloat x2, jfloat y2, jint maxCount, jobjectArray array) {
<         printf("Starting Shape Query");
<         MyQueryCallback queryCallback;
<         env->GetJavaVM(&g_vm);
<         g_obj = env->NewGlobalRef(obj);
<         if(g_clazz == 0) {
<           g_clazz = env->GetObjectClass(g_obj);
<         } 
<         callbackSetData = env->GetMethodID(g_clazz, "callbackSetData", "(FFFFFFF)V");
<         if(callbackSetData == 0) {
<           throwExc(env, "callbackSetData method ID (FFFFFFF)V not found");
<           return;
<         }
287a243
> 	b2Shape** shapeList = new b2Shape* [maxCount];
289c245,282
< 	world->QueryAABB(&queryCallback, aabb);
---
> 	int count = world->Query(aabb, shapeList, maxCount);
> 
> 	int upCount = 0;
> 	for (int32 i = 0; i < count; ++i)
> 	{
> 		jobject JNIShape = (jobject) shapeList[i]->GetUserData();
> 
> 		// update the JNI body position unless sleeping
> 		// sleeping bodies never change their position
> 		b2Body* body = shapeList[i]->GetBody();
> 
> //		printf("#%d: ", i);
> //		if(body->IsStatic())
> //			printf("\tstatic");
> //		else
> //			printf("\tdynamic");
> //		printf("\tflag = %d ", body->IsJNIUpdated());
> 
> 		// if the body is static and has updated flag set, don't update
> 		if(!body->IsStatic() || !body->IsJNIUpdated()) {
> 			updateBodyData(env, body);
> 			// set updated flag
> 			body->SetJNIUpdated();
> 			upCount++;
> 
> //			printf("\tnew up.=", body->IsJNIUpdated());
> 		}
> //		printf(" | ");
> 		env->SetObjectArrayElement(array, i, JNIShape);
> 	}
> 
> //	printf(" - TOTAL %d updates\n", upCount);
> //	fflush(stdout);
> 
> 
> 	delete [] shapeList;
> 
> 	return count;
297,319c290
< class MyRayCastCallback : public b2RayCastCallback
< {
<   public:
<   MyRayCastCallback()
<   {
<     m_fixture = NULL;
<   }
<   float32 ReportFixture(b2Fixture* fixture, const b2Vec2& point,
<   const b2Vec2& normal, float32 fraction)
<   {
<     printf("Raycast Callback");
<     m_fixture = fixture;
<     m_point = point;
<     m_normal = normal;
<     m_fraction = fraction;
<     return fraction;
<   }
<   b2Fixture* m_fixture;
<   b2Vec2 m_point;
<   b2Vec2 m_normal;
<   float32 m_fraction;
< };
< JNIEXPORT void JNICALL Java_com_kristianlm_robotanks_box2dbridge_jnibox2d_JNIBox2DWorld_nRaycastOne
---
> JNIEXPORT jobject JNICALL Java_com_kristianlm_robotanks_box2dbridge_jnibox2d_JNIBox2DWorld_nRaycastOne
321,325c292,320
<         printf("Calling Raycast");
<         MyRayCastCallback callback;
<         b2Vec2 point1(p1x, p1y);
<         b2Vec2 point2(p2x, p2y);
< 	world->RayCast(&callback, point1, point2);
---
> 
> 	float32 lambda = 1;
> 	b2Vec2 normal;
> 
> 	b2Segment segment;
> 	segment.p1.x = p1x;
> 	segment.p1.y = p1y;
> 
> 	segment.p2.x = p2x;
> 	segment.p2.y = p2y;
> 
> //	cout << "p1 = (" << segment.p1.x << ", " << segment.p1.y << ")  ";
> //	cout << "p2 = (" << segment.p2.x << ", " << segment.p2.y << ") \n";
> 
> 
> 	b2Shape* shape = world->RaycastOne(segment, &lambda, &normal, solidShapes, NULL);
> 
> 	jclass classRaycastResult = env->GetObjectClass(raycastRes);
> 	jfieldID fieldIDlambda = env->GetFieldID(classRaycastResult, "lambda", "F");
> 
> 	env->SetFloatField(raycastRes, fieldIDlambda, lambda);
> 
> //	cout << "native lambda: " << lambda << "\t\t" << flush;
> 
> 	if(shape == NULL)
> 		return NULL;
> 
> 
> 	return (jobject)shape->GetUserData();
diff -r -x './svn/*' native/Box2D/JNIBox2DWorld.h ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d/JNIBox2DWorld.h
24c24
< extern b2Fixture* shapeList [MAX_SHAPES];
---
> extern b2Shape* shapeList [MAX_SHAPES];
Only in ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d: Makefile
Only in native/Box2D: Rope
Only in ../android-opengl-box2d-basics-read-only/rt-jnibox2d/box2d: box2d.h
Only in native/Box2D: include
Only in native/Box2D: libs
Only in native/Box2D: obj
